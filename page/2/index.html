<!DOCTYPE html>
<html lang="en, zh_CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"bi-an.github.io","root":"/blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="江南人物的博客">
<meta property="og:url" content="https://bi-an.github.io/blog/page/2/index.html">
<meta property="og:site_name" content="江南人物的博客">
<meta property="og:locale">
<meta property="article:author" content="bi-an">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://bi-an.github.io/blog/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en, zh_CN'
  };
</script>

  <title>江南人物的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">江南人物的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-resource">

    <a href="/blog/resources/" rel="section"><i class="fa fa-paperclip fa-fw"></i>Resource</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/21/dmtcp/DMTCP%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86jalib/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/21/dmtcp/DMTCP%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86jalib/" class="post-title-link" itemprop="url">DMTCP 之内存管理 (jalib)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-21 09:59:55" itemprop="dateCreated datePublished" datetime="2025-08-21T09:59:55+00:00">2025-08-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-16 02:21:27" itemprop="dateModified" datetime="2025-09-16T02:21:27+00:00">2025-09-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/DMTCP/" itemprop="url" rel="index"><span itemprop="name">DMTCP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a target="_blank" rel="noopener" href="https://github.com/dmtcp/dmtcp/tree/main/jalib">https://github.com/dmtcp/dmtcp/tree/main/jalib</a></p>
<h2 id="malloc-的特性和局限"><a href="#malloc-的特性和局限" class="headerlink" title="malloc 的特性和局限"></a>malloc 的特性和局限</h2><p><code>malloc</code>&#x2F;<code>free</code> 是操作系统（或 C 库）提供的通用堆分配器。</p>
<ul>
<li>它通常会采用 “内存池 + 分块 + 空闲链表” 等技术，但它为了通用性和线程安全，设计得很复杂，开销较大。</li>
<li>在高并发 &#x2F; 频繁小块分配释放的场景下，<code>malloc</code> 的性能和碎片控制未必理想。</li>
</ul>
<p><code>malloc</code> 很难让你：</p>
<ul>
<li>控制分配内存的位置（如 DMTCP 需要特殊内存区域）</li>
<li>统计 &#x2F; 追踪所有分配的内存块</li>
<li>实现定制的分配策略（如无锁、分层小块池、预扩展等）</li>
<li>轻松调试和隔离内存问题</li>
</ul>
<h3 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h3><p>malloc 的确在其实现内部也维护着自己的 “内存池”，并且会对小块内存（small bins&#x2F;tcache&#x2F;fast bins 等）做优化和分组管理。比如在 glibc 的 malloc（ptmalloc）中，就有针对小块内存的快速分配机制。</p>
<ol>
<li><p>malloc 是 “通用分配器”<br>malloc 需要支持所有应用场景，包括大 &#x2F; 小 &#x2F; 奇异尺寸的分配、跨多线程、兼容各种系统调用和 ABI。<br>为了兼容性和健壮性，malloc 实现复杂，包含很多额外的元数据和检查，导致分配 &#x2F; 释放开销更大。</p>
</li>
<li><p>malloc 的小块管理是 “全局的”<br>malloc 管理的小块是全进程共享的，所有线程 &#x2F; 模块都会竞争同一套管理结构（如 fastbin、tcache、small bin）。<br>在高并发、频繁小块分配 &#x2F; 释放的场景下，锁竞争和同步成本变高，可能成为性能瓶颈。</p>
</li>
<li><p>自定义分配器（如 jalib）“更窄、更专用”<br>jalib 只服务 DMTCP 内部的特殊内存分配需求，只关注固定几种典型的小块尺寸（如 64&#x2F;256&#x2F;1024…）。<br>可以用更简单、更高效的 “无锁链表 + 内存对齐块” 来管理池，分配和释放几乎都是 O(1)的原子操作。<br>不需要兼容所有 malloc 的场景（如 realloc、跨模块释放等），所以能极致优化。</p>
</li>
<li><p>控制权和可观测性<br>jalib 可以完全掌控池的生命周期、分配区域、分配策略（如预扩展、定制回收），还可以追踪统计、调试。<br>malloc 的内部状态你无法直接控制或感知，也无法方便地和 DMTCP 的 checkpoint、回滚等功能集成。</p>
</li>
<li><p>内存碎片和确定性<br>专用分配器能保证分配块 “定长、对齐”，几乎无碎片，分配和回收都是确定性的。<br>malloc 需要兼容各种尺寸，碎片和内存抖动不可避免。</p>
</li>
</ol>
<h2 id="jalib（自定义分配器）的设计动机"><a href="#jalib（自定义分配器）的设计动机" class="headerlink" title="jalib（自定义分配器）的设计动机"></a>jalib（自定义分配器）的设计动机</h2><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul>
<li>DMTCP 频繁地分配和释放小块内存（如元数据、临时缓存等），如果每次都用 malloc，性能损耗大。</li>
<li>jalib 采用分级固定块池，每次分配 &#x2F; 释放只需操作链表和原子变量，比 malloc 更快、更少碎片。</li>
</ul>
<h3 id="线程安全的高效实现"><a href="#线程安全的高效实现" class="headerlink" title="线程安全的高效实现"></a>线程安全的高效实现</h3><ul>
<li>jalib 用无锁（128 位 CAS）或轻量级互斥方案，适合高并发分配 &#x2F; 释放。</li>
<li>malloc 虽然线程安全，但实现方式更重，适用范围更广，未必最优。</li>
</ul>
<h3 id="可控性和可追踪性"><a href="#可控性和可追踪性" class="headerlink" title="可控性和可追踪性"></a>可控性和可追踪性</h3><ul>
<li>jalib 可以统计分配次数、追踪所有内存池区，方便调试、分析和 checkpoint 恢复。</li>
<li>可根据实际需求预分配或批量扩展，避免运行时大规模内存抖动。</li>
</ul>
<h3 id="适应-DMTCP-的特殊需求"><a href="#适应-DMTCP-的特殊需求" class="headerlink" title="适应 DMTCP 的特殊需求"></a>适应 DMTCP 的特殊需求</h3><ul>
<li>DMTCP 需要在 checkpoint&#x2F;restore 时管理所有内存区域，jalib 可以定制分配区域、分配方式，malloc 无法满足。</li>
<li>可实现特定平台的优化，如 mmap 固定地址分配等。</li>
</ul>
<h3 id="故障隔离和调试"><a href="#故障隔离和调试" class="headerlink" title="故障隔离和调试"></a>故障隔离和调试</h3><ul>
<li>jalib 可以在有 bug 或内存泄漏时，帮助定位具体的分配 &#x2F; 释放流程。</li>
<li>可以方便地记录所有 arena 信息，甚至实现特殊的调试模式。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虽然 malloc 也是内存池管理，但它是为通用用途设计的，不能满足 DMTCP 这类高性能、高可控性、特殊内存管理需求场景。自定义 jalib 分配器可以更高效地管理小块内存，优化多线程性能，便于调试和适配特定需求。</p>
<p>可以归纳为三点：</p>
<ul>
<li>性能更高，碎片更少</li>
<li>更好地适应 DMTCP 的需求</li>
<li>更易于调试和控制</li>
</ul>
<h2 id="jalloc-设计思路"><a href="#jalloc-设计思路" class="headerlink" title="jalloc 设计思路"></a>jalloc 设计思路</h2><h3 id="多层级固定大小块分配（层级分配器）"><a href="#多层级固定大小块分配（层级分配器）" class="headerlink" title="多层级固定大小块分配（层级分配器）"></a>多层级固定大小块分配（层级分配器）</h3><ul>
<li>设计了 5 个分配层级（lvl1~lvl5），每层负责不同大小的定长内存块（如 64、256、1024、4096、16384 字节）。</li>
<li>小于等于这 5 个等级的分配请求，会被分配到各自的层级。</li>
<li>超过最大层级的请求，则直接调用 <code>_alloc_raw</code>（通常是 <code>mmap</code>）。</li>
</ul>
<p>优点：</p>
<ul>
<li>小块内存可以复用，减少系统调用和碎片。</li>
<li>大块内存仍可直接用系统接口，兼顾通用性。</li>
</ul>
<h3 id="固定块分配器-JFixedAllocStack"><a href="#固定块分配器-JFixedAllocStack" class="headerlink" title="固定块分配器 JFixedAllocStack"></a>固定块分配器 JFixedAllocStack</h3><p>每个层级对应一个 <code>JFixedAllocStack&lt;N&gt;</code>，其核心是无锁栈式管理：</p>
<ul>
<li>内部维护一个空闲块栈（LIFO 链表）。</li>
<li>allocate 时从栈取出一个空闲块，栈空时调用 expand 申请一批新块。</li>
<li>deallocate 时将块归还到栈顶。</li>
</ul>
<p>核心技术点</p>
<ul>
<li><p>原子双字比较交换（128 位 CAS）</p>
<p>为了线程安全，栈顶指针 _top 需要原子更新。这里用到了 128 位 CAS（Compare-And-Swap），保证 node 指针和计数器同时更新，避免 ABA 问题。</p>
</li>
<li><p>CAS 不可用时的降级方案</p>
<p>对于不支持 128 位原子操作的平台，采用 futex+memcpy 的方式手动实现互斥和原子性。</p>
</li>
</ul>
<h3 id="线程安全设计"><a href="#线程安全设计" class="headerlink" title="线程安全设计"></a>线程安全设计</h3><p>分配和释放都用原子操作保护，无需锁，性能高。<br>多线程环境下不会出现竞争条件或内存破坏。</p>
<h3 id="Arena-记录和调试"><a href="#Arena-记录和调试" class="headerlink" title="Arena 记录和调试"></a>Arena 记录和调试</h3><p>分配的内存区域（arena）可以记录到全局数组中，方便调试和统计。<br>通过 <code>JAlloc::getAllocArenas()</code> 可获得分配区域列表。</p>
<h3 id="全局-new-delete-重载（可选）"><a href="#全局-new-delete-重载（可选）" class="headerlink" title="全局 new&#x2F;delete 重载（可选）"></a>全局 new&#x2F;delete 重载（可选）</h3><p>如果定义了 <code>OVERRIDE_GLOBAL_ALLOCATOR</code>，会重载 <code>operator new</code> 和 <code>operator delete</code>，让全局 <code>new</code>&#x2F;<code>delete</code> 也用这个分配器。</p>
<h3 id="灵活切换"><a href="#灵活切换" class="headerlink" title="灵活切换"></a>灵活切换</h3><p>可以通过宏 <code>JALIB_ALLOCATOR</code> 切换：</p>
<ul>
<li>启用时用自定义分配器</li>
<li>否则回退为标准 malloc&#x2F;free</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>本内存分配器的设计核心在于：</p>
<ul>
<li>采用多级固定块内存池 + 无锁算法，高效服务于小块高频分配 &#x2F; 释放；</li>
<li>通过 128 位原子操作或 futex 确保并发安全，适用多平台；</li>
<li>提供 arena 管理和统计，方便调试与维护；</li>
<li>兼容传统分配方式，易于集成和切换。</li>
</ul>
<p>这种设计非常适合像 DMTCP 这样对性能和内存管理有特殊要求的系统级软件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/20/EDA/EAD%E4%BB%BF%E7%9C%9F%E4%B9%8BMemory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/20/EDA/EAD%E4%BB%BF%E7%9C%9F%E4%B9%8BMemory/" class="post-title-link" itemprop="url">EDA 仿真之 Memory</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-20 22:25:49" itemprop="dateCreated datePublished" datetime="2025-08-20T22:25:49+00:00">2025-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-16 02:21:27" itemprop="dateModified" datetime="2025-09-16T02:21:27+00:00">2025-09-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/EDA/" itemprop="url" rel="index"><span itemprop="name">EDA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>Memory &#x3D; 存储 + 访问逻辑</p>
<p>存储</p>
<ul>
<li>在仿真里，memory 本质上就是一个数组（Array）或者向量（Vector），每个元素对应一个存储单元（bit&#x2F;byte&#x2F;word）。</li>
<li>例：一个 8 位 × 1024 深度的 RAM，可以在仿真里用 <code>uint8_t mem[1024];</code> 表示。</li>
</ul>
<p>访问逻辑</p>
<ul>
<li>读（Read）：根据地址返回对应的数据。</li>
<li>写（Write）：根据地址和写使能信号，将数据写入存储单元。</li>
<li>可能涉及 时序：同步（clock 边沿写入）或异步（立即生效）。</li>
</ul>
<p>时序和延迟</p>
<ul>
<li>在硬件里，memory 访问不是瞬间的：存在 读延迟、写延迟。</li>
<li>仿真时，可以用 延时事件 或 clock 边沿触发 来模拟。</li>
</ul>
<h2 id="仿真代码"><a href="#仿真代码" class="headerlink" title="仿真代码"></a>仿真代码</h2><p>功能说明</p>
<ul>
<li>多端口读写：支持同时多个端口访问 memory</li>
<li>写冲突仲裁：写优先策略或延迟写，可扩展读优先 &#x2F; 轮询</li>
<li>读延迟 pipeline：延迟由 read_delay 控制</li>
<li>Burst &#x2F; wrap-around：访问超出末尾自动回绕</li>
<li>简单 Cache&#x2F;Tag：模拟命中 &#x2F; 未命中</li>
<li>异步端口：不同端口调用 read&#x2F;write 可在不同 tick，模拟异步时钟</li>
<li>随机 bit flip &#x2F; SEU：1% 概率错误注入</li>
<li>统计与功耗估算基础：记录读写次数、命中数、平均延迟</li>
</ul>
<figure class="highlight cpp"><figcaption><span>EdaMemoryFull.cpp</span><a href="/blog/downloads/code/eda/memory/EdaMemoryFull.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Event</span> {</span><br><span class="line">    <span class="type">int</span> time;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; action;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Event&amp; other) <span class="type">const</span> { <span class="keyword">return</span> time &gt; other.time; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EdaMemoryFull</span> {</span><br><span class="line">    std::vector&lt;<span class="type">uint8_t</span>&gt; mem;</span><br><span class="line">    std::priority_queue&lt;Event&gt; event_queue;</span><br><span class="line">    <span class="type">int</span> sim_time = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> read_delay;</span><br><span class="line">    std::mt19937 gen;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cache_size;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CacheLine</span> { <span class="type">bool</span> valid=<span class="literal">false</span>; <span class="type">int</span> tag=<span class="number">-1</span>; };</span><br><span class="line">    std::vector&lt;CacheLine&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max_bus_access_per_cycle = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> current_cycle_access = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计信息</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; read_count, write_count, read_hits, write_hits;</span><br><span class="line">    std::map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; read_delay_total;</span><br><span class="line">    <span class="type">int</span> dynamic_power = <span class="number">0</span>; <span class="comment">// 动态功耗</span></span><br><span class="line">    <span class="type">int</span> static_power; <span class="comment">// 静态功耗</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; dynamic_power_per_cycle; <span class="comment">// 每周期动态功耗</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态功耗公式（单位：动态功耗单位 = 每bit切换一次算1）</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// P_dyn = α * C * V^2 * f</span></span><br><span class="line">    <span class="comment">// 其中，α 开关活动因子（switching activity）</span></span><br><span class="line">    <span class="comment">//      C 负载电容</span></span><br><span class="line">    <span class="comment">//      V 电源电压</span></span><br><span class="line">    <span class="comment">//      f 时钟频率</span></span><br><span class="line">    <span class="comment">// 简化为每次 bit 改变增加一个单位动态功耗</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 静态功耗公式（单位：静态功耗单位 = 每8bit存储单元算1）</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// P_static = I_leak * V * N</span></span><br><span class="line">    <span class="comment">// 简化为每8bit存储单元增加1单位静态功耗</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 总功耗</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// P_total = P_dyn + P_static</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">WritePriority</span> { WRITE_FIRST, READ_FIRST, ROUND_ROBIN } write_prio;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EdaMemoryFull</span>(<span class="type">size_t</span> size, <span class="type">int</span> delay, <span class="type">int</span> c_size, WritePriority prio=WRITE_FIRST)</span><br><span class="line">        : <span class="built_in">mem</span>(size,<span class="number">0</span>), <span class="built_in">read_delay</span>(delay), <span class="built_in">gen</span>(std::random_device{}()), </span><br><span class="line">          <span class="built_in">cache_size</span>(c_size), <span class="built_in">cache</span>(c_size), <span class="built_in">static_power</span>(size/<span class="number">8</span>), <span class="built_in">write_prio</span>(prio)</span><br><span class="line">    {</span><br><span class="line">        std::uniform_int_distribution&lt;&gt; <span class="built_in">dis</span>(<span class="number">0</span>,<span class="number">255</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v: mem) v = <span class="built_in">dis</span>(gen);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> port,<span class="type">int</span> addr,<span class="type">const</span> std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; data)</span></span>{</span><br><span class="line">        write_count[port]++;</span><br><span class="line">        <span class="keyword">if</span>(current_cycle_access&gt;=max_bus_access_per_cycle){</span><br><span class="line">            event_queue.<span class="built_in">push</span>({sim_time+<span class="number">1</span>,[<span class="keyword">this</span>,port,addr,data](){ <span class="built_in">write</span>(port,addr,data); }});</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        current_cycle_access++;</span><br><span class="line">        <span class="keyword">if</span>(write_prio==WRITE_FIRST){</span><br><span class="line">            <span class="built_in">apply_write</span>(addr,data);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            event_queue.<span class="built_in">push</span>({sim_time+<span class="number">1</span>,[<span class="keyword">this</span>,addr,data](){ <span class="built_in">apply_write</span>(addr,data); }});</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">update_cache</span>(port, addr,data,<span class="literal">true</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> port,<span class="type">int</span> addr,<span class="type">size_t</span> length,std::function&lt;<span class="type">void</span>(std::vector&lt;<span class="type">uint8_t</span>&gt;)&gt; callback)</span></span>{</span><br><span class="line">        read_count[port]++;</span><br><span class="line">        <span class="keyword">if</span>(current_cycle_access&gt;=max_bus_access_per_cycle){</span><br><span class="line">            event_queue.<span class="built_in">push</span>({sim_time+<span class="number">1</span>,[<span class="keyword">this</span>,port,addr,length,callback](){ <span class="built_in">read</span>(port,addr,length,callback); }});</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        current_cycle_access++;</span><br><span class="line">        <span class="type">int</span> trigger_time = sim_time+read_delay;</span><br><span class="line">        <span class="type">bool</span> hit = <span class="built_in">check_cache</span>(port, addr,length);</span><br><span class="line">        <span class="keyword">if</span>(hit) read_hits[port]++;</span><br><span class="line">        event_queue.<span class="built_in">push</span>({trigger_time,[<span class="keyword">this</span>,addr,length,callback,port,trigger_time]() {</span><br><span class="line">            std::vector&lt;<span class="type">uint8_t</span>&gt; data;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;length;i++){</span><br><span class="line">                <span class="type">uint8_t</span> val = mem[(addr+i)%mem.<span class="built_in">size</span>()];</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">random_bit_flip</span>()) val ^= (<span class="number">1</span>&lt;&lt;(<span class="built_in">gen</span>()%<span class="number">8</span>));</span><br><span class="line">                dynamic_power += <span class="built_in">count_bit_changes</span>(val, mem[(addr+i)%mem.<span class="built_in">size</span>()]);</span><br><span class="line">                data.<span class="built_in">push_back</span>(val);</span><br><span class="line">            }</span><br><span class="line">            read_delay_total[port] += (trigger_time - sim_time);</span><br><span class="line">            <span class="built_in">callback</span>(data);</span><br><span class="line">        }});</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">()</span></span>{</span><br><span class="line">        sim_time++;</span><br><span class="line">        current_cycle_access = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cycle_dyn_power = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!event_queue.<span class="built_in">empty</span>() &amp;&amp; event_queue.<span class="built_in">top</span>().time &lt;= sim_time){</span><br><span class="line">            <span class="keyword">auto</span> e = event_queue.<span class="built_in">top</span>(); event_queue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> before = dynamic_power;</span><br><span class="line">            e.<span class="built_in">action</span>();</span><br><span class="line">            cycle_dyn_power += (dynamic_power - before);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        dynamic_power_per_cycle.<span class="built_in">push_back</span>(cycle_dyn_power);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ASCII 可视化每周期动态功耗</span></span><br><span class="line">        <span class="type">int</span> scale = <span class="number">50</span>;</span><br><span class="line">        <span class="type">int</span> bar_len = *std::<span class="built_in">max_element</span>(dynamic_power_per_cycle.<span class="built_in">begin</span>(), dynamic_power_per_cycle.<span class="built_in">end</span>())&gt;<span class="number">0</span> ?</span><br><span class="line">                      cycle_dyn_power*scale/(*std::<span class="built_in">max_element</span>(dynamic_power_per_cycle.<span class="built_in">begin</span>(), dynamic_power_per_cycle.<span class="built_in">end</span>())) : <span class="number">0</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Cycle &quot;</span> &lt;&lt; sim_time &lt;&lt; <span class="string">&quot; dyn power: &quot;</span> &lt;&lt; cycle_dyn_power</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; total power: &quot;</span> &lt;&lt; dynamic_power + static_power &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;bar_len;i++) std::cout&lt;&lt;<span class="string">&quot;#&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_stats</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Simulation stats:\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [port,cnt]: read_count)</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;Port &quot;</span>&lt;&lt;port&lt;&lt;<span class="string">&quot; read count: &quot;</span>&lt;&lt;cnt</span><br><span class="line">                     &lt;&lt;<span class="string">&quot;, hits: &quot;</span>&lt;&lt;read_hits.<span class="built_in">at</span>(port)</span><br><span class="line">                     &lt;&lt;<span class="string">&quot;, avg delay: &quot;</span>&lt;&lt;(cnt?read_delay_total.<span class="built_in">at</span>(port)/cnt:<span class="number">0</span>)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [port,cnt]: write_count)</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;Port &quot;</span>&lt;&lt;port&lt;&lt;<span class="string">&quot; write count: &quot;</span>&lt;&lt;cnt</span><br><span class="line">                     &lt;&lt;<span class="string">&quot;, hits: &quot;</span>&lt;&lt;write_hits.<span class="built_in">at</span>(port)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Dynamic power units: &quot;</span>&lt;&lt;dynamic_power&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Static power units: &quot;</span>&lt;&lt;static_power&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Total power units: &quot;</span>&lt;&lt;dynamic_power + static_power&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">export_power_csv</span><span class="params">(<span class="type">const</span> std::string &amp;filename)</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="function">std::ofstream <span class="title">ofs</span><span class="params">(filename)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(!ofs.<span class="built_in">is_open</span>()) {</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Failed to open file: &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        ofs &lt;&lt; <span class="string">&quot;Cycle,DynamicPower,StaticPower,TotalPower\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;dynamic_power_per_cycle.<span class="built_in">size</span>();i++){</span><br><span class="line">            <span class="type">int</span> dyn = dynamic_power_per_cycle[i];</span><br><span class="line">            <span class="type">int</span> total = dyn + static_power;</span><br><span class="line">            ofs &lt;&lt; (i+<span class="number">1</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; dyn &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; static_power &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; total &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        }</span><br><span class="line">        ofs.<span class="built_in">close</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Power data exported to &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">random_bit_flip</span><span class="params">()</span></span>{</span><br><span class="line">        std::uniform_real_distribution&lt;&gt; <span class="built_in">dis</span>(<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dis</span>(gen)&lt;<span class="number">0.01</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count_bit_changes</span><span class="params">(<span class="type">uint8_t</span> a,<span class="type">uint8_t</span> b)</span></span>{</span><br><span class="line">        <span class="type">uint8_t</span> diff = a^b;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(diff){ count+=diff&amp;<span class="number">1</span>; diff&gt;&gt;=<span class="number">1</span>; }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check_cache</span><span class="params">(<span class="type">int</span> port, <span class="type">int</span> addr,<span class="type">size_t</span> length)</span></span>{</span><br><span class="line">        <span class="type">int</span> line = addr % cache_size;</span><br><span class="line">        <span class="type">int</span> tag = addr / cache_size;</span><br><span class="line">        <span class="keyword">return</span> cache[line].valid &amp;&amp; cache[line].tag==tag;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update_cache</span><span class="params">(<span class="type">int</span> port, <span class="type">int</span> addr,<span class="type">const</span> std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; data,<span class="type">bool</span> write=<span class="literal">false</span>)</span></span>{</span><br><span class="line">        <span class="type">int</span> line = addr % cache_size;</span><br><span class="line">        <span class="type">int</span> tag = addr / cache_size;</span><br><span class="line">        cache[line].valid=<span class="literal">true</span>;</span><br><span class="line">        cache[line].tag=tag;</span><br><span class="line">        <span class="keyword">if</span>(write) write_hits[port]++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply_write</span><span class="params">(<span class="type">int</span> addr,<span class="type">const</span> std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; data)</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;data.<span class="built_in">size</span>();i++) mem[(addr+i)%mem.<span class="built_in">size</span>()]=data[i];</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例主程序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="function">EdaMemoryFull <span class="title">mem</span><span class="params">(<span class="number">1024</span>,<span class="number">2</span>,<span class="number">16</span>,EdaMemoryFull::WRITE_FIRST)</span></span>;</span><br><span class="line"></span><br><span class="line">    mem.<span class="built_in">write</span>(<span class="number">0</span>,<span class="number">10</span>,{<span class="number">42</span>,<span class="number">43</span>,<span class="number">44</span>});</span><br><span class="line">    mem.<span class="built_in">write</span>(<span class="number">1</span>,<span class="number">11</span>,{<span class="number">99</span>});</span><br><span class="line">    mem.<span class="built_in">read</span>(<span class="number">0</span>,<span class="number">10</span>,<span class="number">3</span>,[](std::vector&lt;<span class="type">uint8_t</span>&gt; data){</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Port0 read burst: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:data) std::cout&lt;&lt;(<span class="type">int</span>)v&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        std::cout&lt;&lt;std::endl;</span><br><span class="line">    });</span><br><span class="line">    mem.<span class="built_in">read</span>(<span class="number">1</span>,<span class="number">11</span>,<span class="number">1</span>,[](std::vector&lt;<span class="type">uint8_t</span>&gt; data){</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Port1 read: &quot;</span>&lt;&lt;(<span class="type">int</span>)data[<span class="number">0</span>]&lt;&lt;std::endl;</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) mem.<span class="built_in">tick</span>();</span><br><span class="line">    <span class="comment">// 导出功耗数据</span></span><br><span class="line">    mem.<span class="built_in">export_power_csv</span>(<span class="string">&quot;memory_power.csv&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mem.<span class="built_in">print_stats</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>输出的 memory_power.csv 文件内容示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Cycle,DynamicPower,StaticPower,TotalPower</span><br><span class="line">1,3,128,131</span><br><span class="line">2,0,128,128</span><br><span class="line">3,5,128,133</span><br><span class="line">4,2,128,130</span><br><span class="line">5,7,128,135</span><br><span class="line">6,1,128,129</span><br><span class="line">7,4,128,132</span><br><span class="line">8,0,128,128</span><br><span class="line">9,2,128,130</span><br><span class="line">10,3,128,131</span><br></pre></td></tr></table></figure>

<p>每列含义：</p>
<ul>
<li>Cycle：周期号</li>
<li>DynamicPower：每周期动态功耗单位</li>
<li>StaticPower：静态功耗单位（固定）</li>
<li>TotalPower：总功耗单位</li>
</ul>
<p>功耗分析</p>
<figure class="highlight python"><figcaption><span>report_power.py</span><a href="/blog/downloads/code/eda/memory/report_power.py">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 CSV</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;memory_power.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到动态功耗峰值周期</span></span><br><span class="line">peak_cycle = df[<span class="string">&#x27;DynamicPower&#x27;</span>].idxmax() + <span class="number">1</span></span><br><span class="line">peak_value = df[<span class="string">&#x27;DynamicPower&#x27;</span>].<span class="built_in">max</span>()</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制条形背景（ASCII风格效果）</span></span><br><span class="line"><span class="keyword">for</span> i, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(df[<span class="string">&#x27;DynamicPower&#x27;</span>]):</span><br><span class="line">    bar_len = <span class="built_in">int</span>(val / peak_value * <span class="number">50</span>)  <span class="comment"># 50字符最大长度</span></span><br><span class="line">    plt.text(i+<span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;#&#x27;</span> * bar_len, fontsize=<span class="number">8</span>, color=<span class="string">&#x27;grey&#x27;</span>, va=<span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制曲线</span></span><br><span class="line">plt.plot(df[<span class="string">&#x27;Cycle&#x27;</span>], df[<span class="string">&#x27;DynamicPower&#x27;</span>], label=<span class="string">&#x27;Dynamic Power&#x27;</span>, marker=<span class="string">&#x27;o&#x27;</span>, color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">plt.plot(df[<span class="string">&#x27;Cycle&#x27;</span>], df[<span class="string">&#x27;StaticPower&#x27;</span>], label=<span class="string">&#x27;Static Power&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>, color=<span class="string">&#x27;orange&#x27;</span>)</span><br><span class="line">plt.plot(df[<span class="string">&#x27;Cycle&#x27;</span>], df[<span class="string">&#x27;TotalPower&#x27;</span>], label=<span class="string">&#x27;Total Power&#x27;</span>, linestyle=<span class="string">&#x27;-.&#x27;</span>, color=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高亮峰值</span></span><br><span class="line">plt.scatter(peak_cycle, peak_value, color=<span class="string">&#x27;red&#x27;</span>, s=<span class="number">100</span>, label=<span class="string">&#x27;Peak Dynamic Power&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&#x27;Memory Power Simulation with Peak Highlight &amp; ASCII-style Bars&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Cycle&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Power Units&#x27;</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>, linestyle=<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h3 id="burst-multi-port-总线冲突"><a href="#burst-multi-port-总线冲突" class="headerlink" title="burst&#x2F;multi-port 总线冲突"></a>burst&#x2F;multi-port 总线冲突</h3><p>在多端口系统中，尤其是在使用总线结构的系统中，总线冲突（Bus contention）是一个常见的问题。总线冲突通常发生在多个设备尝试同时访问总线上的同一资源时。这种情况可能会导致数据损坏、系统性能下降或甚至系统崩溃。下面是一些解决和缓解总线冲突的策略：</p>
<ol>
<li>仲裁机制<br>仲裁是解决总线冲突的一种常用方法。它通过一个仲裁器（Arbiter）来决定哪个设备可以访问总线。常见的仲裁策略有：</li>
</ol>
<p>优先级仲裁：根据预先设定的优先级顺序决定哪个设备可以访问总线。</p>
<p>轮询仲裁：轮流让每个设备访问总线。</p>
<p>基于请求的仲裁（如请求共享（Request-for-Shared, RFS）和请求独占（Request-for-Exclusive, RFE））：设备首先请求对资源的访问，然后根据请求的类型（共享或独占）来决定访问权限。</p>
<ol start="2">
<li><p>分时复用<br>通过时间分割（Time Division Multiplexing, TDM）或频率分割（Frequency Division Multiplexing, FDM），可以允许多个设备在不同的时间或频率上使用总线，从而减少冲突。例如，可以使用时分多路复用将总线的不同时间段分配给不同的设备。</p>
</li>
<li><p>编码和解码技术<br>使用特殊的编码和解码技术，如霍纳编码（Hornar code）或格雷码（Gray code），可以减少在总线上传输数据时的错误，并帮助检测和纠正数据冲突。</p>
</li>
<li><p>总线锁定<br>在访问总线期间，通过总线锁定机制确保没有其他设备可以访问总线。这可以通过在总线上设置一个锁定信号来实现，该信号在访问期间保持激活状态。</p>
</li>
<li><p>缓存和缓冲<br>为每个设备提供局部缓存或缓冲机制，可以减少对总线的直接访问次数，从而降低冲突的可能性。当一个设备需要与总线上的另一个设备通信时，它可以先将数据写入自己的缓存，然后再由缓存同步到总线上。</p>
</li>
<li><p>使用更宽的总线<br>增加总线的宽度可以允许在同一时间内传输更多的数据，从而减少对总线的需求，降低冲突的可能性。</p>
</li>
</ol>
<p>实施步骤<br>评估系统需求：确定哪些类型的设备将使用总线，以及它们对带宽的需求。</p>
<p>选择仲裁策略：根据设备的优先级和带宽需求选择合适的仲裁策略。</p>
<p>设计硬件：根据选定的策略设计硬件，包括添加仲裁器、缓存和适当的控制逻辑。</p>
<p>测试和优化：实施后进行系统测试，根据测试结果调整策略或硬件设计。</p>
<p>通过上述方法，可以有效管理和减少多端口系统中的总线冲突问题，提高系统的稳定性和性能。</p>
<h3 id="Cache-Tag（缓存标记）"><a href="#Cache-Tag（缓存标记）" class="headerlink" title="Cache Tag（缓存标记）"></a>Cache Tag（缓存标记）</h3><p>Cache Tag（缓存标记）是高速缓存（Cache）中的关键组成部分，用于存储数据在主存中的地址信息，以便快速定位数据位置。 ‌</p>
<p>核心功能<br>Tag字段存储了主存中数据的地址信息，当CPU访问主存时，首先通过Tag字段判断数据是否存在于Cache中。若存在，则直接从Cache读取；若不存在，则访问主存。 ‌</p>
<p>结构组成</p>
<ul>
<li>‌Tag‌：记录数据在主存的地址信息。</li>
<li>‌Data‌：存储实际数据。</li>
<li>‌Valid Bit‌：标记数据是否有效。</li>
<li>‌Dir‌：目录信息，用于区分不同数据块。 ‌</li>
</ul>
<p>应用场景</p>
<p>现代处理器通常采用多级Cache结构（如L1、L2、L3），其中Tag与Data共同构成Cache Line，用于快速访问和存储数据。例如，ARMv8-A架构的处理器包含独立的I-Cache和D-Cache，分别存储指令和数据。</p>
<p>Cache Tag 仿真代码</p>
<blockquote>
<p>FIXME: 该代码会 coredump 。</p>
</blockquote>
<figure class="highlight cpp"><figcaption><span>cache_simulator.h</span><a href="/blog/downloads/code/eda/memory/cache/cache_simulator.h">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CACHE_SIMULATOR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHE_SIMULATOR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存行结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CacheLine</span> {</span><br><span class="line">    <span class="type">bool</span> valid = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> dirty = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">uint32_t</span> tag = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint64_t</span> last_used = <span class="number">0</span>; <span class="comment">// 用于LRU替换策略</span></span><br><span class="line">    std::vector&lt;<span class="type">uint8_t</span>&gt; data;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 端口访问请求结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PortRequest</span> {</span><br><span class="line">    <span class="type">uint32_t</span> port_id;</span><br><span class="line">    <span class="type">bool</span> is_write;</span><br><span class="line">    <span class="type">uint32_t</span> addr;</span><br><span class="line">    <span class="type">uint8_t</span>* data_ptr;</span><br><span class="line">    <span class="type">size_t</span> data_size;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CacheSimulator</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CacheSimulator</span>(<span class="type">uint32_t</span> line_size, <span class="type">uint32_t</span> num_lines, <span class="type">uint32_t</span> num_ports);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 多端口访问接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process_request</span><span class="params">(<span class="type">const</span> PortRequest&amp; req)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 缓存配置</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_write_policy</span><span class="params">(<span class="type">bool</span> write_back)</span></span>; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_replacement_policy</span><span class="params">(<span class="type">int</span> policy)</span></span>; <span class="comment">// 0:LRU, 1:FIFO, 2:Random</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 内部缓存操作</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">access_cache</span><span class="params">(<span class="type">uint32_t</span> port_id, <span class="type">uint32_t</span> addr, <span class="type">bool</span> is_write, <span class="type">uint8_t</span>* data, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle_miss</span><span class="params">(<span class="type">uint32_t</span> port_id, <span class="type">uint32_t</span> addr)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">evict_line</span><span class="params">(<span class="type">uint32_t</span> set_idx, <span class="type">uint32_t</span> way_idx)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多端口同步</span></span><br><span class="line">    std::atomic&lt;<span class="type">uint64_t</span>&gt; global_counter_{<span class="number">0</span>}; <span class="comment">// 原子计数器</span></span><br><span class="line">    std::vector&lt;std::mutex&gt; port_locks_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 缓存结构</span></span><br><span class="line">    <span class="type">uint32_t</span> line_size_;</span><br><span class="line">    <span class="type">uint32_t</span> num_sets_;</span><br><span class="line">    std::vector&lt;std::vector&lt;CacheLine&gt;&gt; cache_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 策略配置</span></span><br><span class="line">    <span class="type">bool</span> write_back_;</span><br><span class="line">    <span class="type">int</span> replacement_policy_;</span><br><span class="line">};</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>cache_simulator.cpp</span><a href="/blog/downloads/code/eda/memory/cache/cache_simulator.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cache_simulator.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line">CacheSimulator::<span class="built_in">CacheSimulator</span>(<span class="type">uint32_t</span> line_size, <span class="type">uint32_t</span> num_lines, <span class="type">uint32_t</span> num_ports) </span><br><span class="line">    : <span class="built_in">port_locks_</span>(num_ports), <span class="built_in">line_size_</span>(line_size) {</span><br><span class="line">    num_sets_ = num_lines; <span class="comment">// 简单实现，可扩展为组相联</span></span><br><span class="line">    cache_.<span class="built_in">resize</span>(num_sets_, std::<span class="built_in">vector</span>&lt;CacheLine&gt;(<span class="number">1</span>)); <span class="comment">// 直接映射</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CacheSimulator::process_request</span><span class="params">(<span class="type">const</span> PortRequest&amp; req)</span> </span>{</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(port_locks_[req.port_id])</span></span>;</span><br><span class="line">    <span class="built_in">access_cache</span>(req.port_id, req.addr, req.is_write, req.data_ptr, req.data_size);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CacheSimulator::access_cache</span><span class="params">(<span class="type">uint32_t</span> port_id, <span class="type">uint32_t</span> addr, <span class="type">bool</span> is_write, </span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">uint8_t</span>* data, <span class="type">size_t</span> size)</span> </span>{</span><br><span class="line">    <span class="type">uint32_t</span> tag = addr / line_size_;</span><br><span class="line">    <span class="type">uint32_t</span> set_idx = tag % num_sets_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找命中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; line : cache_[set_idx]) {</span><br><span class="line">        <span class="keyword">if</span> (line.valid &amp;&amp; line.tag == tag) {</span><br><span class="line">            line.last_used = ++global_counter_;</span><br><span class="line">            <span class="keyword">if</span> (is_write) {</span><br><span class="line">                <span class="built_in">memcpy</span>(line.data.<span class="built_in">data</span>(), data, size);</span><br><span class="line">                line.dirty = <span class="literal">true</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="built_in">memcpy</span>(data, line.data.<span class="built_in">data</span>(), size);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 未命中处理</span></span><br><span class="line">    <span class="built_in">handle_miss</span>(port_id, addr);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CacheSimulator::handle_miss</span><span class="params">(<span class="type">uint32_t</span> port_id, <span class="type">uint32_t</span> addr)</span> </span>{</span><br><span class="line">    <span class="type">uint32_t</span> tag = addr / line_size_;</span><br><span class="line">    <span class="type">uint32_t</span> set_idx = tag % num_sets_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找可替换行</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; lines = cache_[set_idx];</span><br><span class="line">    <span class="keyword">auto</span> victim = std::<span class="built_in">min_element</span>(lines.<span class="built_in">begin</span>(), lines.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="type">const</span> CacheLine&amp; a, <span class="type">const</span> CacheLine&amp; b) {</span><br><span class="line">            <span class="keyword">return</span> a.last_used &lt; b.last_used; <span class="comment">// LRU策略</span></span><br><span class="line">        });</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写回脏数据</span></span><br><span class="line">    <span class="keyword">if</span> (write_back_ &amp;&amp; victim-&gt;dirty) {</span><br><span class="line">        <span class="comment">// 模拟写回主存操作</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载新数据</span></span><br><span class="line">    victim-&gt;valid = <span class="literal">true</span>;</span><br><span class="line">    victim-&gt;tag = tag;</span><br><span class="line">    victim-&gt;dirty = <span class="literal">false</span>;</span><br><span class="line">    victim-&gt;last_used = ++global_counter_;</span><br><span class="line">    <span class="comment">// 模拟从主存加载数据</span></span><br><span class="line">    victim-&gt;data.<span class="built_in">resize</span>(line_size_);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>main.cpp</span><a href="/blog/downloads/code/eda/memory/cache/main.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cache_simulator.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">port_thread</span><span class="params">(CacheSimulator&amp; cache, <span class="type">uint32_t</span> port_id)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) {</span><br><span class="line">        PortRequest req;</span><br><span class="line">        req.port_id = port_id;</span><br><span class="line">        req.is_write = (i % <span class="number">3</span> == <span class="number">0</span>);</span><br><span class="line">        req.addr = <span class="built_in">rand</span>() % <span class="number">0xFFFF</span>;</span><br><span class="line">        <span class="type">uint8_t</span> data[<span class="number">64</span>] = {<span class="number">0</span>};</span><br><span class="line">        req.data_ptr = data;</span><br><span class="line">        req.data_size = <span class="built_in">sizeof</span>(data);</span><br><span class="line">        </span><br><span class="line">        cache.<span class="built_in">process_request</span>(req);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">CacheSimulator <span class="title">cache</span><span class="params">(<span class="number">64</span>, <span class="number">1024</span>, <span class="number">4</span>)</span></span>; <span class="comment">// 64B行, 1024行, 4端口</span></span><br><span class="line">    </span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) {</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(port_thread, std::<span class="built_in">ref</span>(cache), i);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) {</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Cache simulation completed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>Makefile</span><a href="/blog/downloads/code/eda/memory/cache/Makefile">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 编译器配置</span><br><span class="line">CXX := g++</span><br><span class="line">CXXFLAGS := -std=c++<span class="number">17</span> -Wall -Wextra -O3 -pthread</span><br><span class="line">LDFLAGS := -pthread</span><br><span class="line"></span><br><span class="line"># 项目结构</span><br><span class="line">SRC_DIR := .</span><br><span class="line">BUILD_DIR := build</span><br><span class="line">TARGET := $(BUILD_DIR)/cache_simulator</span><br><span class="line"></span><br><span class="line"># 源文件列表</span><br><span class="line">SRCS := $(wildcard $(SRC_DIR)<span class="comment">/*.cpp)</span></span><br><span class="line"><span class="comment">OBJS := $(patsubst $(SRC_DIR)/%.cpp,$(BUILD_DIR)/%.o,$(SRCS))</span></span><br><span class="line"><span class="comment">DEPS := $(OBJS:.o=.d)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 默认目标</span></span><br><span class="line"><span class="comment">all: $(BUILD_DIR) $(TARGET)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 创建构建目录</span></span><br><span class="line"><span class="comment">$(BUILD_DIR):</span></span><br><span class="line"><span class="comment">	mkdir -p $(BUILD_DIR)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 主目标链接</span></span><br><span class="line"><span class="comment">$(TARGET): $(OBJS)</span></span><br><span class="line"><span class="comment">	$(CXX) $(LDFLAGS) $^ -o $@</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 编译规则</span></span><br><span class="line"><span class="comment">$(BUILD_DIR)/%.o: $(SRC_DIR)/%.cpp</span></span><br><span class="line"><span class="comment">	$(CXX) $(CXXFLAGS) -MMD -c $&lt; -o $@</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 包含依赖关系</span></span><br><span class="line"><span class="comment">-include $(DEPS)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 清理</span></span><br><span class="line"><span class="comment">clean:</span></span><br><span class="line"><span class="comment">	rm -rf $(BUILD_DIR)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">.PHONY: all clean</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/19/concurrency/TBB%E5%85%B8%E5%9E%8B%E5%9C%BA%E6%99%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/19/concurrency/TBB%E5%85%B8%E5%9E%8B%E5%9C%BA%E6%99%AF/" class="post-title-link" itemprop="url">TBB典型场景</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-19 22:48:38" itemprop="dateCreated datePublished" datetime="2025-08-19T22:48:38+00:00">2025-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-16 02:21:27" itemprop="dateModified" datetime="2025-09-16T02:21:27+00:00">2025-09-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="IO-CPU-密集-IO"><a href="#IO-CPU-密集-IO" class="headerlink" title="IO + CPU 密集 + IO"></a>IO + CPU 密集 + IO</h2><p>tasks</p>
<figure class="highlight cpp"><figcaption><span>tasks.hpp</span><a href="/blog/downloads/code/tbb/pipeline/tasks.hpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟 IO 和 CPU 任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataChunk</span> {</span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; data;</span><br><span class="line">    <span class="built_in">DataChunk</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">DataChunk</span><span class="params">(<span class="type">size_t</span> size)</span> : data(size) {</span>}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CompressedChunk</span> {</span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; data;</span><br><span class="line">    <span class="built_in">CompressedChunk</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CompressedChunk</span><span class="params">(<span class="type">size_t</span> size)</span> : data(size) {</span>}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟数据读取函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">read_from_network</span><span class="params">(DataChunk&amp; chunk)</span> </span>{</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);  <span class="comment">// 模拟 IO 延迟</span></span><br><span class="line"></span><br><span class="line">    chunk.data.<span class="built_in">resize</span>(<span class="number">100</span>);  <span class="comment">// 模拟每个数据块有 100 个字节</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (count++ &gt;= <span class="number">10</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 模拟读取 10 个数据块后结束</span></span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">generate</span>(chunk.data.<span class="built_in">begin</span>(), chunk.data.<span class="built_in">end</span>(),</span><br><span class="line">                  []() { <span class="keyword">return</span> <span class="built_in">rand</span>() % <span class="number">256</span>; });</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟压缩函数</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">compress_byte</span><span class="params">(<span class="type">char</span> byte)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10&#x27;000ll</span>; ++i)</span><br><span class="line">        ;               <span class="comment">// 模拟 CPU busy</span></span><br><span class="line">    <span class="keyword">return</span> byte % <span class="number">128</span>;  <span class="comment">// 简单压缩算法示例</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟写入函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_to_file</span><span class="params">(<span class="type">const</span> CompressedChunk&amp; chunk)</span> </span>{</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);  <span class="comment">// 模拟 IO 延迟</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Writing chunk of size &quot;</span> &lt;&lt; chunk.data.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>方案一</p>
<figure class="highlight cpp"><figcaption><span>1_message_queue.cpp</span><a href="/blog/downloads/code/tbb/pipeline/1_message_queue.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方案 1：异步队列 + TBB 流水线</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/tbb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tasks.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局队列</span></span><br><span class="line">std::queue&lt;std::vector&lt;<span class="type">char</span>&gt;&gt; readQueue;</span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::atomic_bool stop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">networkReader</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (!stop) {</span><br><span class="line">        DataChunk chunk;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">read_from_network</span>(chunk))  <span class="comment">// 阻塞 I/O</span></span><br><span class="line">        {</span><br><span class="line">            stop.<span class="built_in">store</span>(<span class="literal">true</span>, memory_order::releaxed);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        {</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            readQueue.<span class="built_in">push</span>(std::<span class="built_in">move</span>(chunk.data));</span><br><span class="line">        }</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩任务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compressor</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (!stop) {</span><br><span class="line">        DataChunk chunk;</span><br><span class="line">        {</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [] { <span class="keyword">return</span> !readQueue.<span class="built_in">empty</span>(); });</span><br><span class="line">            chunk.data = std::<span class="built_in">move</span>(readQueue.<span class="built_in">front</span>());</span><br><span class="line">            readQueue.<span class="built_in">pop</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CPU 密集计算，使用 TBB 并行</span></span><br><span class="line">        <span class="function">CompressedChunk <span class="title">compressed</span><span class="params">(chunk.data.size())</span></span>;</span><br><span class="line">        tbb::<span class="built_in">parallel_for</span>(<span class="built_in">size_t</span>(<span class="number">0</span>), chunk.data.<span class="built_in">size</span>(), [&amp;](<span class="type">size_t</span> i) {</span><br><span class="line">            compressed.data[i] = <span class="built_in">compress_byte</span>(chunk.data[i]);  <span class="comment">// 假设单字节压缩</span></span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="built_in">write_to_file</span>(compressed);  <span class="comment">// 可以异步</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::thread <span class="title">reader</span><span class="params">(networkReader)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(compressor)</span></span>;</span><br><span class="line"></span><br><span class="line">    reader.<span class="built_in">join</span>();</span><br><span class="line">    worker.<span class="built_in">join</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>方案二</p>
<figure class="highlight cpp"><figcaption><span>2_flow_graph.cpp</span><a href="/blog/downloads/code/tbb/pipeline/2_flow_graph.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方案 2：TBB Flow Graph</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/flow_graph.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/tbb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tasks.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tbb;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tbb::flow;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    graph g;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 读取节点（串行）</span></span><br><span class="line">    <span class="function">input_node&lt;DataChunk&gt; <span class="title">reader</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        g,</span></span></span><br><span class="line"><span class="params"><span class="function">        [](flow_control&amp; fc) -&gt; DataChunk {</span></span></span><br><span class="line"><span class="params"><span class="function">            DataChunk chunk(<span class="number">1024</span>);  <span class="comment">// 1KB数据块</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (!read_from_network(chunk)) {</span></span></span><br><span class="line"><span class="params"><span class="function">                fc.stop();</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">return</span> DataChunk();</span></span></span><br><span class="line"><span class="params"><span class="function">            }</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">return</span> chunk;</span></span></span><br><span class="line"><span class="params"><span class="function">        })</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 并行处理节点（无限制并发）</span></span><br><span class="line">    <span class="function">function_node&lt;DataChunk, CompressedChunk&gt; <span class="title">processor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        g, unlimited,</span></span></span><br><span class="line"><span class="params"><span class="function">        [](<span class="type">const</span> DataChunk&amp; input) -&gt; CompressedChunk {</span></span></span><br><span class="line"><span class="params"><span class="function">            CompressedChunk output(input.data.size());</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            tbb::parallel_for(</span></span></span><br><span class="line"><span class="params"><span class="function">                tbb::blocked_range&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>, input.data.size()),</span></span></span><br><span class="line"><span class="params"><span class="function">                [&amp;](<span class="type">const</span> tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r) {</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">for</span> (<span class="type">size_t</span> i = r.begin(); i != r.end(); ++i) {</span></span></span><br><span class="line"><span class="params"><span class="function">                        output.data[i] = compress_byte(input.data[i]);</span></span></span><br><span class="line"><span class="params"><span class="function">                    }</span></span></span><br><span class="line"><span class="params"><span class="function">                });</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">return</span> output;</span></span></span><br><span class="line"><span class="params"><span class="function">        })</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 写入节点（串行保证写入顺序）</span></span><br><span class="line">    <span class="function">function_node&lt;CompressedChunk&gt; <span class="title">writer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        g, serial,</span></span></span><br><span class="line"><span class="params"><span class="function">        [](<span class="type">const</span> CompressedChunk&amp; output) {</span></span></span><br><span class="line"><span class="params"><span class="function">            write_to_file(output);</span></span></span><br><span class="line"><span class="params"><span class="function">        })</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建数据流管道</span></span><br><span class="line">    <span class="built_in">make_edge</span>(reader, processor);</span><br><span class="line">    <span class="built_in">make_edge</span>(processor, writer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动管道</span></span><br><span class="line">    reader.<span class="built_in">activate</span>();</span><br><span class="line">    g.<span class="built_in">wait_for_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>方案三</p>
<figure class="highlight cpp"><figcaption><span>3_pipeline.cpp</span><a href="/blog/downloads/code/tbb/pipeline/3_pipeline.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方案 3: TBB 流水线</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/tbb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tasks.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    tbb::<span class="built_in">parallel_pipeline</span>(</span><br><span class="line">        <span class="comment">/* max_number_of_live_token */</span> <span class="number">4</span>,</span><br><span class="line">        <span class="comment">// Stage 1: 读网络数据</span></span><br><span class="line">        tbb::<span class="built_in">make_filter</span>&lt;<span class="type">void</span>, DataChunk&gt;(</span><br><span class="line">            tbb::filter_mode::serial_in_order,</span><br><span class="line">            [](tbb::flow_control&amp; fc) -&gt; DataChunk {</span><br><span class="line">                DataChunk chunk;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">read_from_network</span>(chunk)) {  <span class="comment">// 返回 false 时结束</span></span><br><span class="line">                    fc.<span class="built_in">stop</span>();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> chunk;</span><br><span class="line">            }) &amp;</span><br><span class="line">            <span class="comment">// Stage 2: CPU 压缩</span></span><br><span class="line">            tbb::<span class="built_in">make_filter</span>&lt;DataChunk, CompressedChunk&gt;(</span><br><span class="line">                tbb::filter_mode::parallel,</span><br><span class="line">                [](DataChunk chunk) -&gt; CompressedChunk {</span><br><span class="line">                    CompressedChunk <span class="built_in">out</span>(chunk.data.<span class="built_in">size</span>());</span><br><span class="line">                    tbb::<span class="built_in">parallel_for</span>(<span class="built_in">size_t</span>(<span class="number">0</span>), chunk.data.<span class="built_in">size</span>(), [&amp;](<span class="type">size_t</span> i) {</span><br><span class="line">                        out.data[i] = <span class="built_in">compress_byte</span>(chunk.data[i]);</span><br><span class="line">                    });</span><br><span class="line">                    <span class="keyword">return</span> out;</span><br><span class="line">                }) &amp;</span><br><span class="line">            <span class="comment">// Stage 3: 写文件</span></span><br><span class="line">            tbb::<span class="built_in">make_filter</span>&lt;CompressedChunk, <span class="type">void</span>&gt;(</span><br><span class="line">                tbb::filter_mode::serial_in_order,</span><br><span class="line">                [](CompressedChunk out) {</span><br><span class="line">                    <span class="built_in">write_to_file</span>(out);  <span class="comment">// 可以异步</span></span><br><span class="line">                }));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/19/net/%E5%BC%82%E6%AD%A5IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/19/net/%E5%BC%82%E6%AD%A5IO/" class="post-title-link" itemprop="url">异步IO</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-19 20:26:00" itemprop="dateCreated datePublished" datetime="2025-08-19T20:26:00+00:00">2025-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-16 02:21:27" itemprop="dateModified" datetime="2025-09-16T02:21:27+00:00">2025-09-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="IO模型概念"><a href="#IO模型概念" class="headerlink" title="IO模型概念"></a>IO模型概念</h2><p>IO 模型通常按两条维度划分：</p>
<ol>
<li><p>阻塞 vs 非阻塞</p>
<ul>
<li>阻塞 IO（Blocking IO）：调用 read&#x2F;recv 等函数时，如果数据没准备好，进程会被挂起，直到数据就绪。</li>
<li>非阻塞 IO（Non-blocking IO）：调用 read&#x2F;recv 时，如果数据没准备好，直接返回 EAGAIN 或 EWOULDBLOCK，进程继续做别的事情。</li>
</ul>
</li>
<li><p>同步 vs 异步</p>
<ul>
<li><p>同步（Synchronous）：调用者要等待操作完成才能继续。</p>
<ul>
<li>阻塞 IO + 同步：最常见，比如普通 read(fd, buf, n)</li>
<li>非阻塞 IO + 同步：调用立即返回，如果没数据则报错或返回 0</li>
</ul>
</li>
<li><p>异步（Asynchronous）：调用者发起操作后，不需要等待，操作完成时通过回调、信号、事件通知等告知结果。</p>
</li>
</ul>
</li>
</ol>
<p>⚡ 关键：异步 IO 的核心是不阻塞当前线程，而结果通知是通过事件或回调完成的。</p>
<h2 id="Linux-常见异步-IO-方式"><a href="#Linux-常见异步-IO-方式" class="headerlink" title="Linux 常见异步 IO 方式"></a>Linux 常见异步 IO 方式</h2><p>Linux 下主要有四种机制：</p>
<ol>
<li><p>POSIX AIO（aio_* 系列）</p>
<ul>
<li><p>系统调用：aio_read(), aio_write()</p>
</li>
<li><p>完成通知方式：</p>
<ul>
<li>轮询 aio_error()</li>
<li>信号通知 SIGIO</li>
<li>回调函数 sigevent.sigev_notify &#x3D; SIGEV_THREAD</li>
</ul>
</li>
<li><p>使用场景：文件 IO，可以在后台发起读写请求，主线程继续工作。</p>
</li>
<li><p>⚠️ 目前性能不如 epoll + 线程池模拟异步。</p>
</li>
</ul>
</li>
<li><p>信号驱动 IO（SIGIO）</p>
<ul>
<li>进程或文件描述符注册 F_SETOWN，开启 O_ASYNC</li>
<li>当 fd 可读写时，内核发信号给进程</li>
<li>通常用于少量 fd 的异步事件</li>
</ul>
</li>
<li><p>I&#x2F;O 多路复用（select, poll, epoll）</p>
<ul>
<li><p>本质是非阻塞 + 事件通知</p>
</li>
<li><p>Epoll + 非阻塞 IO 可以模拟高效的异步 IO</p>
</li>
<li><p>适合网络服务器、socket 编程</p>
</li>
<li><p>典型流程：</p>
<ul>
<li>设置 fd 为非阻塞（否则 read&#x2F;write 可能阻塞，因为 epoll 本质是同步的）</li>
<li>注册 fd 到 epoll，关注 EPOLLIN &#x2F; EPOLLOUT</li>
<li>调用 epoll_wait 等待事件</li>
<li>事件触发时读取或写入数据</li>
</ul>
</li>
</ul>
</li>
<li><p>Linux AIO（io_uring）</p>
<ul>
<li>新一代高性能异步 IO 接口</li>
<li>支持文件、网络 IO</li>
<li>提供 提交队列 + 完成队列，几乎零系统调用开销</li>
<li>可以真正做到线程几乎不阻塞等待</li>
</ul>
</li>
</ol>
<h3 id="异步-IO-的优点"><a href="#异步-IO-的优点" class="headerlink" title="异步 IO 的优点"></a>异步 IO 的优点</h3><ul>
<li>不阻塞主线程，提高吞吐量</li>
<li>可同时处理大量 IO（特别是网络&#x2F;文件服务器）</li>
<li>与多线程相比，降低线程上下文切换开销</li>
</ul>
<h3 id="异步-IO-的缺点"><a href="#异步-IO-的缺点" class="headerlink" title="异步 IO 的缺点"></a>异步 IO 的缺点</h3><ul>
<li>编程复杂度高（需要事件驱动、回调或状态机）</li>
<li>错误处理和信号安全问题复杂</li>
<li>文件异步 IO 性能在传统 AIO 下不一定比多线程高</li>
</ul>
<h3 id="Linux-下常见异步-I-O-机制对比"><a href="#Linux-下常见异步-I-O-机制对比" class="headerlink" title="Linux 下常见异步 I&#x2F;O 机制对比"></a>Linux 下常见异步 I&#x2F;O 机制对比</h3><table>
<thead>
<tr>
<th>特性 &#x2F; 机制</th>
<th>POSIX AIO</th>
<th>epoll + 非阻塞 IO</th>
<th>io_uring</th>
<th>信号驱动 IO (SIGIO)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>类型</strong></td>
<td>异步文件 IO</td>
<td>多路复用 + 非阻塞网络 IO</td>
<td>高性能异步 IO</td>
<td>异步事件通知</td>
</tr>
<tr>
<td><strong>支持对象</strong></td>
<td>文件</td>
<td>文件描述符（socket、管道等）</td>
<td>文件 + 网络 + 其他 IO</td>
<td>文件描述符（socket、pipe）</td>
</tr>
<tr>
<td><strong>用户态&#x2F;内核态</strong></td>
<td>系统调用提交，内核异步处理</td>
<td>用户态轮询&#x2F;等待事件，内核检查 fd</td>
<td>用户态 SQ + 内核 CQ</td>
<td>用户注册 fd，内核通过信号通知</td>
</tr>
<tr>
<td><strong>提交方式</strong></td>
<td>aio_read&#x2F;aio_write</td>
<td>写入 fd 并通过 epoll_wait 检查</td>
<td>写入 SQ（批量可提交）</td>
<td>设置 O_ASYNC + F_SETOWN</td>
</tr>
<tr>
<td><strong>完成通知</strong></td>
<td>信号 &#x2F; 回调 &#x2F; aio_error轮询</td>
<td>epoll_wait 返回就绪事件</td>
<td>完成队列 (CQ)，阻塞或非阻塞读取</td>
<td>信号处理函数 (SIGIO)</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>中等，系统调用多</td>
<td>高，单线程处理大量 fd</td>
<td>很高，几乎零系统调用，批量提交</td>
<td>较低，信号开销大，适合少量 fd</td>
</tr>
<tr>
<td><strong>编程复杂度</strong></td>
<td>中等偏复杂</td>
<td>中等，需要状态机处理</td>
<td>高，但灵活，可批量和链式操作</td>
<td>高，信号处理函数限制多，必须信号安全</td>
</tr>
<tr>
<td><strong>适合场景</strong></td>
<td>文件异步读写</td>
<td>高并发网络服务器</td>
<td>高性能文件和网络 IO</td>
<td>少量异步事件或控制信号触发场景</td>
</tr>
</tbody></table>
<h2 id="Linux-io-uring"><a href="#Linux-io-uring" class="headerlink" title="Linux io_uring"></a>Linux io_uring</h2><p>io_uring 是 Linux 内核自 5.1 版本引入的一个异步 I&#x2F;O 框架，它提供了 低延迟、高吞吐的异步文件和网络 I&#x2F;O。它的特点是：</p>
<ul>
<li>零拷贝提交：应用程序可以直接向内核提交 I&#x2F;O 请求，无需系统调用每次阻塞。</li>
<li>环形队列机制：通过共享内存的 提交队列（Submission Queue, SQ） 和 完成队列（Completion Queue, CQ），用户态和内核态可以高效交互。</li>
<li>支持多种 I&#x2F;O 类型：文件读写、网络收发、文件同步、缓冲区操作等。</li>
<li>批量提交和完成：可以一次提交多个 I&#x2F;O 请求，并批量获取完成结果。</li>
</ul>
<p>简单理解：它把传统阻塞 I&#x2F;O 的 “系统调用来回” 改成了 共享环形队列 + 异步通知。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li>方法一：从 APT 安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install liburing-dev</span><br></pre></td></tr></table></figure>

<p>检查安装路径</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /usr/include/liburing.h</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>方法二：从源码安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/axboe/liburing.git</span><br><span class="line"><span class="built_in">cd</span> liburing</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h3 id="io-uring-的核心数据结构"><a href="#io-uring-的核心数据结构" class="headerlink" title="io_uring 的核心数据结构"></a>io_uring 的核心数据结构</h3><p>Submission Queue（SQ）</p>
<ul>
<li>用户态将 I&#x2F;O 请求放入 SQ。</li>
<li>SQ 是一个环形数组，存放 io_uring_sqe（I&#x2F;O 请求条目）。</li>
<li>用户通过 系统调用 io_uring_enter 将 SQ 中的新请求通知内核。</li>
<li>内核会按顺序处理 SQ 中的 I&#x2F;O 请求。</li>
</ul>
<table>
<thead>
<tr>
<th>字段</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>opcode</code></td>
<td>I&#x2F;O 类型，如读、写、fsync、accept、sendmsg</td>
</tr>
<tr>
<td><code>fd</code></td>
<td>文件描述符</td>
</tr>
<tr>
<td><code>off</code></td>
<td>偏移量（文件 I&#x2F;O）</td>
</tr>
<tr>
<td><code>addr</code></td>
<td>用户缓冲区地址</td>
</tr>
<tr>
<td><code>len</code></td>
<td>I&#x2F;O 数据长度</td>
</tr>
<tr>
<td><code>flags</code></td>
<td>请求标志，如 <code>IOSQE_FIXED_FILE</code>、<code>IOSQE_IO_LINK</code></td>
</tr>
</tbody></table>
<p>Completion Queue（CQ）</p>
<ul>
<li>内核完成 I&#x2F;O 后，将结果写入 CQ。</li>
<li>CQ 也是一个环形数组，存放 io_uring_cqe（完成条目）。</li>
<li>用户可以轮询或等待 CQ 获取完成结果。</li>
</ul>
<table>
<thead>
<tr>
<th>字段</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>res</code></td>
<td>I&#x2F;O 结果，成功为正数（读写字节数），失败为负错误码</td>
</tr>
<tr>
<td><code>user_data</code></td>
<td>用户自定义数据，方便识别请求</td>
</tr>
</tbody></table>
<h3 id="io-uring-工作流程"><a href="#io-uring-工作流程" class="headerlink" title="io_uring 工作流程"></a>io_uring 工作流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+-----------+          +-----------+</span><br><span class="line">| User App  | &lt;-----&gt;  |  Kernel  |</span><br><span class="line">+-----------+          +-----------+</span><br><span class="line">      |                     |</span><br><span class="line">      |  write SQE to SQ    | &lt;- Submission Queue</span><br><span class="line">      |--------------------&gt;|</span><br><span class="line">      |                     |</span><br><span class="line">      |   io_uring_enter    | &lt;- 通知内核处理</span><br><span class="line">      |--------------------&gt;|</span><br><span class="line">      |                     |</span><br><span class="line">      | &lt;------------------ | &lt;- CQE 放入 CQ</span><br><span class="line">      |  read CQE from CQ   |</span><br></pre></td></tr></table></figure>

<ul>
<li>用户态填充 SQE（Submission Queue Entry）。</li>
<li>调用 io_uring_enter() 提交 SQE （不阻塞）。</li>
<li>内核处理 I&#x2F;O 请求。</li>
<li>内核把完成结果写入 CQ。</li>
<li>用户态可以：<ul>
<li>轮询 CQ：主动读取 CQE（Completion Queue Entry）</li>
<li>注册回调（liburing 新版本支持 IORING_SETUP_IOPOLL + IORING_SETUP_SQPOLL 或自己封装）</li>
</ul>
</li>
</ul>
<p>注意：</p>
<ul>
<li>异步 I&#x2F;O ≠ 必须用回调。关键是提交后不阻塞等待，可以同步轮询完成结果，也可以异步触发回调。</li>
<li>回调是一种可选的使用方式。</li>
<li>最核心的是 共享环形队列 + 完成队列，用户可以同步取结果也可以异步通知。</li>
</ul>
<h3 id="为什么-io-uring-没有强制回调"><a href="#为什么-io-uring-没有强制回调" class="headerlink" title="为什么 io_uring 没有强制回调"></a>为什么 io_uring 没有强制回调</h3><p>传统异步 I&#x2F;O（比如 Windows IOCP）必须注册回调或事件句柄，因为内核不会给你“主动通知”。</p>
<p>Linux io_uring 的设计哲学是：</p>
<ul>
<li>用户态和内核共享内存 → 用户态可以自己轮询完成队列。</li>
<li>减少系统调用次数 → 不依赖信号或回调触发。</li>
<li>需要回调时，用户可以自己封装一个事件循环。</li>
</ul>
<p>所以你看到 io_uring 的官方示例都是 顺序写代码，但是仍然是异步 I&#x2F;O，因为：</p>
<ul>
<li>提交后内核可以并行处理多个 I&#x2F;O。</li>
<li>用户态无需阻塞等待内核完成处理（可以去做别的事）。</li>
</ul>
<h3 id="io-uring-的使用示例（C-语言）"><a href="#io-uring-的使用示例（C-语言）" class="headerlink" title="io_uring 的使用示例（C 语言）"></a>io_uring 的使用示例（C 语言）</h3><figure class="highlight cpp"><figcaption><span>io_uring_hello.c</span><a href="/blog/downloads/code/io/io_uring_hello.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;liburing.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE_DEPTH  8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE  1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">io_uring</span> ring;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">io_uring_sqe</span> *sqe;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">io_uring_cqe</span> *cqe;</span><br><span class="line">    <span class="type">int</span> ret, fd;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 io_uring</span></span><br><span class="line">    ret = <span class="built_in">io_uring_queue_init</span>(QUEUE_DEPTH, &amp;ring, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;io_uring_queue_init&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取提交队列条目</span></span><br><span class="line">    sqe = <span class="built_in">io_uring_get_sqe</span>(&amp;ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) {</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;io_uring_get_sqe failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备读取操作</span></span><br><span class="line">    <span class="built_in">io_uring_prep_read</span>(sqe, fd, buf, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交到内核</span></span><br><span class="line">    ret = <span class="built_in">io_uring_submit</span>(&amp;ring);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;io_uring_submit&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待完成</span></span><br><span class="line">    ret = <span class="built_in">io_uring_wait_cqe</span>(&amp;ring, &amp;cqe);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;io_uring_wait_cqe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取结果</span></span><br><span class="line">    <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Async read failed: %d\n&quot;</span>, cqe-&gt;res);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read %d bytes: %.*s\n&quot;</span>, cqe-&gt;res, cqe-&gt;res, buf);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知内核完成</span></span><br><span class="line">    <span class="built_in">io_uring_cqe_seen</span>(&amp;ring, cqe);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    <span class="built_in">io_uring_queue_exit</span>(&amp;ring);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>这个例子展示了 最基本的异步文件读取：</p>
<ul>
<li>初始化 ring。</li>
<li>获取一个 SQE 并填充读请求。</li>
<li>提交 SQE。</li>
<li>等待 CQE 获取结果。</li>
<li>标记完成并清理。</li>
</ul>
<h2 id="Boost-asio"><a href="#Boost-asio" class="headerlink" title="Boost asio"></a>Boost asio</h2><p>要区分 操作系统级别的异步 I&#x2F;O 和 asio 的抽象，因为 asio 并不是单一机制，而是根据平台选择最优实现。具体分析如下：</p>
<h3 id="asio-的工作原理"><a href="#asio-的工作原理" class="headerlink" title="asio 的工作原理"></a>asio 的工作原理</h3><p>asio 提供 异步接口（async_read, async_write 等），程序不会阻塞线程</p>
<p>内部实现方式根据平台不同而不同：</p>
<table>
<thead>
<tr>
<th>平台</th>
<th>异步方式</th>
</tr>
</thead>
<tbody><tr>
<td>Linux</td>
<td>基于 <strong>epoll &#x2F; io_uring &#x2F; AIO</strong>，是真正的内核异步 I&#x2F;O（零拷贝，内核通知完成）</td>
</tr>
<tr>
<td>Windows</td>
<td>基于 <strong>IOCP</strong>（I&#x2F;O Completion Ports），内核异步 I&#x2F;O</td>
</tr>
<tr>
<td>Mac &#x2F; BSD</td>
<td>基于 <strong>kqueue &#x2F; poll</strong>，有些情况下是模拟异步（多线程或事件轮询）</td>
</tr>
</tbody></table>
<p>要确认 asio 在你的 Linux 机器上选择了哪种底层 I&#x2F;O 机制，可以按下面几个方法操作：</p>
<ol>
<li>查看 asio 使用的 I&#x2F;O 对象</li>
</ol>
<p>asio 有两个主要 I&#x2F;O 后端：</p>
<ul>
<li>旧版 AIO &#x2F; epoll（select_reactor &#x2F; epoll_reactor）</li>
<li>io_uring（在新版本 Boost.Asio 或 standalone Asio 支持）</li>
</ul>
<p>在 编译时，asio 会检测系统特性：</p>
<ul>
<li>如果 Linux 内核 ≥ 5.1，asio 默认启用 io_uring</li>
<li>否则使用 epoll</li>
</ul>
<ol start="2">
<li>通过宏或配置查看</li>
</ol>
<p>在你的 asio 头文件中，可能有如下宏：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(BOOST_ASIO_HAS_IOURING)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;asio will use io_uring\n&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(BOOST_ASIO_HAS_EPOLL)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;asio will use epoll\n&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这些宏在 boost&#x2F;asio&#x2F;detail&#x2F;config.hpp 或 asio&#x2F;config.hpp 中定义，表示底层机制。</p>
<ol start="3">
<li>运行时确认</li>
</ol>
<p>asio 本身没有公开 API 显示底层 I&#x2F;O 类型，但可以通过系统调用监控判断：</p>
<p>使用 strace 观察程序 I&#x2F;O：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -f ./your_program 2&gt;&amp;1 | grep io_uring</span><br></pre></td></tr></table></figure>

<ul>
<li>如果看到 io_uring_setup、io_uring_enter 系统调用，就说明启用了 io_uring</li>
<li>如果没有，只看到 epoll_wait &#x2F; epoll_ctl，说明使用的是 epoll</li>
</ul>
<p>对 epoll，strace 会显示 epoll_create1 &#x2F; epoll_ctl &#x2F; epoll_wait</p>
<h3 id="阻塞-vs-异步"><a href="#阻塞-vs-异步" class="headerlink" title="阻塞 vs 异步"></a>阻塞 vs 异步</h3><table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>asio 中的表现</th>
</tr>
</thead>
<tbody><tr>
<td>阻塞 I&#x2F;O</td>
<td>调用时线程被挂起，等待 I&#x2F;O 完成</td>
<td>不使用，线程会被阻塞，TBB 线程占用</td>
</tr>
<tr>
<td>模拟异步</td>
<td>内核不支持真正异步，用线程轮询或线程池实现</td>
<td>Mac&#x2F;BSD 某些场景下可能是模拟</td>
</tr>
<tr>
<td>真正异步 I&#x2F;O</td>
<td>内核支持，操作提交后立即返回，完成由内核通知</td>
<td>Linux&#x2F;io_uring、Windows IOCP 就是真正异步</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/19/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/19/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-19 20:12:58" itemprop="dateCreated datePublished" datetime="2025-08-19T20:12:58+00:00">2025-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-16 02:21:27" itemprop="dateModified" datetime="2025-09-16T02:21:27+00:00">2025-09-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><p>malloc 是线程安全的，但有一些细节需要注意。</p>
<ol>
<li>线程安全含义</li>
</ol>
<p>线程安全：多个线程同时调用 malloc&#x2F;free 不会破坏堆管理结构，也不会导致内存管理崩溃。</p>
<p>实现方法：</p>
<p>glibc malloc 在内部使用 锁（mutex 或 spinlock） 保护全局堆管理数据结构</p>
<p>不同线程同时申请或释放内存，内核保证堆表一致</p>
<ol start="2">
<li>限制与注意事项</li>
</ol>
<p>性能问题</p>
<p>多线程频繁 malloc&#x2F;free，锁竞争可能成为瓶颈</p>
<p>对性能敏感的程序可能使用：</p>
<p>线程本地缓存（thread-local cache） 的 jemalloc &#x2F; tcmalloc</p>
<p>避免全局锁竞争</p>
<p>信号处理上下文不安全</p>
<p>虽然线程安全，但 malloc 在信号处理函数里不安全</p>
<p>原因：</p>
<p>信号可能打断正在执行的 malloc</p>
<p>malloc 内部锁可能被持有 → 再次调用可能死锁</p>
<p>所以 signal handler 中不能直接调用 malloc&#x2F;free</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>malloc&#x2F;glibc</th>
</tr>
</thead>
<tbody><tr>
<td>多线程调用安全</td>
<td>✅ 是线程安全的</td>
</tr>
<tr>
<td>信号处理函数调用安全</td>
<td>❌ 不安全</td>
</tr>
<tr>
<td>性能</td>
<td>可能锁竞争，需要优化（jemalloc&#x2F;tcmalloc）</td>
</tr>
</tbody></table>
<h2 id="信号安全"><a href="#信号安全" class="headerlink" title="信号安全"></a>信号安全</h2><p>malloc &#x2F; free 内部会修改全局堆管理结构（如 free list）</p>
<p>如果信号到达时主程序正在调用 malloc 或 free，信号处理函数里再次调用 malloc&#x2F;free → 堆数据结构可能被破坏，<br>可能导致崩溃或内存泄漏</p>
<p>虽然线程安全，但 malloc 在信号处理函数里不安全</p>
<p>原因：</p>
<ul>
<li>信号可能打断正在执行的 malloc</li>
<li>malloc 内部锁可能被持有 → 再次调用可能死锁</li>
</ul>
<p>所以 signal handler 中不能直接调用 malloc&#x2F;free</p>
<h3 id="安全做法"><a href="#安全做法" class="headerlink" title="安全做法"></a>安全做法</h3><p>信号处理函数里只做：</p>
<ul>
<li>设置标志位（sig_atomic_t flag &#x3D; 1;）</li>
<li>写入 pipe &#x2F; eventfd</li>
<li>调用 async-signal-safe 系统调用（write(), _exit()）</li>
</ul>
<p>之后由主程序在安全上下文处理 malloc&#x2F;free 或其他复杂操作</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/19/os/%E4%BF%A1%E5%8F%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/19/os/%E4%BF%A1%E5%8F%B7/" class="post-title-link" itemprop="url">信号</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-19 20:08:39" itemprop="dateCreated datePublished" datetime="2025-08-19T20:08:39+00:00">2025-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-16 02:21:27" itemprop="dateModified" datetime="2025-09-16T02:21:27+00:00">2025-09-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="异步信号"><a href="#异步信号" class="headerlink" title="异步信号"></a>异步信号</h2><p>锁、malloc 等不能在信号处理函数里用。这里涉及到 异步信号安全 (async-signal-safe) 的概念。</p>
<ol>
<li>信号处理函数的执行环境</li>
</ol>
<p>当一个信号到达进程时，内核 异步中断当前执行流，立即跳转到信号处理函数执行。</p>
<p>这意味着：</p>
<p>当前线程可能 正在持有锁（mutex、spinlock 等）</p>
<p>当前线程可能 正在使用 malloc&#x2F;free，操作堆数据结构</p>
<ol start="2">
<li>为什么不能调用这些函数</li>
</ol>
<p>锁（mutex 等）</p>
<p>如果信号处理函数里调用 pthread_mutex_lock()：</p>
<p>线程可能已经在信号到达前持有这个锁</p>
<p>信号处理函数再次尝试加锁 → 死锁</p>
<p>malloc &#x2F; free</p>
<p>malloc 内部会修改全局堆管理结构（如 free list）</p>
<p>如果信号到达时主程序正在调用 malloc 或 free，信号处理函数里再次调用 malloc&#x2F;free → 堆数据结构可能被破坏</p>
<p>可能导致崩溃或内存泄漏</p>
<ol start="3">
<li>async-signal-safe 函数</li>
</ol>
<p>POSIX 定义了一组 “异步信号安全函数”（async-signal-safe functions）</p>
<p>信号处理函数中 只允许调用这些函数</p>
<p>常用安全函数示例：</p>
<p>_exit()</p>
<p>write()（低级系统调用，不会锁堆）</p>
<p>sig_atomic_t 类型变量赋值</p>
<p>总结</p>
<table>
<thead>
<tr>
<th>函数类型</th>
<th>可在信号处理函数里用？</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>pthread_mutex_lock</td>
<td>❌</td>
<td>可能已持锁 → 死锁</td>
</tr>
<tr>
<td>malloc&#x2F;free</td>
<td>❌</td>
<td>可能正在操作堆 → 数据结构破坏</td>
</tr>
<tr>
<td>write(fd, buf, n)</td>
<td>✅</td>
<td>系统调用，不会破坏用户态结构</td>
</tr>
<tr>
<td>_exit()</td>
<td>✅</td>
<td>安全终止进程</td>
</tr>
</tbody></table>
<blockquote>
<p>核心思想：信号是异步的，中断当前执行流，调用非 async-signal-safe 函数可能破坏正在执行的操作，导致不可预测的行为。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/19/concurrency/thread_local%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/19/concurrency/thread_local%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">thread_local的实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-19 19:41:37" itemprop="dateCreated datePublished" datetime="2025-08-19T19:41:37+00:00">2025-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-16 02:21:27" itemprop="dateModified" datetime="2025-09-16T02:21:27+00:00">2025-09-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/c-cpp/" itemprop="url" rel="index"><span itemprop="name">c/cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>thread_local 的基本语义</li>
</ol>
<p>C++11 引入的存储类型说明符：</p>
<p>thread_local int x &#x3D; 0;</p>
<p>表示 每个线程都有一份独立的 x，互不干扰。</p>
<p>生命周期：跟普通静态变量类似（全局存活直到线程退出）。</p>
<ol start="2">
<li>底层实现原理</li>
</ol>
<p>它的实现依赖于 TLS (Thread Local Storage, 线程局部存储) 机制。</p>
<p>在 ELF&#x2F;Linux 下：</p>
<p>编译器在 .tdata &#x2F; .tbss 段里为 thread_local 变量分配空间（就像全局变量在 .data &#x2F; .bss 段里）。</p>
<p>程序加载时，动态链接器（ld.so）会记录这些 TLS 变量的“模板布局”。</p>
<p>每个线程启动时，线程库（glibc&#x2F;pthread）会：</p>
<p>给这个线程分配一块 TLS 块（通常放在线程栈附近，或者专门的内存页）。</p>
<p>把 .tdata 里的初始值拷贝到这个线程的 TLS 块。</p>
<p>.tbss 部分（未初始化的 thread_local）则清零。</p>
<p>线程访问 thread_local 时，编译器生成的代码会通过 TLS 寄存器（如 x86-64 的 FS&#x2F;GS 段寄存器）+ 偏移量，找到对应线程的存储单元。</p>
<p>例如 x86-64 Linux 上，errno 就是：</p>
<p>#define errno (*__errno_location())</p>
<p>而 __errno_location() 内部就是通过 %fs:offset 找到 TLS 块里的 errno。</p>
<ol start="3">
<li>存放在哪里？</li>
</ol>
<p>Windows：在 TEB (Thread Environment Block) 里有 TLS 指针，__declspec(thread) 就用它。</p>
<p>Linux&#x2F;ELF：在每个线程的 TLS 块里（通常分配在线程栈附近的一片内存区域）。访问通过 FS&#x2F;GS 寄存器。</p>
<p>编译器细节：</p>
<p>GCC&#x2F;Clang 默认用 “动态 TLS 模型”（访问时通过动态链接器查询 TLS 偏移）。</p>
<p>如果加 -ftls-model&#x3D;initial-exec，编译器会直接用固定偏移访问 TLS，速度更快（但要求变量在主程序或静态库里）。</p>
<ol start="4">
<li>示例</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        counter++;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;: counter = &quot;</span> &lt;&lt; counter &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(worker, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(worker, <span class="number">2</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出大致是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread 1: counter = 1</span><br><span class="line">Thread 1: counter = 2</span><br><span class="line">Thread 1: counter = 3</span><br><span class="line">Thread 2: counter = 1</span><br><span class="line">Thread 2: counter = 2</span><br><span class="line">Thread 2: counter = 3</span><br></pre></td></tr></table></figure>

<p>说明 counter 在不同线程里独立。</p>
<p>✅ 总结：</p>
<p>thread_local 变量放在 TLS 段，每个线程有自己的拷贝。</p>
<p>访问是通过 线程局部存储寄存器（FS&#x2F;GS）+ 偏移量 实现的。</p>
<p>存储空间由线程库在创建线程时分配和初始化。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/18/%E5%AE%9E%E7%94%A8%E4%B9%A6%E7%B1%8D%E5%88%97%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/18/%E5%AE%9E%E7%94%A8%E4%B9%A6%E7%B1%8D%E5%88%97%E8%A1%A8/" class="post-title-link" itemprop="url">实用书籍列表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-18 21:25:16" itemprop="dateCreated datePublished" datetime="2025-08-18T21:25:16+00:00">2025-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-16 02:21:27" itemprop="dateModified" datetime="2025-09-16T02:21:27+00:00">2025-09-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Misc/" itemprop="url" rel="index"><span itemprop="name">Misc</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>.<br>├── AT&amp;T Assembly Manual.pdf<br>├── C++ Primer Plus 第五版中文版.pdf<br>├── C++.Primer.5th.Edition_2013.pdf<br>├── CplusplusConcurrencyInAction_PracticalMultithreading.pdf<br>├── Debug Hacks中文版：深入调试的技术和工具.pdf<br>├── IB-Host-and-Ports.pdf<br>├── IBTA-Overview-of-IBTA-Volume-1-Release-1.6-2022-07-15.pdf<br>├── InifiniBand Guide.pdf<br>├── LDAP Authentication Guide.pdf<br>├── Linux Kernel Networking - Implementation and Theory.pdf<br>├── Linux-UNIX系统编程手册（上、下册）.pdf<br>├── Linux内核设计与实现(第三版中文高清带目录).pdf<br>├── Linux多线程服务端编程 - 陈硕.pdf<br>├── Linux多线程服务端编程：使用muduo C++网络库.pdf<br>├── Linux高性能服务器编程.pdf<br>├── OKTA Multifactor Authentication (MFA) FAQ.pdf<br>├── Shell脚本学习指南.pdf<br>├── TBB<br>│   ├── Intel TBB.pdf<br>│   ├── TBBtutorial.pdf<br>│   ├── intel-tbb.pdf<br>│   ├── oneTBB-master.zip<br>│   └── onetbb_developer-guide-api-reference_2021.6-772616-772617.pdf<br>├── UNIX环境高级编程(第三版).pdf<br>├── UNIX网络编程卷1：套接字联网API（第3版）.pdf<br>├── ccia_code_samples-master.zip<br>├── dmtcp<br>│   ├── Be Kind, Rewind —Checkpoint &amp; Restore Capability for Improving Reliability of Large-scale Semiconductor Design.pdf<br>│   ├── dmtcp-mug-17.pdf<br>│   └── plugin-tutorial.pdf<br>├── gdb-and-assembly.pdf<br>├── gdb-refcard.pdf<br>├── gdb.pdf<br>├── p4-p4v-cheat-sheet_cn.pdf<br>├── thread-analyzer-193426.pdf<br>├── 并行编程<br>│   ├── C++ Concurrency in Action.pdf<br>│   ├── C++-Concurrency-In-Action-2ed-zh-v0.2.pdf<br>│   ├── C++并发编程实战(中文版).pdf<br>│   ├── C++并发编程实战.pdf<br>│   ├── C++并发编程实战源代码<br>│   ├── C++并发编程实战源代码.zip<br>│   ├── Patterns_for_Parallel_Programming.pdf<br>│   └── 高并发网络模型.png<br>└── 编译原理(龙书) 第二版.pdf</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/17/misc/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/17/misc/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/" class="post-title-link" itemprop="url">如何创建个人主页</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-17 16:14:48" itemprop="dateCreated datePublished" datetime="2025-08-17T16:14:48+00:00">2025-08-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-16 02:21:27" itemprop="dateModified" datetime="2025-09-16T02:21:27+00:00">2025-09-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-Github-Pages"><a href="#1-Github-Pages" class="headerlink" title="1. Github Pages"></a>1. Github Pages</h1><p>本文解释利用<a target="_blank" rel="noopener" href="https://docs.github.com/en/pages">github pages</a>搭建个人主页&#x2F;项目主页的方法。</p>
<p>github pages简介：<a target="_blank" rel="noopener" href="https://docs.github.com/en/pages/getting-started-with-github-pages/about-github-pages">官方链接</a>。</p>
<p>github pages使用了<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/CNAME_record">CNAME record</a>技术，参考：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/39301250">链接1</a>、<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/26609475">链接2</a>、<a target="_blank" rel="noopener" href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/about-custom-domains-and-github-pages#using-a-subdomain-for-your-github-pages-site">Custom domains in Github Pages</a>。</p>
<p>注：<a target="_blank" rel="noopener" href="https://readthedocs.org/">Read the Docs</a>也是一个很好的搭建个人主页的网站。</p>
<h2 id="Github-Pages-站点类型"><a href="#Github-Pages-站点类型" class="headerlink" title="Github Pages 站点类型"></a>Github Pages 站点类型</h2><p>有3种类型的 Github Pages 站点（sites）：project, user 和 organization 。</p>
<p>Project sites 连接到 github 上特定 project ，比如 Javascript library 或 recipe collection。user 或 organization sites 连接到 github.com 的特定账户。</p>
<p>发布 user site ，你必须创建一个你的个人账户下的一个名为 <code>&lt;username&gt;.github.io</code> 的 repository 。发布 organization site ，你必须创建一个组织所有的名为 <code>&lt;organization&gt;.github.io</code> 的 repository 。除非你使用 custom domain ，否则 user 和 organization sites 将位于 <code>http(s)://&lt;username&gt;.github.io</code> 或 <code>http(s)://&lt;organization&gt;.github.io</code> 。</p>
<p>project site 的源文件存储在作为 project 的相同的 repository 中。除非使用 custom domain ， 否则 project sites 将位于 <code>http(s)://&lt;username&gt;.github.io/&lt;repository&gt;</code> 或 <code>http(s)://&lt;organization&gt;.github.io/&lt;repository&gt;</code> 。</p>
<p>有关如何自定义影响您网站的域名的更多信息，参见”<a target="_blank" rel="noopener" href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/about-custom-domains-and-github-pages">About custom domains and GitHub Pages</a>“。</p>
<p>每个 github 账户允许创建 1 个 user 或 organization 站点。无论是被组织还是个人所有，project 站点的个数不限制。</p>
<h2 id="GitHub-Pages-访问方法"><a href="#GitHub-Pages-访问方法" class="headerlink" title="GitHub Pages 访问方法"></a>GitHub Pages 访问方法</h2><p>参考<a target="_blank" rel="noopener" href="https://docs.github.com/en/pages/getting-started-with-github-pages/creating-a-github-pages-site#next-steps">官方文档</a>。</p>
<p>例如，你的project站点配置的发布源是<code>gh-pages</code>分支，然后在<code>gh-pages</code>分支上创建了一个<code>about/contact-us.md</code>文件，你将可以在<code>https://&lt;user&gt;.github.io/&lt;repository&gt;/about/contact-us.html</code>访问它。</p>
<p>你也可以使用<code>Jekyll</code>等静态站点生成器来给你的github page配置一个主题。</p>
<h2 id="站点发布常见问题的解决方法"><a href="#站点发布常见问题的解决方法" class="headerlink" title="站点发布常见问题的解决方法"></a>站点发布常见问题的解决方法</h2><ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/72851548/permission-denied-to-github-actionsbot">Permission denied to github-actions[bot]</a></li>
</ul>
<h2 id="Github-workflows"><a href="#Github-workflows" class="headerlink" title="Github workflows"></a>Github workflows</h2><p>参考<a target="_blank" rel="noopener" href="https://docs.github.com/zh/actions/using-workflows/workflow-syntax-for-github-actions">官方文档</a>。</p>
<h1 id="2-配置前准备"><a href="#2-配置前准备" class="headerlink" title="2. 配置前准备"></a>2. 配置前准备</h1><h2 id="2-1-Markdown编辑器"><a href="#2-1-Markdown编辑器" class="headerlink" title="2.1. Markdown编辑器"></a>2.1. Markdown编辑器</h2><p>推荐的<a target="_blank" rel="noopener" href="https://www.zhihu.com/tardis/zm/art/103348449?source_id=1003">markdown编辑器</a>：</p>
<ul>
<li>VSCode：免费。VSCode原生支持Markdown，安装一些插件可以帮助更快地编写markdown文件。</li>
<li>Typora：现在已经开始收费。</li>
</ul>
<p>VSCode markdown插件：</p>
<ul>
<li>Mardown All in One: 提供快捷键，帮助更快的编写markdown文件。</li>
<li>Markdown+Math：提供数学公式支持。</li>
<li>Markdown Preview Enhanced: 将原生markdown预览的黑色背景改成白色。</li>
<li>Markdown Preview Github Styling：提供Github风格的预览。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.tablesgenerator.com/markdown_tables">在线表格生成器</a>：可以生成Markdown、Text、HTML、LaTex、MediaWiki格式的表格。</p>
<h2 id="2-2-轻量级虚拟机WSL"><a href="#2-2-轻量级虚拟机WSL" class="headerlink" title="2.2. 轻量级虚拟机WSL"></a>2.2. 轻量级虚拟机WSL</h2><p>WSL，<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/wsl/install">Windows Subsystem for Linux</a>，是Windows提供的轻量级Linux虚拟机。</p>
<p>安装教程：见<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/170210673">链接</a>。</p>
<h3 id="2-2-1-WSL默认没有启用systemctl："><a href="#2-2-1-WSL默认没有启用systemctl：" class="headerlink" title="2.2.1. WSL默认没有启用systemctl："></a>2.2.1. WSL默认没有启用systemctl：</h3><p>启用systemctl的方法：<a target="_blank" rel="noopener" href="https://askubuntu.com/questions/1379425/system-has-not-been-booted-with-systemd-as-init-system-pid-1-cant-operate">链接</a>。</p>
<p>替代方法：不需要启动systemctl，因为会比较占用资源，启动也会变慢。可以使用service命令替代。</p>
<h3 id="2-2-2-WSL默认没有安装openssl-server："><a href="#2-2-2-WSL默认没有安装openssl-server：" class="headerlink" title="2.2.2. WSL默认没有安装openssl-server："></a>2.2.2. WSL默认没有安装openssl-server：</h3><p>使用ssh连接到服务器时，需要服务器运行着sshd程序，否则连接不上，会出现”<a target="_blank" rel="noopener" href="https://www.makeuseof.com/fix-ssh-connection-refused-error-linux/">Connection refused</a>“错误。</p>
<p>参考<a target="_blank" rel="noopener" href="https://askubuntu.com/questions/1339980/enable-ssh-in-wsl-system">链接</a>。</p>
<p>查看openssh-server有没有安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg --list | grep ssh</span><br></pre></td></tr></table></figure>

<p>注：如果安装了openssh-server，执行which sshd可以看到路径。</p>
<p>WSL默认没有安装openssh-server，安装方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure>

<p>启动ssh：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service ssh start</span><br></pre></td></tr></table></figure>

<h3 id="2-2-3-通过https登录到github"><a href="#2-2-3-通过https登录到github" class="headerlink" title="2.2.3. 通过https登录到github"></a>2.2.3. 通过https登录到github</h3><p><code>git push</code>不再支持输入用户名和密码，当提示输入密码时，需要输入personal access token.</p>
<p>步骤1：在github上<a target="_blank" rel="noopener" href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#creating-a-personal-access-token-classic">创建personal access token</a>；</p>
<p>步骤2：<a target="_blank" rel="noopener" href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#using-a-personal-access-token-on-the-command-line">在命令行上使用personal access token</a>；</p>
<p>步骤3：为了避免每次都需要输入personal access token，可以将其<a target="_blank" rel="noopener" href="https://docs.github.com/en/get-started/getting-started-with-git/caching-your-github-credentials-in-git">缓存在git client上</a>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gh auth login</span><br></pre></td></tr></table></figure>

<p>注：使用<code>gh</code>命令需要先安装GitHub CLI：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gh</span><br></pre></td></tr></table></figure>

<h3 id="2-2-4-执行git-pull-push时，出现”The-authenticity-of-host-‘github-com-20-205-243-166-’-can’t-be-established-ED25519-key-fingerprint-is-SHA256-…”错误"><a href="#2-2-4-执行git-pull-push时，出现”The-authenticity-of-host-‘github-com-20-205-243-166-’-can’t-be-established-ED25519-key-fingerprint-is-SHA256-…”错误" class="headerlink" title="2.2.4 执行git pull&#x2F;push时，出现”The authenticity of host ‘github.com (20.205.243.166)’ can’t be established. ED25519 key fingerprint is SHA256:…”错误"></a>2.2.4 执行git pull&#x2F;push时，出现”The authenticity of host ‘github.com (20.205.243.166)’ can’t be established. ED25519 key fingerprint is SHA256:…”错误</h3><p>报错解释：</p>
<p>这个报错信息通常出现在使用SSH连接到一个新的主机时。它表示你的计算机无法验证远程服务器的身份，因为服务器的公钥不在你本地计算机的known_hosts文件中。这是SSH为了防止”中间人”攻击而进行的安全检查。</p>
<p>解决方法：</p>
<p>验证指纹信息：你可以查看远程主机的指纹信息，并与服务器gitee.com的公钥指纹进行对比，确保它们匹配。你可以在~&#x2F;.ssh&#x2F;known_hosts文件中找到已知主机的公钥指纹。</p>
<p>如果确认指纹正确无误，且你信任这个服务器，可以添加这个主机及其公钥到你的known_hosts文件中，以便SSH不再警告。执行以下命令：</p>
<p>ssh-keyscan -H gitee.com &gt;&gt; ~&#x2F;.ssh&#x2F;known_hosts</p>
<p>如果你不想添加到known_hosts文件中，可以在第一次连接时使用ssh -o StrictHostKeyChecking&#x3D;no来跳过这个检查。但这样做会降低安全性。</p>
<p>如果你是在多个服务器上使用相同的IP地址，并且之前已经添加过这个IP的记录，那么可能是服务器的公钥发生了变化，这种情况下你应该联系服务器管理员确认公钥的变更。</p>
<p>注意：在实际生产环境中，不建议无条件信任新的SSH指纹，除非你完全了解这个服务器的来源和身份。</p>
<h1 id="3-静态站点生成器"><a href="#3-静态站点生成器" class="headerlink" title="3. 静态站点生成器"></a>3. 静态站点生成器</h1><p>以下几种<a target="_blank" rel="noopener" href="https://docs.github.com/en/pages/getting-started-with-github-pages/about-github-pages">静态站点生成器</a>都可以用来搭建个人主页。如果使用除JekyII外的工具，则需要配置<a target="_blank" rel="noopener" href="https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions">Github Actions</a>以构建和发布你的站点。</p>
<h2 id="3-1-mkdocs"><a href="#3-1-mkdocs" class="headerlink" title="3.1. mkdocs"></a>3.1. mkdocs</h2><p><a target="_blank" rel="noopener" href="https://www.mkdocs.org/">mkdocs</a>是一个快速的静态网页生成器。</p>
<p>发布个人网站的方法：参见<a target="_blank" rel="noopener" href="https://squidfunk.github.io/mkdocs-material/publishing-your-site/">mkdocs-material官网</a>。</p>
<h2 id="3-2-JekyII"><a href="#3-2-JekyII" class="headerlink" title="3.2. JekyII"></a>3.2. JekyII</h2><p>Jekyll 是一个静态站点生成器，内置对 GitHub Pages 的支持和简化的构建进程。</p>
<p>参见 <a target="_blank" rel="noopener" href="https://docs.github.com/en/pages/setting-up-a-github-pages-site-with-jekyll/about-github-pages-and-jekyll">About GitHub Pages and Jekyll</a> 。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/17/concurrency/%E8%AF%A6%E8%A7%A3RCU%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/17/concurrency/%E8%AF%A6%E8%A7%A3RCU%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">详解RCU机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-17 10:39:19" itemprop="dateCreated datePublished" datetime="2025-08-17T10:39:19+00:00">2025-08-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-16 02:21:27" itemprop="dateModified" datetime="2025-09-16T02:21:27+00:00">2025-09-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="RCU-读-复制-更新"><a href="#RCU-读-复制-更新" class="headerlink" title="RCU (读-复制-更新)"></a>RCU (读-复制-更新)</h2><p>RCU（Read-Copy-Update，读-拷贝-更新）是 Linux 内核中一种高效的 并发读-写同步机制，专门用于在多核系统下实现 大量读、少量写 的场景。它的核心思想是：读操作完全无锁，写操作通过复制更新，最后再安全地回收旧版本。</p>
<p>RCU 的核心思想</p>
<ul>
<li>读操作直接访问数据结构，不加锁</li>
<li>写操作：<ul>
<li>先 复制原数据 → 修改副本</li>
<li>更新指针，使新数据生效</li>
<li>延迟回收旧数据，保证当前正在读取旧数据的线程不受影响</li>
</ul>
</li>
</ul>
<h3 id="rcu"><a href="#rcu" class="headerlink" title="__rcu"></a><code>__rcu</code></h3><p>它是 RCU 机制中非常关键的一环，用来让 编译器和内核知道某个指针是 RCU 保护的。</p>
<ol>
<li><code>__rcu</code> 的定义</li>
</ol>
<p>在 Linux 内核中（以 x86_64 为例）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __rcu</span></span><br></pre></td></tr></table></figure>

<p>实际上，它 本身对编译器不产生直接影响</p>
<p>主要用途是 标记类型，告诉 Sparse 静态分析工具 或 内核开发者：这个指针受 RCU 保护，不能随意直接读&#x2F;写</p>
<p>也就是说，<code>__rcu</code> 是 一个注释性质的宏，编译器编译时忽略，但静态分析工具会检查 RCU 访问规则。</p>
<ol start="2">
<li><code>__rcu</code> 的作用</li>
</ol>
<p>标记 RCU 保护的指针，常见用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> __<span class="title">rcu</span> *<span class="title">fdt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> *<span class="title">fd_array</span>[<span class="title">NR_OPEN_DEFAULT</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>含义：</p>
<ul>
<li><code>fdt</code> 是 RCU 指针</li>
<li>不能直接写 <code>fdt = new_ptr</code>; 或直接解引用 <code>fdt-&gt;xxx</code></li>
<li>必须通过 RCU API，如：<ul>
<li><code>rcu_assign_pointer(fdt, new_fdt);</code> → 安全更新指针</li>
<li><code>rcu_dereference(fdt)</code> → 安全读取指针</li>
</ul>
</li>
<li>这样可以保证：<ul>
<li>写线程更新指针时不会破坏读线程的访问</li>
<li>读线程可以无锁访问旧数据</li>
</ul>
</li>
</ul>
<ol start="3">
<li><code>__rcu</code> 与编译器和内核</li>
</ol>
<ul>
<li>静态检查（Sparse）<ul>
<li>Sparse 是 Linux 内核推荐的静态分析工具</li>
<li>它会检查：<ul>
<li>所有 <code>__rcu</code> 指针的写操作是否用 <code>rcu_assign_pointer</code></li>
<li>所有读取是否用 <code>rcu_dereference</code></li>
</ul>
</li>
<li>如果直接访问，就会报错，避免 RCU 访问错误</li>
</ul>
</li>
<li>内存屏障和优化<ul>
<li><code>rcu_assign_pointer</code> 内部会加上 适当的写屏障 (<code>smp_wmb()</code>)</li>
<li><code>rcu_dereference</code> 内部会加 读取屏障 (<code>smp_rmb()</code>)</li>
<li>防止编译器&#x2F;CPU 重排导致读写顺序错误</li>
</ul>
</li>
</ul>
<ol start="4">
<li><code>__rcu</code> 的核心原理总结</li>
</ol>
<table>
<thead>
<tr>
<th>方面</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>编译器作用</td>
<td>本身是空宏，不改变代码</td>
</tr>
<tr>
<td>静态分析</td>
<td>Sparse 检查 RCU 指针的安全读写</td>
</tr>
<tr>
<td>内存屏障</td>
<td>通过 <code>rcu_assign_pointer</code> &#x2F; <code>rcu_dereference</code> 添加屏障，保证并发安全</td>
</tr>
<tr>
<td>运行时</td>
<td>指针仍然是普通指针，实际存储和访问和普通指针一样</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="page-number current">2</span><a class="page-number" href="/blog/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/11/">11</a><a class="extend next" rel="next" href="/blog/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="bi-an"
      src="/blog/images/avatar.gif">
  <p class="site-author-name" itemprop="name">bi-an</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">103</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/bi-an" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;bi-an" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ah_zzg@126.com" title="E-Mail → mailto:ah_zzg@126.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://cuda-doc.readthedocs.io/" title="https:&#x2F;&#x2F;cuda-doc.readthedocs.io" rel="noopener" target="_blank">CUDA中文手册</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://infiniband-doc.readthedocs.io/" title="https:&#x2F;&#x2F;infiniband-doc.readthedocs.io&#x2F;" rel="noopener" target="_blank">InfiniBand中文手册</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bi-an</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>




  




  
<script src="/blog/js/local-search.js"></script>













  

  

</body>
</html>
