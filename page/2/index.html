<!DOCTYPE html>
<html lang="en, zh_CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"bi-an.github.io","root":"/blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="江南人物的博客">
<meta property="og:url" content="https://bi-an.github.io/blog/page/2/index.html">
<meta property="og:site_name" content="江南人物的博客">
<meta property="og:locale">
<meta property="article:author" content="bi-an">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://bi-an.github.io/blog/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en, zh_CN'
  };
</script>

  <title>江南人物的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">江南人物的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-resource">

    <a href="/blog/resources/" rel="section"><i class="fa fa-paperclip fa-fw"></i>Resource</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/09/03/cuda/CUDA%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/09/03/cuda/CUDA%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/" class="post-title-link" itemprop="url">CUDA矩阵乘法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-09-03 09:23:17" itemprop="dateCreated datePublished" datetime="2025-09-03T09:23:17+00:00">2025-09-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-23 14:39:34" itemprop="dateModified" datetime="2025-09-23T14:39:34+00:00">2025-09-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/CUDA/" itemprop="url" rel="index"><span itemprop="name">CUDA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="使用共享内存优化"><a href="#使用共享内存优化" class="headerlink" title="使用共享内存优化"></a>使用共享内存优化</h2><p><a href='https://postimg.cc/BjfXcPQ9' target='_blank'><img src='https://i.postimg.cc/dVLrFGb1/matrix-Mul.png' border='0' alt='matrix-Mul'/></a></p>
<figure class="highlight cpp"><figcaption><span>matrixMul.cpp</span><a href="/blog/downloads/code/cuda/matrixMul.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Matrix multiplication (CUDA Kernel) on the device: C = A * B</span></span><br><span class="line"><span class="comment"> * wA is A&#x27;s width and wB is B&#x27;s width</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> BLOCK_SIZE&gt; <span class="function">__global__ <span class="type">void</span> <span class="title">MatrixMulCUDA</span><span class="params">(<span class="type">float</span> *C, <span class="type">float</span> *A, <span class="type">float</span> *B, <span class="type">int</span> wA, <span class="type">int</span> wB)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Block index</span></span><br><span class="line">    <span class="type">int</span> bx = blockIdx.x;</span><br><span class="line">    <span class="type">int</span> by = blockIdx.y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Thread index</span></span><br><span class="line">    <span class="type">int</span> tx = threadIdx.x;</span><br><span class="line">    <span class="type">int</span> ty = threadIdx.y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Index of the first sub-matrix of A processed by the block</span></span><br><span class="line">    <span class="type">int</span> aBegin = wA * BLOCK_SIZE * by;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Index of the last sub-matrix of A processed by the block</span></span><br><span class="line">    <span class="type">int</span> aEnd = aBegin + wA - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step size used to iterate through the sub-matrices of A</span></span><br><span class="line">    <span class="type">int</span> aStep = BLOCK_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Index of the first sub-matrix of B processed by the block</span></span><br><span class="line">    <span class="type">int</span> bBegin = BLOCK_SIZE * bx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step size used to iterate through the sub-matrices of B</span></span><br><span class="line">    <span class="type">int</span> bStep = BLOCK_SIZE * wB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Csub is used to store the element of the block sub-matrix</span></span><br><span class="line">    <span class="comment">// that is computed by the thread</span></span><br><span class="line">    <span class="type">float</span> Csub = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loop over all the sub-matrices of A and B</span></span><br><span class="line">    <span class="comment">// required to compute the block sub-matrix</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = aBegin, b = bBegin; a &lt;= aEnd; a += aStep, b += bStep) {</span><br><span class="line">        <span class="comment">// Declaration of the shared memory array As used to</span></span><br><span class="line">        <span class="comment">// store the sub-matrix of A</span></span><br><span class="line">        __shared__ <span class="type">float</span> As[BLOCK_SIZE][BLOCK_SIZE];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Declaration of the shared memory array Bs used to</span></span><br><span class="line">        <span class="comment">// store the sub-matrix of B</span></span><br><span class="line">        __shared__ <span class="type">float</span> Bs[BLOCK_SIZE][BLOCK_SIZE];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Load the matrices from device memory</span></span><br><span class="line">        <span class="comment">// to shared memory; each thread loads</span></span><br><span class="line">        <span class="comment">// one element of each matrix</span></span><br><span class="line">        As[ty][tx] = A[a + wA * ty + tx];</span><br><span class="line">        Bs[ty][tx] = B[b + wB * ty + tx];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Synchronize to make sure the matrices are loaded</span></span><br><span class="line">        __syncthreads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Multiply the two matrices together;</span></span><br><span class="line">        <span class="comment">// each thread computes one element</span></span><br><span class="line">        <span class="comment">// of the block sub-matrix</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> unroll</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; BLOCK_SIZE; ++k) {</span><br><span class="line">            Csub += As[ty][k] * Bs[k][tx];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Synchronize to make sure that the preceding</span></span><br><span class="line">        <span class="comment">// computation is done before loading two new</span></span><br><span class="line">        <span class="comment">// sub-matrices of A and B in the next iteration</span></span><br><span class="line">        __syncthreads();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write the block sub-matrix to device memory;</span></span><br><span class="line">    <span class="comment">// each thread writes one element</span></span><br><span class="line">    <span class="type">int</span> c               = wB * BLOCK_SIZE * by + BLOCK_SIZE * bx;</span><br><span class="line">    C[c + wB * ty + tx] = Csub;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/09/02/concurrency/%E4%BA%BA%E4%BA%BA%E9%83%BD%E7%9C%8B%E5%BE%97%E6%87%82%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/09/02/concurrency/%E4%BA%BA%E4%BA%BA%E9%83%BD%E7%9C%8B%E5%BE%97%E6%87%82%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">人人都看得懂的内存模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-09-02 11:10:13" itemprop="dateCreated datePublished" datetime="2025-09-02T11:10:13+00:00">2025-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-23 14:39:34" itemprop="dateModified" datetime="2025-09-23T14:39:34+00:00">2025-09-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/c-cpp/" itemprop="url" rel="index"><span itemprop="name">c/cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>内存模型（Memory Model）是定义<strong>数据一致性</strong>与<strong>执行顺序</strong>规则的一组规范。</p>
<p>关键概念：</p>
<ol>
<li>原子性：操作不可打断；如果同时修改，硬件会串行排队。</li>
<li>可见性：对其他核心（即<strong>其他线程</strong>）可见，也就是 load 指令可以读到最新值。</li>
<li>顺序性：禁止<strong>本线程</strong>内的指令重排序。所以可以用作同步点。</li>
</ol>
<p>所有原子变量都满足原子性。但是其他两者不一定满足，由内存序定义。</p>
<p>比如原子自增 fetch_add(relaxed) 是线程安全的，但是无法使用 load 指令读到最新的结果。</p>
<h2 id="缓存一致性协议-MESI"><a href="#缓存一致性协议-MESI" class="headerlink" title="缓存一致性协议 (MESI)"></a>缓存一致性协议 (MESI)</h2><table>
<thead>
<tr>
<th align="center">状态</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">M (Modified)</td>
<td align="center">缓存行已被修改，只有当前 CPU 拥有，主内存未更新</td>
</tr>
<tr>
<td align="center">E (Exclusive)</td>
<td align="center">缓存行未被修改，只有当前 CPU 拥有，与主内存一致</td>
</tr>
<tr>
<td align="center">S (Shared)</td>
<td align="center">缓存行未被修改，多个 CPU 拥有，与主内存一致</td>
</tr>
<tr>
<td align="center">I (Invalid)</td>
<td align="center">缓存行无效，必须重新从主内存加载</td>
</tr>
</tbody></table>
<h2 id="relaxed-内存序"><a href="#relaxed-内存序" class="headerlink" title="relaxed 内存序"></a>relaxed 内存序</h2><p>术语：</p>
<ol>
<li>保证原子性：整个操作不可被打断；不一定立即回写主内存，可能暂时把结果放在 Store Buffer 中。</li>
<li>不保证顺序：编译器和CPU可能对指令重排序。</li>
<li>不保证可见性：其他核心不一定立即可见。</li>
</ol>
<p>说人话：</p>
<ol>
<li>原子性：原子操作是串行的（由硬件排队）</li>
<li>不保证可见性：<ul>
<li>load 操作是并行的，并且不保证看到最新值。</li>
<li>“可见性”是针对程序员的，因为对于 relaxed ，没有任何指令可以保证 load 拿到最新值。它可能直接从自己的缓存行中把旧值返回给你。</li>
<li>硬件本身是知道最新值的，它会根据 MESI 来保证自己当时拿到的是最新值（但是无法通过指令告知你）。</li>
</ul>
</li>
<li>不保证顺序：不是同步点，无法保证前后指令与程序员的编写顺序一致。</li>
</ol>
<table>
<thead>
<tr>
<th align="center">层级</th>
<th align="center">机制</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">指令级</td>
<td align="center">原子指令（如 LOCK XADD）</td>
<td align="center">保证操作不可打断</td>
</tr>
<tr>
<td align="center">缓存级</td>
<td align="center">MESI 协议</td>
<td align="center">控制缓存行访问，避免冲突</td>
</tr>
<tr>
<td align="center">编译器级</td>
<td align="center">编译器屏障</td>
<td align="center">防止指令重排</td>
</tr>
<tr>
<td align="center">CPU级</td>
<td align="center">内存屏障</td>
<td align="center">保证执行顺序</td>
</tr>
<tr>
<td align="center">高级机制</td>
<td align="center">事务性内存</td>
<td align="center">实现复杂原子逻辑（可选）</td>
</tr>
</tbody></table>
<h2 id="release-acquire-语义"><a href="#release-acquire-语义" class="headerlink" title="release-acquire 语义"></a>release-acquire 语义</h2><h2 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h2><ol>
<li>编译器指令重排：编译器屏障防止指令重排</li>
<li>CPU 乱序执行：内存屏障保证执行顺序。</li>
</ol>
<h2 id="原子指令"><a href="#原子指令" class="headerlink" title="原子指令"></a>原子指令</h2><p>原子指令（如 LOCK XADD）：保证操作不可打断</p>
<h2 id="Load-Store-Buffer"><a href="#Load-Store-Buffer" class="headerlink" title="Load &#x2F; Store Buffer"></a>Load &#x2F; Store Buffer</h2><h2 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h2><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/26/cpp/%E4%BD%8D%E7%BD%AE%E6%97%A0%E5%85%B3%E4%BB%A3%E7%A0%81PIC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/26/cpp/%E4%BD%8D%E7%BD%AE%E6%97%A0%E5%85%B3%E4%BB%A3%E7%A0%81PIC/" class="post-title-link" itemprop="url">位置无关代码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-26 13:54:18" itemprop="dateCreated datePublished" datetime="2025-08-26T13:54:18+00:00">2025-08-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-23 14:39:34" itemprop="dateModified" datetime="2025-09-23T14:39:34+00:00">2025-09-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/c-cpp/" itemprop="url" rel="index"><span itemprop="name">c/cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="位置无关代码（PIC）"><a href="#位置无关代码（PIC）" class="headerlink" title="位置无关代码（PIC）"></a>位置无关代码（PIC）</h2><ul>
<li>位置无关代码（<code>PIC</code>）：程序可以在内存中的任意位置运行，不需要修改代码中的绝对地址。</li>
<li>节省空间：相比使用 64 位绝对地址，RIP 相对寻址只需要一个 32 位偏移量。</li>
<li>更安全：支持地址随机化（ASLR），提高程序的安全性。</li>
</ul>
<p>在 x86-64 架构中，传统的绝对地址寻址方式不再适用于位置无关代码。于是引入了 RIP（指令指针）相对寻址：</p>
<p>假设你有一个全局变量 int x &#x3D; 42;，在汇编中访问它可能会变成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asm</span><br><span class="line">mov eax, DWORD PTR [rip + offset_to_x]</span><br></pre></td></tr></table></figure>

<p>这里的 offset_to_x 是编译器计算出来的 x 相对于当前指令的偏移量。</p>
<table>
<thead>
<tr>
<th align="center">寻址方式</th>
<th align="center">描述</th>
<th align="center">是否位置无关</th>
</tr>
</thead>
<tbody><tr>
<td align="center">绝对地址寻址</td>
<td align="center">使用固定地址，如 [0x400123]</td>
<td align="center">❌ 否</td>
</tr>
<tr>
<td align="center">寄存器间接寻址</td>
<td align="center">如 [rax]，地址由寄存器决定</td>
<td align="center">✅ 是</td>
</tr>
<tr>
<td align="center">RIP 相对寻址</td>
<td align="center">如 [rip + offset]，相对当前指令位置</td>
<td align="center">✅ 是</td>
</tr>
</tbody></table>
<p>但并不是所有 PIC 都用 RIP 相对寻址，PIC 的实现方式取决于：</p>
<ul>
<li>架构：在 x86（32 位）中没有 RIP 寄存器，PIC 通常通过 call 指令获取当前地址，再加偏移量。</li>
<li>编译器策略：有些编译器会使用全局偏移表（GOT）或过程链接表（PLT）来实现位置无关性。</li>
<li>访问目标：访问函数地址时可能通过 PLT；访问外部变量时可能通过 GOT；访问静态数据时可能用 RIP 相对寻址。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">架构</th>
<th align="center">是否使用 RIP 相对寻址</th>
<th align="center">是否支持位置无关代码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">x86-64</td>
<td align="center">✅ 常用，尤其访问数据段</td>
<td align="center">✅ 强力支持（默认启用）</td>
</tr>
<tr>
<td align="center">x86 (32位)</td>
<td align="center">❌ 无 RIP，用其他方式实现</td>
<td align="center">✅ 但需要特殊技巧</td>
</tr>
</tbody></table>
<p>举个 gdb 调试的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/i <span class="variable">$rip</span></span><br><span class="line">=&gt; 0x2ac084b5ec10 &lt;poll&gt;:       cmpl   <span class="variable">$0x0</span>,0x2d939d(%rip)        <span class="comment"># 0x2ac084e37fb4 &lt;__libc_multiple_threads&gt;</span></span><br><span class="line">(gdb) p (bool)<span class="variable">$__libc_multiple_threads</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>cmpl $0x0, 0x2d939d(%rip)</code> 是一条比较指令（<code>cmp</code>），用于将某个内存地址中的值与立即数 <code>0</code> 进行比较。</li>
<li><code>(%rip)</code> 表示使用 RIP 相对寻址，这是 x86-64 架构中常见的一种寻址方式。</li>
<li>实际比较的是地址 <code>0x2ac084e37fb4</code> 处的值，也就是 <code>__libc_multiple_threads</code> 这个变量。</li>
</ul>
<p><code>__libc_multiple_threads</code> 是什么？</p>
<ul>
<li>这是 GNU C 库（glibc）中的一个内部变量，用来标记当前进程是否启用了多线程。</li>
<li>如果这个值是 0，说明当前进程是单线程。</li>
<li>如果是非零，说明进程中有多个线程。</li>
</ul>
<p>所以这条指令的作用是：判断当前进程是否是多线程环境，可能用于决定是否启用线程安全的行为。</p>
<h3 id="为什么使用-RIP-相对寻址？"><a href="#为什么使用-RIP-相对寻址？" class="headerlink" title="为什么使用 RIP 相对寻址？"></a>为什么使用 RIP 相对寻址？</h3><ol>
<li>RIP 是唯一始终已知的寄存器</li>
</ol>
<ul>
<li>在执行指令时，CPU总是知道当前指令的地址（即 RIP）。</li>
<li>所以可以在编译时计算出目标数据与当前指令之间的偏移量，而不需要知道数据的绝对地址。</li>
</ul>
<p>这就允许编译器生成位置无关代码，即使程序被加载到不同的内存地址，偏移量仍然有效。</p>
<ol start="2">
<li>其他寄存器值是动态的，不可预测</li>
</ol>
<ul>
<li>比如 RBX、RAX、RDI 等寄存器，它们的值在运行时可能被程序修改。</li>
<li>如果用这些寄存器做基址寻址，编译器就无法提前知道它们的值，也就无法生成稳定的偏移量。</li>
</ul>
<ol start="3">
<li>支持共享库和地址空间布局随机化（ASLR）</li>
</ol>
<ul>
<li>RIP 相对寻址让代码段不依赖固定地址，可以被多个进程共享。</li>
<li>也支持操作系统在运行时随机加载地址，提高安全性（ASLR）。</li>
</ul>
<ol start="4">
<li>节省指令空间</li>
</ol>
<ul>
<li>使用 RIP 相对寻址只需要一个 32 位偏移量。</li>
<li>如果使用绝对地址，需要嵌入完整的 64 位地址，指令长度更长，效率更低。</li>
</ul>
<h3 id="为什么使用-RIP-相对寻址只需要一个-32-位偏移量"><a href="#为什么使用-RIP-相对寻址只需要一个-32-位偏移量" class="headerlink" title="为什么使用 RIP 相对寻址只需要一个 32 位偏移量"></a>为什么使用 RIP 相对寻址只需要一个 32 位偏移量</h3><p>在 x86-64 架构中，RIP 相对寻址的偏移量被设计为一个有符号的 32 位整数，也就是一个 displacement（位移）字段，它在机器码中只占用 4 个字节。</p>
<ul>
<li><p>RIP 是 64 位的指令指针，表示当前指令的地址。</p>
</li>
<li><p>RIP 相对寻址的目标地址是通过：</p>
<p><code>目标地址 = 下一条指令地址（RIP） + 32 位偏移量</code></p>
</li>
<li><p>这个偏移量是一个 有符号整数，所以它的范围是：</p>
<p>从 −2³¹ 到 +2³¹−1，即 <strong>±2GB</strong> 的寻址范围。</p>
</li>
</ul>
<p>这意味着，当前指令附近 ±2GB 范围内的任何数据都可以通过 RIP 相对寻址访问。</p>
<table>
<thead>
<tr>
<th align="center">优点</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">✅ 节省空间</td>
<td align="center">只用 4 字节表示偏移，比使用完整 64 位地址节省指令长度</td>
</tr>
<tr>
<td align="center">✅ 支持位置无关代码</td>
<td align="center">编译器只需计算偏移，不依赖绝对地址</td>
</tr>
<tr>
<td align="center">✅ 高效</td>
<td align="center">CPU 执行时只需加法运算，无需查表或重定位</td>
</tr>
<tr>
<td align="center">✅ 安全</td>
<td align="center">支持地址空间布局随机化（ASLR），提高安全性</td>
</tr>
</tbody></table>
<h3 id="为什么可以被多个进程共享？"><a href="#为什么可以被多个进程共享？" class="headerlink" title="为什么可以被多个进程共享？"></a>为什么可以被多个进程共享？</h3><p>因为代码中不再硬编码具体地址，多个进程可以：</p>
<ul>
<li>使用同一份物理内存中的代码段。</li>
<li>每个进程有自己的数据段，但共享同一份只读代码。</li>
</ul>
<p>这大大节省了内存，提高了系统效率。</p>
<p>举个例子：</p>
<table>
<thead>
<tr>
<th align="center">进程</th>
<th align="center">加载地址</th>
<th align="center">使用的代码段</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">0x400000</td>
<td align="center">使用共享代码段</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">0x500000</td>
<td align="center">使用共享代码段</td>
</tr>
</tbody></table>
<p>两者的代码段内容完全一样，因为里面的寻址是相对 RIP 的，不依赖于加载地址。</p>
<p>为什么绝对寻址不可以被多进程共享？</p>
<ul>
<li>每个进程的虚拟地址空间是独立的<ul>
<li>操作系统为每个进程分配独立的虚拟地址空间。</li>
<li>即使两个进程都加载了同一个程序，它们的地址空间可能完全不同。</li>
<li>如果代码中使用绝对地址，加载到不同地址空间后，这些地址就不再有效。</li>
</ul>
</li>
</ul>
<p>所以，绝对地址在一个进程中是有效的，在另一个进程中可能就指向错误的地方或根本不存在。</p>
<ul>
<li><p>需要重定位，无法直接共享物理页</p>
<ul>
<li>如果使用绝对地址，操作系统必须在每个进程加载时对代码进行“重定位”，修改指令中的地址。</li>
<li>一旦修改，代码段就变成了进程私有，不能共享同一份物理内存。</li>
<li>而位置无关代码（如使用 RIP 相对寻址）不需要修改，可以直接映射到多个进程的地址空间。</li>
</ul>
</li>
<li><p>违反共享库的设计原则</p>
<ul>
<li>动态链接库（如 <code>.so</code> 或 <code>.dll</code>）的核心优势就是可以被多个进程共享。</li>
<li>如果库中使用绝对地址，每个进程都要有自己的副本，失去了共享的意义。</li>
<li>正确做法是使用位置无关代码（PIC），让库在任意地址都能运行。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">区域</th>
<th align="center">是否可共享</th>
<th align="center">原因说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">代码段</td>
<td align="center">✅ 是</td>
<td align="center">只读 + 位置无关，多个进程可映射同一物理页</td>
</tr>
<tr>
<td align="center">数据段</td>
<td align="center">❌ 否</td>
<td align="center">每个进程的数据不同，需独立副本</td>
</tr>
<tr>
<td align="center">堆</td>
<td align="center">❌ 否</td>
<td align="center">动态分配，地址空间不同</td>
</tr>
<tr>
<td align="center">栈</td>
<td align="center">❌ 否</td>
<td align="center">私有调用栈，不能混用</td>
</tr>
<tr>
<td align="center">共享内存段</td>
<td align="center">✅ 是</td>
<td align="center">显式创建，专门用于共享</td>
</tr>
</tbody></table>
<p>如果你想深入了解某个进程的内存布局，可以分析 <code>/proc/[pid]/maps</code> 或用工具如 <code>pmap</code>、<code>vmmap</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/22/cpp/%E6%B1%87%E7%BC%96%E4%B8%8Egdb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/22/cpp/%E6%B1%87%E7%BC%96%E4%B8%8Egdb/" class="post-title-link" itemprop="url">汇编与 gdb</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-22 15:42:27" itemprop="dateCreated datePublished" datetime="2025-08-22T15:42:27+00:00">2025-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-23 14:39:34" itemprop="dateModified" datetime="2025-09-23T14:39:34+00:00">2025-09-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/c-cpp/" itemprop="url" rel="index"><span itemprop="name">c/cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>我们在调试 release 版本的程序时，由于缺乏符号信息，所以需要通过寄存器来查看函数的参数、返回值等。</p>
<h2 id="2-寄存器"><a href="#2-寄存器" class="headerlink" title="2. 寄存器"></a>2. 寄存器</h2><h3 id="2-1-通用寄存器-General-Purpose-Registers"><a href="#2-1-通用寄存器-General-Purpose-Registers" class="headerlink" title="2.1. 通用寄存器 (General Purpose Registers)"></a>2.1. 通用寄存器 (General Purpose Registers)</h3><table>
<thead>
<tr>
<th>寄存器名</th>
<th>英文名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>rax</td>
<td>Accumulator</td>
<td>累加器，通常用于算术运算和函数返回值存储。</td>
</tr>
<tr>
<td>rbx</td>
<td>Base</td>
<td>基址寄存器，常用于存储数据或指针。</td>
</tr>
<tr>
<td>rsi</td>
<td>Source Index</td>
<td>源索引寄存器，常用于字符串操作中的源地址指针（函数第一个参数）。</td>
</tr>
<tr>
<td>rdi</td>
<td>Destination Index</td>
<td>目标索引寄存器，常用于字符串操作中的目标地址指针或结构体指针（函数第二个参数）。</td>
</tr>
<tr>
<td>rdx</td>
<td>Data</td>
<td>数据寄存器，常用于 I&#x2F;O 操作或乘除法运算中的扩展数据存储（函数第三个参数）。</td>
</tr>
<tr>
<td>rcx</td>
<td>Counter</td>
<td>计数器寄存器，常用于循环计数或字符串操作中的计数（函数第四个参数）。</td>
</tr>
<tr>
<td>rsp</td>
<td>Stack Pointer</td>
<td>栈指针寄存器，指向当前栈顶。</td>
</tr>
<tr>
<td>rbp</td>
<td>Base Pointer</td>
<td>基址指针寄存器，指向当前栈帧的基址。</td>
</tr>
<tr>
<td>r8~r15</td>
<td>General Purpose</td>
<td>通用寄存器，扩展的 64 位寄存器之一，用于存储数据或指针（<code>r8</code><del><code>r9</code> 常用于保存函数第五</del>六个参数）。</td>
</tr>
</tbody></table>
<h3 id="2-2-特殊用途寄存器-Special-Purpose-Registers"><a href="#2-2-特殊用途寄存器-Special-Purpose-Registers" class="headerlink" title="2.2. 特殊用途寄存器 (Special Purpose Registers)"></a>2.2. 特殊用途寄存器 (Special Purpose Registers)</h3><table>
<thead>
<tr>
<th>寄存器名</th>
<th>英文名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>rip</td>
<td>Instruction Pointer</td>
<td>指令指针寄存器，存储当前执行指令的地址。</td>
</tr>
<tr>
<td>rflags</td>
<td>Flags</td>
<td>标志寄存器，存储状态标志位（如进位、溢出、零标志等）。</td>
</tr>
</tbody></table>
<h3 id="2-3-段寄存器-Segment-Registers"><a href="#2-3-段寄存器-Segment-Registers" class="headerlink" title="2.3. 段寄存器 (Segment Registers)"></a>2.3. 段寄存器 (Segment Registers)</h3><table>
<thead>
<tr>
<th>寄存器名</th>
<th>英文名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>cs</td>
<td>Code Segment</td>
<td>代码段寄存器，指向当前代码段的基址。</td>
</tr>
<tr>
<td>ds</td>
<td>Data Segment</td>
<td>数据段寄存器，指向当前数据段的基址。</td>
</tr>
<tr>
<td>es</td>
<td>Extra Segment</td>
<td>额外段寄存器，指向额外数据段的基址。</td>
</tr>
<tr>
<td>fs</td>
<td>FS Segment</td>
<td>特殊用途段寄存器，常用于线程本地存储等。</td>
</tr>
<tr>
<td>gs</td>
<td>GS Segment</td>
<td>特殊用途段寄存器，常用于线程本地存储等。</td>
</tr>
<tr>
<td>ss</td>
<td>Stack Segment</td>
<td>栈段寄存器，指向当前栈段的基址。</td>
</tr>
</tbody></table>
<h3 id="2-4-浮点与向量寄存器-Floating-Point-and-Vector-Registers"><a href="#2-4-浮点与向量寄存器-Floating-Point-and-Vector-Registers" class="headerlink" title="2.4. 浮点与向量寄存器 (Floating Point and Vector Registers)"></a>2.4. 浮点与向量寄存器 (Floating Point and Vector Registers)</h3><table>
<thead>
<tr>
<th>寄存器名</th>
<th>英文名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>xmm0-xmm15</td>
<td>SIMD Registers</td>
<td>用于 SSE 指令集的 128 位向量运算。</td>
</tr>
<tr>
<td>ymm0-ymm15</td>
<td>AVX Registers</td>
<td>用于 AVX 指令集的 256 位向量运算。</td>
</tr>
<tr>
<td>zmm0-zmm31</td>
<td>AVX-512 Registers</td>
<td>用于 AVX-512 指令集的 512 位向量运算。</td>
</tr>
</tbody></table>
<h3 id="2-5-函数调用时的参数传递"><a href="#2-5-函数调用时的参数传递" class="headerlink" title="2.5. 函数调用时的参数传递"></a>2.5. 函数调用时的参数传递</h3><p>在 x86_64 架构中，函数调用时的参数传递遵循 System V AMD64 ABI（Linux&#x2F;Unix 系统的标准调用约定）。</p>
<p>前六个整数或指针类型的参数依次存储在以下寄存器中：</p>
<ol>
<li><strong>rdi</strong> - 第一个参数</li>
<li><strong>rsi</strong> - 第二个参数</li>
<li><strong>rdx</strong> - 第三个参数</li>
<li><strong>rcx</strong> - 第四个参数</li>
<li><strong>r8</strong> - 第五个参数</li>
<li><strong>r9</strong> - 第六个参数</li>
</ol>
<p>对于浮点类型的参数（如 <code>float</code> 或 <code>double</code>），前八个参数存储在以下 <strong>SSE 寄存器</strong> 中：</p>
<ol>
<li><strong>xmm0</strong> - 第一个浮点参数</li>
<li><strong>xmm1</strong> - 第二个浮点参数</li>
<li><strong>xmm2</strong> - 第三个浮点参数</li>
<li><strong>xmm3</strong> - 第四个浮点参数</li>
<li><strong>xmm4</strong> - 第五个浮点参数</li>
<li><strong>xmm5</strong> - 第六个浮点参数</li>
<li><strong>xmm6</strong> - 第七个浮点参数</li>
<li><strong>xmm7</strong> - 第八个浮点参数</li>
</ol>
<p>溢出参数（超过寄存器数量）会依次存储在 <strong>栈</strong> 中：</p>
<ul>
<li>超过寄存器数量（整数参数超过 6 个，浮点参数超过 8 个）的参数会依次压入栈中。</li>
<li>栈需要保持 16 字节对齐，可能会插入填充字节。</li>
<li>可以通过访问栈指针（rsp）或基址指针（rbp）来找到栈上的参数。<ul>
<li>使用 rsp（栈指针）<ul>
<li>在函数入口时，rsp 指向栈顶（即返回地址的下一个位置）。</li>
<li>栈上的第一个参数位于 [rsp + 8]（跳过返回地址）。</li>
<li>第二个参数位于 [rsp + 16]，依此类推。</li>
</ul>
</li>
<li>使用 rbp（基址指针）<ul>
<li>如果函数使用了帧指针（rbp），rbp 通常指向调用者的栈帧基址。</li>
<li>栈上的第一个参数位于 [rbp + 16]（跳过返回地址和保存的 rbp）。</li>
<li>第二个参数位于 [rbp + 24]，依此类推。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-栈"><a href="#3-栈" class="headerlink" title="3. 栈"></a>3. 栈</h2><h3 id="3-1-理解栈布局"><a href="#3-1-理解栈布局" class="headerlink" title="3.1. 理解栈布局"></a>3.1. 理解栈布局</h3><p>在函数调用时，栈的布局通常如下（从高地址到低地址）：</p>
<ol>
<li>返回地址：调用函数时，call 指令会将返回地址（下一条指令的地址）压入栈中。</li>
<li>溢出参数：如果参数超过寄存器数量，多余的参数会依次压入栈中。</li>
<li>栈对齐填充：为了满足 16 字节对齐要求，可能会有额外的填充字节。</li>
<li>局部变量和保存的寄存器：函数内部可能会在栈上分配空间用于局部变量或保存调用者的寄存器。</li>
</ol>
<h3 id="3-2-函数调用时的压栈过程"><a href="#3-2-函数调用时的压栈过程" class="headerlink" title="3.2. 函数调用时的压栈过程"></a>3.2. 函数调用时的压栈过程</h3><p>在 x86_64 架构中，函数调用时会涉及到栈的操作，包括压栈和出栈。这些操作主要用于保存调用者的上下文（如<br>返回地址、寄存器值）以及为被调用函数分配栈帧。</p>
<h4 id="3-2-1-调用者（Caller）的操作"><a href="#3-2-1-调用者（Caller）的操作" class="headerlink" title="3.2.1. 调用者（Caller）的操作"></a>3.2.1. 调用者（Caller）的操作</h4><ol>
<li><p><strong>压入返回地址</strong> 当调用者使用 <code>call</code> 指令调用函数时，CPU 会自动将返回地址（下一条指令的地址）压入<br>栈中。此时，<code>rsp</code>（栈指针）会减少 8 字节（64 位系统）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call function</span><br><span class="line"># 等价于：</span><br><span class="line">push rip  ; 将返回地址压入栈</span><br><span class="line">jmp function</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>压入溢出参数（如果有）</strong> 如果函数的参数超过了寄存器数量（整数参数超过 6 个，浮点参数超过 8 个）<br>，多余的参数会从右到左依次压入栈中。<code>rsp</code> 会随着每个参数的压入减少。</p>
</li>
<li><p><strong>对齐栈</strong> 为了满足 <strong>16 字节对齐</strong> 的要求，调用者可能会插入额外的填充字节，使得 <code>rsp</code> 在调用函数<br>前保持 16 字节对齐。</p>
</li>
</ol>
<h4 id="3-2-2-被调用者（Callee）的操作"><a href="#3-2-2-被调用者（Callee）的操作" class="headerlink" title="3.2.2. 被调用者（Callee）的操作"></a>3.2.2. <strong>被调用者（Callee）的操作</strong></h4><ol>
<li><p><strong>保存调用者的栈帧基址</strong> 被调用者通常会保存调用者的栈帧基址（<code>rbp</code>），以便在函数返回时恢复调用者<br>的栈帧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push rbp       ; 保存调用者的 rbp</span><br><span class="line">mov rbp, rsp   ; 设置当前函数的栈帧基址</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>分配栈空间</strong> 被调用者会根据函数内部局部变量的需求，在栈上分配空间。<code>rsp</code> 会减少相应的字节数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub rsp, &lt;size&gt;  ; 为局部变量分配栈空间</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-3-2-函数返回时的出栈过程"><a href="#3-3-2-函数返回时的出栈过程" class="headerlink" title="3.3. 2. 函数返回时的出栈过程"></a>3.3. <strong>2. 函数返回时的出栈过程</strong></h3><h4 id="3-3-1-被调用者（Callee）的操作"><a href="#3-3-1-被调用者（Callee）的操作" class="headerlink" title="3.3.1. 被调用者（Callee）的操作"></a>3.3.1. <strong>被调用者（Callee）的操作</strong></h4><ol>
<li><p><strong>释放局部变量的栈空间</strong> 被调用者在返回前会释放为局部变量分配的栈空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add rsp, &lt;size&gt;  ; 恢复 rsp</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>恢复调用者的栈帧基址</strong> 被调用者会恢复调用者的 <code>rbp</code>，以确保调用者的栈帧完整。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop rbp  ; 恢复调用者的 rbp</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>返回到调用者</strong> 被调用者使用 <code>ret</code> 指令从栈中弹出返回地址，并跳转到该地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret  ; 等价于：pop rip</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="3-3-2-调用者（Caller）的操作"><a href="#3-3-2-调用者（Caller）的操作" class="headerlink" title="3.3.2. 调用者（Caller）的操作"></a>3.3.2. <strong>调用者（Caller）的操作</strong></h4><ol>
<li><strong>清理栈上的参数（如果需要）</strong> 如果调用约定要求调用者清理栈上的参数（如 <code>cdecl</code> 调用约定），调用<br>者会调整 <code>rsp</code>。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add rsp, &lt;size&gt;  ; 清理栈上的参数</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-4-3-栈指针（rsp）和基址指针（rbp）的变化"><a href="#3-4-3-栈指针（rsp）和基址指针（rbp）的变化" class="headerlink" title="3.4. 3. 栈指针（rsp）和基址指针（rbp）的变化"></a>3.4. <strong>3. 栈指针（<code>rsp</code>）和基址指针（<code>rbp</code>）的变化</strong></h3><p>以下是一个函数调用的栈布局示例：</p>
<p><strong>C 代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">example</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    example(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>汇编代码（简化版）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># main 函数</span><br><span class="line">main:</span><br><span class="line">    sub rsp, 16         ; 对齐栈</span><br><span class="line">    mov edi, 1          ; 第一个参数 -&gt; rdi</span><br><span class="line">    mov esi, 2          ; 第二个参数 -&gt; rsi</span><br><span class="line">    call example        ; 调用 example 函数</span><br><span class="line">    add rsp, 16         ; 恢复栈</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line"># example 函数</span><br><span class="line">example:</span><br><span class="line">    push rbp            ; 保存调用者的 rbp</span><br><span class="line">    mov rbp, rsp        ; 设置当前栈帧基址</span><br><span class="line">    sub rsp, 16         ; 为局部变量分配栈空间</span><br><span class="line">    mov eax, edi        ; a -&gt; eax</span><br><span class="line">    add eax, esi        ; a + b</span><br><span class="line">    leave               ; 恢复栈帧（等价于：mov rsp, rbp; pop rbp）</span><br><span class="line">    ret                 ; 返回调用者</span><br></pre></td></tr></table></figure>

<p><strong>栈布局变化</strong> | 操作 | <code>rsp</code> 变化 | 栈内容（从高地址到低地址） | | ————– | ———– |<br>————————– | | <code>call example</code> | <code>rsp -= 8</code> | 返回地址 | | <code>push rbp</code> | <code>rsp -= 8</code> |<br>保存调用者的 <code>rbp</code> | | <code>sub rsp, 16</code> | <code>rsp -= 16</code> | 为局部变量分配空间 | | <code>leave</code> | <code>rsp += 16</code> |<br>释放局部变量空间 | | <code>ret</code> | <code>rsp += 8</code> | 弹出返回地址 |</p>
<h3 id="3-5-总结"><a href="#3-5-总结" class="headerlink" title="3.5. 总结"></a>3.5. <strong>总结</strong></h3><ol>
<li><strong>函数调用的栈操作</strong>：<ul>
<li>调用者负责压入返回地址和溢出参数。</li>
<li>被调用者负责保存 <code>rbp</code> 和分配局部变量空间。</li>
<li>函数返回时，释放局部变量空间并恢复调用者的栈帧。</li>
</ul>
</li>
<li><strong><code>rsp</code> 和 <code>rbp</code> 的变化</strong>：<ul>
<li><code>rsp</code> 指向栈顶，动态变化。</li>
<li><code>rbp</code> 指向栈帧基址，通常固定不变。</li>
</ul>
</li>
</ol>
<h2 id="4-使用-gdb-查看寄存器"><a href="#4-使用-gdb-查看寄存器" class="headerlink" title="4. 使用 gdb 查看寄存器"></a>4. 使用 gdb 查看寄存器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有寄存器</span></span><br><span class="line">info registers</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定寄存器</span></span><br><span class="line">info registers rdi</span><br><span class="line"><span class="comment"># 或简写</span></span><br><span class="line">i r rdi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看十六进制</span></span><br><span class="line">p/x <span class="variable">$rdx</span>    <span class="comment"># 十六进制</span></span><br><span class="line">p/d <span class="variable">$rdx</span>    <span class="comment"># 十进制</span></span><br><span class="line"><span class="comment"># 或简写</span></span><br><span class="line">p <span class="variable">$rdx</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>info registers</code> 会打印三列：</p>
<ul>
<li>第一列：寄存器名称</li>
<li>第二列：寄存器的值（十六进制）</li>
<li>第三列：寄存器的值（十进制；也可能是十六进制，用 <code>0x</code> 开头）</li>
</ul>
<p><code>info registers rdi</code> 与 <code>p $rdi</code> 效果相同。</p>
<p>从寄存器查到的内存地址，可以用 <code>x</code> （examinze）命令来查看内存的值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看指令</span></span><br><span class="line">x/i <span class="variable">$rip</span></span><br><span class="line"><span class="comment"># 查看栈顶</span></span><br><span class="line">x/16x <span class="variable">$rsp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内存</span></span><br><span class="line">p <span class="variable">$rdi</span></span><br><span class="line">x/2gx <span class="variable">$rdi</span></span><br><span class="line"><span class="comment"># 或先用 $rdi 查出内存地址，直接用地址访问</span></span><br><span class="line">x/2gx 47926411878160</span><br></pre></td></tr></table></figure>

<p><code>x</code> 命令的说明：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/FMT ADDRESS</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>x</code>：表示“examine memory”（查看内存）</li>
<li><code>2</code>：数字，表示要查看的单元数</li>
<li><code>g</code>：表示每个单元的 size，有 b(byte), h(halfword), w(word), g(giant, 8 bytes)</li>
<li><code>x</code>：表示值的格式，有 o(octal), x(hex), d(decimal), u(unsigned decimal), t(binary), f(float),<br>a(address), i(instruction), c(char), s(string) and z(hex, zero padded on the left).</li>
</ul>
<p>在 gdb 命令行中使用 <code>help</code> 命令，可以查看命令的说明。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">help</span> x</span><br><span class="line">Examine memory: x/FMT ADDRESS.</span><br><span class="line">ADDRESS is an expression <span class="keyword">for</span> the memory address to examine.</span><br><span class="line">FMT is a repeat count followed by a format letter and a size letter.</span><br><span class="line">Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal),</span><br><span class="line">  t(binary), f(<span class="built_in">float</span>), a(address), i(instruction), c(char), s(string)</span><br><span class="line">  and z(hex, zero padded on the left).</span><br><span class="line">Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).</span><br><span class="line">The specified number of objects of the specified size are printed</span><br><span class="line">according to the format.  If a negative number is specified, memory is</span><br><span class="line">examined backward from the address.</span><br><span class="line"></span><br><span class="line">Defaults <span class="keyword">for</span> format and size letters are those previously used.</span><br><span class="line">Default count is 1.  Default address is following last thing printed</span><br><span class="line">with this <span class="built_in">command</span> or <span class="string">&quot;print&quot;</span>.</span><br></pre></td></tr></table></figure>

<h2 id="5-使用-gdb-查看栈"><a href="#5-使用-gdb-查看栈" class="headerlink" title="5. 使用 gdb 查看栈"></a>5. 使用 gdb 查看栈</h2><ul>
<li>bt</li>
<li>frame</li>
<li>args</li>
<li>locals</li>
<li>x</li>
</ul>
<p>TDODO</p>
<h3 id="5-1-frame-与寄存器的值"><a href="#5-1-frame-与寄存器的值" class="headerlink" title="5.1. frame 与寄存器的值"></a>5.1. <code>frame</code> 与寄存器的值</h3><ul>
<li>GDB 中的寄存器值（如 <code>$rax</code>, <code>$rdi</code>, <code>$rsp</code> 等）是当前 CPU 执行上下文的快照。</li>
<li>当你切换到 <code>frame 0</code>（最内层栈帧）时，寄存器值是最真实的，因为这是程序当前正在执行的地方。</li>
<li>当你切换到 外层栈帧（frame 1, 2, …）时，GDB 会尝试还原当时的寄存器状态，但这依赖于：<ul>
<li>编译器是否保存了寄存器值（如 callee-saved）</li>
<li>是否有调试符号或 unwind 信息</li>
<li>GDB 是否能推断出寄存器的保存位置</li>
</ul>
</li>
</ul>
<p>寄存器值可能出现的情况</p>
<table>
<thead>
<tr>
<th align="center">情况</th>
<th align="center">表现</th>
</tr>
</thead>
<tbody><tr>
<td align="center">寄存器是 caller-saved（如 rdi, rsi, rax）</td>
<td align="center">可能显示 <not saved> 或错误值</td>
</tr>
<tr>
<td align="center">寄存器是 callee-saved（如 rbx, rbp, r12~r15）</td>
<td align="center">通常能正确还原</td>
</tr>
<tr>
<td align="center">没有调试信息或优化严重</td>
<td align="center">GDB 无法还原，显示当前值或 <not saved></td>
</tr>
</tbody></table>
<p>建议</p>
<ul>
<li>如果你要分析寄存器状态，最好在 frame 0 或断点处进行。</li>
<li>如果你在分析 core dump 或栈破坏问题，寄存器值只能作为参考，不要完全依赖外层 frame 的寄存器快照。</li>
<li>使用 info args 和 info locals 更可靠地查看参数和局部变量（如果有符号信息）。</li>
</ul>
<h2 id="6-在特定线程中设置断点"><a href="#6-在特定线程中设置断点" class="headerlink" title="6. 在特定线程中设置断点"></a>6. 在特定线程中设置断点</h2><h3 id="6-1-断点只作用于某线程"><a href="#6-1-断点只作用于某线程" class="headerlink" title="6.1. 断点只作用于某线程"></a>6.1. 断点只作用于某线程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有线程 ID 和当前线程 ID（gdb 中会使用 * 标注当前线程）</span></span><br><span class="line">(gdb) info threads</span><br><span class="line"><span class="comment"># 切换当前上下文到指定线程</span></span><br><span class="line">(gdb) thread &lt;THREAD_ID&gt;</span><br><span class="line"><span class="comment"># 通过查看当前堆栈是不是自己要断点的线程</span></span><br><span class="line">(gdb) bt</span><br><span class="line">(gdb) <span class="built_in">break</span> LOCATION thread THREADNUM</span><br><span class="line"><span class="comment"># 条件断点</span></span><br><span class="line">(gdb) <span class="built_in">break</span> source.c:123 thread 5 <span class="keyword">if</span> fds[0].fd == 7</span><br><span class="line"><span class="comment"># 如果没有 debug 符号，可以利用函数返回值寄存器断点</span></span><br><span class="line">(gdb) <span class="built_in">break</span> poll thread 2 <span class="keyword">if</span> <span class="variable">$rdx</span> &gt; 0</span><br><span class="line"><span class="comment"># 完整格式</span></span><br><span class="line"><span class="built_in">break</span> [PROBE_MODIFIER] [LOCATION] [thread THREADNUM] [<span class="keyword">if</span> CONDITION]</span><br></pre></td></tr></table></figure>

<h3 id="6-2-锁定调度器，只让当前线程运行"><a href="#6-2-锁定调度器，只让当前线程运行" class="headerlink" title="6.2. 锁定调度器，只让当前线程运行"></a>6.2. 锁定调度器，只让当前线程运行</h3><p>默认情况下，GDB 会让所有线程一起运行（比如你执行 continue 时）。如果你只想让当前线程运行，其它线程保<br>持暂停，可以使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> scheduler-locking on</span><br></pre></td></tr></table></figure>

<p>这表示：只有当前线程会执行，其他线程全部暂停。</p>
<p>其中模式还有：</p>
<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">off</td>
<td align="center">默认值，所有线程都可以运行</td>
</tr>
<tr>
<td align="center">on</td>
<td align="center">只有当前线程运行，其他线程暂停</td>
</tr>
<tr>
<td align="center">step</td>
<td align="center">单步调试时只运行当前线程，continue 时其他线程也会运行</td>
</tr>
</tbody></table>
<p>你可以随时切换：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> scheduler-locking step</span><br></pre></td></tr></table></figure>

<ul>
<li>如果你在调试死锁、竞态或线程间通信问题，锁定调度器是非常有效的方式。</li>
<li>如果你在调试某个 poll() 或 epoll_wait() 调用，只想观察某个线程的行为，可以结合 catch syscall 和<br>thread 命令一起使用。</li>
</ul>
<h2 id="7-查看汇编代码"><a href="#7-查看汇编代码" class="headerlink" title="7. 查看汇编代码"></a>7. 查看汇编代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看汇编代码，其中 &quot;=&gt;&quot; 标记的是当前执行位置</span></span><br><span class="line">(gdb) disassemble</span><br><span class="line"><span class="comment"># 反汇编指定地址范围</span></span><br><span class="line"><span class="comment"># 这会显示从当前指令开始的 32 字节范围内的汇编代码。</span></span><br><span class="line">(gdb) disassemble <span class="variable">$rip</span>, <span class="variable">$rip</span>+32</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前指令（x86）</span></span><br><span class="line">(gdb) x/i <span class="variable">$pc</span></span><br><span class="line"><span class="comment"># 或在 x86-64 架构下：</span></span><br><span class="line">(gdb) x/i <span class="variable">$rip</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bonus: 默认 GDB 使用 AT&amp;T 风格（如 %rax），你可以切换为 Intel 风格</span></span><br><span class="line"><span class="comment"># 这样输出会更接近你在汇编教材或 IDA Pro 中看到的格式</span></span><br><span class="line">(gdb) <span class="built_in">set</span> disassembly-flavor intel</span><br></pre></td></tr></table></figure>

<h2 id="8-位置无关代码（PIC）"><a href="#8-位置无关代码（PIC）" class="headerlink" title="8. 位置无关代码（PIC）"></a>8. 位置无关代码（PIC）</h2><h3 id="8-1-什么是-PIC"><a href="#8-1-什么是-PIC" class="headerlink" title="8.1. 什么是 PIC"></a>8.1. <strong>什么是 PIC</strong></h3><ul>
<li><strong>PIC</strong>（Position Independent Code，位置无关代码）是一种编译方式，使得生成的代码可以在内存中的任意<br>位置运行，而无需硬编码绝对地址。</li>
<li>在动态链接库（<code>shared libraries</code>）中，通常需要使用 PIC，以便库可以被加载到任意内存地址。</li>
<li>节省空间：相比使用 64 位绝对地址，RIP 相对寻址只需要一个 32 位偏移量。</li>
<li>更安全：支持地址随机化（ASLR），提高程序的安全性。</li>
</ul>
<h3 id="8-2-PIC-的实现"><a href="#8-2-PIC-的实现" class="headerlink" title="8.2. PIC 的实现"></a>8.2. <strong>PIC 的实现</strong></h3><ol>
<li><p><strong>访问全局变量</strong> 在 PIC 模式下，代码通过 <strong>全局偏移表（GOT, Global Offset Table）</strong> 和 <strong>过程链接<br>表（PLT, Procedure Linkage Table）</strong> 访问全局变量和函数地址。</p>
</li>
<li><p><strong>寄存器 <code>rip</code> 的使用</strong> x86_64 支持基于 <code>rip</code>（指令指针）的寻址方式，PIC 会利用 <code>rip</code> 相对寻址来<br>访问全局变量或函数地址，而不是使用绝对地址。</p>
</li>
</ol>
<p>在 x86-64 架构中，传统的绝对地址寻址方式不再适用于位置无关代码。于是引入了 RIP（指令指针）相对寻址：</p>
<p>假设你有一个全局变量 int x &#x3D; 42;，在汇编中访问它可能会变成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asm</span><br><span class="line">mov eax, DWORD PTR [rip + offset_to_x]</span><br></pre></td></tr></table></figure>

<p>这里的 offset_to_x 是编译器计算出来的 x 相对于当前指令的偏移量。</p>
<table>
<thead>
<tr>
<th align="center">寻址方式</th>
<th align="center">描述</th>
<th align="center">是否位置无关</th>
</tr>
</thead>
<tbody><tr>
<td align="center">绝对地址寻址</td>
<td align="center">使用固定地址，如 [0x400123]</td>
<td align="center">❌ 否</td>
</tr>
<tr>
<td align="center">寄存器间接寻址</td>
<td align="center">如 [rax]，地址由寄存器决定</td>
<td align="center">✅ 是</td>
</tr>
<tr>
<td align="center">RIP 相对寻址</td>
<td align="center">如 [rip + offset]，相对当前指令位置</td>
<td align="center">✅ 是</td>
</tr>
</tbody></table>
<h3 id="8-3-PIC-的优化"><a href="#8-3-PIC-的优化" class="headerlink" title="8.3. PIC 的优化"></a>8.3. <strong>PIC 的优化</strong></h3><ul>
<li><strong>减少重定位</strong>：通过 <code>rip</code> 相对寻址，避免了加载时的重定位操作，提高了加载速度。</li>
<li><strong>共享内存</strong>：多个进程可以共享同一段动态库代码，而无需为每个进程生成独立的副本。</li>
</ul>
<h3 id="8-4-示例"><a href="#8-4-示例" class="headerlink" title="8.4. 示例"></a>8.4. <strong>示例</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [rip + global_var@GOTPCREL]  ; 通过 GOT 表访问全局变量</span><br><span class="line">call [rip + func@PLT]                ; 通过 PLT 表调用函数</span><br></pre></td></tr></table></figure>

<p>举个 gdb 调试的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/i <span class="variable">$rip</span></span><br><span class="line">=&gt; 0x2ac084b5ec10 &lt;poll&gt;:       cmpl   <span class="variable">$0x0</span>,0x2d939d(%rip)        <span class="comment"># 0x2ac084e37fb4 &lt;__libc_multiple_threads&gt;</span></span><br><span class="line">(gdb) p (bool)<span class="variable">$__libc_multiple_threads</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>cmpl $0x0, 0x2d939d(%rip)</code> 是一条比较指令（<code>cmp</code>），用于将某个内存地址中的值与立即数 <code>0</code> 进行比较<br>。</li>
<li><code>(%rip)</code> 表示使用 RIP 相对寻址，这是 x86-64 架构中常见的一种寻址方式。</li>
<li>实际比较的是地址 <code>0x2ac084e37fb4</code> 处的值，也就是 <code>__libc_multiple_threads</code> 这个变量。</li>
</ul>
<p><code>__libc_multiple_threads</code> 是什么？</p>
<ul>
<li>这是 GNU C 库（glibc）中的一个内部变量，用来标记当前进程是否启用了多线程。</li>
<li>如果这个值是 0，说明当前进程是单线程。</li>
<li>如果是非零，说明进程中有多个线程。</li>
</ul>
<p>所以这条指令的作用是：判断当前进程是否是多线程环境，可能用于决定是否启用线程安全的行为。</p>
<h3 id="8-5-为什么使用-RIP-相对寻址？"><a href="#8-5-为什么使用-RIP-相对寻址？" class="headerlink" title="8.5. 为什么使用 RIP 相对寻址？"></a>8.5. 为什么使用 RIP 相对寻址？</h3><ol>
<li>RIP 是唯一始终已知的寄存器</li>
</ol>
<ul>
<li>在执行指令时，CPU 总是知道当前指令的地址（即 RIP）。</li>
<li>所以可以在编译时计算出目标数据与当前指令之间的偏移量，而不需要知道数据的绝对地址。</li>
</ul>
<p>这就允许编译器生成位置无关代码，即使程序被加载到不同的内存地址，偏移量仍然有效。</p>
<ol start="2">
<li>其他寄存器值是动态的，不可预测</li>
</ol>
<ul>
<li>比如 RBX、RAX、RDI 等寄存器，它们的值在运行时可能被程序修改。</li>
<li>如果用这些寄存器做基址寻址，编译器就无法提前知道它们的值，也就无法生成稳定的偏移量。</li>
</ul>
<ol start="3">
<li>支持共享库和地址空间布局随机化（ASLR）</li>
</ol>
<ul>
<li>RIP 相对寻址让代码段不依赖固定地址，可以被多个进程共享。</li>
<li>也支持操作系统在运行时随机加载地址，提高安全性（ASLR）。</li>
</ul>
<ol start="4">
<li>节省指令空间</li>
</ol>
<ul>
<li>使用 RIP 相对寻址只需要一个 32 位偏移量。</li>
<li>如果使用绝对地址，需要嵌入完整的 64 位地址，指令长度更长，效率更低。</li>
</ul>
<h3 id="8-6-为什么使用-RIP-相对寻址只需要一个-32-位偏移量"><a href="#8-6-为什么使用-RIP-相对寻址只需要一个-32-位偏移量" class="headerlink" title="8.6. 为什么使用 RIP 相对寻址只需要一个 32 位偏移量"></a>8.6. 为什么使用 RIP 相对寻址只需要一个 32 位偏移量</h3><p>在 x86-64 架构中，RIP 相对寻址的偏移量被设计为一个有符号的 32 位整数，也就是一个 displacement（位移<br>）字段，它在机器码中只占用 4 个字节。</p>
<ul>
<li><p>RIP 是 64 位的指令指针，表示当前指令的地址。</p>
</li>
<li><p>RIP 相对寻址的目标地址是通过：</p>
<p><code>目标地址 = 下一条指令地址（RIP） + 32 位偏移量</code></p>
</li>
<li><p>这个偏移量是一个 有符号整数，所以它的范围是：</p>
<p>从 −2³¹ 到 +2³¹−1，即 <strong>±2GB</strong> 的寻址范围。</p>
</li>
</ul>
<p>这意味着，当前指令附近 ±2GB 范围内的任何数据都可以通过 RIP 相对寻址访问。</p>
<table>
<thead>
<tr>
<th align="center">优点</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">✅ 节省空间</td>
<td align="center">只用 4 字节表示偏移，比使用完整 64 位地址节省指令长度</td>
</tr>
<tr>
<td align="center">✅ 支持位置无关代码</td>
<td align="center">编译器只需计算偏移，不依赖绝对地址</td>
</tr>
<tr>
<td align="center">✅ 高效</td>
<td align="center">CPU 执行时只需加法运算，无需查表或重定位</td>
</tr>
<tr>
<td align="center">✅ 安全</td>
<td align="center">支持地址空间布局随机化（ASLR），提高安全性</td>
</tr>
</tbody></table>
<h3 id="8-7-为什么可以被多个进程共享？"><a href="#8-7-为什么可以被多个进程共享？" class="headerlink" title="8.7. 为什么可以被多个进程共享？"></a>8.7. 为什么可以被多个进程共享？</h3><p>因为代码中不再硬编码具体地址，多个进程可以：</p>
<ul>
<li>使用同一份物理内存中的代码段。</li>
<li>每个进程有自己的数据段，但共享同一份只读代码。</li>
</ul>
<p>这大大节省了内存，提高了系统效率。</p>
<p>举个例子：</p>
<table>
<thead>
<tr>
<th align="center">进程</th>
<th align="center">加载地址</th>
<th align="center">使用的代码段</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">0x400000</td>
<td align="center">使用共享代码段</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">0x500000</td>
<td align="center">使用共享代码段</td>
</tr>
</tbody></table>
<p>两者的代码段内容完全一样，因为里面的寻址是相对 RIP 的，不依赖于加载地址。</p>
<p>为什么绝对寻址不可以被多进程共享？</p>
<ul>
<li>每个进程的虚拟地址空间是独立的<ul>
<li>操作系统为每个进程分配独立的虚拟地址空间。</li>
<li>即使两个进程都加载了同一个程序，它们的地址空间可能完全不同。</li>
<li>如果代码中使用绝对地址，加载到不同地址空间后，这些地址就不再有效。</li>
</ul>
</li>
</ul>
<p>所以，绝对地址在一个进程中是有效的，在另一个进程中可能就指向错误的地方或根本不存在。</p>
<ul>
<li><p>需要重定位，无法直接共享物理页</p>
<ul>
<li>如果使用绝对地址，操作系统必须在每个进程加载时对代码进行“重定位”，修改指令中的地址。</li>
<li>一旦修改，代码段就变成了进程私有，不能共享同一份物理内存。</li>
<li>而位置无关代码（如使用 RIP 相对寻址）不需要修改，可以直接映射到多个进程的地址空间。</li>
</ul>
</li>
<li><p>违反共享库的设计原则</p>
<ul>
<li>动态链接库（如 <code>.so</code> 或 <code>.dll</code>）的核心优势就是可以被多个进程共享。</li>
<li>如果库中使用绝对地址，每个进程都要有自己的副本，失去了共享的意义。</li>
<li>正确做法是使用位置无关代码（PIC），让库在任意地址都能运行。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">区域</th>
<th align="center">是否可共享</th>
<th align="center">原因说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">代码段</td>
<td align="center">✅ 是</td>
<td align="center">只读 + 位置无关，多个进程可映射同一物理页</td>
</tr>
<tr>
<td align="center">数据段</td>
<td align="center">❌ 否</td>
<td align="center">每个进程的数据不同，需独立副本</td>
</tr>
<tr>
<td align="center">堆</td>
<td align="center">❌ 否</td>
<td align="center">动态分配，地址空间不同</td>
</tr>
<tr>
<td align="center">栈</td>
<td align="center">❌ 否</td>
<td align="center">私有调用栈，不能混用</td>
</tr>
<tr>
<td align="center">共享内存段</td>
<td align="center">✅ 是</td>
<td align="center">显式创建，专门用于共享</td>
</tr>
</tbody></table>
<p>如果你想深入了解某个进程的内存布局，可以分析 <code>/proc/[pid]/maps</code> 或用工具如 <code>pmap</code>、<code>vmmap</code>。</p>
<h2 id="9-实际-debug-例子：在多线程中查看-poll-的事件"><a href="#9-实际-debug-例子：在多线程中查看-poll-的事件" class="headerlink" title="9. 实际 debug 例子：在多线程中查看 poll 的事件"></a>9. 实际 debug 例子：在多线程中查看 poll 的事件</h2><p>先复习下 <code>poll</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数 fds 的类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="type">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">    <span class="type">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>FIXME：这种在汇编代码 ret 前断点，并依据 <code>rax</code> 、<code>rdi</code> 设置条件断点的方式不可靠，因为可能进入了<br>libc 层。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 polll 的汇编代码</span></span><br><span class="line">(gdb) disass poll</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> poll:</span><br><span class="line">   0x00002ac084b5ec10 &lt;+0&gt;:     cmpl   <span class="variable">$0x0</span>,0x2d939d(%rip)        <span class="comment"># 0x2ac084e37fb4 &lt;__libc_multiple_threads&gt;</span></span><br><span class="line">   0x00002ac084b5ec17 &lt;+7&gt;:     jne    0x2ac084b5ec29 &lt;poll+25&gt;</span><br><span class="line">   0x00002ac084b5ec19 &lt;+0&gt;:     mov    <span class="variable">$0x7</span>,%eax</span><br><span class="line">   0x00002ac084b5ec1e &lt;+5&gt;:     syscall</span><br><span class="line">   0x00002ac084b5ec20 &lt;+7&gt;:     cmp    <span class="variable">$0xfffffffffffff001</span>,%rax</span><br><span class="line">   0x00002ac084b5ec26 &lt;+13&gt;:    jae    0x2ac084b5ec59 &lt;poll+73&gt;</span><br><span class="line">   0x00002ac084b5ec28 &lt;+15&gt;:    ret</span><br><span class="line">   0x00002ac084b5ec29 &lt;+25&gt;:    sub    <span class="variable">$0x8</span>,%rsp</span><br><span class="line">   0x00002ac084b5ec2d &lt;+29&gt;:    call   0x2ac084b77600 &lt;__libc_enable_asynccancel&gt;</span><br><span class="line">   0x00002ac084b5ec32 &lt;+34&gt;:    mov    %rax,(%rsp)</span><br><span class="line">   0x00002ac084b5ec36 &lt;+38&gt;:    mov    <span class="variable">$0x7</span>,%eax</span><br><span class="line">   0x00002ac084b5ec3b &lt;+43&gt;:    syscall</span><br><span class="line">   0x00002ac084b5ec3d &lt;+45&gt;:    mov    (%rsp),%rdi</span><br><span class="line">   0x00002ac084b5ec41 &lt;+49&gt;:    mov    %rax,%rdx</span><br><span class="line">   0x00002ac084b5ec44 &lt;+52&gt;:    call   0x2ac084b77660 &lt;__libc_disable_asynccancel&gt;</span><br><span class="line">   0x00002ac084b5ec49 &lt;+57&gt;:    mov    %rdx,%rax</span><br><span class="line">   0x00002ac084b5ec4c &lt;+60&gt;:    add    <span class="variable">$0x8</span>,%rsp</span><br><span class="line">   0x00002ac084b5ec50 &lt;+64&gt;:    cmp    <span class="variable">$0xfffffffffffff001</span>,%rax</span><br><span class="line">   0x00002ac084b5ec56 &lt;+70&gt;:    jae    0x2ac084b5ec59 &lt;poll+73&gt;</span><br><span class="line">=&gt; 0x00002ac084b5ec58 &lt;+72&gt;:    ret</span><br><span class="line">   0x00002ac084b5ec59 &lt;+73&gt;:    mov    0x2d31f0(%rip),%rcx        <span class="comment"># 0x2ac084e31e50</span></span><br><span class="line">   0x00002ac084b5ec60 &lt;+80&gt;:    neg    %eax</span><br><span class="line">   0x00002ac084b5ec62 &lt;+82&gt;:    mov    %eax,%fs:(%rcx)</span><br><span class="line">   0x00002ac084b5ec65 &lt;+85&gt;:    or     <span class="variable">$0xffffffffffffffff</span>,%rax</span><br><span class="line">   0x00002ac084b5ec69 &lt;+89&gt;:    ret</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到所有的 ret 指令，设置条件断点</span></span><br><span class="line"><span class="comment"># 注意：最好是在 ret 指令之前的指令上也加上断点，</span></span><br><span class="line"><span class="comment"># 因为 ret 的时候，可能已经把当前栈（除 rsp / rbp 外）都弹出了，寄存器中将看不到当前栈的信息</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># $rax 是返回值寄存器，也就是返回大于 0 时，让进程暂停</span></span><br><span class="line"><span class="comment"># 这里的 * 表示取内存的值（存放的是指令），* 断不可少，不然会被认为是 Function name</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">(gdb) b *0x00002ac084b5ec26 thread 4 <span class="keyword">if</span> <span class="variable">$rax</span> &gt; 0</span><br><span class="line">(gdb) b *0x00002ac084b5ec28 thread 4 <span class="keyword">if</span> <span class="variable">$rax</span> &gt; 0</span><br><span class="line">(gdb) b *0x00002ac084b5ec56 thread 4 <span class="keyword">if</span> <span class="variable">$rax</span> &gt; 0</span><br><span class="line">(gdb) b *0x00002ac084b5ec58 thread 4 <span class="keyword">if</span> <span class="variable">$rax</span> &gt; 0</span><br><span class="line">(gdb) b *0x00002ac084b5ec65 thread 4 <span class="keyword">if</span> <span class="variable">$rax</span> &gt; 0</span><br><span class="line">(gdb) b *0x00002ac084b5ec69 thread 4 <span class="keyword">if</span> <span class="variable">$rax</span> &gt; 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继续运行</span></span><br><span class="line">(gdb) c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 IO 事件发生，程序会被暂停</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><ul>
<li>addr2line</li>
</ul>
<p>日志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread 0 (crashed) 0 libexample.so + 0x36406</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addr2line -e libexample.so 0x36406</span><br></pre></td></tr></table></figure>

<p>或用 gdb :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb libexample.so</span><br><span class="line">(gdb) info line *0x36406</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/21/dmtcp/DMTCP%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86jalib/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/21/dmtcp/DMTCP%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86jalib/" class="post-title-link" itemprop="url">DMTCP 之内存管理 (jalib)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-21 09:59:55" itemprop="dateCreated datePublished" datetime="2025-08-21T09:59:55+00:00">2025-08-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-23 14:39:34" itemprop="dateModified" datetime="2025-09-23T14:39:34+00:00">2025-09-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/DMTCP/" itemprop="url" rel="index"><span itemprop="name">DMTCP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a target="_blank" rel="noopener" href="https://github.com/dmtcp/dmtcp/tree/main/jalib">https://github.com/dmtcp/dmtcp/tree/main/jalib</a></p>
<h2 id="malloc-的特性和局限"><a href="#malloc-的特性和局限" class="headerlink" title="malloc 的特性和局限"></a>malloc 的特性和局限</h2><p><code>malloc</code>&#x2F;<code>free</code> 是操作系统（或 C 库）提供的通用堆分配器。</p>
<ul>
<li>它通常会采用 “内存池 + 分块 + 空闲链表” 等技术，但它为了通用性和线程安全，设计得很复杂，开销较大。</li>
<li>在高并发 &#x2F; 频繁小块分配释放的场景下，<code>malloc</code> 的性能和碎片控制未必理想。</li>
</ul>
<p><code>malloc</code> 很难让你：</p>
<ul>
<li>控制分配内存的位置（如 DMTCP 需要特殊内存区域）</li>
<li>统计 &#x2F; 追踪所有分配的内存块</li>
<li>实现定制的分配策略（如无锁、分层小块池、预扩展等）</li>
<li>轻松调试和隔离内存问题</li>
</ul>
<h3 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h3><p>malloc 的确在其实现内部也维护着自己的 “内存池”，并且会对小块内存（small bins&#x2F;tcache&#x2F;fast bins 等）做优化和分组管理。比如在 glibc 的 malloc（ptmalloc）中，就有针对小块内存的快速分配机制。</p>
<ol>
<li><p>malloc 是 “通用分配器”<br>malloc 需要支持所有应用场景，包括大 &#x2F; 小 &#x2F; 奇异尺寸的分配、跨多线程、兼容各种系统调用和 ABI。<br>为了兼容性和健壮性，malloc 实现复杂，包含很多额外的元数据和检查，导致分配 &#x2F; 释放开销更大。</p>
</li>
<li><p>malloc 的小块管理是 “全局的”<br>malloc 管理的小块是全进程共享的，所有线程 &#x2F; 模块都会竞争同一套管理结构（如 fastbin、tcache、small bin）。<br>在高并发、频繁小块分配 &#x2F; 释放的场景下，锁竞争和同步成本变高，可能成为性能瓶颈。</p>
</li>
<li><p>自定义分配器（如 jalib）“更窄、更专用”<br>jalib 只服务 DMTCP 内部的特殊内存分配需求，只关注固定几种典型的小块尺寸（如 64&#x2F;256&#x2F;1024…）。<br>可以用更简单、更高效的 “无锁链表 + 内存对齐块” 来管理池，分配和释放几乎都是 O(1)的原子操作。<br>不需要兼容所有 malloc 的场景（如 realloc、跨模块释放等），所以能极致优化。</p>
</li>
<li><p>控制权和可观测性<br>jalib 可以完全掌控池的生命周期、分配区域、分配策略（如预扩展、定制回收），还可以追踪统计、调试。<br>malloc 的内部状态你无法直接控制或感知，也无法方便地和 DMTCP 的 checkpoint、回滚等功能集成。</p>
</li>
<li><p>内存碎片和确定性<br>专用分配器能保证分配块 “定长、对齐”，几乎无碎片，分配和回收都是确定性的。<br>malloc 需要兼容各种尺寸，碎片和内存抖动不可避免。</p>
</li>
</ol>
<h2 id="jalib（自定义分配器）的设计动机"><a href="#jalib（自定义分配器）的设计动机" class="headerlink" title="jalib（自定义分配器）的设计动机"></a>jalib（自定义分配器）的设计动机</h2><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul>
<li>DMTCP 频繁地分配和释放小块内存（如元数据、临时缓存等），如果每次都用 malloc，性能损耗大。</li>
<li>jalib 采用分级固定块池，每次分配 &#x2F; 释放只需操作链表和原子变量，比 malloc 更快、更少碎片。</li>
</ul>
<h3 id="线程安全的高效实现"><a href="#线程安全的高效实现" class="headerlink" title="线程安全的高效实现"></a>线程安全的高效实现</h3><ul>
<li>jalib 用无锁（128 位 CAS）或轻量级互斥方案，适合高并发分配 &#x2F; 释放。</li>
<li>malloc 虽然线程安全，但实现方式更重，适用范围更广，未必最优。</li>
</ul>
<h3 id="可控性和可追踪性"><a href="#可控性和可追踪性" class="headerlink" title="可控性和可追踪性"></a>可控性和可追踪性</h3><ul>
<li>jalib 可以统计分配次数、追踪所有内存池区，方便调试、分析和 checkpoint 恢复。</li>
<li>可根据实际需求预分配或批量扩展，避免运行时大规模内存抖动。</li>
</ul>
<h3 id="适应-DMTCP-的特殊需求"><a href="#适应-DMTCP-的特殊需求" class="headerlink" title="适应 DMTCP 的特殊需求"></a>适应 DMTCP 的特殊需求</h3><ul>
<li>DMTCP 需要在 checkpoint&#x2F;restore 时管理所有内存区域，jalib 可以定制分配区域、分配方式，malloc 无法满足。</li>
<li>可实现特定平台的优化，如 mmap 固定地址分配等。</li>
</ul>
<h3 id="故障隔离和调试"><a href="#故障隔离和调试" class="headerlink" title="故障隔离和调试"></a>故障隔离和调试</h3><ul>
<li>jalib 可以在有 bug 或内存泄漏时，帮助定位具体的分配 &#x2F; 释放流程。</li>
<li>可以方便地记录所有 arena 信息，甚至实现特殊的调试模式。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虽然 malloc 也是内存池管理，但它是为通用用途设计的，不能满足 DMTCP 这类高性能、高可控性、特殊内存管理需求场景。自定义 jalib 分配器可以更高效地管理小块内存，优化多线程性能，便于调试和适配特定需求。</p>
<p>可以归纳为三点：</p>
<ul>
<li>性能更高，碎片更少</li>
<li>更好地适应 DMTCP 的需求</li>
<li>更易于调试和控制</li>
</ul>
<h2 id="jalloc-设计思路"><a href="#jalloc-设计思路" class="headerlink" title="jalloc 设计思路"></a>jalloc 设计思路</h2><h3 id="多层级固定大小块分配（层级分配器）"><a href="#多层级固定大小块分配（层级分配器）" class="headerlink" title="多层级固定大小块分配（层级分配器）"></a>多层级固定大小块分配（层级分配器）</h3><ul>
<li>设计了 5 个分配层级（lvl1~lvl5），每层负责不同大小的定长内存块（如 64、256、1024、4096、16384 字节）。</li>
<li>小于等于这 5 个等级的分配请求，会被分配到各自的层级。</li>
<li>超过最大层级的请求，则直接调用 <code>_alloc_raw</code>（通常是 <code>mmap</code>）。</li>
</ul>
<p>优点：</p>
<ul>
<li>小块内存可以复用，减少系统调用和碎片。</li>
<li>大块内存仍可直接用系统接口，兼顾通用性。</li>
</ul>
<h3 id="固定块分配器-JFixedAllocStack"><a href="#固定块分配器-JFixedAllocStack" class="headerlink" title="固定块分配器 JFixedAllocStack"></a>固定块分配器 JFixedAllocStack</h3><p>每个层级对应一个 <code>JFixedAllocStack&lt;N&gt;</code>，其核心是无锁栈式管理：</p>
<ul>
<li>内部维护一个空闲块栈（LIFO 链表）。</li>
<li>allocate 时从栈取出一个空闲块，栈空时调用 expand 申请一批新块。</li>
<li>deallocate 时将块归还到栈顶。</li>
</ul>
<p>核心技术点</p>
<ul>
<li><p>原子双字比较交换（128 位 CAS）</p>
<p>为了线程安全，栈顶指针 _top 需要原子更新。这里用到了 128 位 CAS（Compare-And-Swap），保证 node 指针和计数器同时更新，避免 ABA 问题。</p>
</li>
<li><p>CAS 不可用时的降级方案</p>
<p>对于不支持 128 位原子操作的平台，采用 futex+memcpy 的方式手动实现互斥和原子性。</p>
</li>
</ul>
<h3 id="线程安全设计"><a href="#线程安全设计" class="headerlink" title="线程安全设计"></a>线程安全设计</h3><p>分配和释放都用原子操作保护，无需锁，性能高。<br>多线程环境下不会出现竞争条件或内存破坏。</p>
<h3 id="Arena-记录和调试"><a href="#Arena-记录和调试" class="headerlink" title="Arena 记录和调试"></a>Arena 记录和调试</h3><p>分配的内存区域（arena）可以记录到全局数组中，方便调试和统计。<br>通过 <code>JAlloc::getAllocArenas()</code> 可获得分配区域列表。</p>
<h3 id="全局-new-delete-重载（可选）"><a href="#全局-new-delete-重载（可选）" class="headerlink" title="全局 new&#x2F;delete 重载（可选）"></a>全局 new&#x2F;delete 重载（可选）</h3><p>如果定义了 <code>OVERRIDE_GLOBAL_ALLOCATOR</code>，会重载 <code>operator new</code> 和 <code>operator delete</code>，让全局 <code>new</code>&#x2F;<code>delete</code> 也用这个分配器。</p>
<h3 id="灵活切换"><a href="#灵活切换" class="headerlink" title="灵活切换"></a>灵活切换</h3><p>可以通过宏 <code>JALIB_ALLOCATOR</code> 切换：</p>
<ul>
<li>启用时用自定义分配器</li>
<li>否则回退为标准 malloc&#x2F;free</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>本内存分配器的设计核心在于：</p>
<ul>
<li>采用多级固定块内存池 + 无锁算法，高效服务于小块高频分配 &#x2F; 释放；</li>
<li>通过 128 位原子操作或 futex 确保并发安全，适用多平台；</li>
<li>提供 arena 管理和统计，方便调试与维护；</li>
<li>兼容传统分配方式，易于集成和切换。</li>
</ul>
<p>这种设计非常适合像 DMTCP 这样对性能和内存管理有特殊要求的系统级软件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/20/EDA/EAD%E4%BB%BF%E7%9C%9F%E4%B9%8BMemory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/20/EDA/EAD%E4%BB%BF%E7%9C%9F%E4%B9%8BMemory/" class="post-title-link" itemprop="url">EDA 仿真之 Memory</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-20 22:25:49" itemprop="dateCreated datePublished" datetime="2025-08-20T22:25:49+00:00">2025-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-23 14:39:34" itemprop="dateModified" datetime="2025-09-23T14:39:34+00:00">2025-09-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/EDA/" itemprop="url" rel="index"><span itemprop="name">EDA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>Memory &#x3D; 存储 + 访问逻辑</p>
<p>存储</p>
<ul>
<li>在仿真里，memory 本质上就是一个数组（Array）或者向量（Vector），每个元素对应一个存储单元（bit&#x2F;byte&#x2F;word）。</li>
<li>例：一个 8 位 × 1024 深度的 RAM，可以在仿真里用 <code>uint8_t mem[1024];</code> 表示。</li>
</ul>
<p>访问逻辑</p>
<ul>
<li>读（Read）：根据地址返回对应的数据。</li>
<li>写（Write）：根据地址和写使能信号，将数据写入存储单元。</li>
<li>可能涉及 时序：同步（clock 边沿写入）或异步（立即生效）。</li>
</ul>
<p>时序和延迟</p>
<ul>
<li>在硬件里，memory 访问不是瞬间的：存在 读延迟、写延迟。</li>
<li>仿真时，可以用 延时事件 或 clock 边沿触发 来模拟。</li>
</ul>
<h2 id="仿真代码"><a href="#仿真代码" class="headerlink" title="仿真代码"></a>仿真代码</h2><p>功能说明</p>
<ul>
<li>多端口读写：支持同时多个端口访问 memory</li>
<li>写冲突仲裁：写优先策略或延迟写，可扩展读优先 &#x2F; 轮询</li>
<li>读延迟 pipeline：延迟由 read_delay 控制</li>
<li>Burst &#x2F; wrap-around：访问超出末尾自动回绕</li>
<li>简单 Cache&#x2F;Tag：模拟命中 &#x2F; 未命中</li>
<li>异步端口：不同端口调用 read&#x2F;write 可在不同 tick，模拟异步时钟</li>
<li>随机 bit flip &#x2F; SEU：1% 概率错误注入</li>
<li>统计与功耗估算基础：记录读写次数、命中数、平均延迟</li>
</ul>
<figure class="highlight cpp"><figcaption><span>EdaMemoryFull.cpp</span><a href="/blog/downloads/code/eda/memory/EdaMemoryFull.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Event</span> {</span><br><span class="line">    <span class="type">int</span> time;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; action;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Event&amp; other) <span class="type">const</span> { <span class="keyword">return</span> time &gt; other.time; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EdaMemoryFull</span> {</span><br><span class="line">    std::vector&lt;<span class="type">uint8_t</span>&gt; mem;</span><br><span class="line">    std::priority_queue&lt;Event&gt; event_queue;</span><br><span class="line">    <span class="type">int</span> sim_time = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> read_delay;</span><br><span class="line">    std::mt19937 gen;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cache_size;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CacheLine</span> { <span class="type">bool</span> valid=<span class="literal">false</span>; <span class="type">int</span> tag=<span class="number">-1</span>; };</span><br><span class="line">    std::vector&lt;CacheLine&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max_bus_access_per_cycle = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> current_cycle_access = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计信息</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; read_count, write_count, read_hits, write_hits;</span><br><span class="line">    std::map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; read_delay_total;</span><br><span class="line">    <span class="type">int</span> dynamic_power = <span class="number">0</span>; <span class="comment">// 动态功耗</span></span><br><span class="line">    <span class="type">int</span> static_power; <span class="comment">// 静态功耗</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; dynamic_power_per_cycle; <span class="comment">// 每周期动态功耗</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态功耗公式（单位：动态功耗单位 = 每bit切换一次算1）</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// P_dyn = α * C * V^2 * f</span></span><br><span class="line">    <span class="comment">// 其中，α 开关活动因子（switching activity）</span></span><br><span class="line">    <span class="comment">//      C 负载电容</span></span><br><span class="line">    <span class="comment">//      V 电源电压</span></span><br><span class="line">    <span class="comment">//      f 时钟频率</span></span><br><span class="line">    <span class="comment">// 简化为每次 bit 改变增加一个单位动态功耗</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 静态功耗公式（单位：静态功耗单位 = 每8bit存储单元算1）</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// P_static = I_leak * V * N</span></span><br><span class="line">    <span class="comment">// 简化为每8bit存储单元增加1单位静态功耗</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 总功耗</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// P_total = P_dyn + P_static</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">WritePriority</span> { WRITE_FIRST, READ_FIRST, ROUND_ROBIN } write_prio;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EdaMemoryFull</span>(<span class="type">size_t</span> size, <span class="type">int</span> delay, <span class="type">int</span> c_size, WritePriority prio=WRITE_FIRST)</span><br><span class="line">        : <span class="built_in">mem</span>(size,<span class="number">0</span>), <span class="built_in">read_delay</span>(delay), <span class="built_in">gen</span>(std::random_device{}()), </span><br><span class="line">          <span class="built_in">cache_size</span>(c_size), <span class="built_in">cache</span>(c_size), <span class="built_in">static_power</span>(size/<span class="number">8</span>), <span class="built_in">write_prio</span>(prio)</span><br><span class="line">    {</span><br><span class="line">        std::uniform_int_distribution&lt;&gt; <span class="built_in">dis</span>(<span class="number">0</span>,<span class="number">255</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v: mem) v = <span class="built_in">dis</span>(gen);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> port,<span class="type">int</span> addr,<span class="type">const</span> std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; data)</span></span>{</span><br><span class="line">        write_count[port]++;</span><br><span class="line">        <span class="keyword">if</span>(current_cycle_access&gt;=max_bus_access_per_cycle){</span><br><span class="line">            event_queue.<span class="built_in">push</span>({sim_time+<span class="number">1</span>,[<span class="keyword">this</span>,port,addr,data](){ <span class="built_in">write</span>(port,addr,data); }});</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        current_cycle_access++;</span><br><span class="line">        <span class="keyword">if</span>(write_prio==WRITE_FIRST){</span><br><span class="line">            <span class="built_in">apply_write</span>(addr,data);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            event_queue.<span class="built_in">push</span>({sim_time+<span class="number">1</span>,[<span class="keyword">this</span>,addr,data](){ <span class="built_in">apply_write</span>(addr,data); }});</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">update_cache</span>(port, addr,data,<span class="literal">true</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> port,<span class="type">int</span> addr,<span class="type">size_t</span> length,std::function&lt;<span class="type">void</span>(std::vector&lt;<span class="type">uint8_t</span>&gt;)&gt; callback)</span></span>{</span><br><span class="line">        read_count[port]++;</span><br><span class="line">        <span class="keyword">if</span>(current_cycle_access&gt;=max_bus_access_per_cycle){</span><br><span class="line">            event_queue.<span class="built_in">push</span>({sim_time+<span class="number">1</span>,[<span class="keyword">this</span>,port,addr,length,callback](){ <span class="built_in">read</span>(port,addr,length,callback); }});</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        current_cycle_access++;</span><br><span class="line">        <span class="type">int</span> trigger_time = sim_time+read_delay;</span><br><span class="line">        <span class="type">bool</span> hit = <span class="built_in">check_cache</span>(port, addr,length);</span><br><span class="line">        <span class="keyword">if</span>(hit) read_hits[port]++;</span><br><span class="line">        event_queue.<span class="built_in">push</span>({trigger_time,[<span class="keyword">this</span>,addr,length,callback,port,trigger_time]() {</span><br><span class="line">            std::vector&lt;<span class="type">uint8_t</span>&gt; data;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;length;i++){</span><br><span class="line">                <span class="type">uint8_t</span> val = mem[(addr+i)%mem.<span class="built_in">size</span>()];</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">random_bit_flip</span>()) val ^= (<span class="number">1</span>&lt;&lt;(<span class="built_in">gen</span>()%<span class="number">8</span>));</span><br><span class="line">                dynamic_power += <span class="built_in">count_bit_changes</span>(val, mem[(addr+i)%mem.<span class="built_in">size</span>()]);</span><br><span class="line">                data.<span class="built_in">push_back</span>(val);</span><br><span class="line">            }</span><br><span class="line">            read_delay_total[port] += (trigger_time - sim_time);</span><br><span class="line">            <span class="built_in">callback</span>(data);</span><br><span class="line">        }});</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">()</span></span>{</span><br><span class="line">        sim_time++;</span><br><span class="line">        current_cycle_access = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cycle_dyn_power = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!event_queue.<span class="built_in">empty</span>() &amp;&amp; event_queue.<span class="built_in">top</span>().time &lt;= sim_time){</span><br><span class="line">            <span class="keyword">auto</span> e = event_queue.<span class="built_in">top</span>(); event_queue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> before = dynamic_power;</span><br><span class="line">            e.<span class="built_in">action</span>();</span><br><span class="line">            cycle_dyn_power += (dynamic_power - before);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        dynamic_power_per_cycle.<span class="built_in">push_back</span>(cycle_dyn_power);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ASCII 可视化每周期动态功耗</span></span><br><span class="line">        <span class="type">int</span> scale = <span class="number">50</span>;</span><br><span class="line">        <span class="type">int</span> bar_len = *std::<span class="built_in">max_element</span>(dynamic_power_per_cycle.<span class="built_in">begin</span>(), dynamic_power_per_cycle.<span class="built_in">end</span>())&gt;<span class="number">0</span> ?</span><br><span class="line">                      cycle_dyn_power*scale/(*std::<span class="built_in">max_element</span>(dynamic_power_per_cycle.<span class="built_in">begin</span>(), dynamic_power_per_cycle.<span class="built_in">end</span>())) : <span class="number">0</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Cycle &quot;</span> &lt;&lt; sim_time &lt;&lt; <span class="string">&quot; dyn power: &quot;</span> &lt;&lt; cycle_dyn_power</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; total power: &quot;</span> &lt;&lt; dynamic_power + static_power &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;bar_len;i++) std::cout&lt;&lt;<span class="string">&quot;#&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_stats</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Simulation stats:\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [port,cnt]: read_count)</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;Port &quot;</span>&lt;&lt;port&lt;&lt;<span class="string">&quot; read count: &quot;</span>&lt;&lt;cnt</span><br><span class="line">                     &lt;&lt;<span class="string">&quot;, hits: &quot;</span>&lt;&lt;read_hits.<span class="built_in">at</span>(port)</span><br><span class="line">                     &lt;&lt;<span class="string">&quot;, avg delay: &quot;</span>&lt;&lt;(cnt?read_delay_total.<span class="built_in">at</span>(port)/cnt:<span class="number">0</span>)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [port,cnt]: write_count)</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;Port &quot;</span>&lt;&lt;port&lt;&lt;<span class="string">&quot; write count: &quot;</span>&lt;&lt;cnt</span><br><span class="line">                     &lt;&lt;<span class="string">&quot;, hits: &quot;</span>&lt;&lt;write_hits.<span class="built_in">at</span>(port)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Dynamic power units: &quot;</span>&lt;&lt;dynamic_power&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Static power units: &quot;</span>&lt;&lt;static_power&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Total power units: &quot;</span>&lt;&lt;dynamic_power + static_power&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">export_power_csv</span><span class="params">(<span class="type">const</span> std::string &amp;filename)</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="function">std::ofstream <span class="title">ofs</span><span class="params">(filename)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(!ofs.<span class="built_in">is_open</span>()) {</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Failed to open file: &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        ofs &lt;&lt; <span class="string">&quot;Cycle,DynamicPower,StaticPower,TotalPower\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;dynamic_power_per_cycle.<span class="built_in">size</span>();i++){</span><br><span class="line">            <span class="type">int</span> dyn = dynamic_power_per_cycle[i];</span><br><span class="line">            <span class="type">int</span> total = dyn + static_power;</span><br><span class="line">            ofs &lt;&lt; (i+<span class="number">1</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; dyn &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; static_power &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; total &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        }</span><br><span class="line">        ofs.<span class="built_in">close</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Power data exported to &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">random_bit_flip</span><span class="params">()</span></span>{</span><br><span class="line">        std::uniform_real_distribution&lt;&gt; <span class="built_in">dis</span>(<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dis</span>(gen)&lt;<span class="number">0.01</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count_bit_changes</span><span class="params">(<span class="type">uint8_t</span> a,<span class="type">uint8_t</span> b)</span></span>{</span><br><span class="line">        <span class="type">uint8_t</span> diff = a^b;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(diff){ count+=diff&amp;<span class="number">1</span>; diff&gt;&gt;=<span class="number">1</span>; }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check_cache</span><span class="params">(<span class="type">int</span> port, <span class="type">int</span> addr,<span class="type">size_t</span> length)</span></span>{</span><br><span class="line">        <span class="type">int</span> line = addr % cache_size;</span><br><span class="line">        <span class="type">int</span> tag = addr / cache_size;</span><br><span class="line">        <span class="keyword">return</span> cache[line].valid &amp;&amp; cache[line].tag==tag;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update_cache</span><span class="params">(<span class="type">int</span> port, <span class="type">int</span> addr,<span class="type">const</span> std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; data,<span class="type">bool</span> write=<span class="literal">false</span>)</span></span>{</span><br><span class="line">        <span class="type">int</span> line = addr % cache_size;</span><br><span class="line">        <span class="type">int</span> tag = addr / cache_size;</span><br><span class="line">        cache[line].valid=<span class="literal">true</span>;</span><br><span class="line">        cache[line].tag=tag;</span><br><span class="line">        <span class="keyword">if</span>(write) write_hits[port]++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply_write</span><span class="params">(<span class="type">int</span> addr,<span class="type">const</span> std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; data)</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;data.<span class="built_in">size</span>();i++) mem[(addr+i)%mem.<span class="built_in">size</span>()]=data[i];</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例主程序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="function">EdaMemoryFull <span class="title">mem</span><span class="params">(<span class="number">1024</span>,<span class="number">2</span>,<span class="number">16</span>,EdaMemoryFull::WRITE_FIRST)</span></span>;</span><br><span class="line"></span><br><span class="line">    mem.<span class="built_in">write</span>(<span class="number">0</span>,<span class="number">10</span>,{<span class="number">42</span>,<span class="number">43</span>,<span class="number">44</span>});</span><br><span class="line">    mem.<span class="built_in">write</span>(<span class="number">1</span>,<span class="number">11</span>,{<span class="number">99</span>});</span><br><span class="line">    mem.<span class="built_in">read</span>(<span class="number">0</span>,<span class="number">10</span>,<span class="number">3</span>,[](std::vector&lt;<span class="type">uint8_t</span>&gt; data){</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Port0 read burst: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:data) std::cout&lt;&lt;(<span class="type">int</span>)v&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        std::cout&lt;&lt;std::endl;</span><br><span class="line">    });</span><br><span class="line">    mem.<span class="built_in">read</span>(<span class="number">1</span>,<span class="number">11</span>,<span class="number">1</span>,[](std::vector&lt;<span class="type">uint8_t</span>&gt; data){</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Port1 read: &quot;</span>&lt;&lt;(<span class="type">int</span>)data[<span class="number">0</span>]&lt;&lt;std::endl;</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) mem.<span class="built_in">tick</span>();</span><br><span class="line">    <span class="comment">// 导出功耗数据</span></span><br><span class="line">    mem.<span class="built_in">export_power_csv</span>(<span class="string">&quot;memory_power.csv&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mem.<span class="built_in">print_stats</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>输出的 memory_power.csv 文件内容示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Cycle,DynamicPower,StaticPower,TotalPower</span><br><span class="line">1,3,128,131</span><br><span class="line">2,0,128,128</span><br><span class="line">3,5,128,133</span><br><span class="line">4,2,128,130</span><br><span class="line">5,7,128,135</span><br><span class="line">6,1,128,129</span><br><span class="line">7,4,128,132</span><br><span class="line">8,0,128,128</span><br><span class="line">9,2,128,130</span><br><span class="line">10,3,128,131</span><br></pre></td></tr></table></figure>

<p>每列含义：</p>
<ul>
<li>Cycle：周期号</li>
<li>DynamicPower：每周期动态功耗单位</li>
<li>StaticPower：静态功耗单位（固定）</li>
<li>TotalPower：总功耗单位</li>
</ul>
<p>功耗分析</p>
<figure class="highlight python"><figcaption><span>report_power.py</span><a href="/blog/downloads/code/eda/memory/report_power.py">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 CSV</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;memory_power.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到动态功耗峰值周期</span></span><br><span class="line">peak_cycle = df[<span class="string">&#x27;DynamicPower&#x27;</span>].idxmax() + <span class="number">1</span></span><br><span class="line">peak_value = df[<span class="string">&#x27;DynamicPower&#x27;</span>].<span class="built_in">max</span>()</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制条形背景（ASCII风格效果）</span></span><br><span class="line"><span class="keyword">for</span> i, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(df[<span class="string">&#x27;DynamicPower&#x27;</span>]):</span><br><span class="line">    bar_len = <span class="built_in">int</span>(val / peak_value * <span class="number">50</span>)  <span class="comment"># 50字符最大长度</span></span><br><span class="line">    plt.text(i+<span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;#&#x27;</span> * bar_len, fontsize=<span class="number">8</span>, color=<span class="string">&#x27;grey&#x27;</span>, va=<span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制曲线</span></span><br><span class="line">plt.plot(df[<span class="string">&#x27;Cycle&#x27;</span>], df[<span class="string">&#x27;DynamicPower&#x27;</span>], label=<span class="string">&#x27;Dynamic Power&#x27;</span>, marker=<span class="string">&#x27;o&#x27;</span>, color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">plt.plot(df[<span class="string">&#x27;Cycle&#x27;</span>], df[<span class="string">&#x27;StaticPower&#x27;</span>], label=<span class="string">&#x27;Static Power&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>, color=<span class="string">&#x27;orange&#x27;</span>)</span><br><span class="line">plt.plot(df[<span class="string">&#x27;Cycle&#x27;</span>], df[<span class="string">&#x27;TotalPower&#x27;</span>], label=<span class="string">&#x27;Total Power&#x27;</span>, linestyle=<span class="string">&#x27;-.&#x27;</span>, color=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高亮峰值</span></span><br><span class="line">plt.scatter(peak_cycle, peak_value, color=<span class="string">&#x27;red&#x27;</span>, s=<span class="number">100</span>, label=<span class="string">&#x27;Peak Dynamic Power&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&#x27;Memory Power Simulation with Peak Highlight &amp; ASCII-style Bars&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Cycle&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Power Units&#x27;</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>, linestyle=<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h3 id="burst-multi-port-总线冲突"><a href="#burst-multi-port-总线冲突" class="headerlink" title="burst&#x2F;multi-port 总线冲突"></a>burst&#x2F;multi-port 总线冲突</h3><p>在多端口系统中，尤其是在使用总线结构的系统中，总线冲突（Bus contention）是一个常见的问题。总线冲突通常发生在多个设备尝试同时访问总线上的同一资源时。这种情况可能会导致数据损坏、系统性能下降或甚至系统崩溃。下面是一些解决和缓解总线冲突的策略：</p>
<ol>
<li>仲裁机制<br>仲裁是解决总线冲突的一种常用方法。它通过一个仲裁器（Arbiter）来决定哪个设备可以访问总线。常见的仲裁策略有：</li>
</ol>
<p>优先级仲裁：根据预先设定的优先级顺序决定哪个设备可以访问总线。</p>
<p>轮询仲裁：轮流让每个设备访问总线。</p>
<p>基于请求的仲裁（如请求共享（Request-for-Shared, RFS）和请求独占（Request-for-Exclusive, RFE））：设备首先请求对资源的访问，然后根据请求的类型（共享或独占）来决定访问权限。</p>
<ol start="2">
<li><p>分时复用<br>通过时间分割（Time Division Multiplexing, TDM）或频率分割（Frequency Division Multiplexing, FDM），可以允许多个设备在不同的时间或频率上使用总线，从而减少冲突。例如，可以使用时分多路复用将总线的不同时间段分配给不同的设备。</p>
</li>
<li><p>编码和解码技术<br>使用特殊的编码和解码技术，如霍纳编码（Hornar code）或格雷码（Gray code），可以减少在总线上传输数据时的错误，并帮助检测和纠正数据冲突。</p>
</li>
<li><p>总线锁定<br>在访问总线期间，通过总线锁定机制确保没有其他设备可以访问总线。这可以通过在总线上设置一个锁定信号来实现，该信号在访问期间保持激活状态。</p>
</li>
<li><p>缓存和缓冲<br>为每个设备提供局部缓存或缓冲机制，可以减少对总线的直接访问次数，从而降低冲突的可能性。当一个设备需要与总线上的另一个设备通信时，它可以先将数据写入自己的缓存，然后再由缓存同步到总线上。</p>
</li>
<li><p>使用更宽的总线<br>增加总线的宽度可以允许在同一时间内传输更多的数据，从而减少对总线的需求，降低冲突的可能性。</p>
</li>
</ol>
<p>实施步骤<br>评估系统需求：确定哪些类型的设备将使用总线，以及它们对带宽的需求。</p>
<p>选择仲裁策略：根据设备的优先级和带宽需求选择合适的仲裁策略。</p>
<p>设计硬件：根据选定的策略设计硬件，包括添加仲裁器、缓存和适当的控制逻辑。</p>
<p>测试和优化：实施后进行系统测试，根据测试结果调整策略或硬件设计。</p>
<p>通过上述方法，可以有效管理和减少多端口系统中的总线冲突问题，提高系统的稳定性和性能。</p>
<h3 id="Cache-Tag（缓存标记）"><a href="#Cache-Tag（缓存标记）" class="headerlink" title="Cache Tag（缓存标记）"></a>Cache Tag（缓存标记）</h3><p>Cache Tag（缓存标记）是高速缓存（Cache）中的关键组成部分，用于存储数据在主存中的地址信息，以便快速定位数据位置。 ‌</p>
<p>核心功能<br>Tag字段存储了主存中数据的地址信息，当CPU访问主存时，首先通过Tag字段判断数据是否存在于Cache中。若存在，则直接从Cache读取；若不存在，则访问主存。 ‌</p>
<p>结构组成</p>
<ul>
<li>‌Tag‌：记录数据在主存的地址信息。</li>
<li>‌Data‌：存储实际数据。</li>
<li>‌Valid Bit‌：标记数据是否有效。</li>
<li>‌Dir‌：目录信息，用于区分不同数据块。 ‌</li>
</ul>
<p>应用场景</p>
<p>现代处理器通常采用多级Cache结构（如L1、L2、L3），其中Tag与Data共同构成Cache Line，用于快速访问和存储数据。例如，ARMv8-A架构的处理器包含独立的I-Cache和D-Cache，分别存储指令和数据。</p>
<p>Cache Tag 仿真代码</p>
<blockquote>
<p>FIXME: 该代码会 coredump 。</p>
</blockquote>
<figure class="highlight cpp"><figcaption><span>cache_simulator.h</span><a href="/blog/downloads/code/eda/memory/cache/cache_simulator.h">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CACHE_SIMULATOR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHE_SIMULATOR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存行结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CacheLine</span> {</span><br><span class="line">    <span class="type">bool</span> valid = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> dirty = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">uint32_t</span> tag = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint64_t</span> last_used = <span class="number">0</span>; <span class="comment">// 用于LRU替换策略</span></span><br><span class="line">    std::vector&lt;<span class="type">uint8_t</span>&gt; data;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 端口访问请求结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PortRequest</span> {</span><br><span class="line">    <span class="type">uint32_t</span> port_id;</span><br><span class="line">    <span class="type">bool</span> is_write;</span><br><span class="line">    <span class="type">uint32_t</span> addr;</span><br><span class="line">    <span class="type">uint8_t</span>* data_ptr;</span><br><span class="line">    <span class="type">size_t</span> data_size;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CacheSimulator</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CacheSimulator</span>(<span class="type">uint32_t</span> line_size, <span class="type">uint32_t</span> num_lines, <span class="type">uint32_t</span> num_ports);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 多端口访问接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process_request</span><span class="params">(<span class="type">const</span> PortRequest&amp; req)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 缓存配置</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_write_policy</span><span class="params">(<span class="type">bool</span> write_back)</span></span>; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_replacement_policy</span><span class="params">(<span class="type">int</span> policy)</span></span>; <span class="comment">// 0:LRU, 1:FIFO, 2:Random</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 内部缓存操作</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">access_cache</span><span class="params">(<span class="type">uint32_t</span> port_id, <span class="type">uint32_t</span> addr, <span class="type">bool</span> is_write, <span class="type">uint8_t</span>* data, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle_miss</span><span class="params">(<span class="type">uint32_t</span> port_id, <span class="type">uint32_t</span> addr)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">evict_line</span><span class="params">(<span class="type">uint32_t</span> set_idx, <span class="type">uint32_t</span> way_idx)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多端口同步</span></span><br><span class="line">    std::atomic&lt;<span class="type">uint64_t</span>&gt; global_counter_{<span class="number">0</span>}; <span class="comment">// 原子计数器</span></span><br><span class="line">    std::vector&lt;std::mutex&gt; port_locks_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 缓存结构</span></span><br><span class="line">    <span class="type">uint32_t</span> line_size_;</span><br><span class="line">    <span class="type">uint32_t</span> num_sets_;</span><br><span class="line">    std::vector&lt;std::vector&lt;CacheLine&gt;&gt; cache_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 策略配置</span></span><br><span class="line">    <span class="type">bool</span> write_back_;</span><br><span class="line">    <span class="type">int</span> replacement_policy_;</span><br><span class="line">};</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>cache_simulator.cpp</span><a href="/blog/downloads/code/eda/memory/cache/cache_simulator.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cache_simulator.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line">CacheSimulator::<span class="built_in">CacheSimulator</span>(<span class="type">uint32_t</span> line_size, <span class="type">uint32_t</span> num_lines, <span class="type">uint32_t</span> num_ports) </span><br><span class="line">    : <span class="built_in">port_locks_</span>(num_ports), <span class="built_in">line_size_</span>(line_size) {</span><br><span class="line">    num_sets_ = num_lines; <span class="comment">// 简单实现，可扩展为组相联</span></span><br><span class="line">    cache_.<span class="built_in">resize</span>(num_sets_, std::<span class="built_in">vector</span>&lt;CacheLine&gt;(<span class="number">1</span>)); <span class="comment">// 直接映射</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CacheSimulator::process_request</span><span class="params">(<span class="type">const</span> PortRequest&amp; req)</span> </span>{</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(port_locks_[req.port_id])</span></span>;</span><br><span class="line">    <span class="built_in">access_cache</span>(req.port_id, req.addr, req.is_write, req.data_ptr, req.data_size);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CacheSimulator::access_cache</span><span class="params">(<span class="type">uint32_t</span> port_id, <span class="type">uint32_t</span> addr, <span class="type">bool</span> is_write, </span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">uint8_t</span>* data, <span class="type">size_t</span> size)</span> </span>{</span><br><span class="line">    <span class="type">uint32_t</span> tag = addr / line_size_;</span><br><span class="line">    <span class="type">uint32_t</span> set_idx = tag % num_sets_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找命中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; line : cache_[set_idx]) {</span><br><span class="line">        <span class="keyword">if</span> (line.valid &amp;&amp; line.tag == tag) {</span><br><span class="line">            line.last_used = ++global_counter_;</span><br><span class="line">            <span class="keyword">if</span> (is_write) {</span><br><span class="line">                <span class="built_in">memcpy</span>(line.data.<span class="built_in">data</span>(), data, size);</span><br><span class="line">                line.dirty = <span class="literal">true</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="built_in">memcpy</span>(data, line.data.<span class="built_in">data</span>(), size);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 未命中处理</span></span><br><span class="line">    <span class="built_in">handle_miss</span>(port_id, addr);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CacheSimulator::handle_miss</span><span class="params">(<span class="type">uint32_t</span> port_id, <span class="type">uint32_t</span> addr)</span> </span>{</span><br><span class="line">    <span class="type">uint32_t</span> tag = addr / line_size_;</span><br><span class="line">    <span class="type">uint32_t</span> set_idx = tag % num_sets_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找可替换行</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; lines = cache_[set_idx];</span><br><span class="line">    <span class="keyword">auto</span> victim = std::<span class="built_in">min_element</span>(lines.<span class="built_in">begin</span>(), lines.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="type">const</span> CacheLine&amp; a, <span class="type">const</span> CacheLine&amp; b) {</span><br><span class="line">            <span class="keyword">return</span> a.last_used &lt; b.last_used; <span class="comment">// LRU策略</span></span><br><span class="line">        });</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写回脏数据</span></span><br><span class="line">    <span class="keyword">if</span> (write_back_ &amp;&amp; victim-&gt;dirty) {</span><br><span class="line">        <span class="comment">// 模拟写回主存操作</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载新数据</span></span><br><span class="line">    victim-&gt;valid = <span class="literal">true</span>;</span><br><span class="line">    victim-&gt;tag = tag;</span><br><span class="line">    victim-&gt;dirty = <span class="literal">false</span>;</span><br><span class="line">    victim-&gt;last_used = ++global_counter_;</span><br><span class="line">    <span class="comment">// 模拟从主存加载数据</span></span><br><span class="line">    victim-&gt;data.<span class="built_in">resize</span>(line_size_);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>main.cpp</span><a href="/blog/downloads/code/eda/memory/cache/main.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cache_simulator.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">port_thread</span><span class="params">(CacheSimulator&amp; cache, <span class="type">uint32_t</span> port_id)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) {</span><br><span class="line">        PortRequest req;</span><br><span class="line">        req.port_id = port_id;</span><br><span class="line">        req.is_write = (i % <span class="number">3</span> == <span class="number">0</span>);</span><br><span class="line">        req.addr = <span class="built_in">rand</span>() % <span class="number">0xFFFF</span>;</span><br><span class="line">        <span class="type">uint8_t</span> data[<span class="number">64</span>] = {<span class="number">0</span>};</span><br><span class="line">        req.data_ptr = data;</span><br><span class="line">        req.data_size = <span class="built_in">sizeof</span>(data);</span><br><span class="line">        </span><br><span class="line">        cache.<span class="built_in">process_request</span>(req);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">CacheSimulator <span class="title">cache</span><span class="params">(<span class="number">64</span>, <span class="number">1024</span>, <span class="number">4</span>)</span></span>; <span class="comment">// 64B行, 1024行, 4端口</span></span><br><span class="line">    </span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) {</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(port_thread, std::<span class="built_in">ref</span>(cache), i);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) {</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Cache simulation completed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>Makefile</span><a href="/blog/downloads/code/eda/memory/cache/Makefile">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 编译器配置</span><br><span class="line">CXX := g++</span><br><span class="line">CXXFLAGS := -std=c++<span class="number">17</span> -Wall -Wextra -O3 -pthread</span><br><span class="line">LDFLAGS := -pthread</span><br><span class="line"></span><br><span class="line"># 项目结构</span><br><span class="line">SRC_DIR := .</span><br><span class="line">BUILD_DIR := build</span><br><span class="line">TARGET := $(BUILD_DIR)/cache_simulator</span><br><span class="line"></span><br><span class="line"># 源文件列表</span><br><span class="line">SRCS := $(wildcard $(SRC_DIR)<span class="comment">/*.cpp)</span></span><br><span class="line"><span class="comment">OBJS := $(patsubst $(SRC_DIR)/%.cpp,$(BUILD_DIR)/%.o,$(SRCS))</span></span><br><span class="line"><span class="comment">DEPS := $(OBJS:.o=.d)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 默认目标</span></span><br><span class="line"><span class="comment">all: $(BUILD_DIR) $(TARGET)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 创建构建目录</span></span><br><span class="line"><span class="comment">$(BUILD_DIR):</span></span><br><span class="line"><span class="comment">	mkdir -p $(BUILD_DIR)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 主目标链接</span></span><br><span class="line"><span class="comment">$(TARGET): $(OBJS)</span></span><br><span class="line"><span class="comment">	$(CXX) $(LDFLAGS) $^ -o $@</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 编译规则</span></span><br><span class="line"><span class="comment">$(BUILD_DIR)/%.o: $(SRC_DIR)/%.cpp</span></span><br><span class="line"><span class="comment">	$(CXX) $(CXXFLAGS) -MMD -c $&lt; -o $@</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 包含依赖关系</span></span><br><span class="line"><span class="comment">-include $(DEPS)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 清理</span></span><br><span class="line"><span class="comment">clean:</span></span><br><span class="line"><span class="comment">	rm -rf $(BUILD_DIR)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">.PHONY: all clean</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/19/concurrency/TBB%E5%85%B8%E5%9E%8B%E5%9C%BA%E6%99%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/19/concurrency/TBB%E5%85%B8%E5%9E%8B%E5%9C%BA%E6%99%AF/" class="post-title-link" itemprop="url">TBB典型场景</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-19 22:48:38" itemprop="dateCreated datePublished" datetime="2025-08-19T22:48:38+00:00">2025-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-23 14:39:34" itemprop="dateModified" datetime="2025-09-23T14:39:34+00:00">2025-09-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="IO-CPU-密集-IO"><a href="#IO-CPU-密集-IO" class="headerlink" title="IO + CPU 密集 + IO"></a>IO + CPU 密集 + IO</h2><p>tasks</p>
<figure class="highlight cpp"><figcaption><span>tasks.hpp</span><a href="/blog/downloads/code/tbb/pipeline/tasks.hpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟 IO 和 CPU 任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataChunk</span> {</span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; data;</span><br><span class="line">    <span class="built_in">DataChunk</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">DataChunk</span><span class="params">(<span class="type">size_t</span> size)</span> : data(size) {</span>}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CompressedChunk</span> {</span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; data;</span><br><span class="line">    <span class="built_in">CompressedChunk</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CompressedChunk</span><span class="params">(<span class="type">size_t</span> size)</span> : data(size) {</span>}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟数据读取函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">read_from_network</span><span class="params">(DataChunk&amp; chunk)</span> </span>{</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);  <span class="comment">// 模拟 IO 延迟</span></span><br><span class="line"></span><br><span class="line">    chunk.data.<span class="built_in">resize</span>(<span class="number">100</span>);  <span class="comment">// 模拟每个数据块有 100 个字节</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (count++ &gt;= <span class="number">10</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 模拟读取 10 个数据块后结束</span></span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">generate</span>(chunk.data.<span class="built_in">begin</span>(), chunk.data.<span class="built_in">end</span>(),</span><br><span class="line">                  []() { <span class="keyword">return</span> <span class="built_in">rand</span>() % <span class="number">256</span>; });</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟压缩函数</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">compress_byte</span><span class="params">(<span class="type">char</span> byte)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10&#x27;000ll</span>; ++i)</span><br><span class="line">        ;               <span class="comment">// 模拟 CPU busy</span></span><br><span class="line">    <span class="keyword">return</span> byte % <span class="number">128</span>;  <span class="comment">// 简单压缩算法示例</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟写入函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_to_file</span><span class="params">(<span class="type">const</span> CompressedChunk&amp; chunk)</span> </span>{</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);  <span class="comment">// 模拟 IO 延迟</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Writing chunk of size &quot;</span> &lt;&lt; chunk.data.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>方案一</p>
<figure class="highlight cpp"><figcaption><span>1_message_queue.cpp</span><a href="/blog/downloads/code/tbb/pipeline/1_message_queue.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方案 1：异步队列 + TBB 流水线</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/tbb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tasks.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局队列</span></span><br><span class="line">std::queue&lt;std::vector&lt;<span class="type">char</span>&gt;&gt; readQueue;</span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::atomic_bool stop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">networkReader</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (!stop) {</span><br><span class="line">        DataChunk chunk;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">read_from_network</span>(chunk))  <span class="comment">// 阻塞 I/O</span></span><br><span class="line">        {</span><br><span class="line">            stop.<span class="built_in">store</span>(<span class="literal">true</span>, memory_order::releaxed);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        {</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            readQueue.<span class="built_in">push</span>(std::<span class="built_in">move</span>(chunk.data));</span><br><span class="line">        }</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩任务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compressor</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (!stop) {</span><br><span class="line">        DataChunk chunk;</span><br><span class="line">        {</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [] { <span class="keyword">return</span> !readQueue.<span class="built_in">empty</span>(); });</span><br><span class="line">            chunk.data = std::<span class="built_in">move</span>(readQueue.<span class="built_in">front</span>());</span><br><span class="line">            readQueue.<span class="built_in">pop</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CPU 密集计算，使用 TBB 并行</span></span><br><span class="line">        <span class="function">CompressedChunk <span class="title">compressed</span><span class="params">(chunk.data.size())</span></span>;</span><br><span class="line">        tbb::<span class="built_in">parallel_for</span>(<span class="built_in">size_t</span>(<span class="number">0</span>), chunk.data.<span class="built_in">size</span>(), [&amp;](<span class="type">size_t</span> i) {</span><br><span class="line">            compressed.data[i] = <span class="built_in">compress_byte</span>(chunk.data[i]);  <span class="comment">// 假设单字节压缩</span></span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="built_in">write_to_file</span>(compressed);  <span class="comment">// 可以异步</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::thread <span class="title">reader</span><span class="params">(networkReader)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(compressor)</span></span>;</span><br><span class="line"></span><br><span class="line">    reader.<span class="built_in">join</span>();</span><br><span class="line">    worker.<span class="built_in">join</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>方案二</p>
<figure class="highlight cpp"><figcaption><span>2_flow_graph.cpp</span><a href="/blog/downloads/code/tbb/pipeline/2_flow_graph.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方案 2：TBB Flow Graph</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/flow_graph.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/tbb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tasks.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tbb;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tbb::flow;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    graph g;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 读取节点（串行）</span></span><br><span class="line">    <span class="function">input_node&lt;DataChunk&gt; <span class="title">reader</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        g,</span></span></span><br><span class="line"><span class="params"><span class="function">        [](flow_control&amp; fc) -&gt; DataChunk {</span></span></span><br><span class="line"><span class="params"><span class="function">            DataChunk chunk(<span class="number">1024</span>);  <span class="comment">// 1KB数据块</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (!read_from_network(chunk)) {</span></span></span><br><span class="line"><span class="params"><span class="function">                fc.stop();</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">return</span> DataChunk();</span></span></span><br><span class="line"><span class="params"><span class="function">            }</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">return</span> chunk;</span></span></span><br><span class="line"><span class="params"><span class="function">        })</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 并行处理节点（无限制并发）</span></span><br><span class="line">    <span class="function">function_node&lt;DataChunk, CompressedChunk&gt; <span class="title">processor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        g, unlimited,</span></span></span><br><span class="line"><span class="params"><span class="function">        [](<span class="type">const</span> DataChunk&amp; input) -&gt; CompressedChunk {</span></span></span><br><span class="line"><span class="params"><span class="function">            CompressedChunk output(input.data.size());</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            tbb::parallel_for(</span></span></span><br><span class="line"><span class="params"><span class="function">                tbb::blocked_range&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>, input.data.size()),</span></span></span><br><span class="line"><span class="params"><span class="function">                [&amp;](<span class="type">const</span> tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r) {</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">for</span> (<span class="type">size_t</span> i = r.begin(); i != r.end(); ++i) {</span></span></span><br><span class="line"><span class="params"><span class="function">                        output.data[i] = compress_byte(input.data[i]);</span></span></span><br><span class="line"><span class="params"><span class="function">                    }</span></span></span><br><span class="line"><span class="params"><span class="function">                });</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">return</span> output;</span></span></span><br><span class="line"><span class="params"><span class="function">        })</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 写入节点（串行保证写入顺序）</span></span><br><span class="line">    <span class="function">function_node&lt;CompressedChunk&gt; <span class="title">writer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        g, serial,</span></span></span><br><span class="line"><span class="params"><span class="function">        [](<span class="type">const</span> CompressedChunk&amp; output) {</span></span></span><br><span class="line"><span class="params"><span class="function">            write_to_file(output);</span></span></span><br><span class="line"><span class="params"><span class="function">        })</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建数据流管道</span></span><br><span class="line">    <span class="built_in">make_edge</span>(reader, processor);</span><br><span class="line">    <span class="built_in">make_edge</span>(processor, writer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动管道</span></span><br><span class="line">    reader.<span class="built_in">activate</span>();</span><br><span class="line">    g.<span class="built_in">wait_for_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>方案三</p>
<figure class="highlight cpp"><figcaption><span>3_pipeline.cpp</span><a href="/blog/downloads/code/tbb/pipeline/3_pipeline.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方案 3: TBB 流水线</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/tbb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tasks.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    tbb::<span class="built_in">parallel_pipeline</span>(</span><br><span class="line">        <span class="comment">/* max_number_of_live_token */</span> <span class="number">4</span>,</span><br><span class="line">        <span class="comment">// Stage 1: 读网络数据</span></span><br><span class="line">        tbb::<span class="built_in">make_filter</span>&lt;<span class="type">void</span>, DataChunk&gt;(</span><br><span class="line">            tbb::filter_mode::serial_in_order,</span><br><span class="line">            [](tbb::flow_control&amp; fc) -&gt; DataChunk {</span><br><span class="line">                DataChunk chunk;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">read_from_network</span>(chunk)) {  <span class="comment">// 返回 false 时结束</span></span><br><span class="line">                    fc.<span class="built_in">stop</span>();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> chunk;</span><br><span class="line">            }) &amp;</span><br><span class="line">            <span class="comment">// Stage 2: CPU 压缩</span></span><br><span class="line">            tbb::<span class="built_in">make_filter</span>&lt;DataChunk, CompressedChunk&gt;(</span><br><span class="line">                tbb::filter_mode::parallel,</span><br><span class="line">                [](DataChunk chunk) -&gt; CompressedChunk {</span><br><span class="line">                    CompressedChunk <span class="built_in">out</span>(chunk.data.<span class="built_in">size</span>());</span><br><span class="line">                    tbb::<span class="built_in">parallel_for</span>(<span class="built_in">size_t</span>(<span class="number">0</span>), chunk.data.<span class="built_in">size</span>(), [&amp;](<span class="type">size_t</span> i) {</span><br><span class="line">                        out.data[i] = <span class="built_in">compress_byte</span>(chunk.data[i]);</span><br><span class="line">                    });</span><br><span class="line">                    <span class="keyword">return</span> out;</span><br><span class="line">                }) &amp;</span><br><span class="line">            <span class="comment">// Stage 3: 写文件</span></span><br><span class="line">            tbb::<span class="built_in">make_filter</span>&lt;CompressedChunk, <span class="type">void</span>&gt;(</span><br><span class="line">                tbb::filter_mode::serial_in_order,</span><br><span class="line">                [](CompressedChunk out) {</span><br><span class="line">                    <span class="built_in">write_to_file</span>(out);  <span class="comment">// 可以异步</span></span><br><span class="line">                }));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/19/net/%E5%BC%82%E6%AD%A5IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/19/net/%E5%BC%82%E6%AD%A5IO/" class="post-title-link" itemprop="url">异步IO</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-19 20:26:00" itemprop="dateCreated datePublished" datetime="2025-08-19T20:26:00+00:00">2025-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-23 14:39:34" itemprop="dateModified" datetime="2025-09-23T14:39:34+00:00">2025-09-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="IO模型概念"><a href="#IO模型概念" class="headerlink" title="IO模型概念"></a>IO模型概念</h2><p>IO 模型通常按两条维度划分：</p>
<ol>
<li><p>阻塞 vs 非阻塞</p>
<ul>
<li>阻塞 IO（Blocking IO）：调用 read&#x2F;recv 等函数时，如果数据没准备好，进程会被挂起，直到数据就绪。</li>
<li>非阻塞 IO（Non-blocking IO）：调用 read&#x2F;recv 时，如果数据没准备好，直接返回 EAGAIN 或 EWOULDBLOCK，进程继续做别的事情。</li>
</ul>
</li>
<li><p>同步 vs 异步</p>
<ul>
<li><p>同步（Synchronous）：调用者要等待操作完成才能继续。</p>
<ul>
<li>阻塞 IO + 同步：最常见，比如普通 read(fd, buf, n)</li>
<li>非阻塞 IO + 同步：调用立即返回，如果没数据则报错或返回 0</li>
</ul>
</li>
<li><p>异步（Asynchronous）：调用者发起操作后，不需要等待，操作完成时通过回调、信号、事件通知等告知结果。</p>
</li>
</ul>
</li>
</ol>
<p>⚡ 关键：异步 IO 的核心是不阻塞当前线程，而结果通知是通过事件或回调完成的。</p>
<h2 id="Linux-常见异步-IO-方式"><a href="#Linux-常见异步-IO-方式" class="headerlink" title="Linux 常见异步 IO 方式"></a>Linux 常见异步 IO 方式</h2><p>Linux 下主要有四种机制：</p>
<ol>
<li><p>POSIX AIO（aio_* 系列）</p>
<ul>
<li><p>系统调用：aio_read(), aio_write()</p>
</li>
<li><p>完成通知方式：</p>
<ul>
<li>轮询 aio_error()</li>
<li>信号通知 SIGIO</li>
<li>回调函数 sigevent.sigev_notify &#x3D; SIGEV_THREAD</li>
</ul>
</li>
<li><p>使用场景：文件 IO，可以在后台发起读写请求，主线程继续工作。</p>
</li>
<li><p>⚠️ 目前性能不如 epoll + 线程池模拟异步。</p>
</li>
</ul>
</li>
<li><p>信号驱动 IO（SIGIO）</p>
<ul>
<li>进程或文件描述符注册 F_SETOWN，开启 O_ASYNC</li>
<li>当 fd 可读写时，内核发信号给进程</li>
<li>通常用于少量 fd 的异步事件</li>
</ul>
</li>
<li><p>I&#x2F;O 多路复用（select, poll, epoll）</p>
<ul>
<li><p>本质是非阻塞 + 事件通知</p>
</li>
<li><p>Epoll + 非阻塞 IO 可以模拟高效的异步 IO</p>
</li>
<li><p>适合网络服务器、socket 编程</p>
</li>
<li><p>典型流程：</p>
<ul>
<li>设置 fd 为非阻塞（否则 read&#x2F;write 可能阻塞，因为 epoll 本质是同步的）</li>
<li>注册 fd 到 epoll，关注 EPOLLIN &#x2F; EPOLLOUT</li>
<li>调用 epoll_wait 等待事件</li>
<li>事件触发时读取或写入数据</li>
</ul>
</li>
</ul>
</li>
<li><p>Linux AIO（io_uring）</p>
<ul>
<li>新一代高性能异步 IO 接口</li>
<li>支持文件、网络 IO</li>
<li>提供 提交队列 + 完成队列，几乎零系统调用开销</li>
<li>可以真正做到线程几乎不阻塞等待</li>
</ul>
</li>
</ol>
<h3 id="异步-IO-的优点"><a href="#异步-IO-的优点" class="headerlink" title="异步 IO 的优点"></a>异步 IO 的优点</h3><ul>
<li>不阻塞主线程，提高吞吐量</li>
<li>可同时处理大量 IO（特别是网络&#x2F;文件服务器）</li>
<li>与多线程相比，降低线程上下文切换开销</li>
</ul>
<h3 id="异步-IO-的缺点"><a href="#异步-IO-的缺点" class="headerlink" title="异步 IO 的缺点"></a>异步 IO 的缺点</h3><ul>
<li>编程复杂度高（需要事件驱动、回调或状态机）</li>
<li>错误处理和信号安全问题复杂</li>
<li>文件异步 IO 性能在传统 AIO 下不一定比多线程高</li>
</ul>
<h3 id="Linux-下常见异步-I-O-机制对比"><a href="#Linux-下常见异步-I-O-机制对比" class="headerlink" title="Linux 下常见异步 I&#x2F;O 机制对比"></a>Linux 下常见异步 I&#x2F;O 机制对比</h3><table>
<thead>
<tr>
<th>特性 &#x2F; 机制</th>
<th>POSIX AIO</th>
<th>epoll + 非阻塞 IO</th>
<th>io_uring</th>
<th>信号驱动 IO (SIGIO)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>类型</strong></td>
<td>异步文件 IO</td>
<td>多路复用 + 非阻塞网络 IO</td>
<td>高性能异步 IO</td>
<td>异步事件通知</td>
</tr>
<tr>
<td><strong>支持对象</strong></td>
<td>文件</td>
<td>文件描述符（socket、管道等）</td>
<td>文件 + 网络 + 其他 IO</td>
<td>文件描述符（socket、pipe）</td>
</tr>
<tr>
<td><strong>用户态&#x2F;内核态</strong></td>
<td>系统调用提交，内核异步处理</td>
<td>用户态轮询&#x2F;等待事件，内核检查 fd</td>
<td>用户态 SQ + 内核 CQ</td>
<td>用户注册 fd，内核通过信号通知</td>
</tr>
<tr>
<td><strong>提交方式</strong></td>
<td>aio_read&#x2F;aio_write</td>
<td>写入 fd 并通过 epoll_wait 检查</td>
<td>写入 SQ（批量可提交）</td>
<td>设置 O_ASYNC + F_SETOWN</td>
</tr>
<tr>
<td><strong>完成通知</strong></td>
<td>信号 &#x2F; 回调 &#x2F; aio_error轮询</td>
<td>epoll_wait 返回就绪事件</td>
<td>完成队列 (CQ)，阻塞或非阻塞读取</td>
<td>信号处理函数 (SIGIO)</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>中等，系统调用多</td>
<td>高，单线程处理大量 fd</td>
<td>很高，几乎零系统调用，批量提交</td>
<td>较低，信号开销大，适合少量 fd</td>
</tr>
<tr>
<td><strong>编程复杂度</strong></td>
<td>中等偏复杂</td>
<td>中等，需要状态机处理</td>
<td>高，但灵活，可批量和链式操作</td>
<td>高，信号处理函数限制多，必须信号安全</td>
</tr>
<tr>
<td><strong>适合场景</strong></td>
<td>文件异步读写</td>
<td>高并发网络服务器</td>
<td>高性能文件和网络 IO</td>
<td>少量异步事件或控制信号触发场景</td>
</tr>
</tbody></table>
<h2 id="Linux-io-uring"><a href="#Linux-io-uring" class="headerlink" title="Linux io_uring"></a>Linux io_uring</h2><p>io_uring 是 Linux 内核自 5.1 版本引入的一个异步 I&#x2F;O 框架，它提供了 低延迟、高吞吐的异步文件和网络 I&#x2F;O。它的特点是：</p>
<ul>
<li>零拷贝提交：应用程序可以直接向内核提交 I&#x2F;O 请求，无需系统调用每次阻塞。</li>
<li>环形队列机制：通过共享内存的 提交队列（Submission Queue, SQ） 和 完成队列（Completion Queue, CQ），用户态和内核态可以高效交互。</li>
<li>支持多种 I&#x2F;O 类型：文件读写、网络收发、文件同步、缓冲区操作等。</li>
<li>批量提交和完成：可以一次提交多个 I&#x2F;O 请求，并批量获取完成结果。</li>
</ul>
<p>简单理解：它把传统阻塞 I&#x2F;O 的 “系统调用来回” 改成了 共享环形队列 + 异步通知。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li>方法一：从 APT 安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install liburing-dev</span><br></pre></td></tr></table></figure>

<p>检查安装路径</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /usr/include/liburing.h</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>方法二：从源码安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/axboe/liburing.git</span><br><span class="line"><span class="built_in">cd</span> liburing</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h3 id="io-uring-的核心数据结构"><a href="#io-uring-的核心数据结构" class="headerlink" title="io_uring 的核心数据结构"></a>io_uring 的核心数据结构</h3><p>Submission Queue（SQ）</p>
<ul>
<li>用户态将 I&#x2F;O 请求放入 SQ。</li>
<li>SQ 是一个环形数组，存放 io_uring_sqe（I&#x2F;O 请求条目）。</li>
<li>用户通过 系统调用 io_uring_enter 将 SQ 中的新请求通知内核。</li>
<li>内核会按顺序处理 SQ 中的 I&#x2F;O 请求。</li>
</ul>
<table>
<thead>
<tr>
<th>字段</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>opcode</code></td>
<td>I&#x2F;O 类型，如读、写、fsync、accept、sendmsg</td>
</tr>
<tr>
<td><code>fd</code></td>
<td>文件描述符</td>
</tr>
<tr>
<td><code>off</code></td>
<td>偏移量（文件 I&#x2F;O）</td>
</tr>
<tr>
<td><code>addr</code></td>
<td>用户缓冲区地址</td>
</tr>
<tr>
<td><code>len</code></td>
<td>I&#x2F;O 数据长度</td>
</tr>
<tr>
<td><code>flags</code></td>
<td>请求标志，如 <code>IOSQE_FIXED_FILE</code>、<code>IOSQE_IO_LINK</code></td>
</tr>
</tbody></table>
<p>Completion Queue（CQ）</p>
<ul>
<li>内核完成 I&#x2F;O 后，将结果写入 CQ。</li>
<li>CQ 也是一个环形数组，存放 io_uring_cqe（完成条目）。</li>
<li>用户可以轮询或等待 CQ 获取完成结果。</li>
</ul>
<table>
<thead>
<tr>
<th>字段</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>res</code></td>
<td>I&#x2F;O 结果，成功为正数（读写字节数），失败为负错误码</td>
</tr>
<tr>
<td><code>user_data</code></td>
<td>用户自定义数据，方便识别请求</td>
</tr>
</tbody></table>
<h3 id="io-uring-工作流程"><a href="#io-uring-工作流程" class="headerlink" title="io_uring 工作流程"></a>io_uring 工作流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+-----------+          +-----------+</span><br><span class="line">| User App  | &lt;-----&gt;  |  Kernel  |</span><br><span class="line">+-----------+          +-----------+</span><br><span class="line">      |                     |</span><br><span class="line">      |  write SQE to SQ    | &lt;- Submission Queue</span><br><span class="line">      |--------------------&gt;|</span><br><span class="line">      |                     |</span><br><span class="line">      |   io_uring_enter    | &lt;- 通知内核处理</span><br><span class="line">      |--------------------&gt;|</span><br><span class="line">      |                     |</span><br><span class="line">      | &lt;------------------ | &lt;- CQE 放入 CQ</span><br><span class="line">      |  read CQE from CQ   |</span><br></pre></td></tr></table></figure>

<ul>
<li>用户态填充 SQE（Submission Queue Entry）。</li>
<li>调用 io_uring_enter() 提交 SQE （不阻塞）。</li>
<li>内核处理 I&#x2F;O 请求。</li>
<li>内核把完成结果写入 CQ。</li>
<li>用户态可以：<ul>
<li>轮询 CQ：主动读取 CQE（Completion Queue Entry）</li>
<li>注册回调（liburing 新版本支持 IORING_SETUP_IOPOLL + IORING_SETUP_SQPOLL 或自己封装）</li>
</ul>
</li>
</ul>
<p>注意：</p>
<ul>
<li>异步 I&#x2F;O ≠ 必须用回调。关键是提交后不阻塞等待，可以同步轮询完成结果，也可以异步触发回调。</li>
<li>回调是一种可选的使用方式。</li>
<li>最核心的是 共享环形队列 + 完成队列，用户可以同步取结果也可以异步通知。</li>
</ul>
<h3 id="为什么-io-uring-没有强制回调"><a href="#为什么-io-uring-没有强制回调" class="headerlink" title="为什么 io_uring 没有强制回调"></a>为什么 io_uring 没有强制回调</h3><p>传统异步 I&#x2F;O（比如 Windows IOCP）必须注册回调或事件句柄，因为内核不会给你“主动通知”。</p>
<p>Linux io_uring 的设计哲学是：</p>
<ul>
<li>用户态和内核共享内存 → 用户态可以自己轮询完成队列。</li>
<li>减少系统调用次数 → 不依赖信号或回调触发。</li>
<li>需要回调时，用户可以自己封装一个事件循环。</li>
</ul>
<p>所以你看到 io_uring 的官方示例都是 顺序写代码，但是仍然是异步 I&#x2F;O，因为：</p>
<ul>
<li>提交后内核可以并行处理多个 I&#x2F;O。</li>
<li>用户态无需阻塞等待内核完成处理（可以去做别的事）。</li>
</ul>
<h3 id="io-uring-的使用示例（C-语言）"><a href="#io-uring-的使用示例（C-语言）" class="headerlink" title="io_uring 的使用示例（C 语言）"></a>io_uring 的使用示例（C 语言）</h3><figure class="highlight cpp"><figcaption><span>io_uring_hello.c</span><a href="/blog/downloads/code/io/io_uring_hello.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;liburing.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE_DEPTH  8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE  1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">io_uring</span> ring;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">io_uring_sqe</span> *sqe;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">io_uring_cqe</span> *cqe;</span><br><span class="line">    <span class="type">int</span> ret, fd;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 io_uring</span></span><br><span class="line">    ret = <span class="built_in">io_uring_queue_init</span>(QUEUE_DEPTH, &amp;ring, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;io_uring_queue_init&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取提交队列条目</span></span><br><span class="line">    sqe = <span class="built_in">io_uring_get_sqe</span>(&amp;ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) {</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;io_uring_get_sqe failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备读取操作</span></span><br><span class="line">    <span class="built_in">io_uring_prep_read</span>(sqe, fd, buf, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交到内核</span></span><br><span class="line">    ret = <span class="built_in">io_uring_submit</span>(&amp;ring);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;io_uring_submit&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待完成</span></span><br><span class="line">    ret = <span class="built_in">io_uring_wait_cqe</span>(&amp;ring, &amp;cqe);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;io_uring_wait_cqe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取结果</span></span><br><span class="line">    <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Async read failed: %d\n&quot;</span>, cqe-&gt;res);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read %d bytes: %.*s\n&quot;</span>, cqe-&gt;res, cqe-&gt;res, buf);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知内核完成</span></span><br><span class="line">    <span class="built_in">io_uring_cqe_seen</span>(&amp;ring, cqe);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    <span class="built_in">io_uring_queue_exit</span>(&amp;ring);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>这个例子展示了 最基本的异步文件读取：</p>
<ul>
<li>初始化 ring。</li>
<li>获取一个 SQE 并填充读请求。</li>
<li>提交 SQE。</li>
<li>等待 CQE 获取结果。</li>
<li>标记完成并清理。</li>
</ul>
<h2 id="Boost-asio"><a href="#Boost-asio" class="headerlink" title="Boost asio"></a>Boost asio</h2><p>要区分 操作系统级别的异步 I&#x2F;O 和 asio 的抽象，因为 asio 并不是单一机制，而是根据平台选择最优实现。具体分析如下：</p>
<h3 id="asio-的工作原理"><a href="#asio-的工作原理" class="headerlink" title="asio 的工作原理"></a>asio 的工作原理</h3><p>asio 提供 异步接口（async_read, async_write 等），程序不会阻塞线程</p>
<p>内部实现方式根据平台不同而不同：</p>
<table>
<thead>
<tr>
<th>平台</th>
<th>异步方式</th>
</tr>
</thead>
<tbody><tr>
<td>Linux</td>
<td>基于 <strong>epoll &#x2F; io_uring &#x2F; AIO</strong>，是真正的内核异步 I&#x2F;O（零拷贝，内核通知完成）</td>
</tr>
<tr>
<td>Windows</td>
<td>基于 <strong>IOCP</strong>（I&#x2F;O Completion Ports），内核异步 I&#x2F;O</td>
</tr>
<tr>
<td>Mac &#x2F; BSD</td>
<td>基于 <strong>kqueue &#x2F; poll</strong>，有些情况下是模拟异步（多线程或事件轮询）</td>
</tr>
</tbody></table>
<p>要确认 asio 在你的 Linux 机器上选择了哪种底层 I&#x2F;O 机制，可以按下面几个方法操作：</p>
<ol>
<li>查看 asio 使用的 I&#x2F;O 对象</li>
</ol>
<p>asio 有两个主要 I&#x2F;O 后端：</p>
<ul>
<li>旧版 AIO &#x2F; epoll（select_reactor &#x2F; epoll_reactor）</li>
<li>io_uring（在新版本 Boost.Asio 或 standalone Asio 支持）</li>
</ul>
<p>在 编译时，asio 会检测系统特性：</p>
<ul>
<li>如果 Linux 内核 ≥ 5.1，asio 默认启用 io_uring</li>
<li>否则使用 epoll</li>
</ul>
<ol start="2">
<li>通过宏或配置查看</li>
</ol>
<p>在你的 asio 头文件中，可能有如下宏：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(BOOST_ASIO_HAS_IOURING)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;asio will use io_uring\n&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(BOOST_ASIO_HAS_EPOLL)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;asio will use epoll\n&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这些宏在 boost&#x2F;asio&#x2F;detail&#x2F;config.hpp 或 asio&#x2F;config.hpp 中定义，表示底层机制。</p>
<ol start="3">
<li>运行时确认</li>
</ol>
<p>asio 本身没有公开 API 显示底层 I&#x2F;O 类型，但可以通过系统调用监控判断：</p>
<p>使用 strace 观察程序 I&#x2F;O：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -f ./your_program 2&gt;&amp;1 | grep io_uring</span><br></pre></td></tr></table></figure>

<ul>
<li>如果看到 io_uring_setup、io_uring_enter 系统调用，就说明启用了 io_uring</li>
<li>如果没有，只看到 epoll_wait &#x2F; epoll_ctl，说明使用的是 epoll</li>
</ul>
<p>对 epoll，strace 会显示 epoll_create1 &#x2F; epoll_ctl &#x2F; epoll_wait</p>
<h3 id="阻塞-vs-异步"><a href="#阻塞-vs-异步" class="headerlink" title="阻塞 vs 异步"></a>阻塞 vs 异步</h3><table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>asio 中的表现</th>
</tr>
</thead>
<tbody><tr>
<td>阻塞 I&#x2F;O</td>
<td>调用时线程被挂起，等待 I&#x2F;O 完成</td>
<td>不使用，线程会被阻塞，TBB 线程占用</td>
</tr>
<tr>
<td>模拟异步</td>
<td>内核不支持真正异步，用线程轮询或线程池实现</td>
<td>Mac&#x2F;BSD 某些场景下可能是模拟</td>
</tr>
<tr>
<td>真正异步 I&#x2F;O</td>
<td>内核支持，操作提交后立即返回，完成由内核通知</td>
<td>Linux&#x2F;io_uring、Windows IOCP 就是真正异步</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/19/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/19/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-19 20:12:58" itemprop="dateCreated datePublished" datetime="2025-08-19T20:12:58+00:00">2025-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-23 14:39:34" itemprop="dateModified" datetime="2025-09-23T14:39:34+00:00">2025-09-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><p>malloc 是线程安全的，但有一些细节需要注意。</p>
<ol>
<li>线程安全含义</li>
</ol>
<p>线程安全：多个线程同时调用 malloc&#x2F;free 不会破坏堆管理结构，也不会导致内存管理崩溃。</p>
<p>实现方法：</p>
<p>glibc malloc 在内部使用 锁（mutex 或 spinlock） 保护全局堆管理数据结构</p>
<p>不同线程同时申请或释放内存，内核保证堆表一致</p>
<ol start="2">
<li>限制与注意事项</li>
</ol>
<p>性能问题</p>
<p>多线程频繁 malloc&#x2F;free，锁竞争可能成为瓶颈</p>
<p>对性能敏感的程序可能使用：</p>
<p>线程本地缓存（thread-local cache） 的 jemalloc &#x2F; tcmalloc</p>
<p>避免全局锁竞争</p>
<p>信号处理上下文不安全</p>
<p>虽然线程安全，但 malloc 在信号处理函数里不安全</p>
<p>原因：</p>
<p>信号可能打断正在执行的 malloc</p>
<p>malloc 内部锁可能被持有 → 再次调用可能死锁</p>
<p>所以 signal handler 中不能直接调用 malloc&#x2F;free</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>malloc&#x2F;glibc</th>
</tr>
</thead>
<tbody><tr>
<td>多线程调用安全</td>
<td>✅ 是线程安全的</td>
</tr>
<tr>
<td>信号处理函数调用安全</td>
<td>❌ 不安全</td>
</tr>
<tr>
<td>性能</td>
<td>可能锁竞争，需要优化（jemalloc&#x2F;tcmalloc）</td>
</tr>
</tbody></table>
<h2 id="信号安全"><a href="#信号安全" class="headerlink" title="信号安全"></a>信号安全</h2><p>malloc &#x2F; free 内部会修改全局堆管理结构（如 free list）</p>
<p>如果信号到达时主程序正在调用 malloc 或 free，信号处理函数里再次调用 malloc&#x2F;free → 堆数据结构可能被破坏，<br>可能导致崩溃或内存泄漏</p>
<p>虽然线程安全，但 malloc 在信号处理函数里不安全</p>
<p>原因：</p>
<ul>
<li>信号可能打断正在执行的 malloc</li>
<li>malloc 内部锁可能被持有 → 再次调用可能死锁</li>
</ul>
<p>所以 signal handler 中不能直接调用 malloc&#x2F;free</p>
<h3 id="安全做法"><a href="#安全做法" class="headerlink" title="安全做法"></a>安全做法</h3><p>信号处理函数里只做：</p>
<ul>
<li>设置标志位（sig_atomic_t flag &#x3D; 1;）</li>
<li>写入 pipe &#x2F; eventfd</li>
<li>调用 async-signal-safe 系统调用（write(), _exit()）</li>
</ul>
<p>之后由主程序在安全上下文处理 malloc&#x2F;free 或其他复杂操作</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/19/os/%E4%BF%A1%E5%8F%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/19/os/%E4%BF%A1%E5%8F%B7/" class="post-title-link" itemprop="url">信号</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-19 20:08:39" itemprop="dateCreated datePublished" datetime="2025-08-19T20:08:39+00:00">2025-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-23 14:39:34" itemprop="dateModified" datetime="2025-09-23T14:39:34+00:00">2025-09-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="异步信号"><a href="#异步信号" class="headerlink" title="异步信号"></a>异步信号</h2><p>锁、malloc 等不能在信号处理函数里用。这里涉及到 异步信号安全 (async-signal-safe) 的概念。</p>
<ol>
<li>信号处理函数的执行环境</li>
</ol>
<p>当一个信号到达进程时，内核 异步中断当前执行流，立即跳转到信号处理函数执行。</p>
<p>这意味着：</p>
<p>当前线程可能 正在持有锁（mutex、spinlock 等）</p>
<p>当前线程可能 正在使用 malloc&#x2F;free，操作堆数据结构</p>
<ol start="2">
<li>为什么不能调用这些函数</li>
</ol>
<p>锁（mutex 等）</p>
<p>如果信号处理函数里调用 pthread_mutex_lock()：</p>
<p>线程可能已经在信号到达前持有这个锁</p>
<p>信号处理函数再次尝试加锁 → 死锁</p>
<p>malloc &#x2F; free</p>
<p>malloc 内部会修改全局堆管理结构（如 free list）</p>
<p>如果信号到达时主程序正在调用 malloc 或 free，信号处理函数里再次调用 malloc&#x2F;free → 堆数据结构可能被破坏</p>
<p>可能导致崩溃或内存泄漏</p>
<ol start="3">
<li>async-signal-safe 函数</li>
</ol>
<p>POSIX 定义了一组 “异步信号安全函数”（async-signal-safe functions）</p>
<p>信号处理函数中 只允许调用这些函数</p>
<p>常用安全函数示例：</p>
<p>_exit()</p>
<p>write()（低级系统调用，不会锁堆）</p>
<p>sig_atomic_t 类型变量赋值</p>
<p>总结</p>
<table>
<thead>
<tr>
<th>函数类型</th>
<th>可在信号处理函数里用？</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>pthread_mutex_lock</td>
<td>❌</td>
<td>可能已持锁 → 死锁</td>
</tr>
<tr>
<td>malloc&#x2F;free</td>
<td>❌</td>
<td>可能正在操作堆 → 数据结构破坏</td>
</tr>
<tr>
<td>write(fd, buf, n)</td>
<td>✅</td>
<td>系统调用，不会破坏用户态结构</td>
</tr>
<tr>
<td>_exit()</td>
<td>✅</td>
<td>安全终止进程</td>
</tr>
</tbody></table>
<blockquote>
<p>核心思想：信号是异步的，中断当前执行流，调用非 async-signal-safe 函数可能破坏正在执行的操作，导致不可预测的行为。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="page-number current">2</span><a class="page-number" href="/blog/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/11/">11</a><a class="extend next" rel="next" href="/blog/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="bi-an"
      src="/blog/images/avatar.gif">
  <p class="site-author-name" itemprop="name">bi-an</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">107</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/bi-an" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;bi-an" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ah_zzg@126.com" title="E-Mail → mailto:ah_zzg@126.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://cuda-doc.readthedocs.io/" title="https:&#x2F;&#x2F;cuda-doc.readthedocs.io" rel="noopener" target="_blank">CUDA中文手册</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://infiniband-doc.readthedocs.io/" title="https:&#x2F;&#x2F;infiniband-doc.readthedocs.io&#x2F;" rel="noopener" target="_blank">InfiniBand中文手册</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bi-an</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>




  




  
<script src="/blog/js/local-search.js"></script>













  

  

</body>
</html>
