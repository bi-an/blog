<!DOCTYPE html>
<html lang="en, zh_CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"bi-an.github.io","root":"/blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="江南人物的博客">
<meta property="og:url" content="https://bi-an.github.io/blog/page/2/index.html">
<meta property="og:site_name" content="江南人物的博客">
<meta property="og:locale">
<meta property="article:author" content="bi-an">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://bi-an.github.io/blog/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en, zh_CN'
  };
</script>

  <title>江南人物的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">江南人物的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-resource">

    <a href="/blog/resources/" rel="section"><i class="fa fa-paperclip fa-fw"></i>Resource</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/19/concurrency/thread_local%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/19/concurrency/thread_local%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">thread_local的实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-19 19:41:37" itemprop="dateCreated datePublished" datetime="2025-08-19T19:41:37+00:00">2025-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-04 17:56:31" itemprop="dateModified" datetime="2025-09-04T17:56:31+00:00">2025-09-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/c-cpp/" itemprop="url" rel="index"><span itemprop="name">c/cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>thread_local 的基本语义</li>
</ol>
<p>C++11 引入的存储类型说明符：</p>
<p>thread_local int x &#x3D; 0;</p>
<p>表示 每个线程都有一份独立的 x，互不干扰。</p>
<p>生命周期：跟普通静态变量类似（全局存活直到线程退出）。</p>
<ol start="2">
<li>底层实现原理</li>
</ol>
<p>它的实现依赖于 TLS (Thread Local Storage, 线程局部存储) 机制。</p>
<p>在 ELF&#x2F;Linux 下：</p>
<p>编译器在 .tdata &#x2F; .tbss 段里为 thread_local 变量分配空间（就像全局变量在 .data &#x2F; .bss 段里）。</p>
<p>程序加载时，动态链接器（ld.so）会记录这些 TLS 变量的“模板布局”。</p>
<p>每个线程启动时，线程库（glibc&#x2F;pthread）会：</p>
<p>给这个线程分配一块 TLS 块（通常放在线程栈附近，或者专门的内存页）。</p>
<p>把 .tdata 里的初始值拷贝到这个线程的 TLS 块。</p>
<p>.tbss 部分（未初始化的 thread_local）则清零。</p>
<p>线程访问 thread_local 时，编译器生成的代码会通过 TLS 寄存器（如 x86-64 的 FS&#x2F;GS 段寄存器）+ 偏移量，找到对应线程的存储单元。</p>
<p>例如 x86-64 Linux 上，errno 就是：</p>
<p>#define errno (*__errno_location())</p>
<p>而 __errno_location() 内部就是通过 %fs:offset 找到 TLS 块里的 errno。</p>
<ol start="3">
<li>存放在哪里？</li>
</ol>
<p>Windows：在 TEB (Thread Environment Block) 里有 TLS 指针，__declspec(thread) 就用它。</p>
<p>Linux&#x2F;ELF：在每个线程的 TLS 块里（通常分配在线程栈附近的一片内存区域）。访问通过 FS&#x2F;GS 寄存器。</p>
<p>编译器细节：</p>
<p>GCC&#x2F;Clang 默认用 “动态 TLS 模型”（访问时通过动态链接器查询 TLS 偏移）。</p>
<p>如果加 -ftls-model&#x3D;initial-exec，编译器会直接用固定偏移访问 TLS，速度更快（但要求变量在主程序或静态库里）。</p>
<ol start="4">
<li>示例</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        counter++;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;: counter = &quot;</span> &lt;&lt; counter &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(worker, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(worker, <span class="number">2</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出大致是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread 1: counter = 1</span><br><span class="line">Thread 1: counter = 2</span><br><span class="line">Thread 1: counter = 3</span><br><span class="line">Thread 2: counter = 1</span><br><span class="line">Thread 2: counter = 2</span><br><span class="line">Thread 2: counter = 3</span><br></pre></td></tr></table></figure>

<p>说明 counter 在不同线程里独立。</p>
<p>✅ 总结：</p>
<p>thread_local 变量放在 TLS 段，每个线程有自己的拷贝。</p>
<p>访问是通过 线程局部存储寄存器（FS&#x2F;GS）+ 偏移量 实现的。</p>
<p>存储空间由线程库在创建线程时分配和初始化。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/18/%E5%AE%9E%E7%94%A8%E4%B9%A6%E7%B1%8D%E5%88%97%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/18/%E5%AE%9E%E7%94%A8%E4%B9%A6%E7%B1%8D%E5%88%97%E8%A1%A8/" class="post-title-link" itemprop="url">实用书籍列表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-18 21:25:16" itemprop="dateCreated datePublished" datetime="2025-08-18T21:25:16+00:00">2025-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-04 17:56:31" itemprop="dateModified" datetime="2025-09-04T17:56:31+00:00">2025-09-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Misc/" itemprop="url" rel="index"><span itemprop="name">Misc</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>.<br>├── AT&amp;T Assembly Manual.pdf<br>├── C++ Primer Plus 第五版中文版.pdf<br>├── C++.Primer.5th.Edition_2013.pdf<br>├── CplusplusConcurrencyInAction_PracticalMultithreading.pdf<br>├── Debug Hacks中文版：深入调试的技术和工具.pdf<br>├── IB-Host-and-Ports.pdf<br>├── IBTA-Overview-of-IBTA-Volume-1-Release-1.6-2022-07-15.pdf<br>├── InifiniBand Guide.pdf<br>├── LDAP Authentication Guide.pdf<br>├── Linux Kernel Networking - Implementation and Theory.pdf<br>├── Linux-UNIX系统编程手册（上、下册）.pdf<br>├── Linux内核设计与实现(第三版中文高清带目录).pdf<br>├── Linux多线程服务端编程 - 陈硕.pdf<br>├── Linux多线程服务端编程：使用muduo C++网络库.pdf<br>├── Linux高性能服务器编程.pdf<br>├── OKTA Multifactor Authentication (MFA) FAQ.pdf<br>├── Shell脚本学习指南.pdf<br>├── TBB<br>│   ├── Intel TBB.pdf<br>│   ├── TBBtutorial.pdf<br>│   ├── intel-tbb.pdf<br>│   ├── oneTBB-master.zip<br>│   └── onetbb_developer-guide-api-reference_2021.6-772616-772617.pdf<br>├── UNIX环境高级编程(第三版).pdf<br>├── UNIX网络编程卷1：套接字联网API（第3版）.pdf<br>├── ccia_code_samples-master.zip<br>├── dmtcp<br>│   ├── Be Kind, Rewind —Checkpoint &amp; Restore Capability for Improving Reliability of Large-scale Semiconductor Design.pdf<br>│   ├── dmtcp-mug-17.pdf<br>│   └── plugin-tutorial.pdf<br>├── gdb-and-assembly.pdf<br>├── gdb-refcard.pdf<br>├── gdb.pdf<br>├── p4-p4v-cheat-sheet_cn.pdf<br>├── thread-analyzer-193426.pdf<br>├── 并行编程<br>│   ├── C++ Concurrency in Action.pdf<br>│   ├── C++-Concurrency-In-Action-2ed-zh-v0.2.pdf<br>│   ├── C++并发编程实战(中文版).pdf<br>│   ├── C++并发编程实战.pdf<br>│   ├── C++并发编程实战源代码<br>│   ├── C++并发编程实战源代码.zip<br>│   ├── Patterns_for_Parallel_Programming.pdf<br>│   └── 高并发网络模型.png<br>└── 编译原理(龙书) 第二版.pdf</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/17/misc/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/17/misc/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/" class="post-title-link" itemprop="url">如何创建个人主页</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-17 16:14:48" itemprop="dateCreated datePublished" datetime="2025-08-17T16:14:48+00:00">2025-08-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-04 17:56:31" itemprop="dateModified" datetime="2025-09-04T17:56:31+00:00">2025-09-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-Github-Pages"><a href="#1-Github-Pages" class="headerlink" title="1. Github Pages"></a>1. Github Pages</h1><p>本文解释利用<a target="_blank" rel="noopener" href="https://docs.github.com/en/pages">github pages</a>搭建个人主页&#x2F;项目主页的方法。</p>
<p>github pages简介：<a target="_blank" rel="noopener" href="https://docs.github.com/en/pages/getting-started-with-github-pages/about-github-pages">官方链接</a>。</p>
<p>github pages使用了<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/CNAME_record">CNAME record</a>技术，参考：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/39301250">链接1</a>、<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/26609475">链接2</a>、<a target="_blank" rel="noopener" href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/about-custom-domains-and-github-pages#using-a-subdomain-for-your-github-pages-site">Custom domains in Github Pages</a>。</p>
<p>注：<a target="_blank" rel="noopener" href="https://readthedocs.org/">Read the Docs</a>也是一个很好的搭建个人主页的网站。</p>
<h2 id="Github-Pages-站点类型"><a href="#Github-Pages-站点类型" class="headerlink" title="Github Pages 站点类型"></a>Github Pages 站点类型</h2><p>有3种类型的 Github Pages 站点（sites）：project, user 和 organization 。</p>
<p>Project sites 连接到 github 上特定 project ，比如 Javascript library 或 recipe collection。user 或 organization sites 连接到 github.com 的特定账户。</p>
<p>发布 user site ，你必须创建一个你的个人账户下的一个名为 <code>&lt;username&gt;.github.io</code> 的 repository 。发布 organization site ，你必须创建一个组织所有的名为 <code>&lt;organization&gt;.github.io</code> 的 repository 。除非你使用 custom domain ，否则 user 和 organization sites 将位于 <code>http(s)://&lt;username&gt;.github.io</code> 或 <code>http(s)://&lt;organization&gt;.github.io</code> 。</p>
<p>project site 的源文件存储在作为 project 的相同的 repository 中。除非使用 custom domain ， 否则 project sites 将位于 <code>http(s)://&lt;username&gt;.github.io/&lt;repository&gt;</code> 或 <code>http(s)://&lt;organization&gt;.github.io/&lt;repository&gt;</code> 。</p>
<p>有关如何自定义影响您网站的域名的更多信息，参见”<a target="_blank" rel="noopener" href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/about-custom-domains-and-github-pages">About custom domains and GitHub Pages</a>“。</p>
<p>每个 github 账户允许创建 1 个 user 或 organization 站点。无论是被组织还是个人所有，project 站点的个数不限制。</p>
<h2 id="GitHub-Pages-访问方法"><a href="#GitHub-Pages-访问方法" class="headerlink" title="GitHub Pages 访问方法"></a>GitHub Pages 访问方法</h2><p>参考<a target="_blank" rel="noopener" href="https://docs.github.com/en/pages/getting-started-with-github-pages/creating-a-github-pages-site#next-steps">官方文档</a>。</p>
<p>例如，你的project站点配置的发布源是<code>gh-pages</code>分支，然后在<code>gh-pages</code>分支上创建了一个<code>about/contact-us.md</code>文件，你将可以在<code>https://&lt;user&gt;.github.io/&lt;repository&gt;/about/contact-us.html</code>访问它。</p>
<p>你也可以使用<code>Jekyll</code>等静态站点生成器来给你的github page配置一个主题。</p>
<h2 id="站点发布常见问题的解决方法"><a href="#站点发布常见问题的解决方法" class="headerlink" title="站点发布常见问题的解决方法"></a>站点发布常见问题的解决方法</h2><ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/72851548/permission-denied-to-github-actionsbot">Permission denied to github-actions[bot]</a></li>
</ul>
<h2 id="Github-workflows"><a href="#Github-workflows" class="headerlink" title="Github workflows"></a>Github workflows</h2><p>参考<a target="_blank" rel="noopener" href="https://docs.github.com/zh/actions/using-workflows/workflow-syntax-for-github-actions">官方文档</a>。</p>
<h1 id="2-配置前准备"><a href="#2-配置前准备" class="headerlink" title="2. 配置前准备"></a>2. 配置前准备</h1><h2 id="2-1-Markdown编辑器"><a href="#2-1-Markdown编辑器" class="headerlink" title="2.1. Markdown编辑器"></a>2.1. Markdown编辑器</h2><p>推荐的<a target="_blank" rel="noopener" href="https://www.zhihu.com/tardis/zm/art/103348449?source_id=1003">markdown编辑器</a>：</p>
<ul>
<li>VSCode：免费。VSCode原生支持Markdown，安装一些插件可以帮助更快地编写markdown文件。</li>
<li>Typora：现在已经开始收费。</li>
</ul>
<p>VSCode markdown插件：</p>
<ul>
<li>Mardown All in One: 提供快捷键，帮助更快的编写markdown文件。</li>
<li>Markdown+Math：提供数学公式支持。</li>
<li>Markdown Preview Enhanced: 将原生markdown预览的黑色背景改成白色。</li>
<li>Markdown Preview Github Styling：提供Github风格的预览。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.tablesgenerator.com/markdown_tables">在线表格生成器</a>：可以生成Markdown、Text、HTML、LaTex、MediaWiki格式的表格。</p>
<h2 id="2-2-轻量级虚拟机WSL"><a href="#2-2-轻量级虚拟机WSL" class="headerlink" title="2.2. 轻量级虚拟机WSL"></a>2.2. 轻量级虚拟机WSL</h2><p>WSL，<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/wsl/install">Windows Subsystem for Linux</a>，是Windows提供的轻量级Linux虚拟机。</p>
<p>安装教程：见<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/170210673">链接</a>。</p>
<h3 id="2-2-1-WSL默认没有启用systemctl："><a href="#2-2-1-WSL默认没有启用systemctl：" class="headerlink" title="2.2.1. WSL默认没有启用systemctl："></a>2.2.1. WSL默认没有启用systemctl：</h3><p>启用systemctl的方法：<a target="_blank" rel="noopener" href="https://askubuntu.com/questions/1379425/system-has-not-been-booted-with-systemd-as-init-system-pid-1-cant-operate">链接</a>。</p>
<p>替代方法：不需要启动systemctl，因为会比较占用资源，启动也会变慢。可以使用service命令替代。</p>
<h3 id="2-2-2-WSL默认没有安装openssl-server："><a href="#2-2-2-WSL默认没有安装openssl-server：" class="headerlink" title="2.2.2. WSL默认没有安装openssl-server："></a>2.2.2. WSL默认没有安装openssl-server：</h3><p>使用ssh连接到服务器时，需要服务器运行着sshd程序，否则连接不上，会出现”<a target="_blank" rel="noopener" href="https://www.makeuseof.com/fix-ssh-connection-refused-error-linux/">Connection refused</a>“错误。</p>
<p>参考<a target="_blank" rel="noopener" href="https://askubuntu.com/questions/1339980/enable-ssh-in-wsl-system">链接</a>。</p>
<p>查看openssh-server有没有安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg --list | grep ssh</span><br></pre></td></tr></table></figure>

<p>注：如果安装了openssh-server，执行which sshd可以看到路径。</p>
<p>WSL默认没有安装openssh-server，安装方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure>

<p>启动ssh：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service ssh start</span><br></pre></td></tr></table></figure>

<h3 id="2-2-3-通过https登录到github"><a href="#2-2-3-通过https登录到github" class="headerlink" title="2.2.3. 通过https登录到github"></a>2.2.3. 通过https登录到github</h3><p><code>git push</code>不再支持输入用户名和密码，当提示输入密码时，需要输入personal access token.</p>
<p>步骤1：在github上<a target="_blank" rel="noopener" href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#creating-a-personal-access-token-classic">创建personal access token</a>；</p>
<p>步骤2：<a target="_blank" rel="noopener" href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#using-a-personal-access-token-on-the-command-line">在命令行上使用personal access token</a>；</p>
<p>步骤3：为了避免每次都需要输入personal access token，可以将其<a target="_blank" rel="noopener" href="https://docs.github.com/en/get-started/getting-started-with-git/caching-your-github-credentials-in-git">缓存在git client上</a>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gh auth login</span><br></pre></td></tr></table></figure>

<p>注：使用<code>gh</code>命令需要先安装GitHub CLI：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gh</span><br></pre></td></tr></table></figure>

<h3 id="2-2-4-执行git-pull-push时，出现”The-authenticity-of-host-‘github-com-20-205-243-166-’-can’t-be-established-ED25519-key-fingerprint-is-SHA256-…”错误"><a href="#2-2-4-执行git-pull-push时，出现”The-authenticity-of-host-‘github-com-20-205-243-166-’-can’t-be-established-ED25519-key-fingerprint-is-SHA256-…”错误" class="headerlink" title="2.2.4 执行git pull&#x2F;push时，出现”The authenticity of host ‘github.com (20.205.243.166)’ can’t be established. ED25519 key fingerprint is SHA256:…”错误"></a>2.2.4 执行git pull&#x2F;push时，出现”The authenticity of host ‘github.com (20.205.243.166)’ can’t be established. ED25519 key fingerprint is SHA256:…”错误</h3><p>报错解释：</p>
<p>这个报错信息通常出现在使用SSH连接到一个新的主机时。它表示你的计算机无法验证远程服务器的身份，因为服务器的公钥不在你本地计算机的known_hosts文件中。这是SSH为了防止”中间人”攻击而进行的安全检查。</p>
<p>解决方法：</p>
<p>验证指纹信息：你可以查看远程主机的指纹信息，并与服务器gitee.com的公钥指纹进行对比，确保它们匹配。你可以在~&#x2F;.ssh&#x2F;known_hosts文件中找到已知主机的公钥指纹。</p>
<p>如果确认指纹正确无误，且你信任这个服务器，可以添加这个主机及其公钥到你的known_hosts文件中，以便SSH不再警告。执行以下命令：</p>
<p>ssh-keyscan -H gitee.com &gt;&gt; ~&#x2F;.ssh&#x2F;known_hosts</p>
<p>如果你不想添加到known_hosts文件中，可以在第一次连接时使用ssh -o StrictHostKeyChecking&#x3D;no来跳过这个检查。但这样做会降低安全性。</p>
<p>如果你是在多个服务器上使用相同的IP地址，并且之前已经添加过这个IP的记录，那么可能是服务器的公钥发生了变化，这种情况下你应该联系服务器管理员确认公钥的变更。</p>
<p>注意：在实际生产环境中，不建议无条件信任新的SSH指纹，除非你完全了解这个服务器的来源和身份。</p>
<h1 id="3-静态站点生成器"><a href="#3-静态站点生成器" class="headerlink" title="3. 静态站点生成器"></a>3. 静态站点生成器</h1><p>以下几种<a target="_blank" rel="noopener" href="https://docs.github.com/en/pages/getting-started-with-github-pages/about-github-pages">静态站点生成器</a>都可以用来搭建个人主页。如果使用除JekyII外的工具，则需要配置<a target="_blank" rel="noopener" href="https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions">Github Actions</a>以构建和发布你的站点。</p>
<h2 id="3-1-mkdocs"><a href="#3-1-mkdocs" class="headerlink" title="3.1. mkdocs"></a>3.1. mkdocs</h2><p><a target="_blank" rel="noopener" href="https://www.mkdocs.org/">mkdocs</a>是一个快速的静态网页生成器。</p>
<p>发布个人网站的方法：参见<a target="_blank" rel="noopener" href="https://squidfunk.github.io/mkdocs-material/publishing-your-site/">mkdocs-material官网</a>。</p>
<h2 id="3-2-JekyII"><a href="#3-2-JekyII" class="headerlink" title="3.2. JekyII"></a>3.2. JekyII</h2><p>Jekyll 是一个静态站点生成器，内置对 GitHub Pages 的支持和简化的构建进程。</p>
<p>参见 <a target="_blank" rel="noopener" href="https://docs.github.com/en/pages/setting-up-a-github-pages-site-with-jekyll/about-github-pages-and-jekyll">About GitHub Pages and Jekyll</a> 。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/17/concurrency/%E8%AF%A6%E8%A7%A3RCU%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/17/concurrency/%E8%AF%A6%E8%A7%A3RCU%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">详解RCU机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-17 10:39:19" itemprop="dateCreated datePublished" datetime="2025-08-17T10:39:19+00:00">2025-08-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-04 17:56:31" itemprop="dateModified" datetime="2025-09-04T17:56:31+00:00">2025-09-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="RCU-读-复制-更新"><a href="#RCU-读-复制-更新" class="headerlink" title="RCU (读-复制-更新)"></a>RCU (读-复制-更新)</h2><p>RCU（Read-Copy-Update，读-拷贝-更新）是 Linux 内核中一种高效的 并发读-写同步机制，专门用于在多核系统下实现 大量读、少量写 的场景。它的核心思想是：读操作完全无锁，写操作通过复制更新，最后再安全地回收旧版本。</p>
<p>RCU 的核心思想</p>
<ul>
<li>读操作直接访问数据结构，不加锁</li>
<li>写操作：<ul>
<li>先 复制原数据 → 修改副本</li>
<li>更新指针，使新数据生效</li>
<li>延迟回收旧数据，保证当前正在读取旧数据的线程不受影响</li>
</ul>
</li>
</ul>
<h3 id="rcu"><a href="#rcu" class="headerlink" title="__rcu"></a><code>__rcu</code></h3><p>它是 RCU 机制中非常关键的一环，用来让 编译器和内核知道某个指针是 RCU 保护的。</p>
<ol>
<li><code>__rcu</code> 的定义</li>
</ol>
<p>在 Linux 内核中（以 x86_64 为例）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __rcu</span></span><br></pre></td></tr></table></figure>

<p>实际上，它 本身对编译器不产生直接影响</p>
<p>主要用途是 标记类型，告诉 Sparse 静态分析工具 或 内核开发者：这个指针受 RCU 保护，不能随意直接读&#x2F;写</p>
<p>也就是说，<code>__rcu</code> 是 一个注释性质的宏，编译器编译时忽略，但静态分析工具会检查 RCU 访问规则。</p>
<ol start="2">
<li><code>__rcu</code> 的作用</li>
</ol>
<p>标记 RCU 保护的指针，常见用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> __<span class="title">rcu</span> *<span class="title">fdt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> *<span class="title">fd_array</span>[<span class="title">NR_OPEN_DEFAULT</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>含义：</p>
<ul>
<li><code>fdt</code> 是 RCU 指针</li>
<li>不能直接写 <code>fdt = new_ptr</code>; 或直接解引用 <code>fdt-&gt;xxx</code></li>
<li>必须通过 RCU API，如：<ul>
<li><code>rcu_assign_pointer(fdt, new_fdt);</code> → 安全更新指针</li>
<li><code>rcu_dereference(fdt)</code> → 安全读取指针</li>
</ul>
</li>
<li>这样可以保证：<ul>
<li>写线程更新指针时不会破坏读线程的访问</li>
<li>读线程可以无锁访问旧数据</li>
</ul>
</li>
</ul>
<ol start="3">
<li><code>__rcu</code> 与编译器和内核</li>
</ol>
<ul>
<li>静态检查（Sparse）<ul>
<li>Sparse 是 Linux 内核推荐的静态分析工具</li>
<li>它会检查：<ul>
<li>所有 <code>__rcu</code> 指针的写操作是否用 <code>rcu_assign_pointer</code></li>
<li>所有读取是否用 <code>rcu_dereference</code></li>
</ul>
</li>
<li>如果直接访问，就会报错，避免 RCU 访问错误</li>
</ul>
</li>
<li>内存屏障和优化<ul>
<li><code>rcu_assign_pointer</code> 内部会加上 适当的写屏障 (<code>smp_wmb()</code>)</li>
<li><code>rcu_dereference</code> 内部会加 读取屏障 (<code>smp_rmb()</code>)</li>
<li>防止编译器&#x2F;CPU 重排导致读写顺序错误</li>
</ul>
</li>
</ul>
<ol start="4">
<li><code>__rcu</code> 的核心原理总结</li>
</ol>
<table>
<thead>
<tr>
<th>方面</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>编译器作用</td>
<td>本身是空宏，不改变代码</td>
</tr>
<tr>
<td>静态分析</td>
<td>Sparse 检查 RCU 指针的安全读写</td>
</tr>
<tr>
<td>内存屏障</td>
<td>通过 <code>rcu_assign_pointer</code> &#x2F; <code>rcu_dereference</code> 添加屏障，保证并发安全</td>
</tr>
<tr>
<td>运行时</td>
<td>指针仍然是普通指针，实际存储和访问和普通指针一样</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/16/os/%E9%AB%98%E6%95%88IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/16/os/%E9%AB%98%E6%95%88IO/" class="post-title-link" itemprop="url">高效 IO</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-16 23:40:06" itemprop="dateCreated datePublished" datetime="2025-08-16T23:40:06+00:00">2025-08-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-04 17:56:31" itemprop="dateModified" datetime="2025-09-04T17:56:31+00:00">2025-09-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="高效的-IO-函数"><a href="#高效的-IO-函数" class="headerlink" title="高效的 IO 函数"></a>高效的 IO 函数</h2><ul>
<li>sendfile</li>
<li>mmap + write</li>
<li>splice</li>
<li>readv</li>
</ul>
<h3 id="零拷贝-Zero-copy"><a href="#零拷贝-Zero-copy" class="headerlink" title="零拷贝 (Zero copy)"></a>零拷贝 (Zero copy)</h3><ul>
<li>mmap + write</li>
<li>sendfile</li>
<li>splice</li>
</ul>
<h3 id="Page-cache-和异步-IO"><a href="#Page-cache-和异步-IO" class="headerlink" title="Page cache 和异步 IO"></a>Page cache 和异步 IO</h3><p><a target="_blank" rel="noopener" href="https://www.xiaolincoding.com/os/8_network_system/zero_copy.html#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%9B%B6%E6%8B%B7%E8%B4%9D">https://www.xiaolincoding.com/os/8_network_system/zero_copy.html#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%9B%B6%E6%8B%B7%E8%B4%9D</a></p>
<ul>
<li>O_DIRECT: 绕过操作系统缓存，直接读写磁盘，可以避免缓存延迟，提高性能。可用于：<ul>
<li>数据库系统：对性能要求极高，且直接操作磁盘数据。</li>
<li>存储设置：如 SSD、硬盘，直接与硬件设备进行高效的 I&#x2F;O 操作。</li>
<li>注意：由于绕过了缓存，所以 read 如果小于当前数据包的大小，则本次 read 后，内核会直接丢弃多余的数据。这是为了避免多余的数据在内存中驻留。</li>
</ul>
</li>
</ul>
<h3 id="散布读写-Scatter-read-write"><a href="#散布读写-Scatter-read-write" class="headerlink" title="散布读写 (Scatter read&#x2F;write)"></a>散布读写 (Scatter read&#x2F;write)</h3><ul>
<li>readv</li>
<li>writev</li>
</ul>
<p>散布读写支持一次性将数据从文件描述符读写到多个缓冲区：</p>
<ul>
<li>避免多次系统调用；</li>
<li>直接分块读取，不需要额外用户态 memcpy 到不同的块。</li>
</ul>
<h2 id="IO-复用"><a href="#IO-复用" class="headerlink" title="IO 复用"></a>IO 复用</h2><ul>
<li>select</li>
<li>poll</li>
<li>epoll</li>
<li>非阻塞 IO</li>
</ul>
<p>如果 select &#x2F; poll &#x2F; epoll 通知可读写，那么一定可读写吗？<br>答案是不一定。因为内核不是 <strong>实时地</strong> 检查内核缓冲区是否有空间或有数据，所以内核的通知有时间差和虚假性。<br>而 epoll 等函数只关注事件变化，不检查缓冲区。这样可以提高效率。<br>最终的结果就是鼓励用户程序尝试，但是不保证一定成功，也就是可能阻塞。所以需要非阻塞 IO 来进一步提高性能。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><ul>
<li>减少数据拷贝：select &#x2F; poll 只有一个函数，这会要求每次调用都必须将描述事件的数据从用户空间复制到内核空间；所以 epoll 拆分成三个函数，用户可以向内核直接注册事件数据；</li>
<li>红黑树：epoll 事件数据是用红黑树来记录，增删查改的时间复杂度为 O(logn) ；select &#x2F; poll 是线性扫描，时间复杂度 O(n) 。红黑树需要额外的空间，所以这是空间换时间的办法。</li>
</ul>
<h4 id="EPOLLONESHOT"><a href="#EPOLLONESHOT" class="headerlink" title="EPOLLONESHOT"></a><code>EPOLLONESHOT</code></h4><p>阅读 manual：</p>
<blockquote>
<p>Since  even  with  edge-triggered  epoll,  multiple events can be generated upon receipt of multiple chunks of data, the caller has the option to specify the EPOLLONESHOT flag, to tell epoll to disable the associated file descriptor after the receipt of an event  with  epoll_wait(2).   When the EPOLLONESHOT flag is specified, it is the caller’s responsibility to rearm the file descriptor using epoll_ctl(2) with EPOLL_CTL_MOD.</p>
</blockquote>
<p>如果某个文件描述符上有多个数据块到达，那么即使是边沿触发也无法保证事件只通知一次。这可能是由于数据包过大被分片，或者是新数据到达。</p>
<ul>
<li>这在单线程程序上不会有太大影响，因为对同一个 fd 不会造成重复读写。</li>
<li>多线程程序中，fd 准备好后，我们常常将这个 fd 交给某个线程去处理。此时如果 fd 有新的事件，会造成多线程处理同一个 fd 的情况。<ul>
<li>为了避免竞争，要么加锁；要么使用内核的 ONESHOT 机制。后者由内核保证，无锁，更高效。</li>
</ul>
</li>
<li><code>EPOLLONSHOT</code> 需要调用者自行 reset 这个标志。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/salmonwilliam/article/details/112347938">https://blog.csdn.net/salmonwilliam/article/details/112347938</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/16/os/%E6%96%87%E4%BB%B6IO%E4%B8%8E%E8%BF%9B%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/16/os/%E6%96%87%E4%BB%B6IO%E4%B8%8E%E8%BF%9B%E7%A8%8B/" class="post-title-link" itemprop="url">文件IO与进程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-16 20:50:37" itemprop="dateCreated datePublished" datetime="2025-08-16T20:50:37+00:00">2025-08-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-04 17:56:31" itemprop="dateModified" datetime="2025-09-04T17:56:31+00:00">2025-09-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="进程打开文件"><a href="#进程打开文件" class="headerlink" title="进程打开文件"></a>进程打开文件</h2><p><a href="https://postimages.org/" target="_blank"><img src="https://i.postimg.cc/50jyHyjJ/image.png" alt="image"/></a></p>
<ul>
<li><code>struct task_struct</code> (进程控制块)<ul>
<li>每个进程有一个 <code>task_struct</code>结构体，内核用它来描述进程。</li>
<li>里面有一个指针 <code>files</code> ，执行该进程的 <code>files_struct</code> 。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v6.16/source/include/linux/sched.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 进程控制块 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span> <span class="comment">// 进程当前打开的文件</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>files_struct</code> (进程的文件表)<ul>
<li>这里保存了一个指向 fd 数组 的指针。</li>
<li>fd 数组的下标就是 0, 1, 2…，每个元素指向一个 <code>file *</code> 结构体。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v6.16/source/include/linux/fdtable.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">files_struct</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">fdtable</span> __rcu *fdt;                          <span class="comment">// fd 表（动态管理）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">file</span> __rcu    *fd_array[NR_OPEN_DEFAULT];    <span class="comment">// 固定大小数组（早期 fd 数组）</span></span><br><span class="line">                                                        <span class="comment">// NR_OPEN_DEFAULT 通常为 1024</span></span><br><span class="line">                                                        <span class="comment">// 早期没有设置 FD_CLOEXEC 新特性</span></span><br><span class="line">    <span class="comment">// 为什么 fdt 与 fd_array 同时存在？</span></span><br><span class="line">    <span class="comment">// 1. 性能优化：大多数程序，fd 都在 0~1023，直接访问数组更快</span></span><br><span class="line">    <span class="comment">// 2. 向后兼容：早期接口会访问fd_array</span></span><br><span class="line">    <span class="comment">// 3. 动态扩展：如果 fd 超过 NR_OPEN_DEFAULT，内核会复制 fd_array 到 fdt-&gt;fd 来保证一致性。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... `struct files_struct&#x27; 还有其他成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fd 表（动态管理）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fdtable</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        max_fds;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">file</span> __rcu **fd;             <span class="comment">/* 当前打开的 fd 指针数组 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>      *close_on_exec;  <span class="comment">// fd 标志，目前只有一个</span></span><br><span class="line">                                        <span class="comment">// FD_CLOEXEC 定义在 &lt;fcntl.h&gt; 中</span></span><br><span class="line">                                        <span class="comment">// close_on_exec 指向一个位图(bitmap)，每个bit代表一个fd</span></span><br><span class="line">                                        <span class="comment">// 如果bit=1，表示该fd设置了FD_CLOEXEC</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>      *open_fds;       <span class="comment">// 标记哪些fd是打开的，也是位图</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>      *full_fds_bits;  <span class="comment">// 辅助位图，用于快速找到空闲fd</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rcu_head</span>     rcu;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>struct file</code> (打开文件表项)<ul>
<li>内核为每次 <code>open()</code>、<code>pipe()</code>、<code>socket()</code> 创建一个 <code>struct file</code>。</li>
<li>它记录了文件状态（读写偏移、flag、引用计数等）。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v6.16/source/include/linux/fs.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="type">spinlock_t</span>                    f_lock;</span><br><span class="line">    <span class="type">fmode_t</span>                       f_mode;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>         *<span class="title">f_mapping</span>;</span></span><br><span class="line">    <span class="type">void</span>                         *private_data;  <span class="comment">// 比如 socket</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>                 *<span class="title">f_inode</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>                  f_flags;  <span class="comment">// 文件状态标志，如 O_RDONLY, O_NONBLOCK, O_APPEND 等</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>                  f_iocb_flags;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>            *<span class="title">f_cred</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>           *<span class="title">f_owner</span>;</span></span><br><span class="line">    <span class="comment">/* --- cacheline 1 boundary (64 bytes) --- */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">f_path</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="comment">/* regular files (with FMODE_ATOMIC_POS) and directories */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">f_pos_lock</span>;</span></span><br><span class="line">        <span class="comment">/* pipes */</span></span><br><span class="line">        u64 f_pipe;  <span class="comment">// 管道</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>inode &#x2F; pipe &#x2F; socket 内核对象<ul>
<li><p><code>struct file</code> 再指向更底层的对象，比如 inode（磁盘文件）、socket 缓冲区、pipe 缓冲区。</p>
</li>
<li><p>i-node 包含以下内容</p>
<ul>
<li>链接计数（指向该i节点的目录项数）；</li>
<li>文件类型、文件访问权限位、文件长度、指向文件数据块的指针等。<code>stat</code>结构中的大多数信息都取自i节点。</li>
<li>只有两项重要数据放在目录项中：文件名和i-node编号。</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="text-align: center">
<figure>
  <img src="https://i.postimg.cc/rFRyX7Rh/image.png" alt="磁盘、分区和文件系统">
  <figcaption>磁盘、分区和文件系统</figcaption>
</figure>
</div>

<div style="text-align: center">
<figure>
  <img src="https://i.postimg.cc/3xM8K9g3/i.png" alt="i节点和数据块">
  <figcaption>i节点和数据块</figcaption>
</figure>
</div>


<p>软链接与硬链接</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>硬链接 (Hard Link)</strong></td>
<td>表示有多少目录项（文件名）指向同一个 <strong>inode</strong> 。它们指向同一个文件内容。</td>
</tr>
<tr>
<td><strong>软链接 (Symbolic Link &#x2F; Symlink)</strong></td>
<td>类似快捷方式，是一个 <strong>独立文件</strong>，内容是指向目标文件的路径。</td>
</tr>
</tbody></table>
<ul>
<li>硬链接：当硬链接数降为0时，才从磁盘的数据块中删除该文件，所以删除文件（即目录项）称为<code>unlink</code>，而不是<code>delete</code>。</li>
<li>软链接：i-node中的文件类型是<code>S_IFLINK</code>，表明是符号链接。</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>硬链接</th>
<th>软链接</th>
</tr>
</thead>
<tbody><tr>
<td>是否指向 inode</td>
<td>是，直接指向同一 inode</td>
<td>否，指向目标路径</td>
</tr>
<tr>
<td>是否可以跨文件系统</td>
<td>否，只能在同一分区</td>
<td>可以跨分区</td>
</tr>
<tr>
<td>是否可以链接目录</td>
<td>通常不能（除非 root）</td>
<td>可以</td>
</tr>
<tr>
<td>删除目标文件后</td>
<td>文件内容仍可访问</td>
<td>链接会失效（称为“悬挂链接”）</td>
</tr>
<tr>
<td>占用空间</td>
<td>不占用额外数据空间（只是多了一个目录项）</td>
<td>占用少量空间存储路径信息</td>
</tr>
<tr>
<td>更新文件内容</td>
<td>所有硬链接同步可见</td>
<td>通过软链接修改目标文件内容时可见，软链接本身只是路径</td>
</tr>
</tbody></table>
<h2 id="两个独立进程各自打开同一个文件"><a href="#两个独立进程各自打开同一个文件" class="headerlink" title="两个独立进程各自打开同一个文件"></a>两个独立进程各自打开同一个文件</h2><p><a href="https://postimages.org/" target="_blank"><img src="https://i.postimg.cc/hG2hPTDM/image.png" alt="两个独立进程各自打开同一个文件"/></a></p>
<ul>
<li>O_APPEND：<ul>
<li>原子操作：如果使用 <code>O_APPEND</code> 标志打开一个文件，那么相应的标志也被设置到文件表项的文件状态标志中。每次对文件执行写操作时，文件表项中的当前文件偏移量首先会被设置为 i 节点表项中的文件长度（相对其他进程来说是<strong>原子</strong>操作，不论是两个独立的进程，还是父子进程）。这就使得每次写入的数据都追加到文件的当前尾端处。<a target="_blank" rel="noopener" href="https://blog.csdn.net/yangbodong22011/article/details/63064166">这里</a>有一个测试的例子，文章结论不见得正确，请参考评论的讨论。</li>
<li><code>PIPE_BUF</code>：只保证小于<code>PIPE_BUF</code>的内容是原子；如果大于则可能被多次多段写入。PIPE_BUF 是管道（pipe）单次写入保证原子的最大字节数，Linux 上是 4096 字节。</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 PIPE_BUF 大小</span></span><br><span class="line"><span class="comment"># `/tmp&#x27; 可以换成任意文件系统路径</span></span><br><span class="line">$ getconf PIPE_BUF /tmp</span><br><span class="line">4096</span><br><span class="line"><span class="comment"># 也可以查看所有文件系统相关的 PIPE_BUF 限制</span></span><br><span class="line">$ getconf -a PIPE_BUF</span><br></pre></td></tr></table></figure>

<p>  以下是 <code>man 2 write</code> 关于 <code>O_APPEND</code> 的说明：</p>
<blockquote>
<p>If the file was open(2)ed with O_APPEND, the file offset is first set to the end of the file before writing.  The adjustment of the file offset and the write operation are performed as an atomic step.</p>
</blockquote>
<ul>
<li>lseek：</li>
</ul>
<p>若一个文件用 <code>lseek</code> 定位到文件当前的尾端，则文件表项中的当前文件偏移量被设置为 i 节点表项中的当前文件长度（注意，此时，设置偏移量和写操作之间不是原子操作）。</p>
<hr>
<h2 id="dup-后的内核数据结构"><a href="#dup-后的内核数据结构" class="headerlink" title="dup()后的内核数据结构"></a><code>dup()</code>后的内核数据结构</h2><p><code>dup()</code> &#x2F; <code>dup2()</code> 只复制 fd ，也就是在 fd 数组中新增了一个 fd 项。一般用来重定向。</p>
<p><a href="https://postimages.org/" target="_blank"><img src="https://i.postimg.cc/s2mGQbcY/dup-1.png" alt="dup(1)"/></a></p>
<hr>
<h2 id="fork与文件共享"><a href="#fork与文件共享" class="headerlink" title="fork与文件共享"></a>fork与文件共享</h2><ul>
<li>进程每打开一个文件，都会新建一个 <code>struct file</code> ，并添加到 fd 数组或 fd 表中。<ul>
<li>对同一个文件，不同进程拥有各自的文件表项。</li>
<li>但是对每个文件，v节点表项在整个操作系统中只有一份。</li>
</ul>
</li>
<li><code>fork()</code> 后的子进程直接复制父进程的 fd 数组，<code>exec()</code> 也不能将其替换；<ul>
<li>子进程对 <code>struct task_struct</code> 是深拷贝，所以 fd 数组被复制；</li>
<li>但是子进程对 fd 数组是浅拷贝，fd 数组中的 <code>struct file*</code> 仍然指向父进程创建的 <code>struct file </code> （共享）；</li>
<li>所以子进程共享了文件状态标志 (O_APPEND, O_NONBLOCK, O_RDONLY 等)、当前文件偏移量。</li>
</ul>
</li>
<li>除非该文件描述符使用<code>fcntl()</code>设置了<code>FD_CLOEXEC</code>标志，此时 <code>exec</code> 会关闭继承的文件描述符。</li>
</ul>
<p><a href="https://postimages.org/" target="_blank"><img src="https://i.postimg.cc/TYbyqK0Y/fork.png" alt="fork"/></a></p>
<p><strong>子进程对文件表项的修改，会不会影响父进程？</strong></p>
<ul>
<li>shell进程启动时，会自动打开这三个文件描述符（可能由配置项决定）；</li>
<li>shell利用<code>fork()</code>开启用户进程（子进程），该子进程复制父进程shell的所有文件描述符，于是0, 1, 2文件描述符被打开；</li>
<li>由于子进程<strong>共享</strong>父进程的<strong>文件表项</strong>，子进程对文件状态标志（读、写、同步或非阻塞等）、文件偏移量的修改，将<strong>会影响父进程</strong>。</li>
</ul>
<p>测试代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> err_sys(x)                                                             \</span></span><br><span class="line"><span class="meta">  &#123;                                                                            \</span></span><br><span class="line"><span class="meta">    perror(x);                                                                 \</span></span><br><span class="line"><span class="meta">    exit(1);                                                                   \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pr_fl</span><span class="params">(<span class="type">int</span> fd)</span>;             <span class="comment">// 自定义函数：打印文件状态标志</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_fl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> flags)</span>; <span class="comment">// 自定义函数：设置文件状态标志</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  pr_fl(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  set_fl(<span class="number">0</span>, O_APPEND);</span><br><span class="line">  pr_fl(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_fl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((val = fcntl(fd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    err_sys(<span class="string">&quot;fcntl F_GETFL error&quot;</span>);</span><br><span class="line"></span><br><span class="line">  val |= flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fcntl(fd, F_SETFL, val) &lt; <span class="number">0</span>)</span><br><span class="line">    err_sys(<span class="string">&quot;fcntl F_SETFL error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pr_fl</span><span class="params">(<span class="type">int</span> fd)</span> &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do not guarantee success on certain system, check EINVAL first</span></span><br><span class="line">  <span class="keyword">if</span> ((val = fcntl(fd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    err_sys(<span class="string">&quot;fcntl F_GETFL error&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (val &amp; O_ACCMODE) &#123;</span><br><span class="line">  <span class="keyword">case</span> O_RDONLY:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read only&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> O_WRONLY:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write only&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> O_RDWR:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read write&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    err_sys(<span class="string">&quot;unknown open type&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (val &amp; O_CREAT)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;, create&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (val &amp; O_APPEND)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;, append&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (val &amp; O_NONBLOCK)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;, non-block&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (val &amp; O_SYNC)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;, synchronized file&quot;</span>);</span><br><span class="line">  <span class="comment">// if (val &amp; O_DSYNC)</span></span><br><span class="line">  <span class="comment">//   printf(&quot;, synchronize data&quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一次运行：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line"><span class="built_in">read</span> write</span><br><span class="line"><span class="built_in">read</span> write, append</span><br></pre></td></tr></table></figure>

<ul>
<li>第二次运行：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line"><span class="built_in">read</span> write, append</span><br><span class="line"><span class="built_in">read</span> write, append</span><br></pre></td></tr></table></figure>

<ul>
<li><p>分析</p>
<ul>
<li>第二次运行时，文件描述符0的初始状态保持了第一次运行的结果！</li>
<li>这是因为父进程shell的文件表项的文件状态标志被子进程<code>a.out</code>改变了。</li>
</ul>
</li>
<li><p>第三次运行：</p>
<p>重新启动shell，并运行<code>a.out</code></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line"><span class="built_in">read</span> write</span><br><span class="line"><span class="built_in">read</span> write, append</span><br></pre></td></tr></table></figure>

<ul>
<li><p>分析</p>
<ul>
<li>第三次运行，结果与第一次一致，这说明我们的猜测正确。</li>
<li>父进程shell关闭之后，所有文件描述符被关闭，文件IO被关闭，文件表被释放。重启shell也就重置了文件表。</li>
</ul>
</li>
<li><p>引申：<br>在此我们注意到，文件描述符0, 1, 2（标准输入、标准输出、标准错误）在一个shell及其所有子进程中，对应的文件（设备）是同一个。由于共享了文件表项，指向了同一个v-node表项，故都指向同一个虚拟终端。这与我们的平时观察一致，不然shell运行程序时，输入输出的入口在哪里呢？</p>
</li>
</ul>
<p><strong>如果进程打开文件，此时我们使用 rm &#x2F; unlink 删除文件，会发生什么？</strong></p>
<p>什么也不会发生。因为 Linux 文件系统的设计允许文件名（目录项）和文件内容（inode）分离。只有当所有引用（包括文件描述符和内存映射）都关闭后，inode 才会被删除。</p>
<p>在 Linux 中，一个文件由三部分组成：</p>
<ul>
<li>目录项（filename）：比如 <code>/lib/libexample.so</code></li>
<li>inode（元数据）：记录权限、大小、时间戳等</li>
<li>数据块（内容）：实际的文件内容</li>
</ul>
<p><code>rm</code> 只是删除了目录项（文件名），并没有删除 inode 或数据块，只要还有进程引用它。</p>
<p>引用 inode 的方式包括：</p>
<ul>
<li>打开文件（open()）</li>
<li>映射文件（mmap()）</li>
<li>动态链接器加载 .so 文件</li>
</ul>
<p>这些引用会让内核知道：这个 inode 仍然在使用中，不能释放。</p>
<p>这是为了支持非常重要的行为：</p>
<blockquote>
<p>✅ 允许进程继续使用已打开或已映射的文件，即使文件名被删除。</p>
</blockquote>
<p>这在很多场景下非常有用：</p>
<ul>
<li>日志轮转：删除旧日志文件，进程仍在写入</li>
<li>安全性：防止其他进程访问文件名，但当前进程仍可使用</li>
<li>临时文件：创建后立即删除，只让当前进程使用</li>
</ul>
<p>在 Linux 内核中，每个 inode 结构体有一个字段 <code>i_count</code>，表示该 inode 当前被引用的次数。这个引用包括：</p>
<ul>
<li>被文件系统挂载</li>
<li>被进程打开</li>
<li>被内核缓存使用</li>
</ul>
<p>这个字段不是用户空间可以直接查看的，但你可以通过以下方式间接观察：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">能看到什么</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>ls -li</code></td>
<td align="center">inode 号 + 硬链接引用计数</td>
</tr>
<tr>
<td align="center"><code>lsof -p &lt;PID&gt; | grep</code> &#x2F; <code>fuser &lt;/path/to/so&gt;</code></td>
<td align="center">是否有进程打开文件</td>
</tr>
<tr>
<td align="center"><code>/proc/&lt;PID&gt;/fd/</code></td>
<td align="center">查看文件描述符引用</td>
</tr>
<tr>
<td align="center"><code>/proc/&lt;PID&gt;/maps</code></td>
<td align="center">查看映射</td>
</tr>
<tr>
<td align="center"><code>ldd</code></td>
<td align="center">查看可执行文件依赖的 .so</td>
</tr>
<tr>
<td align="center"><code>strace</code></td>
<td align="center">跟踪运行时加载行为</td>
</tr>
<tr>
<td align="center">内核字段 <code>i_count</code></td>
<td align="center">真实引用计数（需内核调试）</td>
</tr>
</tbody></table>
<p>在本地文件系统（如 ext4）中：</p>
<ul>
<li>即使文件正在使用，<code>rm</code> 也能删除目录项</li>
<li>文件内容仍保留在 inode 中，直到所有引用关闭</li>
</ul>
<p>但在 NFS 文件系统 中：</p>
<ul>
<li>客户端不能立即删除正在被使用的文件</li>
<li>所以它会将文件重命名为 <code>.nfsXXXX</code></li>
<li>等引用释放后，自动删除该临时文件</li>
</ul>
<p>所以此时如果 <code>rm -rf</code> 目录，但是目录下某文件被使用，会提示 <code>xxx/.nfs000000004ec2d5e70000da89</code> 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ lsof -p &lt;PID&gt; | grep .nfs</span><br><span class="line">my_executable 283964 my_name  mem    REG  0,183  18371240 1321391591 /XXX/.nfs000000004ec2d5e70000da89 (xxx:/yyy/zzz)</span><br></pre></td></tr></table></figure>

<p>因为 so 被手动删除，此时引用的 so 被重命名成 <code>.nfsXXXX</code> 。</p>
<p>手动删除 .so 文件后，系统生成了 .nfsXXXX 文件，但进程仍然能继续使用它。进程怎么知道新文件名？</p>
<p>答案是：进程根本不知道新文件名，也不需要知道。</p>
<p>当一个进程打开一个文件（比如 <code>libexample.so</code>），它获得的是一个 文件描述符（fd），这个描述符指向的是内核中的 inode，而不是文件名。</p>
<p>那 <code>.nfsXXXX</code> 文件名是给谁看的？</p>
<p>它是 NFS 客户端自动创建的临时文件名，用于：</p>
<ul>
<li>保留 inode 内容，直到所有引用关闭</li>
<li>让系统知道这个文件还不能真正删除</li>
<li>让你可以用 lsof 或 fuser 查找谁在使用它</li>
</ul>
<p>📌 这个文件名不会被通知给进程，也不会影响进程的运行。</p>
<p>正常情况下：进程关闭后 .nfsXXXX 自动消失</p>
<ul>
<li>.nfsXXXX 文件是由 NFS客户端 创建的临时文件</li>
<li>当某个文件被打开后删除，客户端会将其重命名为 .nfsXXXX</li>
<li>一旦该文件的 打开引用计数为 0（即所有进程都关闭了该文件），客户端会自动删除 .nfsXXXX</li>
</ul>
<p>⚠️ 异常情况：文件可能残留</p>
<p>如果出现以下情况，.nfsXXXX 文件可能不会自动删除：</p>
<ul>
<li>客户端 crash 或断网，未能完成清理动作</li>
<li>使用 kill -9 强制终止进程，绕过了正常关闭流程</li>
<li>NFS 客户端或服务器之间同步延迟</li>
<li>文件被多个进程同时打开，只有部分进程关闭</li>
</ul>
<p>在这些情况下，.nfsXXXX 文件会残留在文件系统中，直到手动清理。</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>通过上文的叙述，我们很容易想到管道本质上也是一种特殊的文件，所以管道机制之所以可以进程间通信也是根据共享文件表项保证的。<br>管道和文件进行进程间通信的本质相同。</p>
<h2 id="Linux-文件锁与记录锁"><a href="#Linux-文件锁与记录锁" class="headerlink" title="Linux 文件锁与记录锁"></a>Linux 文件锁与记录锁</h2><p>TODO</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xuyh/p/3278881.html">链接1</a>、<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fortunely/p/15219611.html">链接2</a>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《UNIX 环境高级编程》</li>
<li>《Linux 内核设计与实现（原书第 3 版） - Linux Kernel Development, Third Edition》，（美）拉芙（Love, R.）著；陈莉君，康华译. ——北京：机械工业出版社，2011.9（2021.5 重印）</li>
<li><a target="_blank" rel="noopener" href="https://github.com/antsHub/task_struct/tree/main">图解进程控制块stask_struct</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/16/os/Linux%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/16/os/Linux%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">Linux 权限管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-16 20:37:50" itemprop="dateCreated datePublished" datetime="2025-08-16T20:37:50+00:00">2025-08-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-04 17:56:31" itemprop="dateModified" datetime="2025-09-04T17:56:31+00:00">2025-09-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Unix 权限涉及三个部分：** 用户 <strong>、</strong> 进程 <strong>、</strong> 文件 **。<br>权限分为常用权限、SELinux 权限。<br>manpage: <code>man 2 stat</code> 中搜索 “mode” 可以看到几种常用权限的详情。</p>
<h2 id="用户和分组"><a href="#用户和分组" class="headerlink" title="用户和分组"></a>用户和分组</h2><p>用户用 user ID 区分。多个用户可以划入同一个用户分组，一个用户可以同时属于不同的分组。这就是 UID（User ID）和 GID（Group ID）。</p>
<p>现在我将使用我的凭据登录到 shell 并运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="variable">$LOGNAME</span> /etc/passwd</span><br></pre></td></tr></table></figure>

<blockquote>
<p>rotem: x:1000:1000:rotem,,,:&#x2F;home&#x2F;rotem:&#x2F;bin&#x2F;bash</p>
</blockquote>
<p>您可以看到我的日志名 (rotem)、均为 1000 的 UID 和 GID，以及其他详细信息，例如我登录的 shell。</p>
<h2 id="进程的用户-ID-UID"><a href="#进程的用户-ID-UID" class="headerlink" title="进程的用户 ID (UID)"></a>进程的用户 ID (UID)</h2><p>每个进程都有一个所有者，并且每个进程都属于一个组。</p>
<p>进程有 3 种 UID：<code>real user ID</code>、<code>effective user ID</code>、<code>saved user ID</code>。其中还有一个 <code>set-user-ID</code> 的概念，这个概念和 <code>effective user ID</code> 紧密关联。</p>
<h3 id="实际用户-ID-RUID-Real-User-ID-5"><a href="#实际用户-ID-RUID-Real-User-ID-5" class="headerlink" title="实际用户 ID (RUID, Real User ID) [^5]"></a>实际用户 ID (RUID, Real User ID) [^5]</h3><p>在我们的 shell 中，我们现在将运行的每个进程都将继承我的用户帐户的权限，并将使用相同的 UID 和 GID 运行。</p>
<p>当您 <code>fork</code> 一个新进程时，该进程会继承父进程的 RUID。通常父级的 RUID 是你的 shell 并且它有当前登录用户的 UID。所以新进程有当前登录用户的 UID 的 RUID。通常这不会改变，只有 root 可以改变它。</p>
<p>举个例子，想想 init 进程派生了你的登录 shell。在 fork 期间，shell 将具有 root 的 RUID（因为 shell 的父级是 init）。但是，init 进程使用 <code>/etc/passwd</code> 将 shell 的 RUID 改成你的 UID. 因此，此后登录 shell 的 RUID 将是您的 UID，而不是 root。所以，我们可以说 RUID 是进程所有者的。</p>
<p>让我们运行一个简单的命令来检查它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sleep</span> 100 &amp; ps aux | grep <span class="string">&#x27;sleep&#x27;</span></span><br><span class="line">bi-an     3741  0.0  0.0  11252   928 pts/0    S    17:00   0:00 <span class="built_in">sleep</span> 100</span><br></pre></td></tr></table></figure>

<p>然后根据 <code>ps</code> 命令打印出的 PID (3741) ，查进程 UID 和 GID：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">stat</span> -c <span class="string">&quot;%u %g&quot;</span> /proc/3741</span><br><span class="line">1000 1000</span><br></pre></td></tr></table></figure>

<p>然而，系统判断一个进程对一个文件是否有权限时，要验证的 ID 是 effective user ID，而不是 real user ID。</p>
<h3 id="有效用户-ID（EUID-Effective-User-ID）"><a href="#有效用户-ID（EUID-Effective-User-ID）" class="headerlink" title="有效用户 ID（EUID, Effective User ID）"></a>有效用户 ID（EUID, Effective User ID）</h3><p>Linux 通常都不建议用户使用 root 权限去进行一般的处理，但是普通用户在做很多很多 services 相关的操作的时候，可能需要一个特殊的权限。为 了满足这样的要求，许多 services 相关的 executable 有一个标志，这就是 <code>set-user-ID bit</code>。当这个 <code>set-user-ID bit=ON</code> 的时候，这个 executable 被用 exec 启动之后的进程的 effective user ID 就是这个 executable 的 owner id，而并非 parent process real user id。如果 <code>set-user-ID bit=OFF</code> 的时候，这个被 exec 起来的进程的 effective user ID 应该是等于进程的 user ID 的。<br>我们以 ping 命令为例。</p>
<p>使用 <code>which</code> 命令搜索二进制位置，然后运行 <code>ls -la</code>：</p>
<blockquote>
<p>-rwsr-xr-x  1 root root   64424 Mar 10  2017  ping</p>
</blockquote>
<p>可以看到文件的所有者和组是 root. 这是因为该 <code>ping</code> 命令需要打开一个套接字，而 Linux 内核 root 为此需要特权。</p>
<p>但是，如果没有 root 特权，我如何使用 <code>ping</code>？</p>
<p>注意文件权限的所有者部分中的 “<code>s</code>” 字母而不是 “<code>x</code>”。</p>
<p>这是特定二进制可执行文件（如 <code>ping</code> 和 <code>sudo</code>）的特殊权限位，称为 <code>set-user-ID</code>。</p>
<p>这是 <code>EUID</code> 和 <code>EGID</code> 发挥作用。</p>
<p>将会发生的情况是，当执行设置了 setuid 的二进制文件 <code>ping</code> 时，该进程将其有效用户 ID (<code>EUID</code>) 从默认值 <code>RUID</code> 更改为此特殊二进制可执行文件的所有者，在本例中为 root。</p>
<p>这一切都是通过这个文件有这个简单的事实来完成的 <code>set-user-ID</code>。</p>
<p>内核通过查看进程的 <code>EUID</code> 来决定该进程是否具有特权。因为现在 <code>EUID</code> 指向 root，操作不会被内核拒绝。</p>
<p>注意：在最新的 Linux 版本中，ping 命令的输出看起来会有所不同，因为它们采用了 Linux Capabilities 方法而不是这种 setuid 方法（对于不熟悉的人）请阅读 <a href="TODO">此处</a>。</p>
<h4 id="set-user-ID"><a href="#set-user-ID" class="headerlink" title="set-user-ID"></a>set-user-ID</h4><p>参考 <a target="_blank" rel="noopener" href="https://www.gnu.org/software/coreutils/manual/html_node/Directory-Setuid-and-Setgid.html">链接 1</a> 。</p>
<p>Unix 包含另一个权限位，即该权限 <code>set-user-ID</code> 位。如果为可执行文件设置了该位，那么只要所有者以外的用户执行该文件，该用户就可以访问所有者的其他任何文件，从而获得所有者的所有文件读 &#x2F; 写 &#x2F; 执行特权！</p>
<p>这会导致运行该文件的任何人或进程都可以访问系统资源，就好像他们是该文件的所有者一样。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l testfile</span><br><span class="line"> -rw-rw-r-- 1 rotem rotem 0 Nov  8 17:12 testfile</span><br></pre></td></tr></table></figure>

<p>为文件添加 <code>set-user-ID</code> 权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">chmod</span> u+s testfile</span><br><span class="line">$ <span class="built_in">ls</span> -l testfile</span><br><span class="line"> -rwSrw-r-- 1 rotem rotem 0 Nov  8 17:12 testfile</span><br></pre></td></tr></table></figure>

<p>说明：大写 <code>S</code> 表示，有 <code>set-user-ID</code> 权限，但是没有执行权限。</p>
<h4 id="set-group-ID"><a href="#set-group-ID" class="headerlink" title="set-group-ID"></a>set-group-ID</h4><p>阅读 Manual：<code>man 2 stat</code>。</p>
<blockquote>
<p>The set-group-ID bit (S_ISGID) has several special uses.<br>For a directory, it indicates that BSD semantics is to be used for that directory: files created there inherit their group ID from the directory, not from the effective group ID of the creating process, and directories created there will also get the S_ISGID bit set.</p>
</blockquote>
<p>如果目录具有设置组 ID（S_ISGID）：</p>
<ul>
<li>其下创建的文件将从其父目录的继承组 ID，而不能从创建其的进程中继承有效组 ID；</li>
<li>其下创建的子目录将继承设置组 ID 位（S_ISGID）。</li>
</ul>
<blockquote>
<p>For a file that does not have the group execution bit (S_IXGRP) set, the set-group-ID bit indicates mandatory file&#x2F;record locking.</p>
</blockquote>
<p>如果一个文件有 “设置组 ID（set-group-ID）” 但是没有 “组执行权限（S_IXGRP）”，也就说具有如下权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">ls</span> -l a.txt</span><br><span class="line">-rw-r-Sr-- 1 username groupname 0 Feb 23 19:34 a.txt</span><br></pre></td></tr></table></figure>

<p>那么，此时 set-group-ID 位喻示强制文件 &#x2F; 记录锁。</p>
<p>TODO：强制文件 &#x2F; 记录锁是什么？<br><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/filesystems/mandatory-locking.txt">Mandatory File Locking</a><br><a target="_blank" rel="noopener" href="https://superuser.com/questions/968565/why-remove-group-execute-for-mandatory-file-lock">Why remove group execute for mandatory file lock?</a></p>
<h4 id="粘滞位："><a href="#粘滞位：" class="headerlink" title="粘滞位："></a>粘滞位：</h4><blockquote>
<p>The sticky bit (S_ISVTX) on a directory means that a file in that directory can be renamed or deleted only by the owner of the file, by the owner of the directory, and by a privileged process.</p>
</blockquote>
<p>大写 <code>T</code> 表示，有 restricted deletion flag or sticky bit（粘滞位），但是没有执行权限，<code>t</code> 权限只对目录有效，作用是保护目录项不能被其他用户删除。目录要同时具有 <code>x</code> 和 <code>s</code> 才能保证粘滞位有效。</p>
<h3 id="保存的用户-ID-SUID-Saved-User-ID"><a href="#保存的用户-ID-SUID-Saved-User-ID" class="headerlink" title="保存的用户 ID (SUID, Saved User ID)"></a>保存的用户 ID (SUID, Saved User ID)</h3><p>为什么要设置一个 saved set-user-ID 呢？它的意义是，它相当于是一个 buffer， 在 exec 启动进程之后，它会从 effective user ID 位拷贝信息到自己。</p>
<ul>
<li>对于非 root 用户，可以在未来使用 <code>setuid()</code> 来将 effective user ID 设置成为 real user ID 和 saved set-user-ID 中的任何一个。但是非 root 用户是不允许用 <code>setuid()</code> 把 effective user ID 设置成为任何第三个 user id。</li>
<li>对于 root 来说，就没有那么大的意义了。因为 root 调用 setuid() 的时候，将会设置所有的这三个 user ID 位。所以可以综合说，这三个位的设置为为了让 unprivilege user 可以获得两种不同的 permission 而设置的。</li>
</ul>
<p>《Unix 环境高级编程》的例子是，普通用户去执行一个 tip 进程，set-user-ID bit&#x3D;ON，执行起来的时候，进程可以有 uucp (executable owner) 的权限来写 lock 文件，也有当前普通用户的权限来写数据文件。在两种文件操作之间，使用 setuid() 来切换 effective user id。但是正是因为 setuid() 的限制，该进程无法获得更多的第三种用户的权限。</p>
<p>saved set-user-ID 是无法取出来的，是 kernel 来控制的。注意 saved set-user-ID 是进程中的 id，而 set-user-ID bit 则是文件上的权限。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>用户 ID:</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">决定特权</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">EUID</td>
<td align="center">✅ 是</td>
<td align="center">内核权限检查时使用</td>
</tr>
<tr>
<td align="center">RUID</td>
<td align="center">❌ 否</td>
<td align="center">表示谁启动了进程</td>
</tr>
<tr>
<td align="center">FSUID</td>
<td align="center">⚠️ 有时</td>
<td align="center">文件访问权限相关</td>
</tr>
<tr>
<td align="center">SUID</td>
<td align="center">⚠️ 有时</td>
<td align="center">用于权限恢复</td>
</tr>
</tbody></table>
<p>组 ID:</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">EGID</td>
<td align="center">有效组 ID</td>
<td align="center">用于权限检查</td>
</tr>
<tr>
<td align="center">RGID</td>
<td align="center">实际组 ID</td>
<td align="center">表示谁启动了进程</td>
</tr>
<tr>
<td align="center">SGID</td>
<td align="center">保存组 ID</td>
<td align="center">用于权限恢复</td>
</tr>
<tr>
<td align="center">FSGID</td>
<td align="center">文件系统组 ID</td>
<td align="center">文件访问专用</td>
</tr>
</tbody></table>
<p>以上都是讨论用户 ID，如果没有特殊说明，以上的组 ID 和用户 ID 基本是类似的，只是作用对象为组。</p>
<h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><h3 id="符号形式的权限（Symbolic-permissions）"><a href="#符号形式的权限（Symbolic-permissions）" class="headerlink" title="符号形式的权限（Symbolic permissions）"></a>符号形式的权限（Symbolic permissions）</h3><p>符号形式表示文件权限有 5 种：<code>rwxst</code>。</p>
<ul>
<li><p><code>r</code>：可读。对文件来说，意味着能执行 <code>vim</code> 查看、<code>cat</code> 等。对目录来说，意味着能执行 <code>ls</code> 查看其下的文件列表。</p>
</li>
<li><p><code>w</code>：可写。对文件来说，意味着能执行 <code>vim</code> 等工具编辑并保存。对目录来说，意味着能够创建、删除文件或新的目录。</p>
</li>
<li><p><code>x</code>：可执行（文件） &#x2F; 可搜索（目录）。对文件来说，意味着可以执行。对目录来说，意味着能够 <code>cd</code> 进入该目录。</p>
</li>
</ul>
<blockquote>
<p>《UNIX 环境高级编程》P80 中如此描述：</p>
<p>读权限允许我们读目录，获得该目录中所有文件名的列表。当一个目录是我们要访问文件的路径名的一个组成部分时，对该目录的执行权限使我们可以通过该目录（也就是搜索该目录，寻找一个特定的文件名）。</p>
</blockquote>
<blockquote>
<p><code>ls 没有可搜索权限的目录 </code> 可以看到文件列表、文件类型，但是不能看到其他信息，比如文件权限、所有者、大小、修改时间等，因为这些信息保存在 inode 中，必须先 <code>cd</code> 进入该目录，才能读取这些信息。同样，<code>ls -R</code> 不能显示没有执行权限的目录下的子目录下的文件，因为这也必须先 <code>cd</code> 该目录，然后执行 <code>ls</code> 显示子目录的文件。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -lR mydir/</span><br><span class="line"> mydir/:</span><br><span class="line"> <span class="built_in">ls</span>: cannot access <span class="string">&#x27;mydir/dir2&#x27;</span>: Permission denied</span><br><span class="line"> <span class="built_in">ls</span>: cannot access <span class="string">&#x27;mydir/file2&#x27;</span>: Permission denied</span><br><span class="line"> total 0</span><br><span class="line"> d????????? ? ? ? ?            ? dir2</span><br><span class="line"> -????????? ? ? ? ?            ? file2</span><br><span class="line"> <span class="built_in">ls</span>: cannot open directory <span class="string">&#x27;mydir/dir2&#x27;</span>: Permission denied</span><br></pre></td></tr></table></figure>

<p>给目录递归恢复权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> -R u+X mydir/</span><br><span class="line">$ <span class="built_in">ls</span> -lR mydir/</span><br><span class="line"> mydir/:</span><br><span class="line"> total 4</span><br><span class="line"> drwxrwxr-x 3 rotem rotem 4096 Nov  9 10:02 dir2</span><br><span class="line"> -rwxrw-r-- 1 rotem rotem    0 Nov  9 10:03 file2</span><br><span class="line"></span><br><span class="line"> mydir/dir2:</span><br><span class="line"> total 8</span><br><span class="line"> -rwxrw-r-- 1 rotem rotem   10 Nov  8 22:55 1.txt</span><br><span class="line"> -rwxrw-r-- 1 rotem rotem    0 Nov  8 22:55 2.txt</span><br><span class="line"> drwxrwxr-x 2 rotem rotem 4096 Nov  9 10:05 dir3</span><br><span class="line"></span><br><span class="line"> mydir/dir2/dir3:</span><br><span class="line"> total 0</span><br><span class="line"> -rwxrw-r-- 1 rotem rotem 0 Nov  9 10:05 3.txt</span><br></pre></td></tr></table></figure>

<ul>
<li><code>s</code>：即 <code>set-user-ID</code> 权限，如果可执行文件有 <code>s</code> 权限属性，那么任意进程执行该文件时，将自动获得该文件所有者相同的所有权限。如果文件没有 <code>x</code> 权限，却有 <code>s</code> 权限，那么 <code>ls -l</code> 命令将该文件显示为大写的 <code>S</code>。文件只有同时具备 <code>s</code> 权限和 <code>x</code> 权限，才有意义，因为一个文件要应用 <code>set-user-ID</code> 属性，首先要保证其可执行。</li>
</ul>
<p>例如 <code>ping</code> 文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l /bin/ping</span><br><span class="line"> -rwsr-xr-x 1 root root 44168 May  8  2014 /bin/ping</span><br></pre></td></tr></table></figure>

<p>由于设置了 <code>s</code> 权限，所以任何文件都能以 root 用户的身份运行，也就被内核允许打开套接字。</p>
<ul>
<li><p><code>t</code>：即 <code>restricted deletion flag or sticky bit</code>，称为 “粘滞位” 或 “限制删除标记”。仅仅对目录有效，对文件无效。在一个目录上设了 <code>t</code> 权限位后，（如 <code>/home</code>，权限为 <code>1777</code>) 任何的用户都能够在这个目录下创建文档，但只能删除自己创建的文档 (root 除外)，这就对任何用户能写的目录下的用户文档 启到了保护的作用。如果目录 &#x2F; 文件没有 <code>x</code> 权限，却有 <code>s</code> 权限，则 <code>ls -l</code> 命令将目录 &#x2F; 文件显示为大写的 <code>T</code>。目录只有同时具备 <code>t</code> 权限和 <code>x</code> 权限，才有意义，因为一个目录如果本来就不允许增删目录项（<code>x</code> 权限），删除其他用户的文件更无须提了。</p>
<ul>
<li>当一个目录设置了 <code>t</code> 权限时：<ul>
<li>所有用户都可以在该目录中创建文件（如果有写权限）</li>
<li>但只能删除自己创建的文件（当然要有写权限，否则也不能创建文件）</li>
<li><code>root</code> 用户除外，始终可以删除任何文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>例如：<code>/tmp</code> 和 <code>/var/tmp</code> 目录供所有用户暂时存取文件，亦即每位用户皆拥有完整的权限进入该目录，去浏览、删除和移动文件。</p>
<h3 id="数字形式的权限（Numeric-permissions）"><a href="#数字形式的权限（Numeric-permissions）" class="headerlink" title="数字形式的权限（Numeric permissions）"></a>数字形式的权限（Numeric permissions）</h3><p>可以用 4 位八进制数（0-7）表示这些文件权限，由 4、2、1 相加得到，0 表示所有权限都没有。</p>
<p>这 4 位的含义如下：</p>
<ul>
<li>第 1 bit：4 表示 set-user-ID，2 表示 set-group-ID，1 表示 restricted deletion or sticky 属性（粘滞位）；</li>
<li>第 2 bit：表示文件所有者的权限：可读（4）、可写（2）、可执行（1）；</li>
<li>第 3 bit：表示文件所属组的权限：可读（4）、可写（2）、可执行（1）；</li>
<li>第 4 bit：表示其他用户的权限：可读（4）、可写（2）、可执行（1）。</li>
</ul>
<p>以下是 <code>chmod</code> 的 man page 的说明 [^2]：</p>
<blockquote>
<p>A numeric mode is from one to  four  octal  digits  (0-7),  derived  by adding up the bits with values 4, 2, and 1.  Omitted digits are assumed to be leading zeros.  The first digit selects the set user ID  (4)  and set group ID (2) and restricted deletion or sticky (1) attributes.  The second digit selects permissions for the user who owns the  file:  read (4),  write  (2),  and  execute  (1); the third selects permissions for other users in the file’s group, with the same values; and  the  fourth for other users not in the file’s group, with the same values.</p>
</blockquote>
<h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><h3 id="ls-命令"><a href="#ls-命令" class="headerlink" title="ls 命令"></a><code>ls</code> 命令</h3><p><code>ls -l</code> 命令用于查看文件权限。</p>
<h3 id="chmod-命令"><a href="#chmod-命令" class="headerlink" title="chmod 命令"></a><code>chmod</code> 命令</h3><p><code>chmod</code> 命令用于改变文件权限。</p>
<p>基本用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> [OPTION]... MODE[,MODE]... FILE...</span><br><span class="line"><span class="built_in">chmod</span> [OPTION]... OCTAL-MODE FILE...</span><br><span class="line"><span class="built_in">chmod</span> [OPTION]... --reference=RFILE FILE...</span><br></pre></td></tr></table></figure>

<p>** 大写 <code>X</code> 参数 ** <a target="_blank" rel="noopener" href="https://www.franzoni.eu/chmod-and-the-capital-x/">^1</a>：</p>
<p>例如 <code>chmod u+X filename</code> 或 <code>chmod u-X filename</code>。</p>
<p>在 <code>chmod</code> 的 man page 中介绍如下：</p>
<blockquote>
<p>The  letters <code>rwxXst</code> select file mode bits for the affected users: read (<code>r</code>), write (<code>w</code>), execute (or search for directories) (<code>x</code>), <strong>execute&#x2F;search only if the file is a directory or<br>  already has execute permission for some user (<code>X</code>)</strong>, set user or group ID on execution (<code>s</code>), restricted deletion flag or sticky bit (<code>t</code>) [^2].</p>
</blockquote>
<p>加黑体的话很费解，但是又十分准确，解释如下：</p>
<ol>
<li><p>对所有目录赋予执行权限，这意味着可以执行 <code>cd</code>。</p>
</li>
<li><p>对所有文件，如果原来文件的 <code>ugo</code>（user &#x2F; group &#x2F; others）任意一个原先有执行权限，那么动作与小写 <code>-x</code> 参数相同；如果原先没有，那么忽略。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<blockquote>
<p>-rw-rw-r– 1 rotem rotem 0 Nov  9 10:55 file1<br>-rw-rw-r-x 1 rotem rotem 0 Nov  9 10:56 file2</p>
</blockquote>
<p>可以看到，原来 file1 的 <code>ugo</code> 都不具备执行权限，file2 的 others 具备执行权限。</p>
<ul>
<li>对 file1 执行 <code>X</code> 动作，将无效：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> u+X file1</span><br><span class="line"><span class="built_in">ls</span> -l file1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>-rw-rw-r– 1 rotem rotem 0 Nov  9 10:55 file1</p>
</blockquote>
<ul>
<li>但是对 file2 执行 <code>X</code>，能够生效：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> u+X file2</span><br><span class="line"><span class="built_in">ls</span> -l file2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>-rwxrw-r-x 1 rotem rotem 0 Nov  9 10:56 file2</p>
</blockquote>
<p>题外话：<code> chmod -R u-X mydir</code> 该命令无法递归执行，因为当执行完顶层目录的权限更改之后，已经没有权限 <code>cd</code> 顶层目录了，其他执行全部被停止。</p>
</li>
</ol>
<ul>
<li>getfacl&#x2F;setfacl</li>
<li>umask</li>
</ul>
<h2 id="SELinux-权限"><a href="#SELinux-权限" class="headerlink" title="SELinux 权限"></a>SELinux 权限</h2><p>SELinux 提供更为严格的访问控制。<br>可以用 <code>ls -Z</code> 查看文件的 SELinux 权限（安全上下文）。这部分将来另用一篇博客说明。暂时可以参考文献 [^3]。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[^2]: chmod 的 man page<br>[^3]:<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/73621cc7c222">https://www.jianshu.com/p/73621cc7c222</a><br>[^4]:<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/User_identifier#Saved_user_ID">https://en.wikipedia.org/wiki/User_identifier#Saved_user_ID</a><br>[^5]:<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/32455684/difference-between-real-user-ID-effective-user-ID-and-saved-user-ID">https://stackoverflow.com/questions/32455684/difference-between-real-user-ID-effective-user-ID-and-saved-user-ID</a><br>[^6]:<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1722142">https://cloud.tencent.com/developer/article/1722142</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/16/net/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/16/net/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">网络编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-16 20:01:24" itemprop="dateCreated datePublished" datetime="2025-08-16T20:01:24+00:00">2025-08-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-04 17:56:31" itemprop="dateModified" datetime="2025-09-04T17:56:31+00:00">2025-09-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="系统文件"><a href="#系统文件" class="headerlink" title="系统文件"></a>系统文件</h2><p><code>/etc/services</code>: 端口列表<br><code>/etc/protocols</code>: 协议列表</p>
<h2 id="socket-参数"><a href="#socket-参数" class="headerlink" title="socket 参数"></a>socket 参数</h2><h3 id="SO-REUSEADDR"><a href="#SO-REUSEADDR" class="headerlink" title="SO_REUSEADDR"></a>SO_REUSEADDR</h3><p>主要功能：允许端口重用。客户端一般不用，只在服务端常见。<br>更准确地说，它有几个具体效果（以 TCP 为例）：</p>
<p>TIME_WAIT 状态下可重绑定</p>
<p>正常情况下，当服务端关闭套接字，端口进入 TIME_WAIT 状态（持续 ~1-4 分钟）</p>
<p>如果不设置 SO_REUSEADDR，你必须等 TIME_WAIT 结束才能再次 bind() 相同端口</p>
<p>设置后，可以立即重新 bind()</p>
<p>多个套接字绑定到同一个端口（但 IP 必须不同）</p>
<p>常见于多播、广播，或者一台机器上多个不同地址绑定同一个端口</p>
<p>Linux 特性：允许 相同 IP 和端口 多个套接字同时监听（结合 SO_REUSEPORT 使用更常见，nginx 就依赖这个做负载均衡）。</p>
<h4 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h4><p>TIME_WAIT 只会出现在主动关闭连接的一方。</p>
<p>一般情况：客户端主动关闭 → 客户端 TIME_WAIT，服务端不需要考虑</p>
<p>特殊情况：如果服务端主动关闭 listen_fd（例如服务进程退出后重启），就会产生 TIME_WAIT，需要优化手段。</p>
<h3 id="SO-REUSEPORT"><a href="#SO-REUSEPORT" class="headerlink" title="SO_REUSEPORT"></a>SO_REUSEPORT</h3><p>多进程&#x2F;线程共享端口（同一IP+端口），避免 TIME_WAIT 堆积影响单个进程。前提是都设置了 SO_REUSEPORT）。</p>
<p>内核会 均匀分发新连接 到这些套接字（负载均衡）。</p>
<p>常见用途：</p>
<ul>
<li>高性能网络服务（nginx、redis、haproxy 等）</li>
<li>利用多进程&#x2F;多线程提升网络吞吐量</li>
</ul>
<p>与 SO_REUSEADDR 的区别</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>SO_REUSEADDR</td>
<td>允许端口在 TIME_WAIT 状态下重用</td>
<td>服务端重启，避免 “Address already in use”</td>
</tr>
<tr>
<td>SO_REUSEPORT</td>
<td>允许同一端口被多个进程&#x2F;线程同时绑定，内核负载均衡</td>
<td>高性能多进程网络服务</td>
</tr>
</tbody></table>
<ul>
<li>SO_REUSEADDR → 解决 TIME_WAIT 问题</li>
<li>SO_REUSEPORT → 解决 多进程监听同一端口的负载均衡</li>
</ul>
<h3 id="TCP-NODELAY"><a href="#TCP-NODELAY" class="headerlink" title="TCP_NODELAY"></a>TCP_NODELAY</h3><p>用于关闭 Nagle 算法。</p>
<ul>
<li><p>背景：Nagle 算法</p>
<ul>
<li><p>Nagle 算法的作用：</p>
<p>把很多小的 TCP 包合并成一个大包再发送，以减少网络中小包的数量，提高效率。</p>
<blockquote>
<p>规则：如果前一个包还没被确认（ACK），新的小包不要立刻发送，而是先缓存，等到收到 ACK 或者缓冲区积累够大时再发。</p>
<ol>
<li>如果要发送的数据很大（≥ MSS，最大报文段长度），直接发。</li>
<li>如果应用要发小数据：<ul>
<li>有未确认的包 → 暂时把新数据放在缓冲区里，不发。</li>
<li>收到了 ACK → 把缓存的数据打包一起发送。</li>
</ul>
</li>
</ol>
</blockquote>
</li>
<li><p>代价：</p>
<p>会造成 延迟（例如即时通信、RPC 请求这种场景，一次 send() 可能会等下一个小包一起发）。</p>
</li>
</ul>
</li>
</ul>
<p>✅ 建议使用的场景：</p>
<ul>
<li>RPC 框架</li>
<li>即时通讯（IM）</li>
<li>游戏服务器（低延迟要求）</li>
<li>高频短小消息的交互</li>
</ul>
<p>❌ 不建议使用的场景：</p>
<ul>
<li>大文件传输（比如 HTTP 下载）</li>
<li>视频流、音频流（关闭 Nagle 反而降低效率）</li>
</ul>
<h3 id="SO-KEEPALIVE"><a href="#SO-KEEPALIVE" class="headerlink" title="SO_KEEPALIVE"></a>SO_KEEPALIVE</h3><p>开启 SO_KEEPALIVE 后，内核在后台做三件事（以 Linux 默认值为例，可能因系统不同而不同）：</p>
<ul>
<li><p>tcp_keepalive_time（默认 7200s &#x3D; 2小时）<br>如果一个连接在 tcp_keepalive_time 时间内都没有任何数据往来，内核会开始发送探测包。</p>
</li>
<li><p>tcp_keepalive_intvl（默认 75s）<br>探测包之间的间隔。</p>
</li>
<li><p>tcp_keepalive_probes（默认 9次）<br>如果连续 tcp_keepalive_probes 次探测都没有回应，内核会认为连接已经断开，并通知应用层 read()&#x2F;recv() 返回 0 或 ECONNRESET。</p>
</li>
</ul>
<p>可以通过 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_keepalive_* 修改这些参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_keepalive_time</span><br><span class="line"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_keepalive_intvl</span><br><span class="line"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_keepalive_probes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改方式</span></span><br><span class="line">sysctl -w net.ipv4.tcp_keepalive_time=600</span><br></pre></td></tr></table></figure>

<p>应用场景</p>
<ul>
<li>长连接 RPC、心跳检测：避免死连接无限挂着。</li>
<li>服务端防止资源泄漏：客户端异常掉线时，服务端能最终释放连接。</li>
<li>中间设备 NAT&#x2F;防火墙：如果链路长时间无流量，可能被踢掉，Keepalive能保持活动状态（但注意默认周期太长，往往要调低）。</li>
</ul>
<p>RESET vs KeepAlive</p>
<ul>
<li><p>客户端正常断开</p>
<ul>
<li><p>客户端调用 close() 或 shutdown()</p>
</li>
<li><p>会向服务端发送 FIN，服务端的 read() 返回 0</p>
</li>
<li><p>这是“主动优雅关闭”，服务端能马上感知</p>
<p>✅ 这种情况下不需要 SO_KEEPALIVE</p>
</li>
</ul>
</li>
<li><p>客户端异常掉线（断电、拔网线、进程挂掉）</p>
<ul>
<li><p>TCP 不能立即知道对方掉线</p>
</li>
<li><p>为什么？</p>
<ul>
<li>TCP 是端到端协议，除非收到 RST 或 FIN，否则内核认为连接仍然存在</li>
<li>异常掉线不会发送 FIN</li>
<li>网络异常（如网线拔掉）也不会发送 RST</li>
<li>这时服务端的 read() &#x2F; write() 不会马上报错</li>
<li>写时可能阻塞</li>
<li>读时可能一直阻塞</li>
</ul>
<p>✅ 所以需要 SO_KEEPALIVE 来让内核周期性探测，最终发现对方掉线</p>
</li>
</ul>
</li>
<li><p>客户端发送 RST 的情况</p>
<ul>
<li>RST 只在一些场景出现：<ul>
<li>客户端向已经关闭的套接字写数据</li>
<li>本地进程调用 abort()</li>
</ul>
</li>
<li>但 异常掉线（掉电、断网、进程被 kill -9）不会发 RST</li>
<li>因此 服务端不能依赖 RST 来发现死连接</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>场景</th>
<th>服务端能否立即发现</th>
<th>是否需要 Keepalive</th>
</tr>
</thead>
<tbody><tr>
<td>客户端正常 close()</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>客户端异常掉线（断电、拔网线）</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>客户端本地 abort() 或 write 已关闭套接字</td>
<td>是（会收到 RST）</td>
<td>否</td>
</tr>
</tbody></table>
<p>所以 SO_KEEPALIVE 主要用于发现客户端异常掉线。没有它，长连接可能永远挂在 ESTABLISHED，资源泄漏。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/392820963">端口0的作用</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/16/os/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/16/os/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/" class="post-title-link" itemprop="url">用户态和内核态</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-16 13:31:26" itemprop="dateCreated datePublished" datetime="2025-08-16T13:31:26+00:00">2025-08-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-04 17:56:31" itemprop="dateModified" datetime="2025-09-04T17:56:31+00:00">2025-09-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="用户空间和内核空间是隔离的"><a href="#用户空间和内核空间是隔离的" class="headerlink" title="用户空间和内核空间是隔离的"></a>用户空间和内核空间是隔离的</h2><p>切换内核态和用户态为什么要内存复制？</p>
<table>
<thead>
<tr>
<th>问题</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>安全性</td>
<td>用户程序可能传入非法地址，导致内核崩溃或被利用攻击</td>
</tr>
<tr>
<td>稳定性</td>
<td>用户程序可能在 <code>poll()</code> 返回前修改数组，导致内核读取不一致</td>
</tr>
<tr>
<td>内存管理</td>
<td>用户空间内存可能被 swap 出或者释放，内核无法保证访问有效</td>
</tr>
</tbody></table>
<h2 id="内核态"><a href="#内核态" class="headerlink" title="内核态"></a>内核态</h2><p>我们在说“切换到内核态”时，其实指的是 CPU 特权级别从用户态（ring3）切换到内核态（ring0） 的过程。</p>
<p>用户态 vs 内核态</p>
<p>用户态（user mode）</p>
<p>应用程序（比如你写的 C++ 程序）运行的环境。</p>
<p>权限受限，不能直接操作硬件（如磁盘、网卡），也不能随便访问内核内存。</p>
<p>只能通过 系统调用 (syscall) 向内核请求服务。</p>
<p>内核态（kernel mode）</p>
<p>操作系统内核运行的环境。</p>
<p>拥有最高权限（ring0），可以操作 CPU 指令集、内存管理、驱动、硬件寄存器。</p>
<p>系统调用的实现代码就在内核态里。</p>
<p>“切换到内核态”的过程</p>
<p>当你调用一个系统调用，比如：</p>
<p>read(fd, buf, size);</p>
<p>你的程序在 用户态，调用 read()。</p>
<p>实际上 read() 会触发一条特殊指令（例如 Linux x86-64 用 syscall 指令）。</p>
<p>CPU 捕捉到这个指令，自动：</p>
<p>从用户态切换到内核态。</p>
<p>切换到内核栈。</p>
<p>保存用户态寄存器上下文。</p>
<p>跳到系统调用处理函数（比如 sys_read）。</p>
<p>内核态代码执行 sys_read，比如访问文件系统、检查 socket buffer。</p>
<p>处理完后返回，CPU 再切回用户态，恢复上下文，继续执行应用代码。</p>
<p>🔹 为什么要区分用户态&#x2F;内核态？</p>
<p>安全：用户程序不能直接操作硬件。</p>
<p>稳定性：即使用户程序崩溃，内核和其他进程不会受影响。</p>
<p>性能隔离：内核提供抽象（系统调用接口），避免应用直接干扰底层资源。</p>
<p>✅ 所以，总结一句：<br>“切换到内核态”就是 CPU 从运行普通用户代码（权限受限）切换到执行内核代码（最高权限）的过程，常常发生在系统调用、异常、硬件中断时。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/16/cpp/C++%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/16/cpp/C++%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/" class="post-title-link" itemprop="url">C++右值引用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-16 10:54:08" itemprop="dateCreated datePublished" datetime="2025-08-16T10:54:08+00:00">2025-08-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-04 17:56:31" itemprop="dateModified" datetime="2025-09-04T17:56:31+00:00">2025-09-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-左值、将亡值、纯右值"><a href="#1-左值、将亡值、纯右值" class="headerlink" title="1. 左值、将亡值、纯右值"></a>1. 左值、将亡值、纯右值</h2><p>C++11的值必定属于：左值、右值（将亡值、纯右值）三者之一。不是左值就是右值。详见值类别。</p>
<ul>
<li><strong>左值</strong>的特点：“有名字、可以取址”。没有名字或者不能取址，则必定是右值。</li>
<li><strong>右值</strong>的特点：即将消亡，也就是说“会被析构”。<ul>
<li><strong>纯右值</strong>：一定没有名字。比如除去<code>string</code>之外字面值常量、函数返回值、运算表达式。</li>
<li><strong>将亡值</strong>：即将消亡的值：比如临时变量，一旦离开作用域就会被销毁；可能没有名字，例如函数的返回值（非引用）。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">A</span>(); <span class="comment">// 匿名对象的作用域仅限于语句中，一旦离开当前语句，就会析构。</span></span><br><span class="line">    <span class="built_in">getchar</span>(); <span class="comment">// 暂停</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-引用、右值引用"><a href="#2-引用、右值引用" class="headerlink" title="2. 引用、右值引用"></a>2. 引用、右值引用</h2><p>右值引用涉及“右值”和“引用”两个概念。</p>
<ul>
<li><strong>引用</strong>不是对象，所以定义一个“右值引用”不会调用构造函数，避免了多余的构造过程。</li>
<li><strong>右值</strong>是即将析构的值，把右值绑定到右值引用上，延长了右值的生命期，所以右值对象没有析构。</li>
</ul>
<h3 id="右值引用规则："><a href="#右值引用规则：" class="headerlink" title="右值引用规则："></a>右值引用规则：</h3><ul>
<li>可以把左值绑定到左值引用。</li>
<li>可以把右值绑定到右值引用。</li>
<li>不允许把左值绑定到右值引用。</li>
<li>不允许把右值绑定到左值引用。</li>
<li><code>const</code>左值引用可以接受左值或右值。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a1 = <span class="number">10</span>; <span class="comment">// 10是纯右值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; aa = <span class="number">10</span>; <span class="comment">// 常量引用可以接受右值</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; aaa = <span class="number">10</span>; <span class="comment">// 右值引用接受右值</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-引用和右值引用是左值"><a href="#3-引用和右值引用是左值" class="headerlink" title="3. 引用和右值引用是左值"></a>3. 引用和右值引用是左值</h2><p>引用（包括右值引用）本身是左值，可以取址，但不能对右值取址。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(<span class="type">int</span>&amp; t)</span> </span>&#123; <span class="comment">// 接受一个左值参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(<span class="type">int</span>&amp;&amp; t)</span> </span>&#123; <span class="comment">// 接受一个右值参数，但t本身是左值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>&amp;&amp; ra = <span class="built_in">move</span>(a); <span class="comment">// move(a)返回一个右值，ra却是一个左值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fun1</span>(ra); <span class="comment">// 正确：ra是左值，可以绑定到左值引用</span></span><br><span class="line">    <span class="built_in">fun2</span>(<span class="built_in">move</span>(a)); <span class="comment">// 正确：move(a)返回一个右值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-复制构造函数和移动构造函数"><a href="#4-复制构造函数和移动构造函数" class="headerlink" title="4. 复制构造函数和移动构造函数"></a>4. 复制构造函数和移动构造函数</h2><h3 id="为什么右值引用的构造函数被视为“移动”语义？"><a href="#为什么右值引用的构造函数被视为“移动”语义？" class="headerlink" title="为什么右值引用的构造函数被视为“移动”语义？"></a>为什么右值引用的构造函数被视为“移动”语义？</h3><p>因为输入参数是一个引用（右值引用也是引用），可以直接访问所引对象的资源并接管它，同时将源对象的资源置空。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp;) &#123; cout &lt;&lt; <span class="string">&quot;A(const A&amp;)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp;) &#123; cout &lt;&lt; <span class="string">&quot;A(A&amp;&amp;)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="function">A <span class="title">b</span><span class="params">(std::move(a))</span></span>; <span class="comment">// 调用移动构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-完美转发"><a href="#5-完美转发" class="headerlink" title="5. 完美转发"></a>5. 完美转发</h2><p>完美转发是指对模板参数实现完美转发：即输入什么类型（左值、右值）的参数，就是什么类型的参数。</p>
<h3 id="引用折叠规则："><a href="#引用折叠规则：" class="headerlink" title="引用折叠规则："></a>引用折叠规则：</h3><ul>
<li>如果有左值引用，优先折叠成左值引用。</li>
<li>如果只有右值引用，参数推导成右值引用。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunCode</span><span class="params">(<span class="type">int</span>&amp; m)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;lvalue ref&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunCode</span><span class="params">(<span class="type">int</span>&amp;&amp; m)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;rvalue ref&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerfectForward</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RunCode</span>(<span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(t)); <span class="comment">// 保证完美转发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">PerfectForward</span>(a); <span class="comment">// lvalue ref</span></span><br><span class="line">    <span class="built_in">PerfectForward</span>(<span class="built_in">move</span>(a)); <span class="comment">// rvalue ref</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-移动构造函数、移动赋值函数、复制构造函数、复制赋值函数"><a href="#6-移动构造函数、移动赋值函数、复制构造函数、复制赋值函数" class="headerlink" title="6. 移动构造函数、移动赋值函数、复制构造函数、复制赋值函数"></a>6. 移动构造函数、移动赋值函数、复制构造函数、复制赋值函数</h2><h3 id="移动构造函数的注意事项："><a href="#移动构造函数的注意事项：" class="headerlink" title="移动构造函数的注意事项："></a>移动构造函数的注意事项：</h3><ul>
<li>移动构造函数不允许抛出异常，建议添加<code>noexcept</code>关键字。</li>
<li>使用<code>std::move_if_noexcept</code>可以在移动构造函数抛出异常时回退到复制构造函数。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp;) &#123; cout &lt;&lt; <span class="string">&quot;A(const A&amp;)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp;) <span class="keyword">noexcept</span> &#123; cout &lt;&lt; <span class="string">&quot;A(A&amp;&amp;)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="function">A <span class="title">b</span><span class="params">(std::move(a))</span></span>; <span class="comment">// 调用移动构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-编译器优化"><a href="#7-编译器优化" class="headerlink" title="7. 编译器优化"></a>7. 编译器优化</h2><p>编译器默认会采用“返回值优化”（RVO或NRVO）。要观察移动语义与复制语义的不同，应该关闭编译器优化。</p>
<p>关闭优化命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o <span class="built_in">test</span> main.cc -fno-elide-constructors</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8-合成的移动操作"><a href="#8-合成的移动操作" class="headerlink" title="8. 合成的移动操作"></a>8. 合成的移动操作</h2><p>如果没有定义复制构造&#x2F;赋值函数，编译器会为我们合成（浅复制）。但如果自定义了复制构造函数、复制赋值运算符或析构函数，编译器将不会合成移动构造&#x2F;赋值函数。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp;) &#123; cout &lt;&lt; <span class="string">&quot;A(const A&amp;)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp;) &#123; cout &lt;&lt; <span class="string">&quot;A(A&amp;&amp;)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="function">A <span class="title">b</span><span class="params">(std::move(a))</span></span>; <span class="comment">// 调用移动构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="9-std-move的实现"><a href="#9-std-move的实现" class="headerlink" title="9. std::move的实现"></a>9. <code>std::move</code>的实现</h2><p><code>std::move</code>是一个类型转换，没有完成其他工作。</p>
<p>实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">typename</span> std::remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="10-unique-ptr与std-move"><a href="#10-unique-ptr与std-move" class="headerlink" title="10. unique_ptr与std::move"></a>10. <code>unique_ptr</code>与<code>std::move</code></h2><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; p = std::<span class="built_in">move</span>(up); <span class="comment">// 现在up为空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释：<code>std::move</code>调用<code>unique_ptr</code>的移动构造函数，转移<code>up</code>所拥有的资源，并将<code>up</code>置为空。</p>
<hr>
<h2 id="11-右值与sizeof"><a href="#11-右值与sizeof" class="headerlink" title="11. 右值与sizeof"></a>11. 右值与<code>sizeof</code></h2><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="built_in">int</span>()) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="number">10</span>) &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl; <span class="comment">// 8</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="built_in">A</span>()) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="built_in">f</span>()) &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《深入理解C++11: C++新特性解析与应用》</li>
<li>《C++ Primer 第五版》</li>
<li>C++中文 - API参考文档</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/blog/">1</a><span class="page-number current">2</span><a class="page-number" href="/blog/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/10/">10</a><a class="extend next" rel="next" href="/blog/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="bi-an"
      src="/blog/images/avatar.gif">
  <p class="site-author-name" itemprop="name">bi-an</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">97</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/bi-an" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;bi-an" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ah_zzg@126.com" title="E-Mail → mailto:ah_zzg@126.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://cuda-doc.readthedocs.io/" title="https:&#x2F;&#x2F;cuda-doc.readthedocs.io" rel="noopener" target="_blank">CUDA中文手册</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://infiniband-doc.readthedocs.io/" title="https:&#x2F;&#x2F;infiniband-doc.readthedocs.io&#x2F;" rel="noopener" target="_blank">InfiniBand中文手册</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bi-an</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>




  




  
<script src="/blog/js/local-search.js"></script>













  

  

</body>
</html>
