---
title: 智能指针
date: 2025-08-12 10:16:44
tags: c/cpp
---

## shared_ptr是线程安全的吗？

[Boost官网：shared_ptr_thread_safety](https://www.boost.org/doc/libs/1_82_0/libs/smart_ptr/doc/html/smart_ptr.html#shared_ptr_thread_safety)

shared_ptr与内建类型（比如int, char；std::string不是内建类型）具有相同的线程安全等级：
- 同一个shared_ptr可以被并发读；
- 不同的shared_ptr可以被并发写（析构也是写）。
- 其他并发访问是未定义的。

Examples:
```cpp
shared_ptr<int> p(new int(42));
```

Code Example 4. Reading a shared_ptr from two threads
```cpp
// thread A
shared_ptr<int> p2(p); // reads p

// thread B
shared_ptr<int> p3(p); // OK, multiple reads are safe
```
读取同一个shared_ptr是线程安全的。
同时增加引用计数，安全。

Code Example 5. Writing different shared_ptr instances from two threads
```cpp
// thread A
p.reset(new int(1912)); // writes p

// thread B
p2.reset(); // OK, writes p2
```
写不同的shared_ptr实例是线程安全的。
不同的实例各自更新自己的引用计数控制块指针，安全。
对共同掌管的资源的引用计数原子减1，安全。

Code Example 6. Reading and writing a shared_ptr from two threads
```cpp
// thread A
p = p3; // reads p3, writes p

// thread B
p3.reset(); // writes p3; undefined, simultaneous read/write
```
同时读写同一个shared_ptr实例，是线程不安全的。
同时对引用计数进行增减，如果先看到减到0，那么可能资源已经被释放。

Code Example 7. Reading and destroying a shared_ptr from two threads
```cpp
// thread A
p3 = p2; // reads p2, writes p3

// thread B
// p2 goes out of scope: undefined, the destructor is considered a "write access"
```
同时读写（析构也是写）同一个shared_ptr实例，是线程不安全的。

Code Example 8. Writing a shared_ptr from two threads
```cpp
// thread A
p3.reset(new int(1));

// thread B
p3.reset(new int(2)); // undefined, multiple writes
```
同时写同一个shared_ptr，可能对引用计数操作多次（应该只能操作一次），线程不安全。



**测试：模拟潜在竞态条件：**

最后一个引用即将销毁时，另一个线程试图复制

<details>
<summary>示例1：复制构造和reset()竞争</summary>

{% include_code lang:cpp shared_ptr/race1.cpp %}

</details>

总结： `reset()` 与复制构造需要加锁保护。

<details>
<summary>示例2：复制构造和析构竞争</summary>

{% include_code lang:cpp shared_ptr/race2.cpp %}

</details>


**总结：**

- 不能以左值引用来复制构造shared_ptr，否则会存在竞争。
- 可以使用const引用，因为可以延续shared_ptr的生命期，析构被推迟，间接消除了竞态。
- 程序中shared_ptr读写操作同时存在时，需要加锁。
- 要防止shared_ptr析构：在shared_ptr副本的整个作用域内加锁同样可以保护这种情况。
- C++20 开始支持 `atomic<shared_ptr<T>>`，可以安全地在多个线程之间共享和更新 shared_ptr。
- 如果 thread A 只是想观察 p2 是否还存在，可以使用 std::weak_ptr 来观察。


## shared_ptr为什么要隐式自持一个weak count？

每个 shared_ptr 和 weak_ptr 都指向一个 控制块（control block），这个控制块通常包含：

| 名称           | 作用                                                |
|----------------|-----------------------------------------------------|
| strong count   | 当前活跃的 shared_ptr 数量                          |
| weak count     | 当前活跃的 weak_ptr 数量 + 当前活跃的 shared_ptr 数量 |
| 指向对象的指针 | 被管理的资源                                        |

控制块的生命周期由 weak count 决定，只要还有 weak_ptr 或 shared_ptr 存在，控制块就不能被销毁。

- weak_ptr和shared_ptr可能存在只有两者之一的情况，所以他们都必须要维护控制块的生命周期。
- 如果只有weak_ptr对weak count进行计数，那么可能出现shared_ptr和weak_ptr共同看到weak count为0的情况：
  - weak_ptr析构将weak count降低为0，准备释放控制块；
  - shared_ptr析构或reset，检测到weak count为0，准备释放控制块；
  - 这样就释放了两次，因为他们都持有指针，且没有设置相互通知的机制。
- 但是，如果weak_ptr和shared_ptr都对weak count进行计数，那么就不可能同时观察到weak count为0的情况。


## 动手实现一个shared_ptr

<details>
<summary>SimpleSharedPtr</summary>

{% include_code lang:cpp shared_ptr/SimpleSharedPtr.cpp %}

</details>

## 附录：shared_ptr源码

https://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/index.html

- `/usr/include/c++/11/bits/shared_ptr.h`
- `/usr/include/c++/11/bits/shared_ptr_base.h`
- `/usr/include/c++/11/bits/shared_ptr_atomic.h`

<details>
<summary>shared_ptr.h</summary>
{% include_code lang:cpp shared_ptr/shared_ptr.h %}
</details>

<details>
<summary>shared_ptr_base.h</summary>
{% include_code lang:cpp shared_ptr/shared_ptr_base.h %}
</details>

<details>
<summary>shared_ptr_atomic.h</summary>
{% include_code lang:cpp shared_ptr/shared_ptr_atomic.h %}
</details>

