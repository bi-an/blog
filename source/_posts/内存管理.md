---
title: 内存管理
date: 2025-08-19 20:12:58
categories: 
tags:
---

## 线程安全性

malloc 是线程安全的，但有一些细节需要注意。

1. 线程安全含义

线程安全：多个线程同时调用 malloc/free 不会破坏堆管理结构，也不会导致内存管理崩溃。

实现方法：

glibc malloc 在内部使用 锁（mutex 或 spinlock） 保护全局堆管理数据结构

不同线程同时申请或释放内存，内核保证堆表一致

2. 限制与注意事项

性能问题

多线程频繁 malloc/free，锁竞争可能成为瓶颈

对性能敏感的程序可能使用：

线程本地缓存（thread-local cache） 的 jemalloc / tcmalloc

避免全局锁竞争

信号处理上下文不安全

虽然线程安全，但 malloc 在信号处理函数里不安全

原因：

信号可能打断正在执行的 malloc

malloc 内部锁可能被持有 → 再次调用可能死锁

所以 signal handler 中不能直接调用 malloc/free

| 特性         | malloc/glibc                  |
| ---------- | ----------------------------- |
| 多线程调用安全    | ✅ 是线程安全的                      |
| 信号处理函数调用安全 | ❌ 不安全                         |
| 性能         | 可能锁竞争，需要优化（jemalloc/tcmalloc） |


## 信号安全

malloc / free 内部会修改全局堆管理结构（如 free list）

如果信号到达时主程序正在调用 malloc 或 free，信号处理函数里再次调用 malloc/free → 堆数据结构可能被破坏，
可能导致崩溃或内存泄漏

虽然线程安全，但 malloc 在信号处理函数里不安全

原因：

- 信号可能打断正在执行的 malloc
- malloc 内部锁可能被持有 → 再次调用可能死锁

所以 signal handler 中不能直接调用 malloc/free

### 安全做法

信号处理函数里只做：

- 设置标志位（sig_atomic_t flag = 1;）
- 写入 pipe / eventfd
- 调用 async-signal-safe 系统调用（write(), _exit()）

之后由主程序在安全上下文处理 malloc/free 或其他复杂操作

