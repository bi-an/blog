<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>原子变量</title>
      <link href="/blog/2025/03/19/%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F/"/>
      <url>/blog/2025/03/19/%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>当两个线程同时修改原子变量时，以下操作会发生：</p><p>原子性：原子变量的修改是原子的，即每次修改都是一个不可分割的操作。这意味着在任何时刻，只有一个线程能够成功地修改原子变量，而不会出现竞争条件。</p><p>同步机制：原子变量使用硬件级别的同步机制（如锁、比较并交换操作等）来确保修改的原子性。这些机制确保线程在修改原子变量时不会干扰其他线程的操作。</p><p>内存可见性：原子变量的修改会确保内存可见性，即一个线程对原子变量的修改会立即对其他线程可见。这意味着其他线程可以看到最新的修改结果，而不会读取到过时的数据。</p><p>举个例子，假设我们有一个原子变量 <code>std::atomic&lt;int&gt; counter</code>，两个线程同时执行 <code>counter++</code> 操作：</p><figure class="highlight cpp"><figcaption><span>atomic1.cpp</span><a href="/blog/downloads/code/atomic/atomic1.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) {</span><br><span class="line">        counter++;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final counter value: &quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><p>两个线程 t1 和 t2 同时执行 increment 函数，尝试修改原子变量 counter。<br>原子性 确保每次 <code>counter++</code> 操作都是不可分割的，避免竞争条件。<br>同步机制 确保两个线程不会同时修改 counter，而是一个线程成功修改后，另一个线程才能继续修改。<br>内存可见性 确保 counter 的最新值对两个线程都是可见的。</p><h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><p>让我们深入探讨一下两个线程同时修改原子变量时的底层机制。</p><ol><li><p>原子操作的硬件支持<br>原子操作通常由硬件指令支持，这些指令确保操作的原子性。例如，x86架构提供了 <code>LOCK</code> 前缀，用于确保指令在多处理器环境中的原子性。常见的原子指令包括 <code>LOCK XADD</code>（原子加法）和 <code>LOCK CMPXCHG</code>（原子比较并交换）。</p></li><li><p>缓存一致性协议<br>多核处理器使用缓存一致性协议（如<code>MESI</code>协议）来确保各个处理器缓存中的数据一致性。当一个处理器修改原子变量时，缓存一致性协议会确保其他处理器的缓存中对应的数据无效或更新。</p></li><li><p>内存屏障<br>内存屏障（Memory Barrier）是一种指令，用于防止编译器和处理器对内存操作进行重排序。原子操作通常会使用内存屏障来确保操作的顺序性和可见性。例如，<code>std::atomic</code> 在实现时会使用内存屏障来确保操作的正确性。</p></li><li><p>比较并交换（CAS）<br>比较并交换（Compare-And-Swap, CAS）是一种常用的原子操作，它通过比较变量的当前值和预期值，如果相等则更新变量的值。CAS操作是无锁编程的基础，用于实现许多并发数据结构。</p></li><li><p>伪代码示例<br>以下是一个伪代码示例，展示了CAS操作的工作原理：</p></li></ol><figure class="highlight cpp"><figcaption><span>cas_mock.cpp</span><a href="/blog/downloads/code/atomic/cas_mock.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_and_swap</span><span class="params">(<span class="type">int</span>* ptr, <span class="type">int</span> old_value, <span class="type">int</span> new_value)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (*ptr == old_value) {</span><br><span class="line">        *ptr = new_value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在多线程环境中，CAS操作可以确保只有一个线程成功修改变量的值，而其他线程会失败并重试。</p><ol start="6"><li>实际应用<br>在实际应用中，原子变量的操作可能如下所示：</li></ol><figure class="highlight cpp"><figcaption><span>atomic2.cpp</span><a href="/blog/downloads/code/atomic/atomic2.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) {</span><br><span class="line">        <span class="type">int</span> expected = counter.<span class="built_in">load</span>();</span><br><span class="line">        <span class="keyword">while</span> (!counter.<span class="built_in">compare_exchange_weak</span>(expected, expected + <span class="number">1</span>)) {</span><br><span class="line">            <span class="comment">// 重试，直到成功</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final counter value: &quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在这个例子中，compare_exchange_weak 使用CAS操作来确保 counter 的原子性修改。每次修改失败时，线程会重试，直到成功。</p><h3 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h3><p>缓存一致性协议是确保多核处理器中各个缓存之间数据一致性的机制。最常见的缓存一致性协议是MESI协议。让我们详细解释一下。</p><p><strong>MESI协议</strong></p><p>MESI协议是由四种状态组成的缓存一致性协议，每个缓存行（Cache Line）可以处于以下四种状态之一：</p><ul><li>Modified（修改）：缓存行中的数据已被修改，与主内存中的数据不一致，且该数据仅存在于当前缓存中。</li><li>Exclusive（独占）：缓存行中的数据与主内存中的数据一致，且该数据仅存在于当前缓存中。</li><li>Shared（共享）：缓存行中的数据与主内存中的数据一致，且该数据可能存在于多个缓存中。</li><li>Invalid（无效）：缓存行中的数据无效。</li></ul><p><strong>状态转换</strong></p><p>缓存行的状态会根据不同的操作进行转换。以下是一些常见的状态转换：</p><p>从主内存读取数据：如果一个缓存行处于Invalid状态，当一个处理器读取该数据时，缓存行会变为Shared或Exclusive状态。<br>修改数据：如果一个缓存行处于Shared或Exclusive状态，当一个处理器修改该数据时，缓存行会变为Modified状态，并通知其他缓存将该缓存行置为Invalid状态。<br>写回数据：如果一个缓存行处于Modified状态，当该缓存行被替换时，数据会被写回主内存，缓存行变为Invalid状态。</p><p><strong>工作原理</strong></p><p>假设有三个处理器A、B和C，它们各自有自己的缓存。主内存中有一个变量x，初始值为0。</p><p>读取数据：</p><p>处理器A从主内存读取x，缓存行状态变为Exclusive。<br>处理器B从主内存读取x，处理器A检测到冲突，将缓存行状态变为Shared，处理器B的缓存行状态也变为Shared。<br>修改数据：</p><p>处理器A修改x，缓存行状态变为Modified，并通知处理器B将其缓存行状态变为Invalid。<br>处理器B尝试读取x时，检测到缓存行无效，从主内存重新读取数据。</p><p>写回数据：</p><p>处理器A将修改后的数据写回主内存，缓存行状态变为Invalid。</p><p><strong>优化和问题</strong></p><p>缓存一致性协议通过总线嗅探（Bus Snooping）和状态机机制来实现数据的一致性，但也会引入一些性能问题，如总线带宽压力和处理器等待时间。为了解决这些问题，现代处理器引入了存储缓冲区（Store Buffer）和写回策略（Write Back）等优化技术。</p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>比较并交换（Compare-And-Swap, CAS）操作在并发编程中有许多好处：</p><ol><li><p>无锁编程<br>CAS操作是无锁编程的基础，它允许多个线程在不使用锁的情况下安全地修改共享数据。无锁编程可以减少锁的开销，避免死锁，提高系统的并发性能。</p></li><li><p>原子性<br>CAS操作是原子的，即它确保比较和交换操作在硬件级别上是不可分割的。这意味着在任何时刻，只有一个线程能够成功地修改变量的值，避免竞争条件。</p></li><li><p>高效性<br>CAS操作通常由硬件指令支持（如x86架构中的 LOCK CMPXCHG 指令），这些指令非常高效，能够快速完成比较和交换操作。相比于使用锁，CAS操作的开销更低。</p></li><li><p>可扩展性<br>CAS操作允许多个线程同时尝试修改变量，而不会阻塞其他线程。这种特性使得CAS操作在高并发环境中具有良好的可扩展性，能够处理大量线程的并发访问。</p></li><li><p>实现复杂的并发数据结构<br>CAS操作可以用于实现复杂的并发数据结构，如无锁队列、无锁栈等。这些数据结构能够在高并发环境中提供高效的操作，而不会引入锁的开销。</p></li></ol><p>以下是一个使用CAS操作实现无锁计数器的示例：</p><figure class="highlight cpp"><figcaption><span>cas_counter.cpp</span><a href="/blog/downloads/code/atomic/cas_counter.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) {</span><br><span class="line">        <span class="type">int</span> expected = counter.<span class="built_in">load</span>();</span><br><span class="line">        <span class="keyword">while</span> (!counter.<span class="built_in">compare_exchange_weak</span>(expected, expected + <span class="number">1</span>)) {</span><br><span class="line">            <span class="comment">// 重试，直到成功</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final counter value: &quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在这个例子中，compare_exchange_weak 使用CAS操作来确保 counter 的原子性修改。每次修改失败时，线程会重试，直到成功。</p><h4 id="compare-exchange-weak-和-fetch-add"><a href="#compare-exchange-weak-和-fetch-add" class="headerlink" title="compare_exchange_weak 和 fetch_add"></a>compare_exchange_weak 和 fetch_add</h4><p>compare_exchange_weak 和 fetch_add 是两种不同的原子操作，它们在功能和使用场景上有明显的区别。让我们详细解释一下它们的区别以及如何选择。</p><h5 id="compare-exchange-weak"><a href="#compare-exchange-weak" class="headerlink" title="compare_exchange_weak"></a>compare_exchange_weak</h5><p>功能：</p><p>compare_exchange_weak 是一种CAS（Compare-And-Swap）操作，用于比较原子变量的当前值与预期值，如果相等，则将新值存储到变量中，并返回 true；如果不相等，则返回 false 并更新预期值。<br>该操作允许偶尔的失败（即使当前值与预期值相等，也可能返回 false），这在一些循环算法中是可以接受的。</p><p>使用场景：</p><p>适用于需要在循环中反复尝试更新变量的场景，例如实现无锁数据结构（如无锁队列、栈等）。<br>在高并发环境中，compare_exchange_weak 通常比 compare_exchange_strong 性能更高，因为它允许偶尔的失败，从而减少了总线锁定的开销.</p><h5 id="fetch-add"><a href="#fetch-add" class="headerlink" title="fetch_add"></a>fetch_add</h5><p>功能：</p><p>fetch_add 是一种原子加法操作，它将给定的值加到原子变量的当前值中，并返回变量的旧值。<br>该操作是原子的，确保在多线程环境中不会出现竞争条件。</p><p>使用场景：</p><p>适用于简单的计数器或累加器场景，例如统计访问次数、累加总和等。<br>在需要对变量进行简单的加法操作时，fetch_add 是一个高效的选择2.</p><h5 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h5><p>选择 compare_exchange_weak 还是 fetch_add 取决于具体的使用场景和需求：</p><p>如果需要实现复杂的无锁数据结构（如无锁队列、栈等），并且需要反复尝试更新变量，选择 compare_exchange_weak。<br>如果需要对变量进行简单的加法操作（如计数器、累加器），选择 fetch_add。<br>示例代码<br>以下是使用 compare_exchange_weak 和 fetch_add 的示例代码：</p><p>compare_exchange_weak 示例：</p><figure class="highlight cpp"><figcaption><span>compare_exchange_weak_eg.cpp</span><a href="/blog/downloads/code/atomic/compare_exchange_weak_eg.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) {</span><br><span class="line">        <span class="type">int</span> expected = counter.<span class="built_in">load</span>();</span><br><span class="line">        <span class="keyword">while</span> (!counter.<span class="built_in">compare_exchange_weak</span>(expected, expected + <span class="number">1</span>)) {</span><br><span class="line">            <span class="comment">// 重试，直到成功</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final counter value: &quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>fetch_add 示例：</p><figure class="highlight cpp"><figcaption><span>fetch_add_eg.cpp</span><a href="/blog/downloads/code/atomic/fetch_add_eg.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) {</span><br><span class="line">        counter.<span class="built_in">fetch_add</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final counter value: &quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>如果我们只需要简单地递增计数器，并且没有其他条件限制，fetch_add 确实是一个更直接和高效的选择。fetch_add 能够确保每次递增操作都是原子的，避免了竞争条件。</p><p>然而，在某些特定场景下，compare_exchange_weak 可能更为合适。例如，当我们需要基于特定条件进行更新时，compare_exchange_weak 可以确保只有在满足条件时才进行更新操作。</p><p>示例：基于条件的更新<br>假设我们有一个计数器，需要在满足特定条件时进行递增操作：</p><figure class="highlight cpp"><figcaption><span>cas_case.cpp</span><a href="/blog/downloads/code/atomic/cas_case.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">conditional_increment</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) {</span><br><span class="line">        <span class="type">int</span> expected = counter.<span class="built_in">load</span>();</span><br><span class="line">        <span class="keyword">while</span> (expected &lt; <span class="number">500</span> &amp;&amp; !counter.<span class="built_in">compare_exchange_weak</span>(expected, expected + <span class="number">1</span>)) {</span><br><span class="line">            <span class="comment">// 重试，直到成功或条件不满足</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(conditional_increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(conditional_increment)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final counter value: &quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在这个例子中，只有当 counter 的值小于500时，才会进行递增操作。compare_exchange_weak 确保条件更新的原子性和安全性。</p><p>使用 fetch_add 的场景<br>如果我们不需要基于条件进行更新，只是简单地递增计数器，那么 fetch_add 是一个更好的选择：</p><figure class="highlight cpp"><figcaption><span>fetch_add_case.cpp</span><a href="/blog/downloads/code/atomic/fetch_add_case.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) {</span><br><span class="line">        counter.<span class="built_in">fetch_add</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final counter value: &quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在这个例子中，fetch_add 确保每次递增操作都是原子的，避免了竞争条件。</p><p>总结来说，如果你的操作只是简单的递增，fetch_add 是更高效的选择；如果需要基于条件进行更新，compare_exchange_weak 则更为合适。</p><h4 id="ABA"><a href="#ABA" class="headerlink" title="ABA"></a>ABA</h4><p>ABA问题在并发编程中是一个常见的问题，尤其是在使用CAS（Compare-And-Swap）操作时。ABA问题的本质是一个变量的值在两次比较之间发生了变化，但最终值又回到了原始值，导致CAS操作无法检测到这种变化。为了避免ABA问题，可以使用带有版本号或标记的原子引用，例如 AtomicStampedReference。</p><p>示例：使用 AtomicStampedReference 避免ABA问题<br>以下是一个使用 AtomicStampedReference 避免ABA问题的示例：</p><figure class="highlight cpp"><figcaption><span>atomic_stamped_reference.cpp</span><a href="/blog/downloads/code/atomic/atomic_stamped_reference.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">stamp</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">conditional_increment</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) {</span><br><span class="line">        <span class="type">int</span> expected = counter.<span class="built_in">load</span>();</span><br><span class="line">        <span class="type">int</span> expected_stamp = stamp.<span class="built_in">load</span>();</span><br><span class="line">        <span class="keyword">while</span> (expected &lt; <span class="number">500</span> &amp;&amp; !counter.<span class="built_in">compare_exchange_weak</span>(expected, expected + <span class="number">1</span>) &amp;&amp; !stamp.<span class="built_in">compare_exchange_weak</span>(expected_stamp, expected_stamp + <span class="number">1</span>)) {</span><br><span class="line">            <span class="comment">// 重试，直到成功或条件不满足</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(conditional_increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(conditional_increment)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final counter value: &quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final stamp value: &quot;</span> &lt;&lt; stamp &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用了一个额外的 stamp 变量来记录每次更新的版本号。每次更新 counter 时，同时更新 stamp。这样，即使 counter 的值回到了原始值，stamp 的值也会不同，从而避免了ABA问题。</p><p>解释<br>版本号：每次更新 counter 时，同时更新 stamp，确保每次更新都有一个唯一的版本号。<br>CAS操作：使用 compare_exchange_weak 确保 counter 和 stamp 的更新是原子的。<br>重试机制：如果CAS操作失败，线程会重试，直到成功或条件不满足。<br>这种方法通过引入版本号或标记，确保即使变量的值回到了原始值，版本号也会不同，从而避免了ABA问题。</p><p>ABA问题不仅存在于CAS操作中，还可能在其他并发编程场景中出现。以下是一些可能出现ABA问题的情景：</p><ol><li><p>双重检查锁定（Double-Checked Locking）<br>在双重检查锁定模式中，ABA问题可能会导致错误的判断。例如，在初始化单例对象时，如果两个线程同时检查对象是否为空，并且一个线程在检查后立即创建对象，而另一个线程在检查后发现对象已经被创建并且再次检查时发现对象为空，这可能会导致错误的初始化。</p></li><li><p>无锁队列和栈<br>在无锁队列和栈的实现中，ABA问题可能会导致节点的插入和删除操作出现错误。例如，一个线程在删除节点时，另一个线程可能会插入和删除相同的节点，导致第一个线程无法正确判断节点的状态。</p></li><li><p>版本控制<br>在版本控制系统中，ABA问题可能会导致错误的版本判断。例如，一个线程在检查版本号时，另一个线程可能会更新版本号并且再次更新回原始版本号，导致第一个线程无法正确判断版本是否被修改。</p></li></ol><p>解决方案<br>为了避免ABA问题，可以使用以下解决方案：</p><p>版本号或标记：使用版本号或标记来记录每次更新的状态。例如，使用 AtomicStampedReference 来确保每次更新都有一个唯一的版本号。<br>时间戳：使用时间戳来记录每次更新的时间，确保每次更新都有一个唯一的时间标记。<br>逻辑时钟：使用逻辑时钟来记录每次更新的顺序，确保每次更新都有一个唯一的顺序标记。<br>示例：使用 AtomicStampedReference 避免ABA问题<br>以下是一个使用 AtomicStampedReference 避免ABA问题的示例：</p><figure class="highlight java"><figcaption><span>atomic_stamped_reference.java</span><a href="/blog/downloads/code/atomic/atomic_stamped_reference.java">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ABAExample</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedRef = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicStampedRef.getStamp();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> atomicStampedRef.getReference();</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 1 initial value: &quot;</span> + value + <span class="string">&quot;, stamp: &quot;</span> + stamp);</span><br><span class="line">            atomicStampedRef.compareAndSet(value, value + <span class="number">1</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 1 updated value: &quot;</span> + atomicStampedRef.getReference() + <span class="string">&quot;, stamp: &quot;</span> + atomicStampedRef.getStamp());</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicStampedRef.getStamp();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> atomicStampedRef.getReference();</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 2 initial value: &quot;</span> + value + <span class="string">&quot;, stamp: &quot;</span> + stamp);</span><br><span class="line">            atomicStampedRef.compareAndSet(value, value + <span class="number">1</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 2 updated value: &quot;</span> + atomicStampedRef.getReference() + <span class="string">&quot;, stamp: &quot;</span> + atomicStampedRef.getStamp());</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在这个例子中，AtomicStampedReference 使用版本号来避免ABA问题，确保每次更新都有一个唯一的版本号。</p><p>C++ 标准库中没有直接等同于 Java 的 AtomicStampedReference 的类，但你可以通过组合 std::atomic 和自定义结构体来实现类似的功能。以下是一个示例，展示如何在 C++ 中实现带有版本号的原子引用，以避免 ABA 问题：</p><p>示例：实现带有版本号的原子引用</p><figure class="highlight cpp"><figcaption><span>cas_with_version.cpp</span><a href="/blog/downloads/code/atomic/cas_with_version.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StampedValue</span> {</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> stamp;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">std::atomic&lt;StampedValue&gt; atomicStampedValue{StampedValue{<span class="number">0</span>, <span class="number">0</span>}};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) {</span><br><span class="line">        StampedValue expected = atomicStampedValue.<span class="built_in">load</span>();</span><br><span class="line">        StampedValue newValue;</span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            newValue = {expected.value + <span class="number">1</span>, expected.stamp + <span class="number">1</span>};</span><br><span class="line">        } <span class="keyword">while</span> (!atomicStampedValue.<span class="built_in">compare_exchange_weak</span>(expected, newValue));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    StampedValue finalValue = atomicStampedValue.<span class="built_in">load</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final value: &quot;</span> &lt;&lt; finalValue.value &lt;&lt; <span class="string">&quot;, Final stamp: &quot;</span> &lt;&lt; finalValue.stamp &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>解释<br>StampedValue 结构体：包含一个值和一个版本号（或时间戳）。<br>std::atomic：使用 std::atomic 包装 StampedValue 结构体，以确保原子性操作。<br>compare_exchange_weak：在更新值和版本号时使用 CAS 操作，确保操作的原子性和避免 ABA 问题。<br>使用场景<br>这种方法适用于需要避免 ABA 问题的场景，例如无锁队列、无锁栈等复杂并发数据结构。</p><h4 id="compare-exchange-weak-和-compare-exchange-strong"><a href="#compare-exchange-weak-和-compare-exchange-strong" class="headerlink" title="compare_exchange_weak 和 compare_exchange_strong"></a>compare_exchange_weak 和 compare_exchange_strong</h4><p>区别<br>可靠性：</p><p>compare_exchange_weak：允许偶尔失败，即使当前值与期望值相等，也可能返回 false。这种设计是为了提高性能，适用于循环中的自旋锁等场景。<br>compare_exchange_strong：保证操作成功，如果当前值与期望值相等，则一定返回 true。适用于需要确保操作成功的场景。<br>性能：</p><p>compare_exchange_weak：通常比 compare_exchange_strong 性能更高，因为它允许偶尔失败。<br>compare_exchange_strong：在某些平台上性能可能较低，因为它需要确保操作成功。<br>适用场景<br>compare_exchange_weak：</p><ul><li>适用于循环中的自旋锁。</li><li>适用于高性能要求的场景。</li></ul><p>compare_exchange_strong：</p><ul><li>适用于需要确保操作成功的场景。</li><li>适用于线程同步。</li></ul><p>compare_exchange_weak 允许虚假失败的底层实现基于 CAS（Compare-And-Swap） 操作和硬件指令的特性。以下是详细解释：</p><p>CAS操作<br>CAS 操作有三个参数：内存地址、预期值和新值。其基本原理是：</p><p>比较内存地址中的值是否与预期值相等。<br>如果相等，则将内存地址中的值更新为新值。<br>如果不相等，则不做任何操作，并返回当前内存地址中的值。<br>虚假失败的原因<br>compare_exchange_weak 允许虚假失败，即使当前值与预期值相等，也可能返回 false。这种情况通常发生在以下几种情况：</p><p>缓存一致性问题：</p><p>在多核处理器中，缓存一致性协议可能导致 CAS 操作失败，即使内存中的值没有改变。例如，在 ARM 架构中，使用 LDXR&#x2F;STXR 指令时，其他线程对同一缓存行的访问可能导致 CAS 操作失败1。<br>硬件指令的实现：</p><p>在某些平台上，CAS 操作可能被实现为单次 LL&#x2F;SC（Load-Linked&#x2F;Store-Conditional）尝试。这种实现允许 CAS 操作偶尔失败，以提高性能</p><p>为什么compare_exchange_strong不被用于实现自旋锁？<br>Copilot said:<br>Copilot<br>compare_exchange_strong 通常不用于实现自旋锁，主要原因在于其性能和设计目的：</p><p>性能<br>compare_exchange_strong 保证操作成功，如果当前值与预期值相等，则一定返回 true1。这种保证需要更多的硬件资源和时间来完成操作，可能导致性能下降1。<br>compare_exchange_weak 允许偶尔失败，即使当前值与预期值相等，也可能返回 false1。这种设计减少了硬件资源的消耗，提高了性能1。<br>设计目的<br>自旋锁 的设计目的是在短时间内频繁尝试获取锁，而不是长时间等待。因此，自旋锁更适合使用 compare_exchange_weak，因为它可以在失败时快速重试1。<br>compare_exchange_strong 更适合需要确保操作成功的场景，如线程同步1。在这些场景中，操作的成功率比性能更重要。<br>代码示例<br>以下是一个使用 compare_exchange_weak 实现自旋锁的示例：</p><figure class="highlight cpp"><figcaption><span>cas_spin_lock.cpp</span><a href="/blog/downloads/code/atomic/cas_spin_lock.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpinLock</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; flag = {<span class="literal">false</span>};</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="type">bool</span> expected = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!flag.<span class="built_in">compare_exchange_weak</span>(expected, <span class="literal">true</span>, std::memory_order_acquire)) {</span><br><span class="line">            expected = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>{</span><br><span class="line">        flag.<span class="built_in">store</span>(<span class="literal">false</span>, std::memory_order_release);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure><p>在这个示例中，compare_exchange_weak 被用来实现自旋锁，因为它在失败时可以快速重试，从而提高性能</p><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>内存屏障（Memory Barrier），也被称为内存栅栏（Memory Fence）或内存围栏（Memory Fence），是一种硬件或软件的同步机制，用于在并发系统中保持内存操作的顺序性123。这是多核和多线程环境中至关重要的，因为现代处理器会对指令进行重排序以提高执行效率123。</p><p>内存屏障的作用<br>防止指令重排序：</p><p>编译器和处理器可能会对指令进行重排序，以优化性能12。内存屏障确保特定的内存操作在屏障之前完成，而不会被重排序到屏障之后12。<br>保证内存可见性：</p><p>在多线程环境中，一个线程对内存的修改必须对其他线程可见12。内存屏障确保在屏障之前的所有写操作对其他线程可见12。<br>类型<br>加载屏障（Load Barrier）：</p><p>确保在屏障之前的所有加载操作完成后，才开始执行屏障之后的加载操作12。<br>存储屏障（Store Barrier）：</p><p>确保在屏障之前的所有存储操作完成后，才开始执行屏障之后的存储操作12。<br>全屏障（Full Barrier）：</p><p>结合了加载屏障和存储屏障的功能，确保在屏障之前的所有加载和存储操作完成后，才开始执行屏障之后的加载和存储操作12。<br>代码示例<br>以下是一个简单的代码示例，展示了如何使用内存屏障：</p><figure class="highlight cpp"><figcaption><span>memory_barrier.cpp</span><a href="/blog/downloads/code/atomic/memory_barrier.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; a{<span class="number">0</span>};</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; b{<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>{</span><br><span class="line">    a.<span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">    std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_seq_cst);  <span class="comment">// 全屏障</span></span><br><span class="line">    b.<span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (b.<span class="built_in">load</span>(std::memory_order_relaxed) == <span class="number">0</span>);</span><br><span class="line">    std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_seq_cst);  <span class="comment">// 全屏障</span></span><br><span class="line">    <span class="built_in">assert</span>(a.<span class="built_in">load</span>(std::memory_order_relaxed) == <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在这个示例中，std::atomic_thread_fence 用于插入内存屏障，确保在屏障之前的存储操作完成后，才开始执行屏障之后的存储操作</p><h4 id="内存序"><a href="#内存序" class="headerlink" title="内存序"></a>内存序</h4><p>内存序（Memory Order）描述了在多线程环境中，内存操作的顺序和可见性。它决定了一个线程对内存的修改何时以及如何对其他线程可见。C++11 引入了六种内存序，以便程序员在并发编程中根据需求选择合适的同步机制123。</p><p>六种内存序<br>memory_order_relaxed：</p><p>只保证当前操作的原子性，不考虑线程间的同步12。适用于不需要同步的场景，如计数器的增加12。<br>memory_order_consume：</p><p>确保当前操作依赖的所有写操作在此操作之前完成12。主要用于依赖关系较强的场景12。<br>memory_order_acquire：</p><p>确保在此操作之后的所有读写操作不会被重排序到此操作之前12。常用于获取锁的操作12。<br>memory_order_release：</p><p>确保在此操作之前的所有读写操作不会被重排序到此操作之后12。常用于释放锁的操作12。<br>memory_order_acq_rel：</p><p>结合了 acquire 和 release 的语义，确保在此操作之前的写操作不会被重排序到此操作之后，同时在此操作之后的读操作不会被重排序到此操作之前12。适用于读-修改-写操作12。<br>memory_order_seq_cst：</p><p>顺序一致性，确保所有线程看到的内存操作顺序一致12。这是最严格的内存序，适用于需要强一致性的场景12。<br>代码示例<br>以下是一个简单的代码示例，展示了如何使用不同的内存序：</p><figure class="highlight cpp"><figcaption><span>memory_order.cpp</span><a href="/blog/downloads/code/atomic/memory_order.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; data{<span class="number">0</span>};</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; ready{<span class="literal">false</span>};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>{</span><br><span class="line">    data.<span class="built_in">store</span>(<span class="number">42</span>, std::memory_order_relaxed);</span><br><span class="line">    ready.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (!ready.<span class="built_in">load</span>(std::memory_order_acquire));</span><br><span class="line">    <span class="built_in">assert</span>(data.<span class="built_in">load</span>(std::memory_order_relaxed) == <span class="number">42</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在这个示例中，producer 线程使用 memory_order_release 来发布数据，而 consumer 线程使用 memory_order_acquire 来确保读取到的数据是最新的</p><p>TODO</p>]]></content>
      
      
      
        <tags>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCL入门</title>
      <link href="/blog/2025/02/24/TCL%E5%85%A5%E9%97%A8/"/>
      <url>/blog/2025/02/24/TCL%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="TCL-Main"><a href="#TCL-Main" class="headerlink" title="TCL_Main"></a>TCL_Main</h2><p><code>Tcl_Main</code>的简化流程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tcl_Main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], Tcl_AppInitProc *appInitProc)</span> </span>&#123;</span><br><span class="line">    Tcl_Interp *interp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的 Tcl 解释器</span></span><br><span class="line">    interp = <span class="built_in">Tcl_CreateInterp</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用应用程序初始化函数</span></span><br><span class="line">    <span class="keyword">if</span> ((*appInitProc)(interp) != TCL_OK) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Application initialization failed: %s\n&quot;</span>, <span class="built_in">Tcl_GetStringResult</span>(interp));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入 Tcl 事件循环</span></span><br><span class="line">    <span class="built_in">Tcl_MainLoop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="花括号的用法"><a href="#花括号的用法" class="headerlink" title="花括号的用法"></a>花括号的用法</h2><p>在Tcl中，花括号 <code>&#123;&#125;</code> 有多种用法，主要用于分组、延迟解析、创建列表和字典等。以下是花括号的主要用法及示例：</p><ol><li><p>分组代码块<br>花括号用于将一段代码分组，使其作为一个整体传递或执行。</p> <figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &#123;[<span class="keyword">catch</span> &#123;myProc&#125; msg]&#125; &#123;</span><br><span class="line">    <span class="keyword">puts</span> <span class="string">&quot;An error occurred: $msg&quot;</span></span><br><span class="line">&#125; else &#123;</span><br><span class="line">    <span class="keyword">puts</span> <span class="string">&quot;myProc executed successfully&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>延迟解析<br>花括号内的内容不会立即解析，直到需要时才会被解析。这在处理包含特殊字符的字符串时非常有用。</p> <figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> script &#123;<span class="keyword">puts</span> <span class="string">&quot;Hello, World!&quot;</span>&#125;</span><br><span class="line"><span class="keyword">eval</span> <span class="variable">$script</span>  <span class="comment">;# 输出 &quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure> <figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &#123;[<span class="keyword">catch</span> &#123;myProc&#125; msg]&#125; &#123;</span><br><span class="line">    <span class="keyword">puts</span> <span class="string">&quot;An error occurred: $msg&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建列表<br>花括号用于创建列表，列表中的元素可以包含空格或特殊字符。</p> <figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> myList &#123;one two three&#125;</span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">lindex</span> <span class="variable">$myList</span> <span class="number">1</span>]  <span class="comment">;# 输出 &quot;two&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>创建字典<br>花括号用于创建字典，字典中的键值对可以包含空格或特殊字符。</p> <figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> myDict &#123;key1 value1 key2 value2&#125;</span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">dict</span> get <span class="variable">$myDict</span> key1]  <span class="comment">;# 输出 &quot;value1&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>多行字符串<br>花括号用于创建多行字符串，字符串中的换行符和空格会被保留。</p> <figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> multiLineString &#123;</span><br><span class="line">    This is a multi-line</span><br><span class="line">    <span class="keyword">string</span> in Tcl.</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$multiLineString</span></span><br></pre></td></tr></table></figure></li><li><p>保护特殊字符<br>花括号用于保护特殊字符，使其不被解释为命令或变量。</p> <figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> specialChars &#123;This is a &#123;special&#125; <span class="keyword">string</span> with [brackets] and <span class="variable">$dollar</span> signs.&#125;</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$specialChars</span></span><br></pre></td></tr></table></figure></li><li><p>在控制结构中使用<br>花括号用于控制结构（如 if、while、for 等）中的条件和代码块。</p> <figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> x <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> &#123;<span class="variable">$x</span> &gt; <span class="number">5</span>&#125; &#123;</span><br><span class="line">    <span class="keyword">puts</span> <span class="string">&quot;x is greater than 5&quot;</span></span><br><span class="line">&#125; else &#123;</span><br><span class="line">    <span class="keyword">puts</span> <span class="string">&quot;x is 5 or less&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义过程<br>花括号用于定义过程的参数和主体。</p> <figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">proc</span><span class="title"> greet</span> &#123;name&#125; &#123;</span><br><span class="line">    <span class="keyword">puts</span> <span class="string">&quot;Hello, $name!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">greet <span class="string">&quot;Tcl User&quot;</span>  <span class="comment">;# 输出 &quot;Hello, Tcl User!&quot;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="global-和-varaible"><a href="#global-和-varaible" class="headerlink" title="global 和 varaible"></a>global 和 varaible</h2><p><code>global</code> 和 <code>variable</code> 用于声明该变量来自全局还是当前命名空间。</p><p>注意：两者都是声明，不是定义。</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> i <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="keyword">eval</span> test &#123;</span><br><span class="line">    <span class="comment">;# variable i</span></span><br><span class="line">    <span class="comment">;# i没有被事先声明为名字空间的变量，则会引用全局变量i</span></span><br><span class="line">    <span class="keyword">for</span> &#123; <span class="keyword">set</span> i <span class="number">1</span>&#125; &#123; <span class="variable">$i</span> &lt;=<span class="number">5</span>&#125; &#123; <span class="keyword">incr</span> i&#125; &#123;</span><br><span class="line">        <span class="keyword">puts</span> -nonewline <span class="string">&quot;i=$i; &quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">puts</span> <span class="string">&quot;\n&quot;</span></span><br><span class="line">    <span class="comment">;# 由于没有全局的j，所以j被默认视作命名空间内部变量，引用时必须加上命名空间为前缀</span></span><br><span class="line">    <span class="keyword">for</span> &#123;<span class="keyword">set</span> j <span class="number">1</span>&#125; &#123; <span class="variable">$j</span>&lt;=<span class="number">5</span>&#125; &#123;<span class="keyword">incr</span> j&#125; &#123;</span><br><span class="line">        <span class="keyword">puts</span> -nonewline <span class="string">&quot;j=$j; &quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">puts</span> <span class="string">&quot;\n&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$test::j</span></span><br></pre></td></tr></table></figure><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;#注意i的定义处被注释了</span></span><br><span class="line"><span class="comment">#set i 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="keyword">eval</span> test &#123;</span><br><span class="line">    <span class="comment">;# 这里的 global 声明无效，因为没有在全局定义i</span></span><br><span class="line">    <span class="keyword">global</span> i</span><br><span class="line">    <span class="comment">;# 此处的i仍然是命令空间内部的</span></span><br><span class="line">    <span class="keyword">for</span> &#123; <span class="keyword">set</span> i <span class="number">1</span>&#125; &#123; <span class="variable">$i</span> &lt;=<span class="number">5</span>&#125; &#123; <span class="keyword">incr</span> i&#125; &#123;</span><br><span class="line">        <span class="keyword">puts</span> -nonewline <span class="string">&quot;i=$i; &quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">;# 错误！</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$i</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;# 正确</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$test::i</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第2章 基于Verilog的数字IC设计方法</title>
      <link href="/blog/2025/01/17/IC/2.%E5%9F%BA%E4%BA%8EVerilog%E7%9A%84%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/"/>
      <url>/blog/2025/01/17/IC/2.%E5%9F%BA%E4%BA%8EVerilog%E7%9A%84%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-参考"><a href="#1-参考" class="headerlink" title="1. 参考"></a>1. 参考</h2><p>白栎旸. 数字IC设计入门（微课视频版）[M]. 北京: 清华大学出版社，2023-09-01:第2章.</p><h2 id="2-数字器件与Verilog语法"><a href="#2-数字器件与Verilog语法" class="headerlink" title="2. 数字器件与Verilog语法"></a>2. 数字器件与Verilog语法</h2><p>虽然 Foundry 提供的可用元器件种类较多，但数字设计师并不特别在意这些元器件，在其头脑中，只存在 10 种简单元器件：</p><ul><li>与门、或门、非门、异或门、</li><li>加法器、乘法器、移位器、</li><li>选择器、比较器、</li><li>触发器</li></ul><p>注意，虽然加法器、乘法器、比较器等元器件可以由逻辑门生成，但是从Verilog常用的表达式来看，一般直接用“+”这个符号表示加法，而很少用门电路去直接搭建。因为现代芯片规模庞大，功能复杂，工程师应该将主要精力投入到重点难题的实现中，而对于如何实现加法器等最底层的问题，应该交给综合步骤自动完成。</p><p>基本元器件中不包括除法，因为除法的实现不同于乘法，它受到被除数、除数、商的数值范围限制，有时需要用到迭代等复杂方法实现，还有分母为 0 等异常情况需要报告，所以不属于Verilog中常用的直接运算方式。</p><p>务必注意，数字前端写的Verilog仅仅是代码，而非程序，其代码是代替电路图的一种文本语言描述。与或非加乘等指的是元器件。写Verilog时要有电路概貌和时序。</p><p>10种数字器件的符号表示及Verilog表示方法见表格：</p><figure style="text-align:center;"><figcaption>10种数字逻辑器件和Verilog表示</figcaption><img src='https://i.postimg.cc/B65vgDMk/20250117214703.jpg' border='0' alt='20250117214703' width="90%"/></figure><p>真正的元器件库中有很多复杂的元器件，如图所示：</p><figure style="text-align:center;"><img src="https://i.postimg.cc/6QSLdsyT/20250117214659.jpg" alt="20250117214659" width="50%"/><figcaption>复杂元器件示例</figcaption></figure><p>但是这些元器件都可以看作以上10种基础元器件的组合，不会超出原有的功能范围。所以设计时，头脑中只需要有以上10种元器件。</p><p>数字IC设计又称为数字逻辑设计，因为其本身就是逻辑的，只有<code>0</code>和<code>1</code>两种逻辑。</p><ul><li>组合逻辑：电平输入和电平输出。元器件结构简单，但问题是如果输入含有毛刺，输出就有毛刺。</li></ul><img src='https://i.postimg.cc/C1s5wkTY/20250117215056.jpg' border='0' alt='20250117215056' width="50%"/><figure style="text-align:center;"><img src='https://i.postimg.cc/NMH8DNHD/20250117214654.jpg' border='0' alt='20250117214654' width="50%"/><figcaption>组合逻辑电路的毛刺</figcaption></figure><ul><li>时序逻辑：以时钟为驱动源。一个触发器，在时钟的驱动（边沿触发）下，将 D 输入端的信号送到 Q 端输出。</li></ul><img src='https://i.postimg.cc/BbfTVx50/20250117214649.jpg' border='0' alt='20250117214649' width="100%"/><p>触发器也可以叫寄存器(register, reg)，因为如果没有时钟驱动，那么Q端会保持原有状态不变，也就寄存了上一次触发时的D端信息。而组合逻辑，输出端是无法寄存信息的。</p><p>时序逻辑是数字电路的基础。10 种元器件中，只有触发器属于时序逻辑器件，所以触发器是整个数字电路的基础。从 RTL 的名称可以知晓，RTL 意为寄存器传输层，直译过来就是：从一个触发器的输出到另一个触发器的输入，通过触发器的层层传递，最终实现了一个功能完整的数字电路。</p><p>数字电路的时序分析，主要是分析两个触发器之间的路径延迟。</p><p>进行前仿时，看到的仿真波形会和本图一样，是理想的，而使用版图网表进行后仿时，仿真波形是带延迟的。</p><p>上图中触发器的符号表示，它共有4个引脚，除输入的D端和输出的<code>Q</code>端外，三角形位置表示时钟，下方的<code>rst_n</code>表示复位，其上的圆圈表示<code>0</code>电平有效，即<code>rst_n</code>等于<code>0</code>时，寄存器处于复位状态。此时，<code>Q</code>端保持<code>0</code>，即使时钟和<code>D</code>端有动作，<code>Q</code>端也不会变化，只有当<code>rst_n</code>等于<code>1</code>时，才解除复位状态，寄存器方能正常工作。</p><h2 id="3-可综合的Verilog设计语法"><a href="#3-可综合的Verilog设计语法" class="headerlink" title="3. 可综合的Verilog设计语法"></a>3. 可综合的Verilog设计语法</h2><p>能变成电路的Verilog表达叫做可综合，在设计电路时，只能使用可综合的语法表述。而在仿真时，由于只在计算机上运行，不留片，可使用不能综合的高级语法，以增加语言表达的灵活度和复杂度。</p><p>可综合的电路表述只有两种：</p><ul><li><code>assign</code></li><li><code>always</code></li></ul><p>与门：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> z = a &amp; b;</span><br></pre></td></tr></table></figure><p>触发器：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">        Q &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Q &lt;= D;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>符号说明：</p><ul><li><code>&lt;=</code>: 非阻塞赋值，凡是时序逻辑，都用非阻塞赋值；</li><li><code>=</code>: 阻塞赋值，凡是组合逻辑，都用阻塞赋值；</li><li><code>@(...)</code>: 括号中的列表叫敏感列表，意思是，<code>always</code>块输出的<code>Q</code>对列表中信号保持敏感，如果敏感信号动，则Q也会动。</li><li><code>posedge clk</code>: 意思是时钟的上升沿；</li><li><code>negedge rst_n</code>: 意思是时钟的下降沿。</li><li><code>begin</code> &#x2F; <code>end</code>: 相当于 C 语言中的 <code>&#123;&#125;</code> ，如果语句只有一条，可以不写 <code>begin</code> &#x2F; <code>end</code> 。</li></ul><p><code>always</code>不仅可以表示时序逻辑，也可以表示组合逻辑。如下是与门的另一种表示：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    z = a &amp; b;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>其中，<code>@(*)</code>中的<code>*</code>是省略表述的敏感列表，综合器会自动在<code>always</code>块中寻找与输出<code>z</code>相关的输入信号，自动填入敏感列表中。本例中，会自动将<code>a</code>和<code>b</code>作为输入填入。这种让工具自动填入的方式是可靠且推荐的。</p><p>Verilog的语法规律：</p><ol><li>时序逻辑，必须使用<code>always</code>块，并同时使用<code>&lt;=</code>非阻塞赋值。在其敏感列表中，必须出现时钟信号的边沿和复位信号的边沿。</li><li>组合逻辑，可以使用<code>assign</code>，也可以使用<code>always</code>块，但是它们的赋值是<code>=</code>阻塞赋值。若使用<code>always</code>块，则敏感列表中使用<code>*</code>。若遇到敏感列表中带有<code>*</code>，则可以直接判定为组合逻辑。</li></ol><p>再次强调，Verilog的语法表达，描述的都是电路，因此例子中的 <code>z</code>、<code>a</code>、<code>b</code>、<code>clk</code>、<code>rst_n</code>、<code>Q</code>、<code>D</code> 都称为信号，在电路中都是实实在在的金属连线，切勿称为变量。</p><h2 id="4-对寄存器的深度解读"><a href="#4-对寄存器的深度解读" class="headerlink" title="4. 对寄存器的深度解读"></a>4. 对寄存器的深度解读</h2><p>一般会使用时钟上升沿来驱动寄存器。对于同样的功能需求，双沿触发需要的时钟慢，但要求时钟是<code>50%</code>占空比，而单沿触发，对时钟的要求快一倍，但对时钟形状的要求降低很多。</p><p>复位信号<code>rst_n</code>，以<code>0</code>电平作为复位电平，1电平解复位，是通用标准，很少有反过来使用的。原因是，数字电路的复位信号是模拟电路给的，通常，模拟电路将其命名为<code>POR(Power On Reset)</code>，即上电复位信号。芯片刚通电时，电压小，逐渐上升到要求的电压，例如<code>1.8V</code>，<code>POR</code>本质上是一个电压上升的标志，模拟电路放一个比较器，将输入电压与<code>0.9V</code>比较，电压小于<code>0.9V</code>，<code>POR</code>为<code>0</code>，电压大于<code>0.9V</code>，<code>POR</code>为<code>1</code>。因而复位信号上电时总是先<code>0</code>后<code>1</code>，数字寄存器需要在复位信号为<code>0</code>的阶段保持复位态，不能运行，因为此时芯片电压不足，不能保证正常运行，而复位信号变成<code>1</code>，说明上电完毕，电压充足，寄存器解除复位进行正常运行是安全的。</p><p>需要特别澄清的是语句<code>negedge rst_n</code>，但是经过仿真和与模拟工程师确认，复位信号对寄存器的作用不是通过信号沿来驱动的，而是通过电平来驱动，也就是 <code>0</code> 信号具有绝对控制权，只要 <code>rst_n</code> 为 <code>0</code> ，那么立即复位。</p><h2 id="5-非阻塞赋值和阻塞赋值的区别"><a href="#5-非阻塞赋值和阻塞赋值的区别" class="headerlink" title="5. 非阻塞赋值和阻塞赋值的区别"></a>5. 非阻塞赋值和阻塞赋值的区别</h2><p>非阻塞赋值的意思是该句表达不会阻塞后续表达的执行。如下例中，<code>X &lt;＝ 0</code>的执行，不会阻碍到<code>Y &lt;＝ 0</code>的执行，它们是同时发生的：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        X &lt;= <span class="number">0</span>;</span><br><span class="line">        Y &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        X &lt;= A;</span><br><span class="line">        Y &lt;= B;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>而阻塞赋值，意思是如果前一句不执行，后一句就无法执行，前一句会阻塞后一句。对于可综合的Verilog来讲，其实并不会阻塞。在下例中， <code>always</code> 块的目的是创造 <code>z</code> 和 <code>k</code> 两个信号。 <code>k ＝ 3 * z</code> 和 <code>z ＝ a &amp; b</code> 是两个不同的电路， <code>k ＝ 3 * z</code> 电路不会被 <code>z ＝ a &amp; b</code> 阻塞。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    z = a &amp; b;  <span class="comment">// 与门</span></span><br><span class="line">    k = <span class="number">3</span> * z;  <span class="comment">// 乘法器</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>本例对应的原理图如图所示：</p><img src='https://i.postimg.cc/MTs1Dhsh/20250117224729.jpg' border='0' alt='20250117224729' width="50%"/><p>可见，对于电路描述来讲，语法只是表示一种连接关系，并没有执行先后顺序的说法，但如果本例使用非阻塞赋值，语法检查会报错，因此，这是一种惯用方法。阻塞赋值在Verilog中真正体现阻塞，是在仿真使用的不可综合语法中，到第3章再做解释。</p><h2 id="6-组合逻辑的表达式"><a href="#6-组合逻辑的表达式" class="headerlink" title="6. 组合逻辑的表达式"></a>6. 组合逻辑的表达式</h2><p>对于一个组合逻辑电路，应该在什么情况下用assign，在什么情况下用always呢？</p><p>比较简单的逻辑适合使用assign方式，较为复杂的逻辑应使用always块。下例给出了一个适合用always块的较复杂例子：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (s1)</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s2)</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s3)</span><br><span class="line">        a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>同样的功能若改用assign，则为下例所示。很明显，用always块表达意思更加清晰。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> a = s1 ? <span class="number">1</span> : (s2 ? <span class="number">2</span> : (s3 ? <span class="number">3</span> : <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>前面解释了敏感列表中的 <code>*</code> 在组合逻辑 <code>always</code> 块中的作用。如果读者使用过一些老IP，则可能还会看到下例所示的表达，这种表达已随着综合器的进步渐渐被淘汰了，不建议初学者使用。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(s1 <span class="keyword">or</span> s2 <span class="keyword">or</span> s3)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (s1)</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s2)</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s3)</span><br><span class="line">        a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="7-组合逻辑中的选择器"><a href="#7-组合逻辑中的选择器" class="headerlink" title="7. 组合逻辑中的选择器"></a>7. 组合逻辑中的选择器</h2><h3 id="7-1-二选一-MUX-如何表达？"><a href="#7-1-二选一-MUX-如何表达？" class="headerlink" title="7.1. 二选一 MUX 如何表达？"></a>7.1. 二选一 MUX 如何表达？</h3><img src='https://i.postimg.cc/L6vnwrjX/20250117225844.jpg' border='0' alt='20250117225844' width="50%"/><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第 1 种表达， assign 完整表达</span></span><br><span class="line"><span class="keyword">assign</span> z = (s == <span class="number">1</span>) ? b : a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 2 种表达， assign 简化表达</span></span><br><span class="line"><span class="keyword">assign</span> z = s ? b : a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 3 种表达， always 块表达</span></span><br><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (s)</span><br><span class="line">        z = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        z = a;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="7-2-多选一MUX，又该如何表示呢？"><a href="#7-2-多选一MUX，又该如何表示呢？" class="headerlink" title="7.2. 多选一MUX，又该如何表示呢？"></a>7.2. 多选一MUX，又该如何表示呢？</h3><p>因为使用 <code>assign</code> 表示显然会过于复杂，所以需要用 <code>always</code> 块表示。表示方法有两种，注意两种表达综合出来的电路是不同的。</p><p>其一如下例所示。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="number">0</span>)</span><br><span class="line">        z = a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">1</span>)</span><br><span class="line">        z = b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">2</span>)</span><br><span class="line">        z = c;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">3</span>)</span><br><span class="line">        z = d;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">4</span>)</span><br><span class="line">        z = e;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">5</span>)</span><br><span class="line">        z = f;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        z = a; <span class="comment">// 默认值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>综合出来的电路如图所示：</p><img src='https://i.postimg.cc/x84BbfW8/20250117230859.jpg' border='0' alt='20250117230859' width="100%"/><p>可见，使用 <code>if</code> 表述的选择关系，综合的电路是一层一层逐渐展开的，写在 <code>if</code> 最前面的语句，掌握着最终的选择权，因而优先级最高，再往后优先级逐层下降，而使用 <code>case</code> 表述的MUX，每个选择都是并列的，优先级相同，见下文。</p><p>其二如下例所示。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span> (s)</span><br><span class="line">        <span class="number">0</span>: z = a;</span><br><span class="line">        <span class="number">1</span>: z = b;</span><br><span class="line">        <span class="number">2</span>: z = c;</span><br><span class="line">        <span class="number">3</span>: z = d;</span><br><span class="line">        <span class="number">4</span>: z = e;</span><br><span class="line">        <span class="number">5</span>: z = f;</span><br><span class="line">        <span class="keyword">default</span>: z = a; <span class="comment">// 默认值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>所综合的电路如图所示：</p><img src='https://i.postimg.cc/PrfqW20k/20250117230221.jpg' border='0' alt='20250117230221' width="30%"/><p>使用 <code>if</code> 表述，有可能出现隐藏逻辑，即设计者没有考虑到，但实际会被综合出来的逻辑门。隐藏逻辑是设计的隐患，设计者在写代码时应该清楚其逻辑含义，尽量避免出现隐藏逻辑。为了避免设计中出现隐藏逻辑，在实际项目中往往会提倡使用 <code>case</code> 语句来表达。</p><p>下例中反映出 <code>if</code> 的优先级特征，条件 <code>s &lt; 5</code> 包含 <code>s ＝＝ 4</code> 的情况，因为 <code>s &lt; 5</code> 优先，因而当 <code>s＝＝4</code> 时， <code>z</code> 的赋值是 <code>a</code> 而不是 <code>b</code> 。如果设计意图是要在 <code>s ＝＝ 4</code> 时使 <code>z ＝ b</code> ，则应当将其写在 <code>s &lt; 5</code> 之前。</p><!--  --><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt; <span class="number">5</span>)</span><br><span class="line">        z = a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">4</span>)</span><br><span class="line">        z = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        z = c;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>case有一种变体是 <code>casez</code> ，它可以拓展case的使用范围：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">casez</span>(s)</span><br><span class="line">        <span class="number">16&#x27;b00011</span>???????????: z = a;</span><br><span class="line">        <span class="number">16&#x27;b10111111</span>????<span class="number">0000</span>: z = b;</span><br><span class="line">        <span class="number">16&#x27;b1111</span>?<span class="number">001000</span>?????: z = c;</span><br><span class="line">        <span class="keyword">default</span>: z = d;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>其中，问号的意思是0或1都能匹配，类似计算机语言中的通配符。</p><p>虽然很多项目提倡使用 <code>case</code> 或 <code>casez</code> 来表述选择器，但究竟是使用 <code>if</code> 还是 <code>case</code> ，仍然取决于表达的需要。总体而言， <code>case</code> 便于判断是否相等的情况，而 <code>if</code> 适合判断大于或小于关系，不同情况用不同的表达，可以使Verilog逻辑更加清晰，也更便于维护。</p><p>注意组合逻辑中的 <code>if</code> 和 <code>else if</code> ，最后必须跟一句 <code>else</code> ，使整体逻辑完整。若没有else，则该电路会综合出一个锁存器(<code>Latch</code>)。锁存器不属于10种基本元器件之一。在设计中，凡有寄存需求，应尽量使用触发器，避免使用锁存器，特别要避免不写 <code>else</code> 引起的隐藏逻辑。</p><h2 id="8-Verilog中的for循环"><a href="#8-Verilog中的for循环" class="headerlink" title="8. Verilog中的for循环"></a>8. Verilog中的for循环</h2><p>关键字：</p><ul><li><code>for</code></li><li><code>generate</code> &#x2F; <code>endgenerate</code> &#x2F; <code>genvar</code></li><li><code>integer</code>: 是编译时的变量，不是信号，不会被综合成电路或金属连线。如果变量 <code>ii</code> 声明为 <code>wire</code> 或 <code>reg</code> ，然后用 <code>a[ii]</code> 表示一个信号，则语法不能综合为电路。但是 <code>ii</code> 声明为 <code>integer</code> ，那么 <code>a[ii]</code> 将被综合成信号。</li></ul><h2 id="9-Verilog中的数值表示方法"><a href="#9-Verilog中的数值表示方法" class="headerlink" title="9. Verilog中的数值表示方法"></a>9. Verilog中的数值表示方法</h2><p> 数值一般不直接写，如果直接写，则工具会理解为十进制32比特数，但实际中的信号位宽多种多样，选用哪种进制表示数值也有多种选择，因此需要将这两方面予以规定。</p><table><thead><tr><th>进制制</th><th>符号号</th><th>举例</th><th>解释</th></tr></thead><tbody><tr><td>二进制</td><td>b</td><td>4’b0110</td><td>4 比特数，用二进制表示为 0110</td></tr><tr><td>十进制</td><td>d</td><td>8’d3</td><td>8 比特数，用十进制表示为 3</td></tr><tr><td>十六进制</td><td>h</td><td>15’h1abc</td><td>15 比特数，用十六进制表示为 1abc</td></tr></tbody></table><p> 特殊的数值表示方法： </p><p> <code>&#123;5&#123;1&#39;b0&#125;&#125;</code> 表示5个比特0，再如 <code>&#123;4&#123;1&#39;b1&#125;&#125;</code> 表示4个比特1。这种表示一般不用，但是它有优点，上例中的比特数量5和4可以用参数替代，若Verilog中有一个参数 <code>kkk</code> ，则可以写为 <code>&#123;(kkk)&#123;1&#39;b0&#125;&#125;</code> ，甚至可以写成用计算式表示的位宽，如 <code>&#123;(kkk＋2)&#123;1&#39;b0&#125;&#125;</code> 。注意，kkk是参数，不是信号，它不是电路，而是一种编译时使用的变量。</p><p> 这种表示方法还可以写为 <code>&#123;常数&#123;逻辑表达式&#125;&#125;</code> 的形式，如</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> int_clr = &#123;<span class="number">2</span>&#123;(apb_addr = = <span class="number">4&#x27;d7</span>) &amp; wr_en&#125;&#125; &amp; apb_wdat[<span class="number">1</span> : <span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>此例的目的是使用APB总线配置两个只写信号（write-only信号）​，这两个信号合称为 <code>int_clr</code> ，等式的右边，仅当地址 <code>apb_addr</code> 等于7，并且在APB总线上发生写操作时，APB写入的两比特数据 <code>apb_wdat[1:0]</code> 才会被配置到int_clr中，否则int_clr就是0。问题在于， <code>(apb_addr＝＝4&#39;d7)&amp;wr_en</code> 是一比特，不能跟 <code>apb_wdat[1:0]</code> 按位求与，因而需要将一比特复制为两比特，即 <code>&#123;2&#123;(apb_addr＝＝4&#39;d7)&amp;wr_en&#125;&#125;</code> 。</p><p>对于其他辅助变量，可以直接写数字，例如在for循环中讲述的 <code>genvar ii</code> ，ii只是个变量，没有对应的电路，那么for循环赋值就不需要带位宽 和进制了，可以像下面这样写</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(ii = <span class="number">0</span>;ii&lt;<span class="number">100</span>;ii = ii + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>注意Verilog中，如果单写a、b、c、d、e、f、x、z，表示的是信号名，不能作为数值，如果想表示十六进制的数值，则可写为4’ha等，1’bx表示未知态，1’bz表示高阻态。</p><h2 id="10-信号的状态类型"><a href="#10-信号的状态类型" class="headerlink" title="10. 信号的状态类型"></a>10. 信号的状态类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 x z</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li><p>0和1是数字电路本身的状态，它的本源是零电平和VDD电平。</p><p>  VDD， Voltage Drain, 其中 Drain 表示漏极，是一个电源引脚，用来提供正电压给电路中的元件。由于晶体管的设计通常包含两个漏极（源极和漏极），所以在一些命名规则中，为了区分正电源和负电源，使用了两个 D，并且VDD 代表正电源电压，VSS（Voltage Source）代表地线或负电源。 整个芯片的电源常称为VCC，芯片的地常标注为VSS。</p><p>  不同工艺和元器件库需要的VDD不同，例如0.9V、1.8V、3.3V等，而同一个元器件库中的所有元器件，其需要的供电电压VDD一般相同的，只有I&#x2F;O器件等少数元器件，其输入端和控制端是比较低的电压，而输出端口却是较高的电压。</p><p>  数字0和1对应的电平不会特别严格，而是有一个浮动范围，通常信号电平低于VDD的30%，就被认为是0，高于VDD的70%，就被认为是1。</p></li><li><p>z态是高阻态。</p><p>  如果一颗芯片不通电，则它所有的引脚就都是高阻态。可见，高阻态的实际意义就是不会干扰到其他信号传输的状态，例如某信号A是高阻态，某信号B不是高阻态，那么信号A叠加到信号B上（可以想象为两根信号线被拧在一起）​，结果仍然是B，而A没有任何效果。</p><p>  一般来讲，一个有着双向传输功能的引脚，如果设置为输入模式，就可以认为这个引脚处于高阻态，意思是它对电路板上与它相连的元器件没有任何影响，这些相连元器件如果要对本芯片输出0或1，就可以直接顺着该高阻态引脚输入，而不会被干扰或阻挡。</p><p>  在FPGA的Verilog表述中，可以很形象地将FPGA的引脚描述为如下语句，其中b是FPGA的引脚，所以声明为inout类型，oe是该引脚的方向选择，若oe为1，则b为输出模式，将信号a输出到FPGA外面，而当oe为0时，是高阻态，即输入模式，外面的信号从b引脚可以进来后与信号c形成了组合逻辑，代码如下：</p>  <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inout</span> b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> b = oe ? a : <span class="number">1&#x27;bz</span></span><br><span class="line"><span class="keyword">assign</span> d = b ^ c;</span><br></pre></td></tr></table></figure><p>  注意上例中引用FPGA的语法只是为了说明z态的含义。IC设计中对引脚的设计不像FPGA这么简单，需要例化一个引脚模块，在代码中不会出现1’bz数值。</p><p>  <strong>博主注1：</strong></p><p>  在集成电路（IC）中，高阻态（High Impedance State，简称 Hi-Z）是指一个电路输出引脚处于没有输出驱动信号的状态，即该引脚既不提供高电平（VDD）也不提供低电平（GND），而是处于一种“悬空”状态，几乎不消耗电流，像是断开了。高阻态通常用于多路复用（bus）或三态总线（tri-state bus）等应用中，允许多个设备共享同一条总线而不会相互干扰。</p><p>  高阻态的实现<br>  高阻态通常通过 <strong>三态门（Tri-state Gate）</strong> 来实现。三态门是一种特殊类型的逻辑门，它具有三个输出状态：</p><p>  高电平（逻辑 1）<br>  低电平（逻辑 0）<br>  高阻态（Hi-Z）<br>  具体来说，高阻态是通过在输出端增加一个高阻抗的电路来实现的，这个高阻抗值通常非常大，以至于该引脚对外部电路几乎没有影响。三态门的工作原理可以分为以下几种方式：</p><p>  开关型设计：</p><p>  P-Channel MOSFET（PMOS） 和 N-Channel MOSFET（NMOS） 组成的电路可以根据控制信号决定是否接通输出。如果三态门处于“高阻态”时，MOSFET 们并不会导通，从而使输出引脚处于高阻抗状态。<br>  控制信号：</p><p>  三态门的输出通常由一个控制信号来控制。当控制信号为“使能”状态时，输出引脚会驱动高或低电平；而当控制信号为“禁用”状态时，输出引脚进入高阻态，基本与外部电路断开连接。<br>  双向总线：</p><p>  在多路复用的场景中，多个设备可能需要共享同一条数据总线。为了避免多个设备同时驱动总线产生冲突，设备在不输出数据时会进入高阻态，不影响其他设备的信号传输。<br>  高阻态的作用<br>  多路复用：高阻态允许多个电路共享同一总线。只有一个电路在某个时间点输出数据，其他电路进入高阻态，防止冲突。</p><p>  总线冲突保护：通过将不参与通信的设备置于高阻态，避免了多个设备在同一时间尝试驱动总线的冲突。</p><p>  节省电力：通过在不需要输出信号时将输出置于高阻态，可以降低功耗，因为在高阻态下输出引脚几乎不消耗电流。</p><p>  举例说明<br>  一个常见的例子是在 Tri-state Bus（三态总线）中，多个设备通过控制信号来决定是否驱动总线。如果设备不需要发送数据，它会将输出置于高阻态，允许其他设备使用总线。</p><p>  总结来说，高阻态的实现依赖于三态门（Tri-state Gate），它通过控制MOSFET开关来使输出处于非驱动状态，从而让其他电路可以共享同一个引脚或总线。</p><p>  <strong>博主注2：</strong></p><p>  在数字电路中，inout 引脚是指一个既可以作为输入端口，也可以作为输出端口的引脚。它通常用于多路复用（bus）或双向数据传输的场合，允许一个引脚在不同时间根据需要在输入和输出之间切换。为了在同一引脚上同时支持输入和输出，通常使用 三态逻辑（Tri-state logic）来控制数据的流向。</p><p>  inout 引脚的实现方式<br>  inout 引脚的实现依赖于几个关键的设计原则和组件</p><p>  三态缓冲器（Tri-state Buffer）：</p><p>  在 inout 引脚上，通常使用 三态缓冲器（Tri-state buffer）来控制该引脚是处于输入、输出还是高阻态。三态缓冲器的作用是通过控制信号来决定该引脚的状态。<br>  当引脚作为 输出 时，缓冲器将数据传递到引脚。<br>  当引脚作为 输入 时，缓冲器将引脚上的电压信号传送到内部电路。<br>  当引脚处于 高阻态（Hi-Z）时，缓冲器断开与引脚的连接，使得该引脚对外部电路“透明”，即不影响电路。<br>  控制信号：</p><p>  inout 引脚的切换通常由控制信号（例如，方向控制信号）来决定，指示该引脚是作为输入使用还是作为输出使用。<br>  控制信号一般是由逻辑电路生成，当电路需要输出数据时，控制信号会使引脚成为输出；而当电路需要接收数据时，控制信号会使引脚成为输入。<br>  双向总线设计：</p><p>  inout 引脚常用于总线设计，其中多个设备共享同一条总线。每个设备可以在需要时向总线发送数据，而在不需要时通过将输出设为高阻态来避免与其他设备的冲突。<br>  例如，数据总线（Data Bus）可能由多个设备共享。当一个设备不在发送数据时，它会将其 inout 引脚设为高阻态，确保只有发送设备影响总线信号。</p><p>  工作原理</p><p>  输出模式：</p><p>  当inout 引脚作为输出时，相关的三态缓冲器连接到该引脚，并驱动电平（高或低）。此时，控制信号将引脚设置为输出模式，并且其他连接到该引脚的电路会处于断开状态。</p><p>  输入模式：</p><p>  当 inout 引脚作为输入时，缓冲器进入高阻态（Hi-Z），即引脚的状态不再由输出逻辑驱动，转而接收外部信号。此时，只有连接到引脚的其他设备会驱动该引脚的电平。<br>  高阻态：</p><p>  当引脚不需要输出数据时，三态缓冲器将进入 高阻态，使该引脚对其他电路没有影响。这样，多个设备就可以共享同一个引脚或总线而不会发生电平冲突。<br>  应用示例<br>  双向数据总线：</p><p>  假设有多个设备共享一条数据总线。每个设备的 inout 引脚可以作为数据的输入端或输出端。在某个时刻，只有一个设备向总线发送数据，其他设备则将其引脚设为高阻态，避免干扰。<br>  双向信号传输：</p><p>  在通信协议中，inout 引脚可用于双向信号传输。例如，I²C总线就使用 inout 引脚，其中一个设备在某个时刻发送信号，而另一个设备则接收信号。<br>  芯片间通信：</p><p>  在多芯片系统中，inout 引脚可用于芯片之间的数据交换，允许不同芯片在不同时刻控制同一引脚的输入和输出行为。<br>  总结<br>  inout 引脚通过三态缓冲器和控制信号的组合，实现了同一引脚可以在输入和输出之间切换的功能。通过将输出置于高阻态，可以使得该引脚不会干扰其他电路或设备，使其适用于总线系统或双向通信的设计中。</p></li><li><p>x态的含义是未知态。</p><p>  有4种情况会产生未知态：</p><ul><li>其一是芯片已上电但复位信号未进行复位的情况；</li><li>其二是双向引脚信号冲突，因为没控制好，导致有一路信号通过引脚输入，另一路信号通过相同的引脚输出；</li><li>其三是芯片中一个元器件的某个输入端为x态，于是输出就跟着变成了x态，这就是所谓x态的传播；</li><li>第四是触发器的时序不满足，产生了亚稳态，从而表示为x态。</li></ul><p>  上述4种情况在仿真中都能看到，但实际中，第1种情况基本不会出现，除非模拟电路设计有误，其他3种在数字设计有缺陷时会出现，实际在测量其电压时会出现不稳定或非预期的问题。在可综合的Verilog中，不会出现1’bx数值，因为没有一个设计会故意将一个错误引入RTL中，所有的错误都是意外发生的。该符号在仿真脚本和仿真波形中可能出现。</p></li></ul><h2 id="电平信号与脉冲信号"><a href="#电平信号与脉冲信号" class="headerlink" title="电平信号与脉冲信号"></a>电平信号与脉冲信号</h2><p>电平信号也叫Latch信号，即一个信号持续多个时钟周期都一直保持为1的信号。</p><p>脉冲信号就是只持续一个时钟周期的信号。</p><p>工程师在交流时，对于电平信号a常用的说法是“将a给Latch住”​，对于脉冲信号b常用的说法是“打一个脉冲b”​。</p>]]></content>
      
      
      
        <tags>
            
            <tag> IC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1章 数字IC设计流程</title>
      <link href="/blog/2025/01/15/IC/1.%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B/"/>
      <url>/blog/2025/01/15/IC/1.%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-参考"><a href="#1-参考" class="headerlink" title="1. 参考"></a>1. 参考</h2><p>白栎旸. 数字IC设计入门（微课视频版）[M]. 北京: 清华大学出版社，2023-09-01:第1章.</p><h2 id="2-数字IC设计流程"><a href="#2-数字IC设计流程" class="headerlink" title="2. 数字IC设计流程"></a>2. 数字IC设计流程</h2><h3 id="2-1-三个主要流程："><a href="#2-1-三个主要流程：" class="headerlink" title="2.1. 三个主要流程："></a>2.1. 三个主要流程：</h3><ol><li><p>前端设计: 用 Verilog 编写 RTL 设计文件（Register Transfer Level，RTL，寄存器传输层）。</p></li><li><p>综合（Synthesis）：将 RTL 转换位实际电子元器件的连接。输出文件称为网表（netlist），也是纯文本文件。</p></li><li><p>后端布局布线（PR）：将网表变为实际电路图，类似 PCB 图，称为版图（Layout）。版图是晶圆厂（Foundry）能识别的通用格式。</p><p> 版图的绘制：</p><ul><li>布局（Place）：元器件如何摆放；</li><li>布线（Route）：元器件如何连接。</li></ul><p> 数字版图的绘制大部分由计算机自动完成，称为自动布局布线（Automatic Place and Route，APR），很多时候也称为 PR 。</p><p> 流片（TapeOut）：Foundry 根据版图制造芯片。</p></li></ol><h3 id="2-2-验收和验证（SignOff）："><a href="#2-2-验收和验证（SignOff）：" class="headerlink" title="2.2. 验收和验证（SignOff）："></a>2.2. 验收和验证（SignOff）：</h3><p>对质量进行把控和最终验收。</p><p>前仿真：检查 RTL 设计文件；用测试平台（Testbench）文件对实际应用环境仿真。这是在版图成型之前，称为前仿。一旦发现错误，验证人员会反馈给设计者修改，如此反复迭代，直至交付到综合阶段的 RTL 文件都是合格的。</p><p>SignOff 检查：检查版图设计；对时序和功耗检查。如果检查不过，首先是数字后端工程师自己努力，重新绘制版图或微调元器件位置，若无法达到目的，再修改综合策略，重新综合。若仍无法达到目的，则反馈到前端 IC 设计，在 RTL 上调整。</p><p>后仿真：在 SignOff 合格后，需要将网表和延迟信息提交给验证人员，进行后仿。对成型版图的时序进行最后验证和验收。后仿就是版图成型之后的仿真。</p><h3 id="2-3-可测性设计（Design-For-Test，DFT）"><a href="#2-3-可测性设计（Design-For-Test，DFT）" class="headerlink" title="2.3. 可测性设计（Design For Test，DFT）"></a>2.3. 可测性设计（Design For Test，DFT）</h3><p>一个附属工序，原理是在芯片中加入与主要功能无关的附属电路，用于在芯片的生产过程中使用 TestBench 快速判断芯片功能的完好行、内部结构的正常性。</p><p>如果芯片中包含 DFT 电路，则 TestBench 可以向芯片的某些引脚发送事先准备好的测试向量，在芯片的另一些引脚上采样芯片对测试向量的反应。将事先准备好的预期效果与实际采样到的结果进行对比，从而判断内部功能是否正常。</p><p>DFT 功能也常常被称为扫描（Scan），即用 TestBench 扫描芯片内部之意。DFT 的检查对象是生产差错造成的芯片损坏，它不能检查设计问题。设计问题应该交给验证工序。</p><p>DFT 对芯片来说不是必需的，一些低成本的芯片没有插入 DFT 电路，在设计流程中，直接从电路综合过渡到后端设计。</p><h3 id="2-4-前端设计-VS-后端设计"><a href="#2-4-前端设计-VS-后端设计" class="headerlink" title="2.4. 前端设计 VS 后端设计"></a>2.4. 前端设计 VS 后端设计</h3><ul><li>前端设计：抽象电路，只描述功能，不是具体电路。</li><li>后端设计：具体电路，不仅要知道哪些元器件，还要确认这些元器件的摆放位置。</li></ul><p>综合是前端和后端的分界线，综合之前没有元器件而只有功能；综合之后，设计才有了具体化的元器件。</p><p>当然，前端工程师往往强调心中有电路，并非实际电路，而是心中有功能相似的概念性电路。这样可以认清设计架构，并避免潜在的设计隐患。</p><h2 id="3-模拟IC设计流程"><a href="#3-模拟IC设计流程" class="headerlink" title="3. 模拟IC设计流程"></a>3. 模拟IC设计流程</h2><ol><li><p>绘制原理图（Schematic）</p><p> 手动绘制。</p></li><li><p>原理图仿真</p><p> 一般由原理图设计者亲自完成。原因是模拟电路的设计参数选择范围宽泛，需要验证的场景也复杂，仿真验收标准不十分明确。这就需要设计者搭建关键的应用环境和场景，对电路上产生的反应做出判断，随时调整电路结构和参数。</p></li><li><p>绘制版图（根据原理图）</p><p> 手动绘制。</p><p> 模拟版图工程师和模拟IC设计师一般是分开的两个职业。</p><p> 模拟IC设计师一般也都掌握一些绘制版图的方法，单熟练程度以及对一些物理问题的处理方面，需要求助专业的版图工程师。</p><p> 模拟版图工程师可以根据原理图及通用的绘图规则直接绘制。但是对诸如社评电路及高功率管之类有着特殊要求的设计，版图工程师需要与模拟IC设计师进行充分沟通，在模拟IC设计师的协助下进行绘制。</p></li><li><p>抽取寄生参数</p></li><li><p>版图后仿</p></li><li><p>设计规则检查（Design Rule Check，DRC）</p></li><li><p>版图和原理图的一致性检查（Layout Versus Schematics，LVS）</p></li><li><p>流片</p></li></ol><p>模拟IC设计没有那么多自动化成分，需要手动绘制原理图、版图，电阻、电容等元器件需要人工确定。</p><p>模拟IC仿真，无法像数字IC那样通过仿真验证和FPGA验证两种方法来相互印证设计效果。模拟仿真速度慢、情况多，很难覆盖真是使用中可能遇到的全部情况，因此，模拟设计具有很高的不确定，芯片的实际效果与仿真结果存在明显差距是经常发生的。</p><p>但是模拟电路也有一些无法被数字电路取代的特性。</p><p>可以想象，数字电路只需要处理 0 和 1 两种信号，但是模拟电路的数值域是实数域，包括所有连续的整数、浮点数、正负数，数据有无穷个。因此，即使是很小的电路，元器件数量不多，也需要设计者和仿真者从数值域中挑选一部份值作为设计和仿真中用到的值，绝对不可能覆盖所有情况。</p><h2 id="4-芯片整体规划"><a href="#4-芯片整体规划" class="headerlink" title="4. 芯片整体规划"></a>4. 芯片整体规划</h2><p>版图布局规划（FloorPlan）：将芯片整体规划，以及内部数字、模拟电路的位置、面积、形状等特征的规划。</p><figure style="text-align:center;"><img TODO width="50%"/><figcaption>FloorPlan示例</figcaption></figure><ul><li>Pad: FloorPlan的周围是芯片引脚(Pad)。Pad实际指的是芯片引脚之外的一块金属。</li><li>IO: 包括Pad和内部逻辑在内的整个引脚设计。</li></ul><p>一个完整的引脚设计如图：</p><img src="https://i.postimg.cc/MKfPd9z4/20250116222905.jpg" alt="20250116222905" width="50%"/><ul><li>封装: 芯片外面的塑料壳子称为芯片的封装，大体分为两种：插针式（引脚如针）、表贴式（引脚扁平）。</li></ul><h2 id="5-IC设计工具"><a href="#5-IC设计工具" class="headerlink" title="5. IC设计工具"></a>5. IC设计工具</h2><p>EDA 公司：电子设计自动化（Electronic Design Automation）公司，粗略来说，数字设计常用 Synopsys ，模拟设计常用 Cadence ， Mentor 在一些细分领域有优势。</p><table><thead><tr><th>数字&#x2F;模块</th><th>数字流程</th><th>常用软件</th><th>其他软件</th></tr></thead><tbody><tr><td>数字</td><td>RTL 编写</td><td>Vim&#x2F;Gvim</td><td>普通文本编辑器</td></tr><tr><td>数字</td><td>仿真</td><td>VCS (Synopsys)</td><td>Incisive (Cadence)</td></tr><tr><td>数字</td><td>看波形</td><td>Verdi (Synopsys)</td><td>DVE (Synopsys)</td></tr><tr><td>数字</td><td>设计检查</td><td>Spyglass (Synopsys)</td><td>Simvision (Cadence)</td></tr><tr><td>数字</td><td>综合</td><td>DC (Synopsys)</td><td>ModelSim (Mentor)</td></tr><tr><td>数字</td><td>时序仿真</td><td>PT (Synopsys)</td><td>nLint (Cadence)</td></tr><tr><td>数字</td><td>自动布局布线</td><td>ICC2 (Synopsys)</td><td>Genus (Cadence)</td></tr><tr><td>数字</td><td>设计版图形式验证</td><td>Formality (Synopsys)</td><td>Tempus (Cadence)</td></tr><tr><td>数字</td><td>提取寄生参数</td><td>StarRC (Synopsys)</td><td></td></tr><tr><td>模拟</td><td>原理图&#x2F;版图&#x2F;仿真等</td><td>Virtuoso (Cadence)</td><td>Calibre (Mentor)</td></tr><tr><td>模拟</td><td>寄生提取&#x2F;DRC&#x2F;LVS</td><td>Calibre (Mentor)</td><td></td></tr></tbody></table><p>仿真加速器： <strong>Palladium</strong> (Cadence) 、 <strong>ZeBu</strong> (Synopsys) 。</p><h3 id="5-1-数字IC设计工具"><a href="#5-1-数字IC设计工具" class="headerlink" title="5.1. 数字IC设计工具"></a>5.1. 数字IC设计工具</h3><p>RTL 仿真工具：有 Synopsys 的 VCS ，Cadence 的 Incisive （也叫 irun ）。这些工具可以胜任前仿、后仿、UVM 架构（Universal Verification Methodology，通用验证方法学）的仿真。Cadence 的 irun 与模拟设计工具 Virtuoso 工具中集成的 AMS 仿真工具相结合，支持数字模拟电路混合仿真。</p><p>波形查看工具：一般集成在仿真工具中。VCS 的波形软件叫 DVE ， Incisive 的波形软件叫 SimVision 。但在这个领域，一家名为 Novas 的公司的软件，以其明快的界面、方便的功能、快捷的操作，异军突起，得到了广泛的认可，它就是 Verdi （以音乐家威尔第的名字命名，前身叫 Debussy ，以音乐家德彪西的名字命名）。 Verdi 现已被 Synopsys 收购。 Mentor 的仿真和看波形软件叫 ModelSim ，主要用于 FPGA 功能的仿真。</p><p>RTL 语法检查工具： Atrenta 公司的 Sypyglass ，可以检查语法、跨时钟域处理方案的可靠性，甚至可以在内部执行综合、功耗评估和简单的布局布线，使它能全方位地给出设计建议。现已被 Synopsys 收购。 Cadence 的对应检查工具是 nLint 。</p><p>综合工具：即将 RTL 转化为实际电路的工具，常用的的有 Synopsys 的 Design Compiler (DC) ，该工具内部还有一些 Synopsys 开发的库，能够帮助设计者减小面积，提高性能，例如加法器、乘法器等，这些设计好的子模块在 DC 中被称为 DesignWare (DW) 。可以是让工具自动从 RTL 中识别出可用 DW 替换的代码，也可以是设计者手动例化 DW 模块。 Cadence 相应的工具叫 Genus （原名叫 RTL Compiler ）。</p><p>版图自动布局布线软件： Synopsys 有 ICC2 （旧版为 ICC ）， Cadence 有 Innovus （原名 Encounter ），两个软件都被广泛使用。由于两个软件的操作命令不同，后端工程师往往只掌握其中一种。 Synopsys 为了增强客户的黏性，开发了一个银河（ MilkyWay ）流程，从前端到后端，通过专用的二进制文件 (db) 传输，占用空间小，处理效率高，但也有许多公司使用 DC 综合，再将网表导入 Innovus 进行布局布线。</p><p>SignOff 工具：即对整个设计的时序、功耗评估。 Synopsys 的 Prime Time (PT) ， Cadence 的 Tempus 。目前， PT 已经称为业内 SignOff 的标准。实际上，时序分析在 DC 中也能做，但两者在分析方法、细节考虑全面度、分析速度等方面存在差异。在综合时使用 DC 检查，而在 SignOff 时，使用 PT 检查。</p><p>形式验证工具：也称为逻辑等效行检查（ Logic Equivalece Check, LEC ），将 RTL 和网表进行一一对照。因为从 RTL 到综合网表，以及从综合网表到后端网表的过程，可能意外地改变原有功能和设计意图，所以需要进行检查。 Synopsys 的工具时 Formality ， Candence 的工具是 Conformal 。</p><p>寄生参数的提取工具：进入设计版图阶段，可以确定走线的延迟。该值受信号负载、线路长短、粗细、周围线路等多重影响，需要用模型和查表进行计算，才能得到确切的值。该过程称为寄生参数的提取。一般使用 Synopsys 的 StarRC 。提取出来的信息可用于 PT 进行 SignOff 。</p><p>上述工具，最主要的控制语法是 TCL 语言， EDA 工具大多以该语言为基础，扩展出各种专用命令。</p><p>除了以上数字设计工具，还有一些更加细分的工具类型，比如仿真加速器，有 Cadence 的 Palladium 、 Synopsys 的 ZeBu 。</p><h3 id="5-2-模拟IC设计工具"><a href="#5-2-模拟IC设计工具" class="headerlink" title="5.2. 模拟IC设计工具"></a>5.2. 模拟IC设计工具</h3><p>主要是 Cadence 的 Virtuoso 。与数字设计中繁多的工具不同， Virtuoso 能满足大部分设计需求，例如绘制并仿真原理图、绘制并仿真版图、数模混合仿真等。实际上， Virtuoso 更像集成开发环境（ Integrated Development Environment, IDE ），它包含很多独立的设计工具，如仿真工具 Spectre 等。</p><p>SignOff 工具：Mentor 的 Calibre 可以用来提取寄生参数、进行 DRC 和 LVS 检查。</p><h3 id="5-3-职位、分工与工具"><a href="#5-3-职位、分工与工具" class="headerlink" title="5.3. 职位、分工与工具"></a>5.3. 职位、分工与工具</h3><table><thead><tr><th>大职位</th><th>细分职位</th><th>功能</th><th>常用工具</th></tr></thead><tbody><tr><td>数字</td><td>数字 IC 设计</td><td>设计芯片中的数字电路</td><td>Vim, VCS, Verdi, Spyglass, DC 等</td></tr><tr><td>数字</td><td>数字 IC 验证</td><td>验证芯片中的数字电路功能</td><td>VCS, Verdi 等</td></tr><tr><td>数字</td><td>数字 IC 后端</td><td>将抽象电路转换为版图</td><td>ICC2, Innovus, Calibre, PT 等</td></tr><tr><td>数字</td><td>其他职位, 如 SignOff, DFT 等</td><td>负责在数字电路中插入 DFT、对最终的版图进行时序、面积、功耗的检查等</td><td>DC, PT, Formality 等</td></tr><tr><td>模拟</td><td>模拟 IC 设计</td><td>设计芯片中的模拟电路</td><td>Virtuoso 等</td></tr><tr><td>模拟</td><td>模拟版图</td><td>将电路原理图做成版图</td><td>Virtuoso, Calibre 等</td></tr><tr><td>软件</td><td>嵌入式软件工程师</td><td>(1) 参与芯片开发&#x2F;验证 (2) 参与 SDK (3) 参与芯片应用方案</td><td>Keil, SourceInsight, Visual Studio 等</td></tr><tr><td>软件方案</td><td>测试工程师</td><td>(1) 对芯片设计性能的测试 (2) 芯片量产测试</td><td>兼用软件和硬件工具</td></tr><tr><td>硬方案</td><td>应用工程师</td><td>做电路板，为芯片找到合适的应用场景</td><td>Pads, Altium Designer, Cadence 等</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">管理</span><br><span class="line">├── 研发</span><br><span class="line">│   ├── 数字IC设计</span><br><span class="line">│   ├── 数字IC验证</span><br><span class="line">│   └── 数字后端</span><br><span class="line">│   └── 模拟IC设计</span><br><span class="line">│       └── 模拟版图</span><br><span class="line">├── 测试</span><br><span class="line">│   ├── 研发类测试</span><br><span class="line">│   │   ├── 方案测试</span><br><span class="line">│   │   └── 量产测试</span><br><span class="line">│   └── 客户测试</span><br><span class="line">├── 销售</span><br><span class="line">└── 方案</span><br><span class="line">    ├── 硬件方案</span><br><span class="line">    └── 软件方案</span><br></pre></td></tr></table></figure><h3 id="5-4-EDA-与-Foundry-的关系"><a href="#5-4-EDA-与-Foundry-的关系" class="headerlink" title="5.4. EDA 与 Foundry 的关系"></a>5.4. EDA 与 Foundry 的关系</h3><p>普通软件公司无力开发 EDA 软件。因为 EDA 厂商需要和 Foundry 厂商紧密合作，才能获得有关的生产细节数据，从而帮助用户进行更加准确的仿真、寄生参数的提取、规则的检查。不同的 EDA 工具抽取的寄生参数可能不同，原因可能是不同的工具获得的工艺数据不同。</p><p>国内 EDA 厂商要想打破垄断，不仅要靠软件技术，还要与各大 Foundry 厂达成战略合作，共享工艺数据，才能做出有实用价值的 EDA 工具。</p><h2 id="6-概念"><a href="#6-概念" class="headerlink" title="6. 概念"></a>6. 概念</h2><h3 id="6-1-寄存器："><a href="#6-1-寄存器：" class="headerlink" title="6.1. 寄存器："></a>6.1. 寄存器：</h3><p>register，这是对功能强调的名称，其物理实体很多，比如触发器 (Flip-Flop, FF)和锁存器(Latch)等等。在数字设计中，主要提倡触发器。</p><p>寄存器是受控于时钟沿的元器件， Foundry 会在标准单元库中提供多种寄存器。</p><p>触发器是由边沿信号而非电平信号导致数据存储的。触发源一般是时钟信号。</p><p>锁存器较少使用，它一般以非时钟信号为存储控制，靠电平触发。一般不连接时钟，只是连接一根普通的信号线。这种锁存器一般很少被纳入时钟计算中，因为它既不属于组合逻辑，又无法像触发器一样作为时序路径的起终点，所以时序上无法通过工具保证，只能通过工程师来保证。</p><p>本书说的寄存器，基本可以替换为触发器。在数字芯片 EDA 工具链中，两个概念也是混用的，一个 reg 既可以指寄存器，也可以指触发器。另外，所谓时序逻辑门电路，也基本等同于触发器。</p><h3 id="6-2-设计-Design-的边界"><a href="#6-2-设计-Design-的边界" class="headerlink" title="6.2. 设计(Design)的边界"></a>6.2. 设计(Design)的边界</h3><img src="https://i.postimg.cc/gjQMGZHN/20250116211433.jpg" alt="20250116211433" width="50%"/><ul><li><p>Pad：芯片（封装）之外的引脚。</p></li><li><p>元器件：指芯片内的组合逻辑门电路及时序逻辑门电路。这些标准的元器件也被称为标准单元(Standard Cell)。元器件也称为逻辑门。</p></li><li><p>标准单元库&#x2F;工艺库：元器件的集合。</p></li><li><p>I&#x2F;O: 如前“FloorPlan”对IO的解释，I&#x2F;O是包括Pad和内部逻辑在内的整个引脚设计。在标准单元库中是一种标准单元，但是它比较特殊，可能与其他标准单元不放在同一个标准单元库中。驱动电平也可能不同。</p></li><li><p>通用单元库: 在综合时，有一个中间步骤是将 RTL 抽象逻辑先映射为<strong>通用单元(Generic Boolean)<strong>，然后映射到</strong>标准单元</strong>。通用单元与工艺无关，也不包含物理特性，只有功能属性，与 RTL 描述类似。而标准单元既有功能属性，又有延迟、电压等工艺属性，与工艺和 Foundry 相关。</p></li><li><p>lef文件: Library Exchange Format. 描述特定流片工艺下元器件的物理属性。</p></li><li><p>lib文件: Library. 描述特定流片工艺下元器件的功能属性。lib文件常常要被编译为二进制的db文件才能在某些EDA工具上使用。 lef 和 lib 文件都是技术库。</p><p>  数字设计只能在 Foundry 提供的已有的选项中挑选元器件。</p></li><li><p>def文件: Design Exchange Format. 设计除了 RTL 外，也可以带有物理信息，保存为 def 文件，基础内容是设计的形状和尺寸，扩展内容包括端口的分布位置、RAM和ROM等硬核的放置位置、内部元器件的放置和布线位置等。 RTL 和 def 统称为设计。</p></li></ul><p>自己写的模块可以称为设备(Device)或模块(Module)。</p><p>用设备一词主要强调它具备相对独立的功能，在介绍SoC架构等上层逻辑时较为常用，设备也经常被替换为单元(Unit)一词，它指人为设计的单元，而非标准单元。一个设计可以包含很多个设备。</p><p>用模块一词，主要强调它在设计文件结构上的独立性，在介绍通用设计和底层逻辑时较为常用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> IC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VPN设置</title>
      <link href="/blog/2025/01/14/VPN%E8%AE%BE%E7%BD%AE/"/>
      <url>/blog/2025/01/14/VPN%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="让-VMWare-的-Linux-虚拟机共享-Windows-主机的-VPN"><a href="#让-VMWare-的-Linux-虚拟机共享-Windows-主机的-VPN" class="headerlink" title="让 VMWare 的 Linux 虚拟机共享 Windows 主机的 VPN"></a>让 VMWare 的 Linux 虚拟机共享 Windows 主机的 VPN</h2><p>方案 2：NAT 模式 + Windows 网络共享<br>另一种方式是保持 VMware 使用 NAT 模式，并通过 Windows 主机的网络共享功能，将 VPN 流量共享给虚拟机。</p><p>步骤：<br>在 Windows 上启用网络共享：</p><p>确保 Clash 在 Windows 主机上运行，并已连接到 VPN。<br>打开 控制面板 &gt; 网络和共享中心 &gt; 更改适配器设置。<br>右键点击你的 VPN 连接（通常是一个以 Ethernet 开头的适配器），选择 属性。<br>在 共享 标签页，勾选 允许其他网络用户通过此计算机的 Internet 连接连接。<br>选择虚拟机使用的网络适配器（例如 VMware 的 VMnet8 适配器），然后点击确定。<br>配置虚拟机网络为 NAT：</p><p>在 VMware 中，确保虚拟机的网络适配器设置为 NAT（这通常是默认设置）。<br>在 NAT 模式下，虚拟机会通过 Windows 主机访问网络，但流量会被路由到共享的网络适配器。<br>验证虚拟机是否可以通过 VPN 访问网络：</p><p>启动虚拟机，测试网络连接。<br>如果虚拟机连接成功并通过 VPN 访问互联网，那么配置就完成了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线段树</title>
      <link href="/blog/2024/09/28/Segment-Tree/"/>
      <url>/blog/2024/09/28/Segment-Tree/</url>
      
        <content type="html"><![CDATA[<p>线段树（Segment Tree）是一种将数组区间存储为树的数据结构 <a href="https://cp-algorithms.com/data_structures/segment_tree.html">^1</a>。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>查询连续子数组 或 查询范围内的最小元素：O(logn)</p><h2 id="最简单形式的线段树"><a href="#最简单形式的线段树" class="headerlink" title="最简单形式的线段树"></a>最简单形式的线段树</h2><h2 id="高阶版本的线段树"><a href="#高阶版本的线段树" class="headerlink" title="高阶版本的线段树"></a>高阶版本的线段树</h2><p>TODO</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://oi-wiki.org/ds/seg/#%E5%AE%9E%E7%8E%B0">OI wiki</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>shared_ptr 的实现</title>
      <link href="/blog/2024/09/26/Implementation-of-shared-ptr/"/>
      <url>/blog/2024/09/26/Implementation-of-shared-ptr/</url>
      
        <content type="html"><![CDATA[<h2 id="参考源码"><a href="#参考源码" class="headerlink" title="参考源码"></a>参考源码</h2><blockquote><p>&#x2F;usr&#x2F;include&#x2F;c++&#x2F;11&#x2F;bits&#x2F;shared_ptr_base.h<br>&#x2F;usr&#x2F;include&#x2F;c++&#x2F;11&#x2F;bits&#x2F;shared_ptr.h</p></blockquote><p>博客：<a href="https://zhiqiang.org/coding/std-shared-ptr.html">https://zhiqiang.org/coding/std-shared-ptr.html</a></p><h2 id="std-shared-ptr-的性质"><a href="#std-shared-ptr-的性质" class="headerlink" title="std::shared_ptr 的性质"></a><code>std::shared_ptr</code> 的性质</h2><ol><li>复制构造、析构是线程安全的。</li></ol><p>标准库使用原子操作实现无锁的线程安全性。</p><ol start="2"><li>写操作（例如 <code>reset</code> 、 赋值 <code>operator=</code> ）是线程不安全的。</li></ol><p>写操作和复制构造、析构的主要区别是：</p><ul><li>复制构造、析构函数中，单个线程只处理一个对象，复制构造函数将其他对象复制过来之后，不会改动其他对象的资源（引用计数、所管理的内存）。</li><li>但是写操作可能多个线程都在处理该 shared_ptr 。例如多个线程都对同一个 shared_ptr 进行赋值：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; sp1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">sp1 = sp2; <span class="comment">// 线程 1</span></span><br><span class="line">sp1 = sp3; <span class="comment">// 线程 2</span></span><br></pre></td></tr></table></figure><p>对比源码分析：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">     __shared_count&amp;</span><br><span class="line">     <span class="keyword">operator</span>=(<span class="type">const</span> __shared_count&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">     &#123;</span><br><span class="line">_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;</span><br><span class="line"><span class="keyword">if</span> (__tmp != _M_pi)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (__tmp != <span class="literal">nullptr</span>)</span><br><span class="line">      __tmp-&gt;_M_add_ref_copy();</span><br><span class="line">    <span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>)</span><br><span class="line">      _M_pi-&gt;_M_release(); <span class="comment">// 注意：线程 1 和线程 2 持有相同的 _M_pi！</span></span><br><span class="line">    _M_pi = __tmp; <span class="comment">// 注意：线程 1 和线程 2 持有相同的 _M_pi！</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>以上代码中两个“注意”可能同时在发生，例如：<br>线程 1 release 的时候，线程 2 在给 _M_pi 赋值；<br>或者两个线程同时在 release 或同时在给 _M_pi 赋值。</p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>管理的内存和引用计数都应该动态分配到堆（ heap ）上，这样多个 shared_ptr 对象才能更新同一份数据。</li><li>需要同时维护强引用计数和弱引用计数。</li><li>引用计数本身应该是一个控制块类，使用 <code>delete this</code> 来自动删除（析构）引用计数。</li></ol><p>永远不要手动 <code>delete use_count</code>，因为其他线程可能此时正在使用该资源，例如解引用 <code>*use_count</code>。</p><figure class="highlight cpp"><figcaption><span>SharedPtr.hpp</span><a href="/blog/downloads/code/SharedPtr.hpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;_Lock_policy _Lp = __default_lock_policy&gt;</span><br><span class="line">    <span class="keyword">class</span> _Sp_counted_base</span><br><span class="line">    : <span class="keyword">public</span> _Mutex_base&lt;_Lp&gt;</span><br><span class="line">    {</span><br><span class="line">      <span class="type">void</span></span><br><span class="line">      _M_add_ref_copy()</span><br><span class="line">      { __gnu_cxx::__atomic_add_dispatch(&amp;_M_use_count, <span class="number">1</span>); }</span><br><span class="line"></span><br><span class="line">      <span class="type">void</span></span><br><span class="line">      _M_release() <span class="keyword">noexcept</span></span><br><span class="line">      {</span><br><span class="line">        <span class="comment">// Be race-detector-friendly.  For more info see bits/c++config.</span></span><br><span class="line">        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_use_count);</span><br><span class="line"><span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, <span class="number">-1</span>) == <span class="number">1</span>)</span><br><span class="line">  {</span><br><span class="line">            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_use_count);</span><br><span class="line">    _M_dispose();</span><br><span class="line">    <span class="comment">// There must be a memory barrier between dispose() and destroy()</span></span><br><span class="line">    <span class="comment">// to ensure that the effects of dispose() are observed in the</span></span><br><span class="line">    <span class="comment">// thread that runs destroy().</span></span><br><span class="line">    <span class="comment">// See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html</span></span><br><span class="line">    <span class="keyword">if</span> (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)</span><br><span class="line">      {</span><br><span class="line">__atomic_thread_fence (__ATOMIC_ACQ_REL);</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Be race-detector-friendly.  For more info see bits/c++config.</span></span><br><span class="line">            _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);</span><br><span class="line">    <span class="keyword">if</span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count,</span><br><span class="line">       <span class="number">-1</span>) == <span class="number">1</span>)</span><br><span class="line">              {</span><br><span class="line">                _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);</span><br><span class="line">        _M_destroy();</span><br><span class="line">              }</span><br><span class="line">  }</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      _Sp_counted_base(_Sp_counted_base <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">      _Sp_counted_base&amp; <span class="keyword">operator</span>=(_Sp_counted_base <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// using _Atomic_word = int;</span></span><br><span class="line">      _Atomic_word  _M_use_count;     <span class="comment">// #shared</span></span><br><span class="line">      _Atomic_word  _M_weak_count;    <span class="comment">// #weak + (#shared != 0)</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;_Lock_policy _Lp&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">__shared_count</span></span><br><span class="line">    {</span><br><span class="line">      _Sp_counted_base&lt;_Lp&gt;*  _M_pi; <span class="comment">// 引用计数的指针</span></span><br><span class="line"></span><br><span class="line">      __shared_count(<span class="type">const</span> __shared_count&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">      : _M_pi(__r._M_pi)</span><br><span class="line">      {</span><br><span class="line"><span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>)</span><br><span class="line">  _M_pi-&gt;_M_add_ref_copy(); <span class="comment">// <span class="doctag">TODO:</span> 有没有可能此时的 _M_pi 所引对象已经被释放了呢</span></span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      ~__shared_count() <span class="keyword">noexcept</span></span><br><span class="line">      {</span><br><span class="line"><span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>)</span><br><span class="line">  _M_pi-&gt;_M_release(); <span class="comment">// 没有直接 delete _M_pi，</span></span><br><span class="line">                           <span class="comment">// 而是使用 _M_pi 的成员函数来释放它。</span></span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      __shared_count&amp;</span><br><span class="line">      <span class="keyword">operator</span>=(<span class="type">const</span> __shared_count&amp; __r) <span class="keyword">noexcept</span></span><br><span class="line">      {</span><br><span class="line">_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;</span><br><span class="line"><span class="keyword">if</span> (__tmp != _M_pi)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span> (__tmp != <span class="literal">nullptr</span>)</span><br><span class="line">      __tmp-&gt;_M_add_ref_copy();</span><br><span class="line">    <span class="keyword">if</span> (_M_pi != <span class="literal">nullptr</span>)</span><br><span class="line">      _M_pi-&gt;_M_release(); <span class="comment">// 没有直接 delete _M_pi，</span></span><br><span class="line">                               <span class="comment">// 而是使用 _M_pi 的成员函数来释放它。</span></span><br><span class="line">    _M_pi = __tmp;</span><br><span class="line">  }</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">      }</span><br><span class="line">    };</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/ext_concurrency.html">https://gcc.gnu.org/onlinedocs/libstdc++/manual/ext_concurrency.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> c/cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 的 bool 和 int</title>
      <link href="/blog/2024/09/17/cplusplus/C++%E7%9A%84bool%E5%92%8Cint/"/>
      <url>/blog/2024/09/17/cplusplus/C++%E7%9A%84bool%E5%92%8Cint/</url>
      
        <content type="html"><![CDATA[<p>在测试leetcode的 <a href="https://leetcode.cn/problems/bus-routes/description/">815.公交路线</a> 一题时，发现一个现象，当我使用<code>vector&lt;vector&lt;bool&gt;&gt;</code>作为图的邻接矩阵的类型时，运行速度比使用<code>vector&lt;vector&lt;int&gt;&gt;</code>慢了近1倍。使用<code>bool</code>运行速度为600ms左右，使用<code>int</code>时运行速度为300ms左右。</p><p>以下是ChatGPT的回答：</p><p>在C++中，bool类型并不一定比int类型慢，但在某些情况下，它们的性能表现可能有所不同。以下是一些与性能差异相关的考虑：</p><ol><li>内存大小<br>bool类型在标准中只需要表示 true（非0）和 false（0），通常占用1个字节（8位），而 int 通常占用4个字节（32位）。因此，bool类型可以节省内存，在某些情况下会带来缓存效率的提升，尤其是在处理大量布尔值时（例如布尔数组）。</li><li>对齐和内存访问<br>在某些架构上，处理单字节的bool类型时，可能会有额外的开销，因为处理器通常优化对齐访问。如果内存没有正确对齐，处理器可能需要额外的操作来处理非对齐的字节，导致性能下降。相比之下，int的对齐通常与系统的内存总线对齐更好（如32位或64位系统上），因此读取和写入可能更高效。</li><li>指令集和操作<br>现代处理器在处理布尔值时通常会将其扩展为完整的寄存器大小（例如32位或64位）。因此，虽然bool类型的存储可能更小，但在实际操作中，处理器可能将它提升为int或更大的类型来执行逻辑操作。处理布尔值可能涉及隐式类型转换，这在某些极端情况下可能带来开销。</li><li>寄存器使用<br>int 类型可以直接映射到处理器寄存器中进行操作，而 bool 类型的操作有时可能会涉及额外的逻辑运算（如掩码操作）以确保布尔值的正确性。</li><li>编译器优化<br>现代编译器在优化时会考虑到bool与int的差异，并尽量优化代码，因此在大多数应用场景下，你不会感受到显著的性能差异。但在一些特定的场合（如大规模数组、频繁内存访问等），bool类型的使用确实可能带来性能影响，尤其是在处理器需要对齐或执行额外的操作时。<br>总结<br>bool类型通常并不会比int慢，实际的性能差异取决于平台、内存对齐、编译器优化以及应用场景。在大多数情况下，差异是微不足道的，但在对性能非常敏感的程序中，这种差异可能会显现。</li></ol>]]></content>
      
      
      <categories>
          
          <category> c/cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bash Debugging</title>
      <link href="/blog/2024/09/06/linux/Bash-Debugging/"/>
      <url>/blog/2024/09/06/linux/Bash-Debugging/</url>
      
        <content type="html"><![CDATA[<h1 id="bash调试技巧"><a href="#bash调试技巧" class="headerlink" title="bash调试技巧"></a>bash调试技巧</h1><h2 id="set-x"><a href="#set-x" class="headerlink" title="set -x"></a><code>set -x</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS4=<span class="string">&#x27;+ $&#123;LINENO&#125;: &#x27;</span></span><br><span class="line"><span class="built_in">set</span> -x</span><br></pre></td></tr></table></figure><p>说明：<code>PS4</code>设置打印格式，<code>$LINENO</code>表示打印行号。</p><h2 id="trap-DEBUG"><a href="#trap-DEBUG" class="headerlink" title="trap DEBUG"></a><code>trap DEBUG</code></h2><p>设置DEBUG陷阱，该陷阱在每一条“简单语句”执行完毕之后会被调用一次。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -o functrace</span><br><span class="line">track_var=<span class="string">&quot;my_var&quot;</span></span><br><span class="line">old_value=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="title">check_var_change</span></span>() &#123;</span><br><span class="line">    new_value=<span class="string">&quot;<span class="variable">$&#123;!track_var&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$new_value</span>&quot;</span> != <span class="string">&quot;<span class="variable">$old_value</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$track_var</span> changed to \&quot;<span class="variable">$new_value</span>\&quot; at <span class="variable">$BASH_LINENO</span>&quot;</span></span><br><span class="line">        old_value=<span class="string">&quot;<span class="variable">$new_value</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">trap</span> check_var_change DEBUG</span><br></pre></td></tr></table></figure><p>说明：监控<code>my_var</code>变量的变化，如果变化，则打印新值。</p><p>注意：实际测试中，我们发现<code>trap</code>监控变量变化似乎会延迟，而<code>set -x</code>打印的信息是可靠的。</p><h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><p>参考：<a href="https://www.gnu.org/software/bash/manual/html_node/Bash-Variables.html">https://www.gnu.org/software/bash/manual/html_node/Bash-Variables.html</a></p><ul><li><code>BASH_LINENO</code>: 这是一个数组变量，‌用于表示当前执行的脚本或函数中每一行的行号。‌它特别适用于调试，‌因为它可以追踪到函数调用栈中每一层的行号。‌通过访问BASH_LINENO数组的不同索引，‌可以获取到不同函数调用层级对应的行号信息‌。</li><li><code>LINENO</code>: 获取当前脚本行号‌，‌而不涉及函数调用栈的追踪‌。</li><li><code>FUNCNAME</code>: 函数名</li><li><code>BASH_SOURCE</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>File Exists</title>
      <link href="/blog/2024/09/06/linux/File-Exists/"/>
      <url>/blog/2024/09/06/linux/File-Exists/</url>
      
        <content type="html"><![CDATA[<h1 id="判断文件是否存在"><a href="#判断文件是否存在" class="headerlink" title="判断文件是否存在"></a>判断文件是否存在</h1><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><ul><li><code>access</code></li><li><code>stat</code></li><li><code>inotify_node</code></li><li><code>opendir</code></li><li><code>readdir</code></li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>文件系统并不会实时刷新缓存，尤其是在网络文件系统中。这会导致文件即使已经创建，<code>access</code>或<code>stat</code>函数依然返回”No such file”。<br>但是<code>ls</code>可以看到文件，这是因为<code>ls</code>和<code>access</code>函数的实现机制不同。</p><p>例如：</p><p>在<code>NFS</code>文件系统中，创建文件之后立即调用<code>stat</code>命令查看文件，<code>stat</code>会报告“文件不存在”。<br>删除文件之后立即调用<code>stat</code>命令查看文件，发现<code>stat</code>依然可以看到该文件。</p><p>我们可以改用<code>readdir</code>来读取目录，因为目录会被更快地更新缓存。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libtirpc Usage</title>
      <link href="/blog/2024/07/08/libtirpc-Usage/"/>
      <url>/blog/2024/07/08/libtirpc-Usage/</url>
      
        <content type="html"><![CDATA[<h2 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h2><ul><li><a href="https://www.ibm.com/docs/en/i/7.3?topic=communications-using-sun-ti-rpc-develop-distributed-applications">TI-RPC</a></li><li><a href="https://www.ibm.com/docs/en/aix/7.1?topic=call-rpc-language">RPC language</a></li><li><a href="https://docs.oracle.com/cd/E19683-01/816-1435/xdrproto-61652/index.html">XDR Protocol</a></li><li><a href="https://www.ibm.com/docs/en/i/7.3?topic=applications-using-rpcgen-compiler">PRC Compiler</a></li><li><a href="https://docs.oracle.com/cd/E19683-01/816-1435/rpcgenpguide-21470/index.html">rpcgen</a></li><li><a href="https://docs-archive.freebsd.org/44doc/psd/22.rpcgen/paper.pdf">rpcgen programming guide</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> rpcgen</span><br><span class="line">/bin/rpcgen</span><br><span class="line">$ rpcgen</span><br><span class="line">usage: rpcgen infile</span><br><span class="line">        rpcgen [-abkCLNTM][-Dname[=value]] [-i size] [-I [-K seconds]] [-Y path] infile</span><br><span class="line">        rpcgen [-c | -h | -l | -m | -t | -Sc | -Ss | -Sm] [-o outfile] [infile]</span><br><span class="line">        rpcgen [-s nettype]* [-o outfile] [infile]</span><br><span class="line">        rpcgen [-n netid]* [-o outfile] [infile]</span><br><span class="line">options:</span><br><span class="line">-a              generate all files, including samples</span><br><span class="line">-b              backward compatibility mode (generates code <span class="keyword">for</span> SunOS 4.1)</span><br><span class="line">-c              generate XDR routines</span><br><span class="line">-C              ANSI C mode</span><br><span class="line">-Dname[=value]  define a symbol (same as <span class="comment">#define)</span></span><br><span class="line">-h              generate header file</span><br><span class="line">-i size         size at <span class="built_in">which</span> to start generating inline code</span><br><span class="line">-I              generate code <span class="keyword">for</span> inetd support <span class="keyword">in</span> server (<span class="keyword">for</span> SunOS 4.1)</span><br><span class="line">-K seconds      server exits after K seconds of inactivity</span><br><span class="line">-l              generate client side stubs</span><br><span class="line">-L              server errors will be printed to syslog</span><br><span class="line">-m              generate server side stubs</span><br><span class="line">-M              generate MT-safe code</span><br><span class="line">-n netid        generate server code that supports named netid</span><br><span class="line">-N              supports multiple arguments and call-by-value</span><br><span class="line">-o outfile      name of the output file</span><br><span class="line">-s nettype      generate server code that supports named nettype</span><br><span class="line">-Sc             generate sample client code that uses remote procedures</span><br><span class="line">-Ss             generate sample server code that defines remote procedures</span><br><span class="line">-Sm             generate makefile template </span><br><span class="line">-t              generate RPC dispatch table</span><br><span class="line">-T              generate code to support RPC dispatch tables</span><br><span class="line">-Y path         directory name to find C preprocessor (cpp)</span><br><span class="line"></span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/libc/bugs.html&gt;.</span><br></pre></td></tr></table></figure><p>Note:</p><p><code>%</code> 可以用来转义某行，任何句首带有 <code>%</code> 的行将被视作字符串，直接放入到输出文件中。<br>注意：<code>rpcgen</code> 可能改变该行的位置，所以应该在输出文件中对这些行进行仔细检查。</p><p><code>rpcgen</code> provides an additional preprocessing feature: any line that begins with a percent sign (<code>%</code>) is passed directly to the output file, with no action on the line’s content. Use caution because <code>rpcgen</code> does not always place the lines where you intend. Check the output source file and, if needed, edit it.</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;abc.h&quot;</span><br></pre></td></tr></table></figure><p>当执行 <code>rpcgen infile</code> 命令时，由于 “abc.h” 不存在，可能会报错。</p><p>但是如果在句首添加一个 <code>%</code> 符号，则可以绕过检查。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%#include &quot;abc.h&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hair</title>
      <link href="/blog/2024/05/08/english/Hair/"/>
      <url>/blog/2024/05/08/english/Hair/</url>
      
        <content type="html"><![CDATA[<h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><p><a href="https://www.youtube.com/watch?v=EzFtsYC4pPg&t=344s">Free English Class! Topic: Hair! 🧔🏽💇✂️ (Lesson Only)</a></p><h2 id="Words-Phrases"><a href="#Words-Phrases" class="headerlink" title="Words&#x2F;Phrases"></a>Words&#x2F;Phrases</h2><p>eyelashes<br>makeup<br>hairstyle&#x2F;hairdo<br>get my hair done<br>hair gel<br>buzz cut<br>helmet<br>When you have a lot of hair, the helmet makes your hair flat.<br>hair colouring</p>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hair </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Multi Thread and Signals</title>
      <link href="/blog/2024/03/22/thread/Multi-Thread-and-Signals/"/>
      <url>/blog/2024/03/22/thread/Multi-Thread-and-Signals/</url>
      
        <content type="html"><![CDATA[<p>From ChatGPT:</p><p>In general, when a program enters a signal handler in a multi-threaded environment, the behavior regarding other threads depends on how the signal handler is set up and the specific signal that is being handled.</p><ol><li>Default Behavior: By default, when a signal is delivered to a process, it interrupt the thread that is currently running and executes the signal handler in the context of that thread. Other threads in the process continue running unless they are also interrupted by signals.</li><li>Thread-Specific Signal Handling: Some signals, such as SIGINT (interrupt signal), SIGTERM (termination signal), or SIGABRT (abort signal), are typically delivered to the entire process, which means they can interrupt any thread. However, other signals, like SIGSEGV (segmentation fault) or SIGILL (illegal signal), are usually delivered to the specific thread that caused the signal.</li><li>Signal Masking: In a multi-threaded program, you can use signal masking (sigprocmask in POSIX systems) to block certain signals in specific threads. This can affect whether a signal handler interrupts a particular thread or not.</li><li>Asynchronous-Signal-Safe Functions: Signal handlers should only execute functions are considered “asynchronous-signal-safe” according to POSIX standards. These functions are designed to be safe to call from within a signal handler. Using non-safe functions in a signal handler can lead to undefined behavior.</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> thread </tag>
            
            <tag> signal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TBB入门</title>
      <link href="/blog/2024/02/24/thread/TBB%E5%85%A5%E9%97%A8/"/>
      <url>/blog/2024/02/24/thread/TBB%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-控制线程数"><a href="#1-控制线程数" class="headerlink" title="1. 控制线程数"></a>1. 控制线程数</h2><ul><li>Method 1: Use the environment variable <code>TBB_NUM_THREADS</code> for the gloabl setting.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> TBB_NUM_THREADS=4</span><br></pre></td></tr></table></figure><p>TODO: It doesn’t seem to work!</p><ul><li>Method 2: Use <code>tbb::task_arena</code> or <code>tbb::task_scheduler_init</code> (Deprecated).</li></ul><p>TBB will use this setting locally within the scope of the <code>tbb::task_arena</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/pipeline.h&gt;</span></span></span><br><span class="line"><span class="comment">// Deprecated:</span></span><br><span class="line"><span class="comment">// #include &lt;tbb/task_scheduler_init.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/task_arena.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Define your pipeline body</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPipeline</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(tbb::flow_control&amp; fc)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Your pipeline logic here</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// Inform the pipeline that there is no more data</span></span><br><span class="line">        fc.<span class="built_in">stop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Deprecated: tbb::task_scheduler_init init(1);</span></span><br><span class="line">    <span class="function">tbb::task_arena <span class="title">arena</span><span class="params">(<span class="number">4</span>)</span></span>; <span class="comment">// 4 threads</span></span><br><span class="line">    <span class="comment">// Do some tasks:</span></span><br><span class="line">    tbb::<span class="built_in">parallel_pipeline</span>(<span class="comment">/* max_number_of_live_tokens */</span> <span class="number">4</span>, MyPipeline); <span class="comment">// <span class="doctag">FIXME:</span> 似乎需要放入 arena 的 execute 函数中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-parallel-for"><a href="#2-parallel-for" class="headerlink" title="2. parallel_for"></a>2. <code>parallel_for</code></h2><p>API: <a href="https://oneapi-spec.uxlfoundation.org/specifications/oneapi/latest/elements/onetbb/source/algorithms/functions/parallel_for_func">parallel_for</a></p><ol><li>用 <code>my_parallel_for</code> 模拟 <code>parallel_for</code> 的实现：</li></ol><figure class="highlight cpp"><figcaption><span>my_parallel_for.cpp</span><a href="/blog/downloads/code/TBB/my_parallel_for.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/tbb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟 parallel_for 的内部实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_parallel_for</span><span class="params">(<span class="type">const</span> tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&amp; range, <span class="type">const</span> std::function&lt;<span class="type">void</span>(<span class="type">const</span> tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&amp;)&gt;&amp; body)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (range.<span class="built_in">is_divisible</span>()) {</span><br><span class="line">        <span class="comment">// 分割范围</span></span><br><span class="line">        <span class="function">tbb::blocked_range&lt;<span class="type">size_t</span>&gt; <span class="title">left</span><span class="params">(range.begin(), range.begin() + (range.end() - range.begin()) / <span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="function">tbb::blocked_range&lt;<span class="type">size_t</span>&gt; <span class="title">right</span><span class="params">(left.end(), range.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归调用</span></span><br><span class="line">        tbb::<span class="built_in">parallel_invoke</span>(</span><br><span class="line">            [&amp;] { <span class="built_in">my_parallel_for</span>(left, body); },</span><br><span class="line">            [&amp;] { <span class="built_in">my_parallel_for</span>(right, body); }</span><br><span class="line">        );</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 处理当前范围</span></span><br><span class="line">        <span class="built_in">body</span>(range);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) {</span><br><span class="line">        data[i] = i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用自定义的 parallel_for 进行并行处理</span></span><br><span class="line">    <span class="built_in">my_parallel_for</span>(tbb::<span class="built_in">blocked_range</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>, data.<span class="built_in">size</span>()), [&amp;](<span class="type">const</span> tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i) {</span><br><span class="line">            data[i] *= <span class="number">2</span>; <span class="comment">// 示例操作：将每个元素乘以2</span></span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; val : data) {</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ol start="2"><li>发出任务的线程也会成为工作线程之一，并参与任务的执行，测试代码如下：</li></ol><figure class="highlight cpp"><figcaption><span>test_parallel_for.cpp</span><a href="/blog/downloads/code/TBB/test_parallel_for.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/tbb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tbb;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> std::atomic&lt;<span class="type">int</span>&gt; <span class="title">total_blocks</span><span class="params">(<span class="number">0</span>)</span></span>;  <span class="comment">// Atomic counter to track the number of tasks processed</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::atomic&lt;<span class="type">int</span>&gt; <span class="title">total_blocks2</span><span class="params">(<span class="number">0</span>)</span></span>;  <span class="comment">// Atomic counter to track the number of tasks processed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to process each data element</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_data</span><span class="params">(<span class="type">int</span> i, std::mutex&amp; mtx)</span> </span>{</span><br><span class="line">    <span class="comment">// std::this_thread::sleep_for(std::chrono::milliseconds(1));  // Simulate some processing time</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">        ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) {</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;number_of_elements&gt;&quot;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;&lt;grain_size&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num_elements = std::<span class="built_in">stoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> grain_size = std::<span class="built_in">stoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">(num_elements)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_elements; ++i) {</span><br><span class="line">        data[i] = i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// {</span></span><br><span class="line">    <span class="comment">//     std::lock_guard&lt;std::mutex&gt; lock(mtx);</span></span><br><span class="line">    <span class="comment">//     std::cout &lt;&lt; &quot;Main thread ID: &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">// }</span></span><br><span class="line"></span><br><span class="line">    tbb::concurrent_unordered_map&lt;std::thread::id, tbb::concurrent_vector&lt;<span class="type">int</span>&gt;&gt; thread_task_counts;  <span class="comment">// To store task counts for each thread</span></span><br><span class="line">    tbb::concurrent_unordered_map&lt;std::thread::id, tbb::concurrent_vector&lt;<span class="type">int</span>&gt;&gt; thread_task_counts2;  <span class="comment">// To store task counts for each thread</span></span><br><span class="line"></span><br><span class="line">    tbb::<span class="built_in">parallel_for</span>(<span class="number">0</span>, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;((data.<span class="built_in">size</span>() + grain_size - <span class="number">1</span>) / grain_size), [&amp;](<span class="type">int</span> i) {</span><br><span class="line">        total_blocks++;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;  <span class="comment">// Thread-local variable to avoid data</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i * grain_size; j &lt; std::<span class="built_in">min</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(data.<span class="built_in">size</span>()), (i + <span class="number">1</span>) * grain_size); ++j) {</span><br><span class="line">            <span class="built_in">process_data</span>(i, mtx);</span><br><span class="line">            ++cnt;</span><br><span class="line">        }</span><br><span class="line">        thread_task_counts[std::this_thread::<span class="built_in">get_id</span>()].<span class="built_in">push_back</span>(cnt);</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    tbb::<span class="built_in">parallel_for</span>(<span class="built_in">blocked_range</span>&lt;<span class="type">int</span>&gt;(<span class="number">0u</span>, data.<span class="built_in">size</span>(), grain_size), [&amp;](<span class="type">const</span> blocked_range&lt;<span class="type">int</span>&gt;&amp; r) {</span><br><span class="line">        total_blocks2++;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;  <span class="comment">// Thread-local variable to avoid data</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r.<span class="built_in">begin</span>(); i &lt; r.<span class="built_in">end</span>(); ++i) {</span><br><span class="line">            <span class="built_in">process_data</span>(i, mtx);</span><br><span class="line">            ++cnt;</span><br><span class="line">        }</span><br><span class="line">        thread_task_counts2[std::this_thread::<span class="built_in">get_id</span>()].<span class="built_in">push_back</span>(cnt);</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Total blocks processed: &quot;</span> &lt;&lt; total_blocks.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : thread_task_counts) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot; processed: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; task_count : pair.second)</span><br><span class="line">            std::cout &lt;&lt; task_count &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Total blocks2 processed: &quot;</span> &lt;&lt; total_blocks2.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : thread_task_counts2) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot; processed: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; task_count : pair.second)</span><br><span class="line">            std::cout &lt;&lt; task_count &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ./test_parallel_for </span><br><span class="line">Main thread ID: 140220582070080</span><br><span class="line">Processing data: 2 on thread 140220582070080</span><br><span class="line">Processing data: 6 on thread 140220557755968</span><br><span class="line">Processing data: 4 on thread 140220574795328</span><br><span class="line">Processing data: 8 on thread 140220566275648</span><br><span class="line">Processing data: 10 on thread 140220562015808</span><br></pre></td></tr></table></figure><p>可见，<code>data 2</code> 是由主线程处理的。也就是说，<code>parallel_for</code> 虽然被称为 a blocking parallel construt，但线程等待所有任务完成期间是非阻塞的，它还可以充当工作线程执行任务池中的任务。</p><p>代码模拟 <code>parallel_for</code> 的 <code>wait</code> ：</p><figure class="highlight cpp"><figcaption><span>my_task_scheduler.cpp</span><a href="/blog/downloads/code/TBB/my_task_scheduler.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskScheduler</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskScheduler</span>(<span class="type">size_t</span> numThreads);</span><br><span class="line">    ~<span class="built_in">TaskScheduler</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; task)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::thread&gt; workers;</span><br><span class="line">    std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks;</span><br><span class="line">    std::mutex queueMutex;</span><br><span class="line">    std::condition_variable condition;</span><br><span class="line">    std::condition_variable finished;</span><br><span class="line">    <span class="type">bool</span> stop;</span><br><span class="line">    <span class="type">size_t</span> activeTasks;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">workerThread</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">executeTask</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">TaskScheduler::<span class="built_in">TaskScheduler</span>(<span class="type">size_t</span> numThreads) : <span class="built_in">stop</span>(<span class="literal">false</span>), <span class="built_in">activeTasks</span>(<span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; numThreads; ++i) {</span><br><span class="line">        workers.<span class="built_in">emplace_back</span>(&amp;TaskScheduler::workerThread, <span class="keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">TaskScheduler::~<span class="built_in">TaskScheduler</span>() {</span><br><span class="line">    {</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queueMutex)</span></span>;</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    condition.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="keyword">for</span> (std::thread &amp;worker : workers) {</span><br><span class="line">        worker.<span class="built_in">join</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskScheduler::enqueue</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; task)</span> </span>{</span><br><span class="line">    {</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queueMutex)</span></span>;</span><br><span class="line">        tasks.<span class="built_in">push</span>(std::<span class="built_in">move</span>(task));</span><br><span class="line">    }</span><br><span class="line">    condition.<span class="built_in">notify_one</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskScheduler::wait</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queueMutex)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!tasks.<span class="built_in">empty</span>() || activeTasks &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 如果还有任务，执行一个任务，避免当前线程被阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (!tasks.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="built_in">executeTask</span>();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            finished.<span class="built_in">wait</span>(lock);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskScheduler::workerThread</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        std::function&lt;<span class="type">void</span>()&gt; task;</span><br><span class="line">        {</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queueMutex)</span></span>;</span><br><span class="line">            condition.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] { <span class="keyword">return</span> stop || !tasks.<span class="built_in">empty</span>(); });</span><br><span class="line">            <span class="keyword">if</span> (stop &amp;&amp; tasks.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">            task = std::<span class="built_in">move</span>(tasks.<span class="built_in">front</span>());</span><br><span class="line">            tasks.<span class="built_in">pop</span>();</span><br><span class="line">            ++activeTasks;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">task</span>();</span><br><span class="line">        {</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queueMutex)</span></span>;</span><br><span class="line">            --activeTasks;</span><br><span class="line">            <span class="keyword">if</span> (tasks.<span class="built_in">empty</span>() &amp;&amp; activeTasks == <span class="number">0</span>) {</span><br><span class="line">                finished.<span class="built_in">notify_all</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskScheduler::executeTask</span><span class="params">()</span> </span>{</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; task;</span><br><span class="line">    {</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queueMutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (tasks.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">        task = std::<span class="built_in">move</span>(tasks.<span class="built_in">front</span>());</span><br><span class="line">        tasks.<span class="built_in">pop</span>();</span><br><span class="line">        ++activeTasks;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">task</span>();</span><br><span class="line">    {</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queueMutex)</span></span>;</span><br><span class="line">        --activeTasks;</span><br><span class="line">        <span class="keyword">if</span> (tasks.<span class="built_in">empty</span>() &amp;&amp; activeTasks == <span class="number">0</span>) {</span><br><span class="line">            finished.<span class="built_in">notify_all</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallel_for</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; func)</span> </span>{</span><br><span class="line">    <span class="function"><span class="type">static</span> TaskScheduler <span class="title">scheduler</span><span class="params">(std::thread::hardware_concurrency())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; end; ++i) {</span><br><span class="line">        scheduler.<span class="built_in">enqueue</span>([i, &amp;func] { <span class="built_in">func</span>(i); });</span><br><span class="line">    }</span><br><span class="line">    scheduler.<span class="built_in">wait</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N1 = <span class="number">100</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N2 = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The first parallel loop.</span></span><br><span class="line">    <span class="built_in">parallel_for</span>(<span class="number">0</span>, N1, [&amp;](<span class="type">int</span> i) {</span><br><span class="line">        <span class="comment">// The second parallel loop.</span></span><br><span class="line">        <span class="built_in">parallel_for</span>(<span class="number">0</span>, N2, [&amp;](<span class="type">int</span> j) {</span><br><span class="line">            <span class="comment">// Some work</span></span><br><span class="line">        });</span><br><span class="line">        <span class="comment">// 线程发出 parallel_for 之后，需要等待内部所有 parallel loop 的任务完成</span></span><br><span class="line">        <span class="comment">// 在此期间允许继续拿取外部的 parallel loop 的任务执行</span></span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="3-TBB线程池"><a href="#3-TBB线程池" class="headerlink" title="3. TBB线程池"></a>3. TBB线程池</h2><p>TBB似乎总是使用同一个全局线程池。测试代码如下：</p><figure class="highlight cpp"><figcaption><span>tbb_thread_pool.cpp</span><a href="/blog/downloads/code/TBB/tbb_thread_pool.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/tbb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task_group_function</span><span class="params">()</span> </span>{</span><br><span class="line">    tbb::task_group tg;</span><br><span class="line">    <span class="type">int</span> max_concurrency = tbb::this_task_arena::<span class="built_in">max_concurrency</span>();</span><br><span class="line">    {</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Task group max concurrency: &quot;</span> &lt;&lt; max_concurrency &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i) {</span><br><span class="line">        tg.<span class="built_in">run</span>([i] {</span><br><span class="line">            {</span><br><span class="line">                std::lock_guard&lt;std::mutex&gt; <span class="built_in">lock</span>(mtx);</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Task group thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; is running.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">    tg.<span class="built_in">wait</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task_arena_function</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">tbb::task_arena <span class="title">arena</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> max_concurrency = arena.<span class="built_in">max_concurrency</span>();</span><br><span class="line">    {</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Task arena max concurrency: &quot;</span> &lt;&lt; max_concurrency &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    arena.<span class="built_in">execute</span>([max_concurrency] {</span><br><span class="line">        tbb::<span class="built_in">parallel_for</span>(<span class="number">0</span>, <span class="number">16</span>, [](<span class="type">int</span> i) {</span><br><span class="line">            {</span><br><span class="line">                std::lock_guard&lt;std::mutex&gt; <span class="built_in">lock</span>(mtx);</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Task arena thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; is running.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">        });</span><br><span class="line">    });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 获取默认task_arena的最大并发线程数</span></span><br><span class="line">    <span class="type">int</span> arena_max_concurrency = tbb::this_task_arena::<span class="built_in">max_concurrency</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Default task_arena max concurrency: &quot;</span> &lt;&lt; arena_max_concurrency &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">tg_thread</span><span class="params">(task_group_function)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">ta_thread</span><span class="params">(task_arena_function)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待两个线程完成</span></span><br><span class="line">    tg_thread.<span class="built_in">join</span>();</span><br><span class="line">    ta_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build &amp;&amp; cmake .. &amp;&amp; make</span><br><span class="line">$ ./tbb_thread_pool &gt; result.txt</span><br><span class="line">$ <span class="built_in">cat</span> result.txt | grep running | <span class="built_in">sort</span> | <span class="built_in">uniq</span></span><br><span class="line">Task arena thread 140667163379264 is running.</span><br><span class="line">Task arena thread 140667167639104 is running.</span><br><span class="line">Task arena thread 140667184678464 is running.</span><br><span class="line">Task arena thread 140667201848896 is running.</span><br><span class="line">Task group thread 140667167639104 is running.</span><br><span class="line">Task group thread 140667171898944 is running.</span><br><span class="line">Task group thread 140667176158784 is running.</span><br><span class="line">Task group thread 140667180418624 is running.</span><br><span class="line">Task group thread 140667188938304 is running.</span><br><span class="line">Task group thread 140667210303040 is running.</span><br></pre></td></tr></table></figure><p>从这两行日志可以看出，arena 和 group 重用了同一个线程 ID ，说明它们同属于同一个全局线程池。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Task arena thread 140667167639104 is running.</span><br><span class="line">Task group thread 140667167639104 is running.</span><br></pre></td></tr></table></figure><p>进一步，我们发现全局线程池中的线程总数是自适应的，比如本例就是 <code>10</code> 个，既不是 <code>task_group</code> 的 <code>8</code> 个，<br>也不是 <code>task_arena</code> 的 <code>4</code> 个：</p><p>TODO</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> result.txt | grep running | <span class="built_in">sort</span> | <span class="built_in">uniq</span> | <span class="built_in">wc</span> -l</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="4-任务调度器（Task-Scheduler）"><a href="#4-任务调度器（Task-Scheduler）" class="headerlink" title="4. 任务调度器（Task Scheduler）"></a>4. 任务调度器（Task Scheduler）</h2><p><a href="https://uxlfoundation.github.io/oneTBB/main/tbb_userguide/The_Task_Scheduler.html">The Task Scheduler</a></p><h3 id="4-1-基于任务编程（Task-Based-Programming）"><a href="#4-1-基于任务编程（Task-Based-Programming）" class="headerlink" title="4.1. 基于任务编程（Task-Based Programming）"></a>4.1. 基于任务编程（Task-Based Programming）</h3><p>当追求性能时，推荐以逻辑任务（logical tasks）而不是线程（threads）来编程，有以下原因：</p><ul><li>将并行性与可用资源匹配</li><li>更快的任务启动和关闭</li><li>更有效的评估顺序</li><li>改进负载均衡</li><li>更高层的思考</li></ul><p>TODO</p><h3 id="4-2-任务调度器（Task-Scheduler）如何工作"><a href="#4-2-任务调度器（Task-Scheduler）如何工作" class="headerlink" title="4.2. 任务调度器（Task Scheduler）如何工作"></a>4.2. 任务调度器（Task Scheduler）如何工作</h3><p><a href="https://uxlfoundation.github.io/oneTBB/main/tbb_userguide/How_Task_Scheduler_Works.html">How Task Scheduler Works</a></p><h4 id="4-2-1-深度优先（depth-first）"><a href="#4-2-1-深度优先（depth-first）" class="headerlink" title="4.2.1. 深度优先（depth-first）"></a>4.2.1. 深度优先（depth-first）</h4><p>每个线程都有自己的双端队列，头部称为 top （也称顶部），尾部称为 bottom （也称底部）。<br>队列的底部是队列的最深处（最末处），底部任务是最新的，顶部任务是最旧的。</p><p>深度优先有以下好处：</p><ul><li><code>热点缓存命中</code>：最新的任务的缓存是最热的，所以优先执行新任务。</li><li><code>最小化空间</code>：广度优先会同时创建指数级数量的共存节点，而深度优先虽然也会创建相同数量的节点，但是只有线性数目的节点会同时共存，因为它创建了其他就绪任务的栈。</li></ul><p>生产：当线程产生一个任务时，将其放置到线程自身所有的 deque 的尾部。</p><p>消费：当线程执行任务时，根据以下规则顺序选取一个任务：</p><ul><li>规则1：获取上一个任务返回的任务，如果有；</li><li>规则2：从线程自己所有的 deque 尾部选取一个任务（即深度优先），如果有；</li><li>规则3：随机选择一个其他线程的 deque ，从其头部窃取一个任务（即广度优先）。如果被选 deque 为空，则重复本条规则直至成功。</li></ul><p>规则1 被称为“任务调度绕行（Task Scheduler Bypass）”。</p><p>规则2 是深度优先，这使得当前线程得以不断执行最新的任务直至其完成所有工作。</p><p>规则3 是临时的广度优先，它将潜在的并行转化为实际的并行。</p><h4 id="4-2-2-任务调度绕行（Task-Scheduler-Bypass）技术"><a href="#4-2-2-任务调度绕行（Task-Scheduler-Bypass）技术" class="headerlink" title="4.2.2. 任务调度绕行（Task Scheduler Bypass）技术"></a>4.2.2. 任务调度绕行（Task Scheduler Bypass）技术</h4><p>一个任务从产生到被执行涉及以下步骤：</p><blockquote><ul><li>将新任务加入线程的 deque 。</li><li>执行当前任务直至完成。</li><li>从线程 deque 获取一个任务执行，除非该任务被其他线程窃取走了。</li></ul></blockquote><p>其中，步骤1 和 步骤3 会引入不必要的 deque 操作，甚至更糟的是，允许窃取会损害局部性而不会增加显著的并行性。<br>任务调度器绕行技术可以直接指向下一个要被执行的任务，而不是生产该任务，从而避免了上述问题。<br>因为根据“规则1”，上一个任务产生的新任务会称为第一个备选任务。<br>此外，该技术几乎保证了该新任务被当前线程执行，而不是其他线程。</p><p>注意：当前唯一能使用该优化技术的是使用 <code>tbb::task_group</code> 。</p><h3 id="4-3-指导任务调度器的执行（Guiding-Task-Scheduler-Execution）"><a href="#4-3-指导任务调度器的执行（Guiding-Task-Scheduler-Execution）" class="headerlink" title="4.3. 指导任务调度器的执行（Guiding Task Scheduler Execution）"></a>4.3. 指导任务调度器的执行（Guiding Task Scheduler Execution）</h3><p><a href="https://uxlfoundation.github.io/oneTBB/main/tbb_userguide/Guiding_Task_Scheduler_Execution.html">Guiding Task Scheduler Execution</a></p><p>默认情况下，任务计划程序会尝试使用所有可用的计算资源。在某些情况下，您可能希望将任务计划程序配置为仅使用其中的一些资源。</p><p>注意：指导任务调度程序的执行可能会导致可组合性问题。</p><p>TBB 提供 <code>task_arena</code> 接口，通过以下方式指导任务在 arena （竞技场）内被执行:</p><ul><li>设置首选计算单元；</li><li>限制部分计算单元。</li></ul><h3 id="4-4-工作隔离（Work-Isolation）"><a href="#4-4-工作隔离（Work-Isolation）" class="headerlink" title="4.4. 工作隔离（Work Isolation）"></a>4.4. 工作隔离（Work Isolation）</h3><p><a href="https://www.intel.com/content/www/us/en/docs/onetbb/developer-guide-api-reference/2021-12/work-isolation.html">Work Isolation</a></p><figure class="highlight cpp"><figcaption><span>work_isolation_eg1.cpp</span><a href="/blog/downloads/code/TBB/work_isolation_eg1.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The first parallel loop.</span></span><br><span class="line">oneapi::tbb::<span class="built_in">parallel_for</span>( <span class="number">0</span>, N1, []( <span class="type">int</span> i ) {</span><br><span class="line">    <span class="comment">// The second parallel loop.</span></span><br><span class="line">    oneapi::tbb::<span class="built_in">parallel_for</span>( <span class="number">0</span>, N2, []( <span class="type">int</span> j ) { <span class="comment">/* Some work */</span> } );</span><br><span class="line">} );</span><br></pre></td></tr></table></figure><p>如果当前线程被 <code>parallel_for</code> “阻塞”（不是真正的阻塞，只能称为 a blocking parallel construct），那么该线程被允许拿取第一个循环的任务来执行。这会导致即使是同一个线程内，也可出现乱序执行的情况。在大多数情况下，这没有什么危害。</p><p>但是少数情况可能出现错误，例如一个 thread-local 变量可能会在嵌套并行构造之外意外被更改：</p><figure class="highlight cpp"><figcaption><span>work_isolation_eg2.cpp</span><a href="/blog/downloads/code/TBB/work_isolation_eg2.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">oneapi::tbb::enumerable_thread_specific&lt;<span class="type">int</span>&gt; ets;</span><br><span class="line">oneapi::tbb::<span class="built_in">parallel_for</span>( <span class="number">0</span>, N1, [&amp;ets]( <span class="type">int</span> i ) {</span><br><span class="line">    <span class="comment">// Set a thread specific value</span></span><br><span class="line">    ets.<span class="built_in">local</span>() = i;</span><br><span class="line">    oneapi::tbb::<span class="built_in">parallel_for</span>( <span class="number">0</span>, N2, []( <span class="type">int</span> j ) { <span class="comment">/* Some work */</span> } );</span><br><span class="line">    <span class="comment">// While executing the above parallel_for, the thread might have run iterations</span></span><br><span class="line">    <span class="comment">// of the outer parallel_for, and so might have changed the thread specific value.</span></span><br><span class="line">    <span class="built_in">assert</span>( ets.<span class="built_in">local</span>()==i ); <span class="comment">// The assertion may fail!</span></span><br><span class="line">} );</span><br></pre></td></tr></table></figure><p>在其它场景下，这种行为可能会导致死锁或其他问题。在这些情况下，需要更有力地保证线程内的执行次序。为此，TBB 提供了一些隔离并行构造的执行的方法，以使其任务不会干扰其他同时运行的任务。</p><p>其中一种方法是在单独的 <code>task_arena</code> 中执行内层循环：</p><figure class="highlight cpp"><figcaption><span>work_isolation_eg3.cpp</span><a href="/blog/downloads/code/TBB/work_isolation_eg3.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">oneapi::tbb::enumerable_thread_specific&lt;<span class="type">int</span>&gt; ets;</span><br><span class="line">oneapi::tbb::task_arena nested;</span><br><span class="line">oneapi::tbb::<span class="built_in">parallel_for</span>( <span class="number">0</span>, N1, [&amp;]( <span class="type">int</span> i ) {</span><br><span class="line">    <span class="comment">// Set a thread specific value</span></span><br><span class="line">    ets.<span class="built_in">local</span>() = i;</span><br><span class="line">    nested.<span class="built_in">execute</span>( []{</span><br><span class="line">        <span class="comment">// Run the inner parallel_for in a separate arena to prevent the thread</span></span><br><span class="line">        <span class="comment">// from taking tasks of the outer parallel_for.</span></span><br><span class="line">        oneapi::tbb::<span class="built_in">parallel_for</span>( <span class="number">0</span>, N2, []( <span class="type">int</span> j ) { <span class="comment">/* Some work */</span> } );</span><br><span class="line">    } );</span><br><span class="line">    <span class="built_in">assert</span>( ets.<span class="built_in">local</span>()==i ); <span class="comment">// Valid assertion</span></span><br><span class="line">} );</span><br></pre></td></tr></table></figure><p>然而，使用单独的 arena 进行工作隔离并不总是方便的，并且可能会产生明显的开销。为了解决这些缺点，TBB 提供 <code>this_task_arena::isolate</code> 函数，通过限制调用线程仅处理在函数对象范围内（也称为隔离区域）安排的任务，来隔离地运行一个用户提供的函数对象。</p><p>当一个线程进入一个任务等待调用或（等待）在一个隔离区域内的阻塞并行结构时，该线程只能执行在该隔离区域内生成的任务及其由其他线程生成的子任务（换句话说，即使子任务是由其他线程生成的，只要属于当前隔离区域，当前线程也可以执行这些任务）。线程被禁止执行任何外层任务或属于其他隔离区域的任务。</p><p>下面的示例展示了 <code>this_task_arena::isolate</code> 的使用，以保证在嵌套的并行结构调用时， thread-local 变量不会被意外修改：</p><figure class="highlight cpp"><figcaption><span>work_isolation_eg4.cpp</span><a href="/blog/downloads/code/TBB/work_isolation_eg4.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oneapi/tbb/task_arena.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oneapi/tbb/parallel_for.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oneapi/tbb/enumerable_thread_specific.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N1 = <span class="number">1000</span>, N2 = <span class="number">1000</span>;</span><br><span class="line">    oneapi::tbb::enumerable_thread_specific&lt;<span class="type">int</span>&gt; ets;</span><br><span class="line">    oneapi::tbb::<span class="built_in">parallel_for</span>( <span class="number">0</span>, N1, [&amp;ets]( <span class="type">int</span> i ) {</span><br><span class="line">        <span class="comment">// Set a thread specific value</span></span><br><span class="line">        ets.<span class="built_in">local</span>() = i;</span><br><span class="line">        <span class="comment">// Run the second parallel loop in an isolated region to prevent the current thread</span></span><br><span class="line">        <span class="comment">// from taking tasks related to the outer parallel loop.</span></span><br><span class="line">        oneapi::tbb::this_task_arena::<span class="built_in">isolate</span>( []{</span><br><span class="line">            oneapi::tbb::<span class="built_in">parallel_for</span>( <span class="number">0</span>, N2, []( <span class="type">int</span> j ) { <span class="comment">/* Some work */</span> } );</span><br><span class="line">        } );</span><br><span class="line">        <span class="built_in">assert</span>( ets.<span class="built_in">local</span>()==i ); <span class="comment">// Valid assertion</span></span><br><span class="line">    } );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><strong>补充：</strong>让我们通过一个简单的例子来说明隔离区域内其他线程如何生成子任务，并且这些子任务可以由当前线程执行。</p><p>假设我们有一个隔离区域，其中有两个线程：线程A和线程B。我们在这个隔离区域内生成了一些任务，并且这些任务可能会生成子任务。</p><figure class="highlight cpp"><figcaption><span>work_isolation_eg5.cpp</span><a href="/blog/downloads/code/TBB/work_isolation_eg5.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/tbb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskA</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task A executed by thread &quot;</span> &lt;&lt; tbb::this_task_arena::<span class="built_in">current_thread_index</span>() &lt;&lt; std::endl;</span><br><span class="line">    tbb::<span class="built_in">parallel_invoke</span>(</span><br><span class="line">         {</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Subtask A1 executed by thread &quot;</span> &lt;&lt; tbb::this_task_arena::<span class="built_in">current_thread_index</span>() &lt;&lt; std::endl;</span><br><span class="line">        },</span><br><span class="line">         {</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Subtask A2 executed by thread &quot;</span> &lt;&lt; tbb::this_task_arena::<span class="built_in">current_thread_index</span>() &lt;&lt; std::endl;</span><br><span class="line">        }</span><br><span class="line">    );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskB</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task B executed by thread &quot;</span> &lt;&lt; tbb::this_task_arena::<span class="built_in">current_thread_index</span>() &lt;&lt; std::endl;</span><br><span class="line">    tbb::<span class="built_in">parallel_invoke</span>(</span><br><span class="line">         {</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Subtask B1 executed by thread &quot;</span> &lt;&lt; tbb::this_task_arena::<span class="built_in">current_thread_index</span>() &lt;&lt; std::endl;</span><br><span class="line">        },</span><br><span class="line">         {</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Subtask B2 executed by thread &quot;</span> &lt;&lt; tbb::this_task_arena::<span class="built_in">current_thread_index</span>() &lt;&lt; std::endl;</span><br><span class="line">        }</span><br><span class="line">    );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    tbb::task_arena arena;</span><br><span class="line">    arena.<span class="built_in">execute</span>([&amp;] {</span><br><span class="line">        tbb::this_task_arena::<span class="built_in">isolate</span>([&amp;] {</span><br><span class="line">            tbb::<span class="built_in">parallel_invoke</span>(taskA, taskB);</span><br><span class="line">        });</span><br><span class="line">    });</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><p>taskA 和 taskB 是在隔离区域内生成的任务。<br>taskA 生成了两个子任务 Subtask A1 和 Subtask A2。<br>taskB 生成了两个子任务 Subtask B1 和 Subtask B2。<br>假设线程A执行了 taskA，线程B执行了 taskB。在隔离区域内，线程A和线程B可以执行彼此生成的子任务。例如，线程A可以执行 Subtask B1 或 Subtask B2，而线程B可以执行 Subtask A1 或 Subtask A2，只要这些子任务属于同一个隔离区域。</p><h2 id="5-推荐阅读"><a href="#5-推荐阅读" class="headerlink" title="5. 推荐阅读"></a>5. 推荐阅读</h2><h3 id="5-1-书籍"><a href="#5-1-书籍" class="headerlink" title="5.1. 书籍"></a>5.1. 书籍</h3><ol><li>Intel Building Blocks 编程指南. James Reinders.</li><li>Patterns for Parallel Pragramming. Timothy Mattson 等.</li><li>设计模式：Design Patterns of Reusable Object-Oriented Software (Addison Wesley). Gamma, Helm, Johnson 和 Vlissides.</li></ol>]]></content>
      
      
      <categories>
          
          <category> c/cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcc 与 glibc</title>
      <link href="/blog/2024/02/02/cplusplus/gcc%E4%B8%8Eglibc/"/>
      <url>/blog/2024/02/02/cplusplus/gcc%E4%B8%8Eglibc/</url>
      
        <content type="html"><![CDATA[<h2 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h2><p>gcc是一个编译套件，包含c、c++、Fortran语言的编译器。</p><h2 id="glibc"><a href="#glibc" class="headerlink" title="glibc"></a>glibc</h2><p>glibc是一个library，为C程序提供基础公共功能，包括系统调用、数学函数和其他核心组件。<br>Linux平台和vscode似乎都依赖glibc，如果擅自将<code>LD_LIBRARY_PATH</code>更改为其他版本的glibc路径，则bash会直接crash。</p><h3 id="glibc包含以下bin和lib："><a href="#glibc包含以下bin和lib：" class="headerlink" title="glibc包含以下bin和lib："></a>glibc包含以下bin和lib：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> glibc-v2.34/Linux/RHEL7.0-2017-x86_64/bin &amp;&amp; <span class="built_in">ls</span></span><br><span class="line">catchsegv  getconf  iconv  locale     makedb  pcprofiledump  sotruss  tzselect  zdump</span><br><span class="line">gencat     getent   ldd    localedef  mtrace  pldd           sprof    xtrace</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入其他版本的glibc/lib目录执行ls命令会报错，大概原因可能是因为当前路径的glibc的lib和系统的lib冲突。</span></span><br><span class="line">$ <span class="built_in">cd</span> ../lib &amp;&amp; <span class="built_in">ls</span></span><br><span class="line"><span class="built_in">ls</span>: relocation error: ./libc.so.6: symbol __tunable_get_val, version GLIBC_PRIVATE not defined <span class="keyword">in</span> file ld-linux-x86-64.so.2 with <span class="built_in">link</span> time reference</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> .. &amp;&amp; <span class="built_in">ls</span> lib</span><br><span class="line">Mcrt1.o               libanl.so.1             libm.so             libnss_hesiod.so.2</span><br><span class="line">Scrt1.o               libc.a                  libm.so.6           libpcprofile.so</span><br><span class="line">audit                 libc.so                 libmcheck.a         libpthread.a</span><br><span class="line">crt1.o                libc.so.6               libmemusage.so      libpthread.so.0</span><br><span class="line">crti.o                libc_malloc_debug.so    libmvec.a           libresolv.a</span><br><span class="line">crtn.o                libc_malloc_debug.so.0  libmvec.so          libresolv.so</span><br><span class="line">gconv                 libc_nonshared.a        libmvec.so.1        libresolv.so.2</span><br><span class="line">gcrt1.o               libcrypt.a              libnsl.so.1         librt.a</span><br><span class="line">ld-linux-x86-64.so.2  libcrypt.so             libnss_compat.so    librt.so.1</span><br><span class="line">libBrokenLocale.a     libcrypt.so.1           libnss_compat.so.2  libthread_db.so</span><br><span class="line">libBrokenLocale.so    libdl.a                 libnss_db.so        libthread_db.so.1</span><br><span class="line">libBrokenLocale.so.1  libdl.so.2              libnss_db.so.2      libutil.a</span><br><span class="line">libSegFault.so        libg.a                  libnss_dns.so.2     libutil.so.1</span><br><span class="line">libanl.a              libm-2.34.a             libnss_files.so.2</span><br><span class="line">libanl.so             libm.a                  libnss_hesiod.so</span><br></pre></td></tr></table></figure><h3 id="查看glibc的版本："><a href="#查看glibc的版本：" class="headerlink" title="查看glibc的版本："></a>查看glibc的版本：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从上可知，ldd是glibc的核心组件之一</span></span><br><span class="line">$ ldd --version</span><br></pre></td></tr></table></figure><h3 id="寻找libc-so的路径："><a href="#寻找libc-so的路径：" class="headerlink" title="寻找libc.so的路径："></a>寻找libc.so的路径：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ locate libc.so</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libc.so</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">$ locate libstdc++.so</span><br><span class="line">/usr/lib/gcc/x86_64-linux-gnu/11/libstdc++.so</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libstdc++.so.6</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.30</span><br><span class="line">/usr/share/gdb/auto-load/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.30-gdb.py</span><br></pre></td></tr></table></figure><h3 id="安装glibc："><a href="#安装glibc：" class="headerlink" title="安装glibc："></a>安装glibc：</h3><p>Ubuntu平台</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install lib6</span><br></pre></td></tr></table></figure><p>RedHat平台</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install glibc</span><br></pre></td></tr></table></figure><h3 id="检查GNC-C-Library-libstdc-的版本："><a href="#检查GNC-C-Library-libstdc-的版本：" class="headerlink" title="检查GNC C++ Library (libstdc++)的版本："></a>检查GNC C++ Library (libstdc++)的版本：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ strings /usr/lib/libstdc++.so.* | grep LIBCXX</span><br><span class="line">[sjcvl-zhigaoz ] /lan/cva_rel/vxe_main/24.02.650.d000/tools.lnx86/lib/64bit % strings /usr/lib/libstdc++.so.* | grep LIBCXX</span><br><span class="line">GLIBCXX_3.4</span><br><span class="line">GLIBCXX_3.4.1</span><br><span class="line">GLIBCXX_3.4.2</span><br><span class="line">...</span><br><span class="line">GLIBCXX_3.4.19</span><br><span class="line">GLIBCXX_DEBUG_MESSAGE_LENGTH</span><br><span class="line"></span><br><span class="line">$ strings /usr/lib/libc.so.* | grep GLIBC</span><br><span class="line">GLIBC_2.0</span><br><span class="line">GLIBC_2.1</span><br><span class="line">GLIBC_2.1.1</span><br><span class="line">...</span><br><span class="line">GLIBC_2.17</span><br><span class="line">GLIBC_PRIVATE</span><br></pre></td></tr></table></figure><p>如果你有一个使用了libstdc++的特定的binary或application，可以用下面的命令来检查其版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ldd &lt;your_binary_or_application&gt; | grep libstdc++</span><br></pre></td></tr></table></figure><p>使用vscode的“Remote SSH”工具试图连接到Linux时，可能会报错如下：</p><blockquote><p>Warning: Missing GLIBCXX &gt;&#x3D; 3.4.25! from &#x2F;usr&#x2F;lib64&#x2F;libstdc++.so.6.0.19<br>Warning: Missing GLIBC &gt;&#x3D; 2.28! from &#x2F;usr&#x2F;lib64&#x2F;libc-2.17.so<br>Error: Missing required dependencies. Please refer to our FAQ <a href="https://aka.ms/vscode-remote/faq/old-linux">https://aka.ms/vscode-remote/faq/old-linux</a> for additional information.</p></blockquote><p>这是因为Linux系统上的glibc版本中不包含GLIBCXX_3.4.25及以上的版本。此时需要降级vscode（建议做法）或升级glibc（似乎很难）。</p>]]></content>
      
      
      <categories>
          
          <category> c/cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gcc </tag>
            
            <tag> glibc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计时工具</title>
      <link href="/blog/2024/01/30/misc/%E8%AE%A1%E6%97%B6%E5%B7%A5%E5%85%B7/"/>
      <url>/blog/2024/01/30/misc/%E8%AE%A1%E6%97%B6%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="times"><a href="#times" class="headerlink" title="times"></a>times</h2><ol><li>bash built-in</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">times</span></span><br></pre></td></tr></table></figure><ol start="2"><li>function</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">clock_t</span> <span class="title">times</span><span class="params">(<span class="keyword">struct</span> tms *buf)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c/cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> timing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduction to memory</title>
      <link href="/blog/2024/01/29/linux/Introduction-to-memory/"/>
      <url>/blog/2024/01/29/linux/Introduction-to-memory/</url>
      
        <content type="html"><![CDATA[<h2 id="malloc-free"><a href="#malloc-free" class="headerlink" title="malloc&#x2F;free"></a>malloc&#x2F;free</h2><p>See <a href="https://www.gnu.org/software/libc/manual/html_node/Backtraces.html">this example</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> ** <span class="title">backtrace_symbols</span> <span class="params">(<span class="type">void</span> *<span class="type">const</span> *buffer, <span class="type">int</span> size)</span> </span></span><br></pre></td></tr></table></figure><blockquote><p>The return value of backtrace_symbols is a pointer obtained via the malloc function, and it is the responsibility of the caller to free that pointer. Note that only the return value need be freed, not the individual strings.</p></blockquote><p>Question: Why does it say “only the return value need be freed, not the individual strings”?</p><p>Let us observe the defintion of the <code>malloc</code>&#x2F;<code>free</code> functions first:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">( <span class="type">size_t</span> size )</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">( <span class="type">void</span> *ptr )</span></span>;</span><br></pre></td></tr></table></figure><p><code>free</code> takes a <code>void*</code> pointer to deallocate the memory, it doesn’t care what type it is, even if it is a multi-level pointer. It means that <code>malloc</code> has stored the memory size in some place and <code>free</code> will find it beforing deallocate the memory.</p><p>Let us return the question. The memory pointer returned by <code>backtrace_symbols</code> is the <code>char**</code> type, it must be a whole block contigunous memory using <code>malloc</code> and might be enforced to be transformed as <code>char**</code> pointer when returing. So when we <code>free</code> the memory block, the Linux kernel find its actual memory size and deallocate it.</p><p>Example:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span>** strings = (<span class="type">char</span>**)<span class="built_in">malloc</span>(<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">char</span>*) + <span class="number">3</span> * <span class="number">50</span>); <span class="comment">// assuming a maximum 50 characters per sentence</span></span><br><span class="line">    <span class="type">char</span>* block = (<span class="type">char</span>*)(strings + <span class="number">3</span>);</span><br><span class="line">    <span class="type">char</span>* s1 = <span class="built_in">strcpy</span>(block, <span class="string">&quot;The first sentence&quot;</span>); block += <span class="built_in">strlen</span>(s1) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span>* s2 = <span class="built_in">strcpy</span>(block, <span class="string">&quot;The second sentence&quot;</span>); block += <span class="built_in">strlen</span>(s2) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span>* s3 = <span class="built_in">strcpy</span>(block, <span class="string">&quot;The third sentence&quot;</span>);</span><br><span class="line">    strings[<span class="number">0</span>] = s1;</span><br><span class="line">    strings[<span class="number">1</span>] = s2;</span><br><span class="line">    strings[<span class="number">2</span>] = s3;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strings[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(strings); <span class="comment">// deallocate all memory at once</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>More elegant but less economical code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span>** strings = (<span class="type">char</span>**)<span class="built_in">malloc</span>(<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">char</span>*) + <span class="number">3</span> * <span class="number">50</span>);</span><br><span class="line">    <span class="type">char</span>* block = (<span class="type">char</span>*)(strings + <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        strings[i] = block + i * <span class="number">50</span>; <span class="comment">// Assuming a maximum of 50 characters per sentence</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(strings[<span class="number">0</span>], <span class="string">&quot;The first sentence&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(strings[<span class="number">1</span>], <span class="string">&quot;The second sentence&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(strings[<span class="number">2</span>], <span class="string">&quot;The third sentence&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strings[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(strings); <span class="comment">// deallocate all memory at once</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.gnu.org/software/libc/manual/html_node/Memory_002dmapped-I_002fO.html">The GNU C Library (glibc) manual: 13.8 Memory-mapped I&#x2F;O</a></li><li><a href="https://www.gnu.org/software/libc/manual/html_node/Memory-Protection.html">The GNU C Library (glibc) manual: 3.4 Memory Protection</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> c/cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML</title>
      <link href="/blog/2024/01/29/UML/"/>
      <url>/blog/2024/01/29/UML/</url>
      
        <content type="html"><![CDATA[<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://cloud.tencent.com/developer/article/1176331">认识UML类关系——依赖、关联、聚合、组合、泛化</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> c/cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell Commands</title>
      <link href="/blog/2024/01/26/linux/Shell-Commands/"/>
      <url>/blog/2024/01/26/linux/Shell-Commands/</url>
      
        <content type="html"><![CDATA[<h2 id="shuf"><a href="#shuf" class="headerlink" title="shuf"></a>shuf</h2><h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><h2 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h2><h2 id="lp"><a href="#lp" class="headerlink" title="lp"></a>lp</h2><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>Options:</p><pre><code>-t, --field-separator=SEP    use SEP instead of non-blank to blank transition-k, --key=POS1[,POS2]    start a key at POS1 (origin 1), end it at POS2 (default end of line)-h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)-n, --numeric-sort    compare according to string numerical value</code></pre><h2 id="nproc"><a href="#nproc" class="headerlink" title="nproc"></a>nproc</h2><p>print the number of processing units avaiable.</p><h2 id="od-xxd-hexdump"><a href="#od-xxd-hexdump" class="headerlink" title="od &#x2F; xxd &#x2F; hexdump"></a>od &#x2F; xxd &#x2F; hexdump</h2><p>read the binary file.</p><p>Notes: byte order</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n <span class="string">&quot;ABCD&quot;</span> | xxd</span><br><span class="line">00000000: 4142 4344                                ABCD</span><br><span class="line">$ <span class="built_in">echo</span> -n <span class="string">&quot;ABCD&quot;</span> | hexdump</span><br><span class="line">0000000 4241 4443                              </span><br><span class="line">0000004</span><br></pre></td></tr></table></figure><p><a href="https://unix.stackexchange.com/questions/282215/how-to-view-a-binary-file">Reference</a></p><h2 id="comm-diff-tkdiff-cmp"><a href="#comm-diff-tkdiff-cmp" class="headerlink" title="comm &#x2F; diff &#x2F; tkdiff &#x2F; cmp"></a>comm &#x2F; diff &#x2F; tkdiff &#x2F; cmp</h2><p>Can be used to compare binary or non-binary files.</p><h3 id="comm"><a href="#comm" class="headerlink" title="comm"></a>comm</h3><p>compare two sorted files line by line.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> file1.txt </span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">cherry</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> file2.txt </span><br><span class="line">banana</span><br><span class="line">cherry</span><br><span class="line"><span class="built_in">date</span></span><br><span class="line">erase</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">comm</span> file1.txt file2.txt </span><br><span class="line">apple</span><br><span class="line">                banana</span><br><span class="line">                cherry</span><br><span class="line">        <span class="built_in">date</span></span><br><span class="line">        erase</span><br></pre></td></tr></table></figure><p>The file must be sorted before using the <code>comm</code> command. Otherwise it will complain that:</p><pre><code>comm: file 1 is not in sorted order</code></pre><p>and cannot work correctly. For example,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> file1.txt </span><br><span class="line">apple</span><br><span class="line">cherry</span><br><span class="line">banana</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> file2.txt </span><br><span class="line">banana</span><br><span class="line">cherry</span><br><span class="line"><span class="built_in">date</span></span><br><span class="line">erase</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">comm</span> file1.txt file2.txt </span><br><span class="line">apple</span><br><span class="line">        banana</span><br><span class="line">                cherry</span><br><span class="line"><span class="built_in">comm</span>: file 1 is not <span class="keyword">in</span> sorted order</span><br><span class="line">banana</span><br><span class="line">        <span class="built_in">date</span></span><br><span class="line">        erase</span><br><span class="line"><span class="built_in">comm</span>: input is not <span class="keyword">in</span> sorted order</span><br></pre></td></tr></table></figure><h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>Syntax:</p><pre><code>diff -u file1 file2</code></pre><p>Options:</p><pre><code>-e, --ed    output an ed script-u, -U NUM, --unified[=NUM]    output NUM (default 3) lines of unified context    (that is, print NUM lines before and after the difference line)</code></pre><h3 id="tkdiff"><a href="#tkdiff" class="headerlink" title="tkdiff"></a>tkdiff</h3><p>Use a GUI to display the differences.</p><h3 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h3><p>Prints less information comparing to <code>diff</code>.</p><p>Syntax:</p><pre><code>cmp file1 file2</code></pre><h2 id="ed-vim-sed-awk"><a href="#ed-vim-sed-awk" class="headerlink" title="ed&#x2F;vim&#x2F;sed&#x2F;awk"></a>ed&#x2F;vim&#x2F;sed&#x2F;awk</h2>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 初始化列表</title>
      <link href="/blog/2024/01/26/cplusplus/C++%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/"/>
      <url>/blog/2024/01/26/cplusplus/C++%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h2><p>struct&#x2F;union&#x2F;array默认支持列表初始化。</p><p><a href="https://en.cppreference.com/w/c/language/struct_initialization">Struct and union initialization</a><br><a href="https://en.cppreference.com/w/c/language/array_initialization">Array initialization</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;initializer_list&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y, z; <span class="comment">// 注意：数据成员必须是public的。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec_;</span><br><span class="line">    <span class="type">int</span> x_;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;vec_=&#123; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : vec_) &#123;</span><br><span class="line">            cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&#125;, x_=&quot;</span> &lt;&lt; x_ &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec_;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;vec_=&#123; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : vec_) &#123;</span><br><span class="line">            cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&#125;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// C++会构造一个列表初始化的默认构造函数，</span></span><br><span class="line">    <span class="comment">// 以下(1)和(2)都是调用这个默认构造函数。</span></span><br><span class="line">    A a1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">// (1) 列表初始化</span></span><br><span class="line">    <span class="function">A <span class="title">a2</span><span class="params">(&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;)</span></span>; <span class="comment">// (2) 同(1)</span></span><br><span class="line">    a1.<span class="built_in">print</span>();</span><br><span class="line">    a2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    B b1&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, <span class="number">4</span>&#125;; <span class="comment">// 内部的&quot;&#123;1,2,3&#125;&quot;用于构造vec_，&quot;4&quot;用于初始化x_</span></span><br><span class="line">    b1.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C C1&#123;1,2,3&#125;; // (1) 这里会报错&quot;error: too many initializers for ‘C’&quot;，</span></span><br><span class="line">    <span class="comment">//              //     因为C只有一个数据成员vec_，这里却传入了3个参数</span></span><br><span class="line">    C c2&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#125;; <span class="comment">// (2) 其中，内部的&quot;&#123;1,2,3&#125;&quot;用于构造vec_，外层的&quot;&#123;&#125;&quot;用于对c2本身进行构造</span></span><br><span class="line">    c2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-initializer-list"><a href="#std-initializer-list" class="headerlink" title="std::initializer_list"></a>std::initializer_list</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(initializer_list&lt;<span class="type">int</span>&gt; il) &#123;</span><br><span class="line">        initializer_list&lt;<span class="type">int</span>&gt;::iterator it = il.<span class="built_in">begin</span>();</span><br><span class="line">        x = *it++;</span><br><span class="line">        y = *it++;</span><br><span class="line">        z = *it++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">B</span>(initializer_list&lt;<span class="type">int</span>&gt; il) &#123;</span><br><span class="line">        vec = il; <span class="comment">// 用initializer_list初始化vector</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&#123; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : vec) &#123;</span><br><span class="line">            cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&#125;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    a.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    B b&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    b.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c/cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> syntax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Brackets in Bash</title>
      <link href="/blog/2024/01/25/linux/Brackets-in-Bash/"/>
      <url>/blog/2024/01/25/linux/Brackets-in-Bash/</url>
      
        <content type="html"><![CDATA[<h2 id="中括号"><a href="#中括号" class="headerlink" title="中括号"></a>中括号</h2><ol><li><p><code>[ ]</code>和<code>test</code>是bash的内部命令，<code>[[ ]]</code>是shell的条件判断关键字。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">type</span> [</span><br><span class="line">[ is a shell <span class="built_in">builtin</span></span><br><span class="line">$ <span class="built_in">type</span> <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span> is a shell <span class="built_in">builtin</span></span><br><span class="line">$ <span class="built_in">type</span> [[</span><br><span class="line">[[ is a shell keyword</span><br></pre></td></tr></table></figure></li><li><p><code>[ ]</code>和<code>test</code>是等价的，用于评估条件表达式。可以使用<code>man [</code>或<code>help [</code>查阅帮助文档。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">help</span> [</span><br><span class="line">[: [ arg... ]</span><br><span class="line">    Evaluate conditional expression.</span><br><span class="line">    </span><br><span class="line">    This is a synonym <span class="keyword">for</span> the <span class="string">&quot;test&quot;</span> <span class="built_in">builtin</span>, but the last argument must</span><br><span class="line">    be a literal `]<span class="string">&#x27;, to match the opening `[&#x27;</span>.</span><br></pre></td></tr></table></figure></li><li><p><code>[[ ]]</code>关键字可以屏蔽shell特殊符号，比如<code>&amp;&amp;</code>、<code>||</code>、<code>&gt;</code>和<code>&lt;</code>可以被认为是条件判断符而不是重定向符。</p></li><li><p><code>[ ]</code>中使用<code>-a</code>和<code>-o</code>表示逻辑与和逻辑或，<code>[[ ]]</code>中则使用<code>&amp;&amp;</code>和<code>||</code>。</p></li></ol><h2 id="小括号"><a href="#小括号" class="headerlink" title="小括号"></a>小括号</h2><ol><li><code>$()</code>用于命令替换。</li><li>双小括号<code>(( ))</code>：在比较过程中使用高级数学表达式。</li></ol><h2 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h2><p>请阅读：<a href="https://www.linux.com/topic/desktop/all-about-curly-braces-bash/">All about {Curly Braces} in Bash</a></p><ol><li><p><code>$&#123;&#125;</code>用于引用变量。</p><p> 与<code>$var</code>相比，<code>$&#123;var&#125;</code>是一种消除歧义的措施，比如：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ var=abc</span><br><span class="line">$ vartest=ABC</span><br><span class="line"><span class="comment"># $var引用变量&#x27;var&#x27;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">abc</span><br><span class="line"><span class="comment"># 引用变量&#x27;vartest&#x27;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$vartest</span></span><br><span class="line">ABC</span><br><span class="line"><span class="comment"># 引用变量&#x27;var&#x27;并在其后加上&#x27;test&#x27;字符</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span><span class="built_in">test</span></span><br><span class="line">abctest</span><br></pre></td></tr></table></figure></li><li><p><code>&#123;&#125;</code>表示分组。</p></li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.cnblogs.com/zeweiwu/p/5485711.html">Shell中test、单中括号、双中括号的区别</a></li><li><a href="https://www.baeldung.com/linux/bash-single-vs-double-brackets">Differences Between Single and Double Brackets in Bash</a></li><li><a href="https://www.jianshu.com/p/3e1eaaa3fee8">Shell中的括号、双括号、方括号和双方括号</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Regular Expression</title>
      <link href="/blog/2024/01/25/linux/Regular-Expression/"/>
      <url>/blog/2024/01/25/linux/Regular-Expression/</url>
      
        <content type="html"><![CDATA[<h2 id="regexp"><a href="#regexp" class="headerlink" title="regexp"></a>regexp</h2><h2 id="ERegExp"><a href="#ERegExp" class="headerlink" title="ERegExp"></a>ERegExp</h2><h2 id="Wildcard-Glob"><a href="#Wildcard-Glob" class="headerlink" title="Wildcard&#x2F;Glob"></a>Wildcard&#x2F;Glob</h2><p><code>man 7 glob</code></p><blockquote><p>glob - globbing pathnames. glob is a shell built-in.</p><p>主要用于匹配带有通配符的文件路径。其匹配字符串的能力比正则表达式弱。</p><p>它最初是贝尔实验室 Unix 系统上的一个名叫 glob 的命令（glob 是 global 的缩写），用于展开命令行中的通配符。后来系统提供了该功能的 C 语言库函数glob()，知名的 shell 解释器就使用了该接口，shell 脚本和命令行中使用的 glob 模式匹配功能便源自于此。——见<a href="https://juejin.cn/post/6844904077801816077">博客</a>。</p></blockquote><p><a href="https://tldp.org/LDP/GNU-Linux-Tools-Summary/html/x11655.htm">Wildcards</a></p><p><code>&#123;&#125;</code>严格来讲不属于glob的范畴，其在shell表示一个分组，见：<a href="https://www.linux.com/topic/desktop/all-about-curly-braces-bash/">All about {Curly Braces} in Bash</a>。</p><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p><a href="https://www.ibm.com/docs/nl/aix/7.2?topic=awk-command">awk Command</a></p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F<span class="string">&#x27; *|:&#x27;</span> <span class="string">&#x27;/LISTEN/&#123;print $2&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>其中，<code>-F</code>表示分隔符；<br><code> *|:</code>是一个正则表达式，表示以”一个或多个空格”或”:”作为分隔符；<br>再其后的<code>//</code>中是另一个正则表达式，用于匹配文本；<br><code>&#123;&#125;</code>中是action。</p><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p><a href="https://tecadmin.net/awk-conditional-statements/">if-else in awk</a><br><a href="https://unix.stackexchange.com/questions/660178/how-to-use-and-and-or-together-in-an-awk-program">use AND and OR in an awk program</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;if ($1 &gt; 49151 &amp;&amp; $1 &lt; 65536) &#123;print $1&#125; &#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;$1 &gt; 49151 &amp;&amp; $1 &lt; 65536&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="BEGIN-END"><a href="#BEGIN-END" class="headerlink" title="BEGIN&#x2F;END"></a>BEGIN&#x2F;END</h3><p>In AWK, <code>BEGIN</code> and <code>END</code> are special patterns that allow you to execute code before processing the input (<code>BEGIN</code>) or after processing all the input (<code>END</code>).</p><ul><li>The <code>BEGIN</code> block is executed once at the beginning of the AWK program and it is typically used for initializing variables or performing setup tasks.</li><li>The <code>END</code> block is executed once after processing all input, and it is commonly used for final caclucations, summaries, or printing results.</li></ul><h3 id="Special-symbols"><a href="#Special-symbols" class="headerlink" title="Special symbols"></a>Special symbols</h3><ul><li><code>$</code> 用于引用field，例如<code>$1</code>代表第一个field（典型来说是第一列）。</li><li><code>NF</code> 表示number of filed，假设一共有7列，那么<code>$NF</code>与<code>$7</code>等价。</li></ul><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><ol><li>找出一个未使用的port</li></ol><div class="tabs" id="code"><ul class="nav-tabs"><li class="tab active"><a href="#code-1">Makefile</a></li><li class="tab"><a href="#code-2">Bash</a></li><li class="tab"><a href="#code-3">Python</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code-1"><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &quot;$$&quot;是为了转义&quot;$&quot;</span></span><br><span class="line">max_port=<span class="variable">$(<span class="built_in">shell</span> netstat -antulpen 2&gt; /dev/null \</span></span><br><span class="line"><span class="variable">    | awk -F&#x27; *&#x27; &#x27;/^(tcp|udp)</span>/&#123;print $$4&#125;&#x27; | cut -d: -f 2 \</span><br><span class="line">    | egrep <span class="string">&quot;\w&quot;</span> | sort | tail -1)</span><br><span class="line"><span class="comment">#$(warning $&#123;max_port&#125;)</span></span><br><span class="line">port=<span class="variable">$(<span class="built_in">shell</span> expr <span class="variable">$(max_port)</span> + 1)</span></span><br><span class="line"><span class="comment">#$(warning $&#123;port&#125;)</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code-2"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从1025开始找出已经存在的端口，如果相邻端口的gap大于1，则返回“当前端口号+1”</span></span><br><span class="line">netstat -ant | awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span> \</span><br><span class="line">    | awk -F: <span class="string">&#x27;&#123;if ($NF ~ /^[0-9]+$/ &amp;&amp; $NF &gt; 1024) &#123;print $NF&#125;&#125;&#x27;</span> \</span><br><span class="line">    | awk <span class="string">&#x27;BEGIN &#123;prev = 1024&#125; </span></span><br><span class="line"><span class="string">        &#123;if ($1 - prev &gt; 1) &#123; port = prev + 1; exit&#125; else &#123; prev = $1&#125;&#125; </span></span><br><span class="line"><span class="string">        END &#123; if (port==&quot;&quot;) &#123;print prev + 1&#125; else &#123;print port&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="code-3"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这不是正则表达式</span></span><br><span class="line"><span class="comment">#以0端口为参数创建一个socket，则系统会自动选择一个未使用的端口号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#one-line mode:</span></span><br><span class="line"><span class="comment">#python -c &#x27;import socket; s=socket.socket(); s.bind((&quot;&quot;, 0)); print(s.getsockname()[1]); s.close()&#x27;</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.bind((<span class="string">&#x27;&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">addr = s.getsockname()</span><br><span class="line"><span class="built_in">print</span>(addr[<span class="number">1</span>])</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure></div></div></div>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Killings at Badger&#39;s Drift</title>
      <link href="/blog/2024/01/24/english/The-Killings-at-Badger-s-Drift/"/>
      <url>/blog/2024/01/24/english/The-Killings-at-Badger-s-Drift/</url>
      
        <content type="html"><![CDATA[<h2 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h2><p>视频：<a href="https://tubitv.com/tv-shows/521987/s01-e01-the-killings-at-badgers-drift">链接</a>。</p><p>影片名：Midsomer Murders, S01:E01, <a href="https://www.google.com/search?q=+Badger%27s+Drift+&rlz=1C1GCEJ_enUS1023US1023&ei=fnuzZJivL96x0PEP4MunkAc&ved=0ahUKEwiY5oz5upKAAxXeGDQIHeDlCXIQ4dUDCBA&uact=5&oq=+Badger%27s+Drift+&gs_lp=Egxnd3Mtd2l6LXNlcnAiECBCYWRnZXIncyBEcmlmdCAyBxAuGBMYgAQyDRAuGBMYgAQYxwEYrwEyBxAAGBMYgAQyBxAAGBMYgAQyCRAAGBMYgAQYCjIHEAAYExiABDIHEAAYExiABDIHEAAYExiABDIHEAAYExiABDIHEAAYExiABDIWEC4YExiABBiXBRjcBBjeBBjgBNgBAUj3MFCYDViYDXAFeAGQAQCYAb0CoAG9AqoBAzMtMbgBA8gBAPgBAvgBAcICChAAGEcY1gQYsAPiAwQYACBBiAYBkAYKugYGCAEQARgU&sclient=gws-wiz-serp">The Killings at Badger’s Drift</a></p><p>S01:E01 - Season 01 : Episode 01，第1季第1集。episode，插曲（某事件；某事发生的短暂时间）；剧集（<a href="https://www.ldoceonline.com/dictionary/episode">一般一周更新放映一次</a>）。</p><p>midsomer - <a href="https://www.wordnik.com/words/midsomer">midsummer的过时写法</a>。本片中是<a href="https://en.wikipedia.org/wiki/Midsomer_Murders">一个虚构的英格兰县</a>，影片开头有一个路牌，写着：“Badger’s Drift, Midsomer’s best kept village”，意思大概是，Badger’s Drift是Midsomer保存最好的村庄。</p><h2 id="开幕介绍"><a href="#开幕介绍" class="headerlink" title="开幕介绍"></a>开幕介绍</h2><p>Screenplay by Anthony Horowitz - Screenplay 剧本。</p><p>From the novel by Caroline Graham</p><p>Starring - 主演</p><p>Directed by - 导演是</p><p>caption - 字幕。</p><p>subtitle - 字幕。</p><h2 id="第一幕-Emily之死"><a href="#第一幕-Emily之死" class="headerlink" title="第一幕 Emily之死"></a>第一幕 Emily之死</h2><h3 id="村落小路上"><a href="#村落小路上" class="headerlink" title="村落小路上"></a>村落小路上</h3><p>-[Doctor] Hello, Missis Simpson. Have a very good afternoon.</p><p>bright playful music - 明快俏皮的音乐。</p><p>Daily Mirror, forward with the people. 这是一块招牌上的字样。《每日镜报》的口号是“与人民同行”，The Sun’s slogan was ‘Forward with the People’, which had been adopted by the Mirror in 1945 and only recently dropped. - 参见谷歌快照《<a href="https://webcache.googleusercontent.com/search?q=cache:32HydJ4eVUYJ:https://www.gale.com/intl/essays/adrian-bingham-introduction-daily-mirror&cd=9&hl=zh-CN&ct=clnk&gl=us">An Introduction to the Daily Mirror</a>》。hayday好天气，全盛时期。hay干草。</p><p>-[Lucy] Ah, sneaking off, aren’t you, Emily? 偷偷溜走，不是吗？</p><p>-[Emily] I wouldn’t call it sneaking, Lucy. Anyway, who’s talking? You’ve been out all day! 我不会称它为溜。不管怎样，是谁在说话？你自己已经出去一整天了！</p><p>-I’m not gonna tell you where. 我不会告诉你我去了哪里。</p><p>-You didn’t find it? 你没有找到？</p><p>-No. 没有。</p><p>-You’ll be buying me tea this year, my dear. You wait and see! 今年你会给我买茶，你等着看！</p><p>-Chance would be a fine thing! 有机会（让我给你买茶）就好了！</p><p>pros and cons - <a href="https://www.merriam-webster.com/dictionary/pros%20and%20cons">优点和缺点</a>。</p><h3 id="树林"><a href="#树林" class="headerlink" title="树林"></a>树林</h3><p>birds chirp - 鸟儿叽叽喳喳。</p><p>Spurred coral root - 刺珊瑚根。spur马刺。”It’s an orchid（兰花）, not a flower.”</p><p>padlock clicks - 挂锁咔咔声。</p><p>camera clicks - 相机咔咔声。</p><p>man moans - 男人呻吟。</p><p>man pants - 男人喘息。pant喘气。</p><p>bird flaps - 鸟儿拍飞。</p><p>Emily shrieks - Emily尖叫。</p><h3 id="Emily回家路上"><a href="#Emily回家路上" class="headerlink" title="Emily回家路上"></a>Emily回家路上</h3><p>brakes screech - 刹车声。brake刹车，screech发出尖叫、噪声。</p><h3 id="Emily家"><a href="#Emily家" class="headerlink" title="Emily家"></a>Emily家</h3><p>slow sinister music - sinister险恶的。</p><p>bees buzz - 蜜蜂嗡嗡。</p><p>beehive cottage - 蜂巢小屋。beehive &#x2F;ˈbiː.haɪv&#x2F; 蜂窝；cottage &#x2F;ˈkɑː.t̬ɪdʒ&#x2F; &#x2F;ˈkɒt.ɪdʒ&#x2F;小屋。</p><p>cat meows - meow &#x2F;ˌmiˈaʊ&#x2F; 喵</p><p>Come on, out you go - 来，你出去。</p><p>door thuds - 门砰的一声。thud &#x2F;θʌd&#x2F; 撞击声，砰。</p><p>dial up phone rattles - 拨号嘎嘎声。rattle 拨浪鼓；嘎嘎声。</p><p>door rattles.</p><p>bangs. - to (cause something to) make a sudden very loud noise or noises.</p><p>birds squawk - 鸟叫（不好的声音）。squawk - (of a bird) to make an unpleasantly loud, sharp noise.</p><p>door knocks - 敲门声。</p><p>door knob screeches - 门把手尖叫（声）。</p><p>intense sinister music - 激烈险恶的音乐。</p><p>dark dreamy music - 黑暗梦幻的音乐。</p><h2 id="第二幕-初步调查"><a href="#第二幕-初步调查" class="headerlink" title="第二幕 初步调查"></a>第二幕 初步调查</h2><p>-This is it, here, Sir.</p><p>-Really, Troy? I’d never have guessed.</p><p>crowd chatters - 人群闲聊。</p><p>We only ever meet when there’s a corpse. - 我们只有在有尸体的时候会见面。corpose - 尸体。ever - at any time: Nothing ever happened in this evening. Have you ever gone to London?</p><p>broken neck - 脖子断了。</p><p>scuff marks on the carpet - 地毯上有磨损痕迹。scuff vt. 磨损，擦伤。</p><p>a blow to the back of the neck and then dragged over here - 颈后遭到一击，然后被拖到这里。</p><p>spinster - 老处女。</p><p>The old girl who lives opposite - 住在对面的老姑娘。</p><p>She slammed the door for a start - 她猛地关上门。slam 猛撞。</p><p>She didn’t padlock her tricycle - 她没有锁上三轮车。padlock 挂锁。tricycle 三轮车。</p><p>There’s no reflection on you, Chief Inspector, but to leave her tricycle like that, she must have been very upset. 总督察，对你来说没有什么反应（没有什么好奇怪的），但是就这样把她的三轮车丢下，她一定很沮丧。</p><p>-I’ll have to go over tomorrow. I still haven’t told the bees. - go over: to make one’s way 开辟新的路。 i.g. go over to store for supplies. 去商店购买日用品。</p><p>-I’m sorry?</p><p>-Well you have to tell the bees when someone dies. Otherwise they just clear off. - <a href="https://en.wikipedia.org/wiki/Telling_the_bees">Telling the bees</a> 养蜂人有一个传统，会将重大事件（生老病死婚姻等）告诉蜜蜂，否则上天会使养蜂家庭受到惩罚（比如本片中Miss Bellringer 说蜜蜂会全部走开）。</p><p>clock bell chimes - 钟声响起。chime &#x2F;tʃaɪm&#x2F; 1.（钟）响起（尤其是告诉你到几点了）；2. 与某某相同或具有相同的效果：e.g. Her views on life didn’t chime with mine. 她的人生观和我不太一致。</p><p>tower bell rings.</p><p>-Clear off her rocker, if you ask me. - rock: 岩石；前后摇晃，rock music摇滚乐。rocker，摇椅，（摇椅等下面的）两条弯木（用来摇晃）之一；off one’s rocker: 处于极度混乱或精神不健全的状态。in a state marked by extreme confusion or mental unsoundness: … he felt dizzy, slightly off his rocker at this extraordinary assailment of his senses.</p><p>-You didn’t believed her?</p><p>-Well, what she got to go on? A slammed door and a trike that wasn’t padlocked. It’s a waste of time.</p><p>undertaker - 殡仪员。</p><p>-I based in Causton but <strong>it happens</strong> I live here in Badger’s Drift and I thought I ought to <strong>pop by</strong>. Miss Simpson was a client. 我在Causton上班，但是碰巧我住这里。pop by: 顺便过来一下；pop, (spoken) to go somewhere for a short time.</p><p>-I’m sorry?</p><p>-She’d pre-paid. Our <strong>Satin</strong> Service. It’s one of our complete funeral packages. Very <strong>up-market</strong>, although between you and me. I let her have it at a discount (sniffs). She taught my mom, you know. - Satin，缎面，绸缎，这里应该指服务的等级，类似金卡会员、银卡会员。</p><p>-What can I do for you, Mister Rainbird?</p><p>-I was wondering if I could take her, <strong>the deceased</strong>. - decease&#x3D;death. the deceased去世的人。</p><p>-Oh, I’m afraid that won’t be possible for a little while.</p><p>-Oh! You do suspect some naughtiness. It was her neck, I undertand. 你确实怀疑有一些捣蛋鬼。致命伤在颈部，我知道的。- naughty 顽皮的；naughtiness 名词，顽皮。</p><p>-[Troy] Who told you that?</p><p>-Come on, everybody knows that by now. It’s that sort of village.</p><p>-[Troy] Well, you can’t have the body yet. All right? Sir?</p><p>-[to Barnaby] Oh, I see you’ve got a right constable there. You let me know when you’re ready for me.</p><p>-[Troy] See the car?</p><p>-Yes.</p><p>-You wouldn’t have thought they were so well paid, would you, undertakers? 你应该没有想到殡仪员会获得如此高的报酬，不是吗？</p><p>-Check the camera, and the telephones. Find out what calls did Miss Simpson made after six o’clock.</p><p>-So you’re taking it seriously then, sir?</p><p>-No, Troy, I’m just filling in time until tea.</p><p>-Right! Oh, camera and telephone, right. What about you?</p><p>-I must find a doctor.</p><p>-Something wrong, sir?</p><p>-Emily Simpson’s doctor, Troy. Maybe she did suffer from dizzy spells. Maybe she did just fail. Either way, I want to know. - spell 拼写；咒语。</p><h3 id="医生的家里"><a href="#医生的家里" class="headerlink" title="医生的家里"></a>医生的家里</h3><p>医生的招牌：</p><pre><code>DR. TREVOR LESSITERM.B B.S M.R.C.G.PPHSICIAN &amp; SURGEON</code></pre><p>DR. - Doctor。Trevor Lessiter是医生的名字。</p><p>M.B B.S - Bachelor of Medicine, Bachelor of Surgery 内外全科医学士</p><p>M.R.C.G.P - Membership of the Royal College of General Practitioners 英国皇家全科医生学院会员资格。pratitioner 从业者。general pratitioner 全科医生。</p><p>She is remarkably fit for her age. - 在她这个年龄，她显得非常健康。fit 健康的。</p><p>I liked to drop in at the end of my rounds. You know, glass of sherry and all that. - go round to sb’s house 拜访某人。 drop in - 顺便过来。</p><p>cricket 板球。</p><p>But she never <a href="https://www.collinsdictionary.com/zh/dictionary/english/get-around-to">got round to</a> saying what it was. - 她没能说出来是什么事。get round to 做成了一件你因其他事情被耽搁了事。</p><p>I’ve got to talk to someone. - 我得这个人说说话。have (got) to 不得不。</p><p>-Did she say what it was?</p><p>-No.</p><p>-Didn’t you press her?</p><p>-We’re not meant to. - 我们不是故意的。</p><p>-And there was nothing more?</p><p>-I’m sorry, Inspector. I know there was something else but I can’t think. 我知道还有些事情，但是我想不起来。</p><p>-Well, if it does come to you, can you give us ring? 当你想起来，能不能给我们一个电话。</p><p>-Yes, of course.</p><p>ring off - 挂断电话。</p><p>Inspector - 督察。</p><p>scrambled eggs - 炒鸡蛋。scramble 争夺。</p><p>Stuck with a heavy object as yet unidentified at the base of the neck. 脖子根部被一个尚未辨认的重物卡住。</p><p>sombre music - 阴沉的音乐。</p><p>The grass flattened, brambles broken. 草被压扁了，荆棘断了。</p><p>What, you think someone’s been having it away? 你认为有人把它们拿走了？</p><p>Two people bonking? 两个人搏斗&#x2F;性交？</p><p>tweezers - 镊子。</p><p>-A piece of black fibre. 一片黑色纤维。</p><p>-Off their clothes. 从他们的衣服上掉下来的？</p><p>-No, I don’t think so. I’d say a blanket or rug, something like that. 我认为是毯子或地毯。</p><p>I want the whole place gone over. - <a href="https://www.collinsdictionary.com/zh/dictionary/english/go-over">go over</a> 仔细检查。</p><p>Do you really think that’s what it came down to, sir? 你真的认为这就是问题所在吗？</p><p>Unless it was adultery. 除非是通奸。</p><p>I suppose they could have been arse-bandits. - 我猜想可能他们是屁股小偷（同性恋）。arse（粗鲁的词）屁股。bandit 有武器的小偷。</p><p>You mean “homesexuals”, Troy?  Troy，你是说同性恋？</p><p>You are as politically correct as <a href="https://en.wikipedia.org/wiki/Nuremberg_rallies">Nuremberg rally</a>. 你和纽伦堡集会（德国纳粹一年一度的党代会）一样政治正确。</p><h3 id="Rainbird家"><a href="#Rainbird家" class="headerlink" title="Rainbird家"></a>Rainbird家</h3><p>eerie music - 怪异的音乐。</p><p>pot to kettle. 把锅里（的水）倒到壶里，应该是上茶的意思。（影片中，茶水是装在瓷壶里）</p><p>eyrie - 是 aerie 的另一种写法，鹰巢。an elevated often secluded dwelling, structure, or position 较高且通常僻静的住宅、结构或位置。<a href="https://www.collinsdictionary.com/zh/dictionary/e%3Cb%3Englis%3C/b%3Eh/eyrie">If you refer to a place such as a house or a castle as an eyrie, you mean it is built high up and is difficult to reach.</a></p><p>My hide. Yes, I’m a keen observer of wild life, birds. 我的隐藏爱好，我喜欢观察野生动物——鸟。</p><p>I thought I saw a pair of binoculars. 我想我看见了一副望远镜。</p><p>trolley 手推车。</p><p>Do help yourself. 请自便。</p><p>widower - 鳏夫。widow 寡妇。</p><p>The clubs are anchovy. Salmon spread in the hearts. Marmite spades and potted meat diamonds.</p><p>梅花状的anchovy。Salmon spread是心形的。黑桃状的Marmite。方块状的potted meat. - potted: preserved in a pot, jar, or can: potted meat.</p><p>Not that you’ll find her there. 并不是说你会在那里找到她。</p><p>Done very nicely for herself. 为自己做得很好。</p><p>-Iced sombrero, constable. - Iced sombrero冰阔边帽（应该是这种形状的食物），constable 警员。constabulary 警察局。</p><p>-No, thank you. And I’m a sergeant.</p><p><a href="https://en.wikipedia.org/wiki/Police_ranks_of_the_United_Kingdom">大不列颠警察等级（由高到低）</a>：</p><p>Chief constable, Deputy chief constable, Assistant chief constable, Chief superintendent总警司, Superintendent警司, Chief inspector总督察, Inspector督察, Sergeant警长, Constable警员. - 参考<a href="https://zh.wikipedia.org/zh-hans/%E5%80%AB%E6%95%A6%E8%AD%A6%E5%AF%9F%E5%BB%B3">维基百科</a>。</p><p>Detective是警察的前缀之一，比如Detective Chief Inspector。这种警察一般穿便衣，职位和职级和制服警察一样。</p><p>-I mean what are you likely to see flying at that time? 我的意思你那个时候想要看什么飞禽？</p><p>-Owls. 猫头鹰。</p><p>These two give me the creeps. 这两个人让我毛骨悚然。<a href="https://dictionary.cambridge.org/us/dictionary/english/creep">give someone the creeps</a> - to cause someone to have uncomfortable feelings of nervousness or fear:</p><p>-You don’t suppose it was him in the woods, do you? 你该不会认为是他在树林里吧？</p><p>-I somehow doubt it, Troy. 我有点怀疑。</p><p>They certainly had it in for her. 他们当然是为了她。</p><h3 id="Barnaby家"><a href="#Barnaby家" class="headerlink" title="Barnaby家"></a>Barnaby家</h3><p><a href="https://en.wikipedia.org/wiki/%27Tis_Pity_She%27s_a_Whore">‘Tis Pity She’s a Whore</a>. 可惜她是一个妓女，John Ford 导演的音乐剧。’Tis 是 it is 的缩写。</p><p>Would you go through my lines with me? 你可以帮我一起练习一下台词吗？</p><p>I doubt he’ll have time. 我怀疑他是否有时间。</p><p>quail - 鹌鹑。</p><p>(Telephone rings) I’ll get it. 我去接电话。</p><p>In the pond behind the quarry. 在采石场后面的池塘里。</p><p>-Think what the police would make of it if their forensic people got hold of it. 想想警察会怎么想，如果他们的法医人员拿到了它。<a href="https://dictionary.cambridge.org/us/dictionary/english/make-of">make of</a> - to have an impression or understanding about something. 对某事有印象或有了解。</p><p>-They’d have a field day. 他们会度过愉快的一天。<a href="https://dictionary.cambridge.org/us/dictionary/english/field-day">field day</a> 特殊的一天。</p><p>-This is the big one, Denny. This is going to make us very, very rich. 这是最重要的，这会让我变得非常富有。</p><p>Two colomns in the local rag and a coroner’s re-port. - coroner 验尸官。</p><h3 id="Tye-House"><a href="#Tye-House" class="headerlink" title="Tye House"></a>Tye House</h3><p>tyres screech - 轮胎尖叫声。</p><p>bright upbeat music - 明亮欢快的音乐。upbeat 乐观的。</p><p>-How the other half live?</p><p>-Rather less then half I’d say. 我说目前还不是（富豪的）另一半。</p><p>estate manager - 物业经理。</p><p>-I don’t suppose you were in the village at any time at between six and eight on Wednesday? 我想你周三六点到八点之间的任何时间都不会在村子里？</p><p>-No. Don’t remember where I was. Out in the fields. 不在。不太记得我去了哪里。我出去到田野里去了。</p><p>drawing room - 客厅。</p><p>late wife - 已故的妻子。</p><p>as a matter of fact - 事实上。</p><p>-If it’s not too painful, sir, I’d be interested to know how your wife died. 如果不是太痛苦的话，先生，我很想知道你妻子是怎么死的。</p><p>-It is painful. And I don’t see how it’s relevant. 很痛苦。并且我没有看到（这两件事的）相关性。</p><p>-Miss Simpson could have known your wife as Annabella. As a nick name, pet name or something like that. If there is a connection - - Simpson女士可能知道你的妻子是Annabella，一个昵称、爱称或其他啥的。</p><p>-There is no connection.</p><p>-We need to be sure.</p><p>-(sighs) If you insist. It was two years ago… 如果你坚持的话。</p><p>And Bella’s sister had come along. Phyllis, Phyllis Cadell. She didn’t shoot that ofen and I always wondered why she closed that day of all days. - Bella的姐妹Phyllis Cadell也来了，她不经常射击，我常常想知道，为什么那天她整天关门（可能是有个私人商店）。</p><p>He’d come as a beater, to scare the birds. 他来的任务敲击吓唬鸟。</p><p>I suppose it’s always easy to talk about these thing with hindsight but I’m often felt think we were ill-fated that day. 我想事后谈论这些事情总是很容易的，但我常常觉得我们那天运气不好。</p><p>Bella tripped on a root and twisted her ankle rather badly. - Bella被树根绊倒并且脚踝被扭伤得非常严重。</p><p>But by the time ambullance arrived it was all over. 但当救护车到达时，一切都结束了。</p><p>dog whines - 狗呜呜声。</p><p>generator - 发电机。</p><p>marquee - 帐篷。</p><p>You finished it, I take it? （警官）你的问讯结束了吧？我可以做其他的事情吧？</p><p>He was a sort of guardian. 他是某种守护者。</p><p>We won’t take up any more or your time. 我们不再占用您的时间了。</p><p>exhale - 呼气。</p><p>But I do what I can even I’m quite worn out. - 我尽我所能帮忙，即使我累坏了。wear 磨损。</p><p>mistress - 女主人，具有权威或控制地位的女人；情妇。</p><p>Henry has a cottage on the estate and I’m being pensioned off there. I’m quite looking forward to it.</p><p>Pathetic. - 可怜的。</p><p>She was scared shitless. - 她被吓得屁滚尿流。</p><p>You do have a way with words, don’t you?</p><p>What are we investigating, sir? Emily Simpson or Belly Trace?</p><p>There’s no point asking me about it. 没有必要问我这个问题。</p><p>I don’t have anything to do with the village. And the village doesn’t have much to do with me.我和那村子没有任何关系。那村子和我也没有太大关系。</p><p>-Could you tell me where you were on last Wednesday?</p><p>-No. I don’t know. Maybe I’m here, I’m most days. </p><p>-Not much of life. 没什么生活。</p><p>-My work is my life. You wouldn’t understand that. 我的工作就是我的生活。你不会理解这一点。I might have gone for a walk or something, I don’t remember.</p><p>Missis - Miss, Misses 小姐。</p><p>I ran hell for leather back to Tye House. - hell表示程度，加强语气。</p><p>I’ll say one thing for Katherine. She certainly doesn’t come cheap. 我要为Katherine说一件事，她的价格当然不便宜。</p><h3 id="Barnaby家-1"><a href="#Barnaby家-1" class="headerlink" title="Barnaby家"></a>Barnaby家</h3><p>intense uneasy music - 强烈不安的音乐。</p><p>-This noble creature was in every part. So angel-like, so glorious, that a woman, who was not human, as was I – 这个高贵的生物无处不在。</p><p>-Had not been but human. 只不过是人类。</p><p>-Who had not been but human, as was I. Would have kneeled to him and begged for love. 谁不是人类，就像我一样。会向他下跪并乞爱。You, why you are not worthy once to name. His name without true worship, or indeed. Unless you kneeled, to have another name him. 你，为何连一次的名字都不配。 他的名字没有真正的崇拜，或者说确实如此。 除非你跪下来给他起另一个名字</p><p>-What was he called?</p><p>-We not come to that. 我们并没有谈到这个。Let it suffice that you shall have the glory. 只要你拥有荣耀就足够了。To father what so brave a father got. 对于父亲来说，一个父亲有多么勇敢。</p><p>That sounded good. It’s coming along.</p><p>She’s wonderful. We’re gonna have to go up and see it.</p><p>-If I ever manage to learn it all. 如果我能学会这一切就好了。manage to do 设法做，（尽管有困难）成功做。</p><p>I’ve got a nice Pot-au-feu in the deep freeze. 我有一份美味的冷冻炖锅。<a href="https://en.wikipedia.org/wiki/Pot-au-feu">Pot-au-feu</a> (&#x2F;ˌpɒtoʊˈfɜːr&#x2F;; French: [pɔt‿o fø] ( listen); “pot on the fire”) is a French dish of slowly boiled meat and vegetables, usually served as two courses: first the broth (bouillon) and then the meat (bouilli) and vegetables.</p><p>horse nickers - nicker: 1, (of a horse) give a soft, low, breathy whinny. 2, a nickering sound.</p><p>white lilies - 白百合。</p><p>This is the Satin Service.</p><p>Whimsical sombre music - 异想天开的忧郁音乐。</p><p>You’ve withdrawn 500 pounds from our joint reserve account. 您已经从我们的联合储蓄账户中提取了500英镑。</p><p>overdraw - 透支。</p><p>I thought I’d leave you two to bicker in private. 我想我应该让你俩私下斗嘴。</p><p>I know that my redeemer liveth, and that he shall stand upon the last on the earth. Whom I shall see for myself, and mine eyes shall behold, and not another.（祷告）我知道我的救世主还活着。- mine 用在元音之前，相当于my.</p><p>Missis Rainbird no more a bird-wather than I am. - Rainbird女士和我一样都不是鸟类观察者。</p><p>personalised Porsche. 个性化的保时捷。</p><p>Rain stopped play. 雨停止了比赛。</p><p>His wife’s just as bad. 他的妻子同样糟糕。</p><p>It’s early closing. 关门还早呀。</p><p>There’s something wrong and something that doesn’t add up. 有些地方出了问题，有些地方不合逻辑。</p><p>Maybe he was. Maybe he simply mistaken in his account. But he wasn’t telling us the truth. 他可能是（在撒谎），也可能只是记错了。但是他没有告诉我们事实。</p><p>Why did he run all the way back to Tye House to call the ambullance when the accident happened on the other side of the village? 事故发生在村子的另一边，为什么他还要千里迢迢跑回The House叫救护车呢？</p><p>-It seems they’re all bloody liars. 看起来他们都是该死的撒谎者。bloody - used to express anger or to emphasize what you are saying in a slightly rude way.</p><p>-One of them is something more. 其中一个有更多东西。</p><p>Forasmuch as it hath pleased Almighty God of his great mercy to take unto himself, the soul of our dear sister here departed, we therefore commit her body to the ground; earth to earth, ashes to ashes, dust to dust; Amen.</p><p>It’s early days yet. 现在还早呢。</p><p>Not for poor Emily.</p><p>Come and have sherry. 来喝杯雪莉酒吧！I feel the need of a drink. I’m afraid funerals do that for me. 我觉得需要喝一杯，恐怕葬礼对我来说就是这样。</p><p>polio - 脊髓灰质炎。</p><p>pensive music - pensive沉思的。</p><p>She adored him. Still does for all I know. - 她崇拜&#x2F;喜欢他，据我所知（for all I know）仍然如此。</p><p>She was Herry’s ward. 她是Herry的被监护人。</p><p>Herry sort of adopted them. - Herry有点收养了他们。</p><p>set them up in a gamekeeper’s cottage on the estate. - 把他们放在庄园的猎场看守人的小屋里。</p><p>They are very young then, barely in their teens. - 他们那时候还很小，才十几岁。</p><p>nanny - 保姆。</p><p>There was a nanny, Mary Sharpe, Nanny Sharpe, which was meant to look after them. - 有一个保姆，叫Sharpe，是为了照顾他们。</p><p>-But she had a terrible time. 但是她度过了一段糟糕的时光。</p><p>-In what way? 以什么样的方式？</p><p>-The children were always fighting. Endless rows. - 孩子们总是打架，无休止地争吵。row 可数名词，争吵：<a href="https://www.collinsdictionary.com/zh/dictionary/english/row">A row is a serious disagreement between people or organizations</a>.</p><p>In the end, Mary upped and left. - 最后，Mary起身离开了。up 动词，增加；突然离开：<a href="https://www.collinsdictionary.com/zh/dictionary/english/up">If you up and leave a place, you go away from it, often suddenly or unexpectedly</a>.</p><p>Now she’s retired down on the coast. 现在她在海边退休了。</p><p>-If you ask me, Katherine is the one to look out for. 如果你问我，凯瑟琳是值得留意的人。</p><p>-Meaning? 意思是？</p><p>-That girl is far too beautiful for other people’s good. 那个女孩太漂亮了，不利于别人。That girl is far too beautiful for other people’s good. If she was found bonking in the wood, she has the most to lose. 如果她被发现在树林里打滚（性交），她的损失将是最大的。</p><p>She’s got a point. 她说得有道理。</p><p>it barks its head off. 它拼命狂叫。its head在这里表示强烈程度。You’d have heard it a mile away! 你一英里外都能听见它。</p><p>Damn! Do you know, for a minute I thought I had the whole thing solved. 该死！你知道吗，有一瞬间我以为我已经解决了整个问题。</p><p>I think I deserve another Marron Lyonnaise. - 我认为我值得再来一份我值得再来一份马龙·里昂酱。</p><p>I want their clothes bagged and down forensics. - 我想把他们的衣服打包并取证。forensics法医。</p><p>What a mess. - 真是一团糟。</p><p>She’s being treated for shock outside, no surprise. - 她休克了，正在外面接受治疗，这并不奇怪。shock休克。</p><p>Don’t expect to get much sense. - 不要指望得到太多意义。</p><p>You’d better come up and take a look at this. 你最好过来看看这个。</p><p>-You’re not going to believe it. 你不会相信的。</p><p>-On the contrary, Troy, I rather think I will. 恰恰相反，我觉得我会相信的。</p><p>What was it she said, sir? 先生，她说了什么？</p><p>Listen to this: At 10:30 a.m. Mister and Missis W crossed over by post box to avoid Miss G. 10点30分，W先生和W小姐穿过邮政信箱以避免G小姐。</p><p>11:00 a.m. A called on Miss S., stayed 15 minutes. 上午11:00，A拜访了S小姐，停留了15分钟。</p><p>There must be a couple of hundred entries in this file alone. 仅这个文件中就得有上百个条目。May thousands of them over the years. 可能有这几年的上千条记录。</p><p>I want them all taken down. 我希望他们都被记录下来了。<a href="https://www.collinsdictionary.com/zh/dictionary/english-chinese/take-down">take down</a> 1, 记录write down; 2, 拆除dismantle: wall, fence etc.</p><p>We’re gonna have to go through the whole lot of them. 我们不得不要把它们全部浏览一遍。</p><p>blackmail - n. &amp; vt. 勒索。</p><p>She wasn’t a bad old stick. 她不是一个很坏的人。</p><p>She is a bit perculiar, her and her son. Him being au undertaker and all. - 她和她的儿子有点奇怪。他是殡仪馆的承办人等等。perculiar - 奇特的。</p><p>But she was very good for me, in her own way, very good to me.</p><p>One is getting wed. 将要结婚的那个。</p><p>-That’s a bend just ahead. 前面就是一个转弯。</p><p>-Now, I’ve seen it, sir. 我看到了。</p><p>And do me a favor, Troy, when we get there, if we get there, park at the bottom of the lane. 帮我一个忙，特洛伊，当我们到达那里时，如果我们到达那里，请将车停在车道的底部。</p><p>yells - 呼喊。</p><p>Sometimes you really make me sick. 有时你真的让我感到恶心。</p><p>I don’t care if you marry him for money, but why can’t you come clean and admit it? 我不在乎你嫁给他是不是为了钱，但你不坦白承认。come clean 坦白说出来。admit 承认。</p><p>It’s not like that. 不是那样的。</p><p>So what is it like? Tying yourself to a bloody cripple at your age. 在你这个年纪，把自己绑在一个该死的瘸子身上。tying - tie的现在分词。</p><p>That bloody cripple looked after us. If it hadn’t been for him, we wouldn’t have had a home. We wouldn’t have had anything.</p><p>Yes, he’s getting his pound of flesh, isn’t he? - 是的，他正在得到一磅肉（意思是买到回报）。</p><p>He’s not buying me, Michael.</p><p>So what is he doing then? Renting you by the hour? 那他现在是做什么？按小时租赁你吗？</p><p>slaps - 拍击。</p><p>Alright, then. Don’t come to our wedding. Henry and I are better off without you. 那好吧。不要来参加我们的婚礼。没有你，亨利和我会过得更好。be better off - If you say that someone would be better off doing something, you are advising them to do it or expressing the opinion that it would benefit them to do it: If you’ve got bags you’re better off taking a taxi.</p><p>I won’t bother buying a present, then!</p><p>-Do you want to go follow her, sir?</p><p>-No, Troy, I’d like to take a closer look in here.</p><p>-What? Go in without a warrant? Isn’t that a bit? - 什么？没有搜查令就进去？warrant - 保证；值得，有必要；搜查令；做某事的依据。</p><p>-You have a problem, Troy?</p><p>-No, no. Just glad I didn’t suggest it. 只是庆幸我没如此建议。</p><p>-If anybody finds us, you did.</p><p>-Pity. 真遗憾。</p><p>-Locked? 锁上了？</p><p>-Yep.</p><p>-I can force it. 我可以强行弄开它。</p><p>Thank you all the same.</p><p>-Mom gone to bed? 妈妈已经睡了吗？</p><p>-Hours ago. 几小时前（就睡了）。What’s all this? 这到底是什么？</p><p>-Notebooks. Iris Rainbrid took a Neighbourhood Watch to unheard of extremes. - Iris Rainbrid将邻里守望者组织带到了前所未闻的极端。extreme - 极端。</p><p>You wouldn’t think that one small village could have so much trouble bubbling under the surface.</p><p>-Was it very horrid? The bodies.</p><p>-I’ve seen worse.</p><p>I’m one more step further down the road. - 我在路上又向前迈进了一步。</p><p>-I haven’t read lines with you. How’s it going?</p><p>-Oh well, four acts down, one to go. - 四幕已结束，还剩一幕。</p><p>-Yes, I suppost it’s the last act that really matters. 是的，我认为真正重要的是最后一幕。</p><p>car rumbles - 车隆隆地。</p><p>peacock hoots - 孔雀叫。</p><p>It’s out of the question. - 这是不可能的。</p><p>Voice of sanity. 理智的声音。</p><p>Parish Council - 教区议会。</p><p>It was only later I realised. 后来我才意识到。</p><p>Everything’s over, it’s all slipping away. 一切都结束了，一切都过去了。</p><p>-I don’t suppose you saw anyone in the woods? 我想你在树林里没有看到任何人吧？</p><p>-No. 没有看到。</p><p>Phillips Codell, I’m here arresting you on suspicion of the murder of Bella Trace on 26th of June 1995.</p><p>You don’t have to say anything, but it may harm your defence if you do not mention when questioned something that you reply on in court. Anything you do say may be given in evidence.</p><p>He was in that wheelchair and she just couldn’t cope.</p><p>It’s something one does in the country. 这是国内每个人都会做的事情。</p><p>I took a hip flask, filled with vodka and I kept on drinking. It was the only that I could get the courge.</p><p>All the dead birds. The noise, the blood that made me feel sick and dizzy. 到处都是死鸟。噪音、血液让我感到恶心和头晕。</p><p>I didn’t think I was gonna be able to do it.</p><p>I doubled back behind the trees and managed to hide. - 我折回树后并设法躲了起来。double back, to turn and go back in the direction you have come from.</p><p>Then I waited until I had a clear shot. And then. I shot her. 然后我就等到了清晰的视角。然后，我就开枪打了她。第一个shot是“镜头”的意思，第二个shot，是shoot的过去式及过去分词。</p><p>It was terrible. I saw her pitch forward and fall to the ground. - 太可怕了。我看到她向前倾倒，倒在了地上。pitch, to move or be moved suddenly, especially by throwing or being thrown.</p><p>And then, I just panicked. 然后，我就惊慌失措了。panickis a common misspelling of panic.</p><p>I got up and I ran and I ran.</p><p>I thought then that I’d done it, that I got away with it. 那时我想我已经做到了，我逃脱了惩罚。</p><p>How could I have known that I’d been seen? 我想知道，我是怎么被看见的？</p><p>She put it all in those notebooks, didn’t she? I had to go to that revolting house.</p><p>I expect you’ll be needed more than ever at Tye House now. 我预计Tye House现在比以往任何时候都更需要你。Quite the chatelaine you’ll be, won’t you? Now, what will you have?</p><p>dramatic siniter music - 戏剧性的险恶音乐</p><p>The diamonds are marmite, the spades are jam, the hearts are tuna and the clubs are sandwich spread. 方块是马麦酱，黑桃是果酱，红心是金枪鱼，梅花是三明治。</p><p>spread - 放在面包或饼干上的软质食物（酱）。a soft food for putting on bread and crackers:</p><p>cheese&#x2F;chocolate&#x2F;fish spread</p><p>There’s bread and various spreads for tea.</p><p>voiceover - 画外音。</p><p>How much did they take? 他们拿了多少钱？</p><p>They’d even stopped asking me. They knew I was cleaned out. 他们甚至不再找我要了。他们知道我被掏空了。</p><p>Sir, there’s someone here for you in reception. 先生，有人在接待处等候您。</p><p>There’s something about that story, the shooting party, that still not right.</p><p>You know you featured in here? 你知道你自己被包括在这个笔记本中了吗？</p><p>He was wearing his denims and that cap he wears. 那个人穿着他的牛子裤和帽子。</p><p>brutal - 野蛮的。</p><p>-You again. You don’t give up, do you?</p><p>-Mister Lacey, we’re here in connection with the death of Iris Rainbird.</p><p>-In connection with. You policemen have a wonderful way of expressing yourselves.</p><p>-As you may know, Mister Lacey, she was murdered in a particularly brutal fashion. 你可能知道，莱西先生，她是被以一种特别残酷的方式谋杀的。</p><p>-I hope you’re not looking for insincere expressions of regret on my part, Chief Inspector. 我希望你不是在寻找我不真诚的遗憾表示，总督察。She was a very nasty woman. 她是个令人讨厌的女人。</p><p>-Did you ever go to her house?</p><p>-No.</p><p>-So what would you say if I told you that somebody had been you entering her front door shortly after four o’clock yesterday afternoon?</p><p>-I would say they needed their eyes testing.</p><p>-(Troy) Mister Lacey, we have a warrant here to search these premises. - premises, 某人（一般是公司或组织）拥有的土地和建筑the land and buildings owned by someone, especially by a company or organization. premise, 前提。</p><p>-So how do you explain this, Sir?</p><p>-I can’t! Of course I can’t!</p><p>-Where have you put the clothes?</p><p>-What clothes?</p><p>-The dungarees, the cap and the golves. 工作服、帽子和手套。</p><p>-What?</p><p>-The clothes you wore to kill Iris Rainbird.</p><p>-You’re raving mad! 你疯了吧！rave, to speak in an uncontrolled way, usually because you are upset or angry, or because you are sick.</p><p>I’ve been framed. 我被陷害了。</p><p>a custody death.</p><p>-Maybe we should have put her on suicide watch, sir?</p><p>-Is that a reprimant, Troy? ‘Cause you’re right. This is my fault.</p><p>-Maybe she’s better off this way. All things considered.</p><p>-That is not the point.</p><p>Lacey has been shouting  his mouth off, sir. 莱西一直在大喊大叫。</p><p>door clanks. 门叮当响。</p><p>How nice of you to look in, Chief Inspector.</p><p>-You say what you’ve got to say and get on with it. 你说出你必须说的话，然后继续说下去。</p><p>-I want to go home.</p><p>-Aren’t you, Mister Comedy? You want the truth, Mister Lacey. I’ve had you up to here. 我几乎都查出你的罪了。</p><p>You were in such a hurry to drag me off yesterday. 你昨天那么急着把我拖走。</p><p>mid-morning - 上午中旬。</p><p>Caped Crusader - 斗篷十字军</p><p>He only did the first sketches but they took all day. 他只画了草图，但是这些草图花了一天的时间。</p><p>He said I had a wonderful complicated face.</p><p>He’s a surrealist, is he? 他是超现实主义者，是吗？</p><p>-And since everyone’s always picking on him, you might as well know he was there the night Emily Simpson died too. 既然每个人都在找他的茬，你不妨知道艾米丽·辛普森去世的那天晚上他也在他的工作室里。</p><p>-You’ve seen quite a bit of him, is there something that I ought to know? 你已经和他见过不少次面了，有没有什么事是我该知道的？（你有没有和他发生过什么？）</p><p>-What? Something like you and your Missis Whiplash? Or Barbara and all her boyfriends? No, dad, there’s nothing you need to know at all. 什么事？就像你和Whiplash太太那样吗？或者Barbara和她的那些男朋友一样？没有，爸爸，没有什么事是你应该知道的（我和他没有发生那样的事）。</p><p>In fact I think she may have told us more than she meant to. 事实上我认为她告诉了我们比她本意更多的事情。</p><p>-It’s very good.</p><p>-It’s only Marks and Sparks, I’m afraid. You should have told me you were coming.</p><p>-Marks and Sparks is fine.</p><p>The Lessiter girl backed up his alibi. 莱斯特女孩支持了他的不在场证据。</p><p>It had to be a trick. 这一定是一个诡计。</p><p>car honks. 汽车鸣笛。</p><p>I have to be off. 我要走了。</p><p>Burnham Crescent - Burnham发音为[BUR] + [NUHM]。crescent雕刻成的类似新月的形状。</p><p>Up ahead this road on the left. 往这条路前面的左边走。</p><p>They were not easy children but of course under the circumstances, one had to make allowances. 他们不是好孩子，但当然在这种情况下，人们必须体谅他们。</p><p>Every day it was a slanging match. 每天都是一场谩骂比赛。She’d scream at him and he’d fling himself out of the house.</p><p>cup shatters. 杯子粉碎。</p><p>How could I’ve betrayed them? 我怎么可能背叛他们？</p><p>All she had to do was to hand the dog over to her brother. 她所要做的就是把狗交给她哥哥。</p><p>Why wouldn’t he open the door. Because then she’d have seen the dog and that would have spoiled the whole set-up. 那会破坏整个设计。</p><p>If it hadn’t been for an observant neighbour and an unlocked tricycle, we’d have never been any the wiser. 如果没有细心的邻居和一辆没上锁的三轮车，我们永远不会变得更聪明。</p><p>Yes, they’re clever, weren’t they? Always working off one another.</p><p>Whoever went to the house was wearing overalls and a cap and they probably made sure they were seen at least from behind. - overalls工作服。</p><p>Katherine stabbed them and then she put the knife and the blood-soaked overalls into the basket.</p><p>Bella Trace was just a freak change, wrong place, wrong time.</p><p>makesman - 制造者。</p><p>bludgeon, poison, stab</p><p>sheep bleat - 羊咩咩叫。</p><p>“I’ve been framed.” And he made this sign. It was a coded message. He was warning her to remove the picture. - 我把画装在框里了。frame, 把画装框，When a picture or photograph is framed, it is put in a frame.</p><p>It’d have given the game away, wouldn’t it? 这幅画泄露了这个游戏，不是吗？give away泄露，If you give away information that should be kept secret, you reveal it to other people.</p><p>-It’s powerful. It’s brilliant even in its own way.</p><p>-He had talent.</p><p>-But so twisted.</p><p>-I almost guessed it when we came here. The three bedrooms and only one bed slept in. They pulled the wool right over my eyes.</p><p>-(Troy) When?</p><p>-That time we came here and they were arguing. They really did seem to hate each other, didn’t they? And they couldn’t have staged it for our benefit. Because they didn’t know we were here. Except they did. They saw us in the mirror. And they did put on a show.</p><p>-Poor Emily.</p><p>-(Troy) And poor Annabella. Who was she?</p><p>-I don’t suppose we’ll ever know. </p><p>I hope you’re not gonna fall asleep in this.</p><p>I wouldn’t dream of it.</p><p>Anyway, after what you’ve just been through, a start of incest should be right up your street.</p><p>Come this in sadness from you.</p><p>Let some mystery befall me soon if I dissemble all.</p>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> movie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode Usage</title>
      <link href="/blog/2024/01/24/misc/VSCode-Usage/"/>
      <url>/blog/2024/01/24/misc/VSCode-Usage/</url>
      
        <content type="html"><![CDATA[<h2 id="Reduce-the-disk-usage-of-VSCode"><a href="#Reduce-the-disk-usage-of-VSCode" class="headerlink" title="Reduce the disk usage of VSCode"></a>Reduce the disk usage of VSCode</h2><p>以下文件可以删除：</p><ul><li><p>.vscode-server&#x2F;data&#x2F;User&#x2F;workspaceStorage&#x2F;*：几十GB.</p></li><li><p>.vscode-server：<a href="https://stackoverflow.com/questions/58453967/vscode-remote-ssh-vscode-server-taking-up-a-lot-of-space">参考</a></p></li><li><p>.config: 可以针对每个目录找到相应的程序，比如 Chrome，然后有针对性地删除一些文件。参考<a href="https://stackoverflow.com/questions/58453967/vscode-remote-ssh-vscode-server-taking-up-a-lot-of-space">这里</a>。</p></li><li><p>.cache: 和 .config 类似处理，参考<a href="https://superuser.com/questions/366771/what-does-cache-do-it-consumes-a-huge-disk-space">这里</a>。</p><p>  .cache&#x2F;vscode-cpptools: This cache folder stores cached precompiled headers or “ipch” files that the IntelliSense engine uses to improve performance. You can limit the size of the cache by changing the setting value of C_Cpp.intelliSenseCacheSize. 参考<a href="https://github.com/microsoft/vscode-cpptools/issues/6594">这里</a>：<br>  <img src="/blog/image.png" alt="C_Cpp.intelliSenseCacheSize"></p></li></ul><h2 id="Hot-keys"><a href="#Hot-keys" class="headerlink" title="Hot keys"></a>Hot keys</h2><ol><li>跳转到对应大括号：<code>Ctrl Shift \</code></li></ol><h2 id="Debug-code-in-VSCode"><a href="#Debug-code-in-VSCode" class="headerlink" title="Debug code in VSCode"></a>Debug code in VSCode</h2><ul><li><a href="https://code.visualstudio.com/Docs/editor/debugging#_multitarget-debugging">Debug multiple processes in VSCode</a></li><li><a href="https://stackoverflow.com/questions/60515935/visual-studio-code-does-not-attach-debugger-to-multi-processes-in-python-using-p">Debug Python Subprocess</a></li></ul><h2 id="Useful-plugins"><a href="#Useful-plugins" class="headerlink" title="Useful plugins"></a>Useful plugins</h2><ul><li><code>Remote - SSH</code>: Windows 连接 Linux。前置条件：Windows 本身需要安装 ssh 命令行工具。</li><li><code>Perforce for VS Code</code>: perforce 工具。</li><li><code>intent-rainbow</code>: 用彩色显示缩进。</li><li><code>C/C++</code></li><li><code>Makefile Tools</code></li><li><code>Verilog Format</code></li><li><code>All in one</code></li><li><code>c/c++ definition generator</code></li><li><code>KoroFileHeader</code>: 参考<a href="https://zhuanlan.zhihu.com/p/610490070">这里</a>。</li></ul><h2 id="Useful-configurations"><a href="#Useful-configurations" class="headerlink" title="Useful configurations"></a>Useful configurations</h2><p><a href="https://www.cxyzjd.com/article/weixin_45461426/105936955">自动填充头文件，比如ifndef宏</a></p><p>配置文件：</p><ul><li>launch.json</li><li>tasks.json: <a href="https://stackoverflow.com/questions/48273346/vscode-command-for-user-input-in-debug-launch-config">ref</a>, <a href="https://code.visualstudio.com/updates/v1_30#_improved-user-input-variables-for-task-and-debug-configurations">ref</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打印进程堆栈</title>
      <link href="/blog/2024/01/23/cplusplus/%E6%89%93%E5%8D%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%A0%86%E6%A0%88/"/>
      <url>/blog/2024/01/23/cplusplus/%E6%89%93%E5%8D%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%A0%86%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><a href="https://www.gnu.org/software/libc/manual/html_node/Backtraces.html">glic Functions</a></p><pre><code>backtracebacktrace_symbolsbacktrace_symbols_fd</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_trace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* buffer[SIZE];</span><br><span class="line">    <span class="type">char</span>** strings;</span><br><span class="line">    <span class="type">int</span> size, i;</span><br><span class="line"></span><br><span class="line">    size = <span class="built_in">backtrace</span>(buffer, SIZE);</span><br><span class="line">    strings = <span class="built_in">backtrace_symbols</span>(buffer, size);</span><br><span class="line">    <span class="keyword">if</span> (strings != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Obtained %d stack frames.\n&quot;</span>, size);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strings[i]);</span><br><span class="line">        <span class="built_in">free</span>(strings);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><p>breakpad: <a href="https://blog.csdn.net/weixin_45609638/article/details/125090204">https://blog.csdn.net/weixin_45609638/article/details/125090204</a></p><p><a href="https://juejin.cn/post/6899070041074073614">https://juejin.cn/post/6899070041074073614</a></p><p><a href="https://juejin.cn/post/7130820896213712927">https://juejin.cn/post/7130820896213712927</a></p>]]></content>
      
      
      <categories>
          
          <category> c/cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> syntax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Build Linux Kernel Module</title>
      <link href="/blog/2024/01/23/linux/Build-Linux-Kernel-Module/"/>
      <url>/blog/2024/01/23/linux/Build-Linux-Kernel-Module/</url>
      
        <content type="html"><![CDATA[<h2 id="内核编译"><a href="#内核编译" class="headerlink" title="内核编译"></a>内核编译</h2><p>obj-m: <a href="https://stackoverflow.com/questions/57839941/what-is-the-meaning-of-obj-m-in-linux-device-driver-makefile">链接</a></p><p>make modules: <a href="https://askubuntu.com/questions/1363530/what-does-make-and-make-modules-do-when-compiling-building-the-kernel">链接</a></p><h2 id="编译内核模块"><a href="#编译内核模块" class="headerlink" title="编译内核模块"></a>编译内核模块</h2><p><a href="https://tldp.org/LDP/lkmpg/2.6/html/x181.html">文档</a></p><p>Makefile:</p><pre><code>obj-m += hello-1.oall:    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modulesclean:    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean</code></pre><p><code>make -C</code> changes to a new directory where the new makefiles will be run.</p><p><code>M=$(PWD)</code> defines a variable <code>M</code> which the child makefiles can use.</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul><li><code>insmod</code>: 插入一个模块（.ko）到kernel中。</li><li><code>rmmod</code>: 从内核中删除一个模块。</li><li><code>modprobe</code>: 从内核中增删模块。<code>modprobe</code>从<code>/lib/modules/`uname -r`</code>中搜索所有的模块和其他文件，除了<code>/etc/modprobe.d</code>目录中的可选配置文件（参见<code>modprobe.d(5)</code>）。</li><li><code>lsmod</code>: 显示当前加载的内核模块的状态（即对<code>/proc/modules</code>内容的格式化）。</li><li><code>modinfo</code>: 从命令行指定的内核模块中提取信息，如果没有给出模块名称，那么会搜索<code>/lib/modules/version</code>目录，就像<code>modprobe</code>加载模块时一样。</li><li><code>depmod</code>: 生成<code>modules.dep</code>和映射文件。</li><li><code>dmesg</code>: 打印或控制内核ring buffer（存储kernel message）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> c/cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introducation to PCIE</title>
      <link href="/blog/2024/01/23/misc/PCIE/"/>
      <url>/blog/2024/01/23/misc/PCIE/</url>
      
        <content type="html"><![CDATA[<h1 id="词汇表（Glossary）"><a href="#词汇表（Glossary）" class="headerlink" title="词汇表（Glossary）"></a>词汇表（Glossary）</h1><ul><li>BAR: base address register.</li><li>PCI configuration space.</li><li>sba: system bus address.</li></ul><p><a href="https://wiki.osdev.org/PCI">PCI</a></p><p><a href="https://en.wikipedia.org/wiki/PCI_configuration_space">PCI configurtation space</a></p><pre><code>PCI设备有一组被称为configuratin space的寄存器，并且PCI Express引入了Extended configuration space。configuration space寄存器被映射到memory locations。驱动设备和诊断软件必须要有权限访问configuration space，操作系统通常使用APIs来授权访问设备configuration space。</code></pre><p>PCI configuration space有两种类型的Header（64 bytes）：</p><h2 id="Header-Type-0x0"><a href="#Header-Type-0x0" class="headerlink" title="Header Type 0x0"></a>Header Type 0x0</h2><style type="text/css">.tg  {border-collapse:collapse;border-spacing:0;}.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;  overflow:hidden;padding:10px 5px;word-break:normal;}.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}.tg .tg-rcf9{background-color:#F9F9F9;text-align:left;vertical-align:middle}.tg .tg-tbl0{background-color:#F9F9F9;font-weight:bold;text-align:center;vertical-align:middle}</style><table class="tg"><thead>  <tr>    <th class="tg-tbl0">Register</th>    <th class="tg-tbl0">Offset</th>    <th class="tg-tbl0">Bits 31-24</th>    <th class="tg-tbl0">Bits 23-16</th>    <th class="tg-tbl0">Bits 15-8</th>    <th class="tg-tbl0">Bits 7-0</th>  </tr></thead><tbody>  <tr>    <td class="tg-rcf9">0x0</td>    <td class="tg-rcf9">0x0</td>    <td class="tg-rcf9" colspan="2">Device ID</td>    <td class="tg-rcf9" colspan="2">Vendor ID</td>  </tr>  <tr>    <td class="tg-rcf9">0x1</td>    <td class="tg-rcf9">0x4</td>    <td class="tg-rcf9" colspan="2">Status</td>    <td class="tg-rcf9" colspan="2">Command</td>  </tr>  <tr>    <td class="tg-rcf9">0x2</td>    <td class="tg-rcf9">0x8</td>    <td class="tg-rcf9">Class code</td>    <td class="tg-rcf9">Subclass</td>    <td class="tg-rcf9">Prog IF</td>    <td class="tg-rcf9">Revision ID</td>  </tr>  <tr>    <td class="tg-rcf9">0x3</td>    <td class="tg-rcf9">0xC</td>    <td class="tg-rcf9">BIST</td>    <td class="tg-rcf9">Header type</td>    <td class="tg-rcf9">Latency Timer</td>    <td class="tg-rcf9">Cache Line Size</td>  </tr>  <tr>    <td class="tg-rcf9">0x4</td>    <td class="tg-rcf9">0x10</td>    <td class="tg-rcf9" colspan="4">Base address #0 (BAR0)</td>  </tr>  <tr>    <td class="tg-rcf9">0x5</td>    <td class="tg-rcf9">0x14</td>    <td class="tg-rcf9" colspan="4">Base address #1 (BAR1)</td>  </tr>  <tr>    <td class="tg-rcf9">0x6</td>    <td class="tg-rcf9">0x18</td>    <td class="tg-rcf9">Secondary Latency Timer</td>    <td class="tg-rcf9">Subordinate Bus Number</td>    <td class="tg-rcf9">Secondary Bus Number</td>    <td class="tg-rcf9">Primary Bus Number</td>  </tr>  <tr>    <td class="tg-rcf9">0x7</td>    <td class="tg-rcf9">0x1C</td>    <td class="tg-rcf9" colspan="2">Secondary Status</td>    <td class="tg-rcf9">I/O Limit</td>    <td class="tg-rcf9">I/O Base</td>  </tr>  <tr>    <td class="tg-rcf9">0x8</td>    <td class="tg-rcf9">0x20</td>    <td class="tg-rcf9" colspan="2">Memory Limit</td>    <td class="tg-rcf9" colspan="2">Memory Base</td>  </tr>  <tr>    <td class="tg-rcf9">0x9</td>    <td class="tg-rcf9">0x24</td>    <td class="tg-rcf9" colspan="2">Prefetchable Memory Limit</td>    <td class="tg-rcf9" colspan="2">Prefetchable Memory Base</td>  </tr>  <tr>    <td class="tg-rcf9">0xA</td>    <td class="tg-rcf9">0x28</td>    <td class="tg-rcf9" colspan="4">Prefetchable Base Upper 32 Bits</td>  </tr>  <tr>    <td class="tg-rcf9">0xB</td>    <td class="tg-rcf9">0x2C</td>    <td class="tg-rcf9" colspan="4">Prefetchable Limit Upper 32 Bits</td>  </tr>  <tr>    <td class="tg-rcf9">0xC</td>    <td class="tg-rcf9">0x30</td>    <td class="tg-rcf9" colspan="2">I/O Limit Upper 16 Bits</td>    <td class="tg-rcf9" colspan="2">I/O Base Upper 16 Bits</td>  </tr>  <tr>    <td class="tg-rcf9">0xD</td>    <td class="tg-rcf9">0x34</td>    <td class="tg-rcf9" colspan="3">Reserved</td>    <td class="tg-rcf9">Capability Pointer</td>  </tr>  <tr>    <td class="tg-rcf9">0xE</td>    <td class="tg-rcf9">0x38</td>    <td class="tg-rcf9" colspan="4">Expansion ROM base address</td>  </tr>  <tr>    <td class="tg-rcf9">0xF</td>    <td class="tg-rcf9">0x3C</td>    <td class="tg-rcf9" colspan="2">Bridge Control</td>    <td class="tg-rcf9">Interrupt PIN</td>    <td class="tg-rcf9">Interrupt Line</td>  </tr></tbody></table><h2 id="Header-Type-0x1"><a href="#Header-Type-0x1" class="headerlink" title="Header Type 0x1"></a>Header Type 0x1</h2><style type="text/css">.tg  {border-collapse:collapse;border-spacing:0;}.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;  overflow:hidden;padding:10px 5px;word-break:normal;}.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}.tg .tg-rcf9{background-color:#F9F9F9;text-align:left;vertical-align:middle}.tg .tg-tbl0{background-color:#F9F9F9;font-weight:bold;text-align:center;vertical-align:middle}</style><table class="tg"><thead>  <tr>    <th class="tg-tbl0">Register</th>    <th class="tg-tbl0">Offset</th>    <th class="tg-tbl0">Bits 31-24</th>    <th class="tg-tbl0">Bits 23-16</th>    <th class="tg-tbl0">Bits 15-8</th>    <th class="tg-tbl0">Bits 7-0</th>  </tr></thead><tbody>  <tr>    <td class="tg-rcf9">0x0</td>    <td class="tg-rcf9">0x0</td>    <td class="tg-rcf9" colspan="2">Device ID</td>    <td class="tg-rcf9" colspan="2">Vendor ID</td>  </tr>  <tr>    <td class="tg-rcf9">0x1</td>    <td class="tg-rcf9">0x4</td>    <td class="tg-rcf9" colspan="2">Status</td>    <td class="tg-rcf9" colspan="2">Command</td>  </tr>  <tr>    <td class="tg-rcf9">0x2</td>    <td class="tg-rcf9">0x8</td>    <td class="tg-rcf9">Class code</td>    <td class="tg-rcf9">Subclass</td>    <td class="tg-rcf9">Prog IF</td>    <td class="tg-rcf9">Revision ID</td>  </tr>  <tr>    <td class="tg-rcf9">0x3</td>    <td class="tg-rcf9">0xC</td>    <td class="tg-rcf9">BIST</td>    <td class="tg-rcf9">Header type</td>    <td class="tg-rcf9">Latency Timer</td>    <td class="tg-rcf9">Cache Line Size</td>  </tr>  <tr>    <td class="tg-rcf9">0x4</td>    <td class="tg-rcf9">0x10</td>    <td class="tg-rcf9" colspan="4">Base address #0 (BAR0)</td>  </tr>  <tr>    <td class="tg-rcf9">0x5</td>    <td class="tg-rcf9">0x14</td>    <td class="tg-rcf9" colspan="4">Base address #1 (BAR1)</td>  </tr>  <tr>    <td class="tg-rcf9">0x6</td>    <td class="tg-rcf9">0x18</td>    <td class="tg-rcf9">Secondary Latency Timer</td>    <td class="tg-rcf9">Subordinate Bus Number</td>    <td class="tg-rcf9">Secondary Bus Number</td>    <td class="tg-rcf9">Primary Bus Number</td>  </tr>  <tr>    <td class="tg-rcf9">0x7</td>    <td class="tg-rcf9">0x1C</td>    <td class="tg-rcf9" colspan="2">Secondary Status</td>    <td class="tg-rcf9">I/O Limit</td>    <td class="tg-rcf9">I/O Base</td>  </tr>  <tr>    <td class="tg-rcf9">0x8</td>    <td class="tg-rcf9">0x20</td>    <td class="tg-rcf9" colspan="2">Memory Limit</td>    <td class="tg-rcf9" colspan="2">Memory Base</td>  </tr>  <tr>    <td class="tg-rcf9">0x9</td>    <td class="tg-rcf9">0x24</td>    <td class="tg-rcf9" colspan="2">Prefetchable Memory Limit</td>    <td class="tg-rcf9" colspan="2">Prefetchable Memory Base</td>  </tr>  <tr>    <td class="tg-rcf9">0xA</td>    <td class="tg-rcf9">0x28</td>    <td class="tg-rcf9" colspan="4">Prefetchable Base Upper 32 Bits</td>  </tr>  <tr>    <td class="tg-rcf9">0xB</td>    <td class="tg-rcf9">0x2C</td>    <td class="tg-rcf9" colspan="4">Prefetchable Limit Upper 32 Bits</td>  </tr>  <tr>    <td class="tg-rcf9">0xC</td>    <td class="tg-rcf9">0x30</td>    <td class="tg-rcf9" colspan="2">I/O Limit Upper 16 Bits</td>    <td class="tg-rcf9" colspan="2">I/O Base Upper 16 Bits</td>  </tr>  <tr>    <td class="tg-rcf9">0xD</td>    <td class="tg-rcf9">0x34</td>    <td class="tg-rcf9" colspan="3">Reserved</td>    <td class="tg-rcf9">Capability Pointer</td>  </tr>  <tr>    <td class="tg-rcf9">0xE</td>    <td class="tg-rcf9">0x38</td>    <td class="tg-rcf9" colspan="4">Expansion ROM base address</td>  </tr>  <tr>    <td class="tg-rcf9">0xF</td>    <td class="tg-rcf9">0x3C</td>    <td class="tg-rcf9" colspan="2">Bridge Control</td>    <td class="tg-rcf9">Interrupt PIN</td>    <td class="tg-rcf9">Interrupt Line</td>  </tr></tbody></table><pre><code>BAR0Memory-mapped I/O (MMIO) registersBAR1Device memory windows.BAR2/3Complementary space of BAR1.BAR5I/O port.BAR6PCI ROM.</code></pre><h1 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h1><p>lspci</p><p><a href="https://diego.assencio.com/?index=649b7a71b35fc7ad41e03b6d0e825f07">Interpreting the output of lspci</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://insujang.github.io/2017-04-03/pci-express-i/o-system/">PCI Express I&#x2F;O System</a></li><li><a href="https://www.pcmag.com/encyclopedia/term/pci-express">PCI Express</a></li><li><a href="https://www.trentonsystems.com/blog/what-is-pcie">What is PCIe</a></li><li><a href="https://stackoverflow.com/questions/30190050/what-is-the-base-address-register-bar-in-pcie">What is the Base Address Register (BAR) in PCIe?</a></li><li><a href="https://utcc.utoronto.ca/~cks/space/blog/linux/PCIeLspciBusAddresses">PCIe bus addresses, lspci, and working out your PCIe bus topology</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PCIE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LDAP</title>
      <link href="/blog/2024/01/23/misc/LDAP/"/>
      <url>/blog/2024/01/23/misc/LDAP/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>LDAP, Lightweight Directory Access Protocol.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://support.bull.com/documentation/byproduct/infra/sw-extremcomp/sw-extremcomp-com/g">Bull Support</a></p>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LDAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Drive</title>
      <link href="/blog/2024/01/23/linux/Drive/"/>
      <url>/blog/2024/01/23/linux/Drive/</url>
      
        <content type="html"><![CDATA[<h1 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h1><p>本文介绍驱动。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul><li><p><code>lsmod</code> - Show status of modules in the Linux kernel.</p><p><code>lsmod</code> is a trivial program which nicely formats the contents of the <code>/proc/odules</code>,<br>showing what kernel modules are currently loaded.</p></li><li><p><code>dmesg</code> - examine or control the kernel ring buffer.</p><p>  The kernel buffer is a data structure used for keeping the log messages of the kernel and the kernel modules.<br>  It’s a ring buffer with a fixed size. Once it’s full, new messages overwrite the oldest messages.<br>  During boot, the kernel saves the messages into the kernel buffer.</p></li><li><p><code>lsscsi</code> - Uses information in sysfs (Linux kernel series 2.6 and later) to list SCSI devices (or hosts) currently attached to the system.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> c/cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git Usage</title>
      <link href="/blog/2024/01/23/personal_site/git-Usage/"/>
      <url>/blog/2024/01/23/personal_site/git-Usage/</url>
      
        <content type="html"><![CDATA[<h2 id="gitignore不生效"><a href="#gitignore不生效" class="headerlink" title="gitignore不生效"></a>gitignore不生效</h2><p>参考：<a href="https://www.python100.com/html/32VIQ026UL7U.html">链接</a>。</p><h2 id="file-mode-10064的含义"><a href="#file-mode-10064的含义" class="headerlink" title="file mode 10064的含义"></a>file mode 10064的含义</h2><p>参考<a href="https://blog.csdn.net/flyd1005/article/details/43824473">博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Environment Variables</title>
      <link href="/blog/2024/01/23/linux/Environment-Variables/"/>
      <url>/blog/2024/01/23/linux/Environment-Variables/</url>
      
        <content type="html"><![CDATA[<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><ul><li><p><code>environ</code> - 用户环境，一个全局变量。头文件 <code>&lt;unistd.h&gt;</code>。可以通过 <code>man environ</code> 查看手册。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;program environment: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span>** entry = environ; *entry; ++entry) &#123;</span><br><span class="line">        cout &lt;&lt; *entry &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>getenv</code> - 获取环境变量。头文件 <code>&lt;stdlib.h&gt;</code>。</p></li><li><p><code>setenv</code> - 设置环境变量。头文件 <code>stdlib.h</code>。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> c/cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> syntax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thread</title>
      <link href="/blog/2024/01/23/thread/Thread/"/>
      <url>/blog/2024/01/23/thread/Thread/</url>
      
        <content type="html"><![CDATA[<h2 id="sched-setaffinity"><a href="#sched-setaffinity" class="headerlink" title="sched_setaffinity"></a><code>sched_setaffinity</code></h2><p>参考<a href="https://man7.org/linux/man-pages/man2/sched_setaffinity.2.html">manpage</a>.</p><p>affinity 表示 CPU 亲缘性：即与哪个更亲，更愿意属于哪一个。</p><p><a href="https://blog.csdn.net/itjinks/article/details/40477779">https://blog.csdn.net/itjinks/article/details/40477779</a></p><p><a href="https://blog.csdn.net/itjinks/article/details/40477779">CPU affinity 是一种调度属性(scheduler property), 它可以将一个进程”绑定” 到一个或一组CPU上.</a></p>]]></content>
      
      
      <categories>
          
          <category> c/cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GNU Introducation</title>
      <link href="/blog/2024/01/23/misc/GNU-Introducation/"/>
      <url>/blog/2024/01/23/misc/GNU-Introducation/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://www.gnu.org/">GNU</a></li><li><a href="https://www.gnu.org/software/">GNU Software</a></li><li><a href="https://www.gnu.org/software/gnulib/">Gnulib</a></li><li><a href="https://www.gnu.org/software/make/">Gnumake</a></li></ul><h2 id="libc"><a href="#libc" class="headerlink" title="libc"></a>libc</h2><h3 id="Memory-Protection"><a href="#Memory-Protection" class="headerlink" title="Memory Protection"></a>Memory Protection</h3><p>参见：<a href="https://www.gnu.org/software/libc/manual/html_node/Memory-Protection.html">文档</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gnu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gdb 入门</title>
      <link href="/blog/2024/01/23/cplusplus/gdb%E5%85%A5%E9%97%A8/"/>
      <url>/blog/2024/01/23/cplusplus/gdb%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="gdb实现原理"><a href="#gdb实现原理" class="headerlink" title="gdb实现原理"></a>gdb实现原理</h2><p>参考<a href="https://www.zhihu.com/people/bi-an-60-46">链接</a>。</p><h2 id="gdb命令"><a href="#gdb命令" class="headerlink" title="gdb命令"></a>gdb命令</h2><ul><li><p><code>thread apply [threadno] [all] args</code> - 将命令传递给一个或多个线程，参见<a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/gdb/gdb/gdb_5.html">链接</a>。<br>比如，<code>thread apply all continue</code>表示将<code>continue</code>命令传递给所有线程，也就是让所有线程都继续运行。</p></li><li><p><code>rbreak</code> - Set a breakpoint for all functions matching REGEXP. 参考<a href="https://blog.csdn.net/zdl1016/article/details/8708077">链接</a>。</p><p>  e.g. <code>rbreak file.C:.*</code> - 给file.C的所有函数加上断点。</p></li><li><p><code>info</code></p><ul><li><code>info inferior</code> - 可以查看当前调试的进程的PID。另外一种方法是在gdb命令行中直接调用C函数：<code>print (int)getpid()</code>。参考：<a href="https://www.qiniu.com/qfans/qnso-36704270">链接</a>。</li><li><code>info source</code> - 当前调试的源文件路径。</li><li><code>info proc</code> - <a href="https://sourceware.org/gdb/onlinedocs/gdb/Process-Information.html">当前进程信息</a>。<ul><li><code>info proc files</code> - 当前进程打开的文件（和文件描述符）。</li></ul></li></ul></li><li><p><code>attach</code> - 连接到正在运行的进程。与<code>gdb -p</code>效果相同。</p></li><li><p><code>detach</code> - 取消连接的进程。</p></li><li><p><code>handle &lt;signal&gt; print pass nostop</code> - 捕获信号（比如<code>SIGSEGV</code>）并且忽略它。<code>handle &lt;signal nostop</code>。</p></li><li><p><code>set</code> - 修改变量的值，比如<code>set x=10</code>（或<code>set var x=10</code>）将变量<code>x</code>的值改为<code>10</code>。参考<a href="https://blog.csdn.net/yasi_xi/article/details/12784507">博客</a>。</p></li><li><p><code>show directories</code></p></li><li><p><code>print</code> - gdb默认设置打印字符串的长度为200；更改打印最大长度：<code>set print elements &lt;number-of-elements&gt;</code>，<code>0</code>表示unlimited.</p></li><li><p><code>ptype &lt;variable name&gt;</code> - 打印变量类型。</p></li><li><p><code>finish</code> - 从函数中返回，并打印函数返回值（即使函数的return语句很复杂，也可以获取返回值）。</p></li></ul><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>见<a href="https://www.irya.unam.mx/computo/sites/manuales/fce12/debugger/cl/commandref/gdb_mode/cmd_set_environm.htm">链接</a></p><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><p>添加断点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">break file:line_no</span><br></pre></td></tr></table></figure><p>查看断点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info break</span><br></pre></td></tr></table></figure><p>删除第2个断点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete 2</span><br></pre></td></tr></table></figure><h3 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h3><p>参考：<a href="http://c.biancheng.net/view/8255.html">博客</a>、<a href="https://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_28.html">文档</a>。</p><p><code>break ... if cond</code></p><h3 id="观察断点"><a href="#观察断点" class="headerlink" title="观察断点"></a>观察断点</h3><h3 id="捕捉断点"><a href="#捕捉断点" class="headerlink" title="捕捉断点"></a>捕捉断点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">try...catch</span><br></pre></td></tr></table></figure><h3 id="打印长度的限制"><a href="#打印长度的限制" class="headerlink" title="打印长度的限制"></a>打印长度的限制</h3><ul><li>Value sizes - 参考：<a href="https://sourceware.org/gdb/onlinedocs/gdb/Value-Sizes.html">文档</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> max-value-size bytes</span><br><span class="line"><span class="built_in">set</span> max-value-size unlimited</span><br></pre></td></tr></table></figure><ul><li><p>打印字符长度限制</p><p>gdb默认设置打印字符串的长度为200；更改打印最大长度：<code>set print elements</code></p></li></ul><h2 id="coredump"><a href="#coredump" class="headerlink" title="coredump"></a>coredump</h2><p>gdb命令：<code>gcore</code>。</p><p><a href="https://man7.org/linux/man-pages/man5/core.5.html">Reference</a></p><h2 id="WSL无法使用gdb"><a href="#WSL无法使用gdb" class="headerlink" title="WSL无法使用gdb"></a>WSL无法使用gdb</h2><p>WSL指Windows虚拟机。</p><p><a href="https://github.com/microsoft/WSL/issues/8516">解决方法</a>：</p><p>安装<a href="https://launchpad.net/~ubuntu-support-team/+archive/ubuntu/gdb">PPA的daily build版本</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ubuntu-support-team/gdb</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install gdb</span><br></pre></td></tr></table></figure><h2 id="gdb-attach-权限报错"><a href="#gdb-attach-权限报错" class="headerlink" title="gdb attach 权限报错"></a>gdb attach 权限报错</h2><p>This is due to kernel hardening in Linux; you can disable this behavior by <code>echo 0 &gt; /proc/sys/kernel/yama/ptrace_scope</code> or by modifying it in <code>/etc/sysctl.d/10-ptrace.conf</code>.</p><p><a href="https://stackoverflow.com/questions/19215177/how-to-solve-ptrace-operation-not-permitted-when-trying-to-attach-gdb-to-a-pro">How to solve “ptrace operation not permitted” when trying to attach GDB to a process?</a></p><h2 id="gdb-debug-forks"><a href="#gdb-debug-forks" class="headerlink" title="gdb debug forks"></a>gdb debug forks</h2><p><a href="https://www-zeuthen.desy.de/unix/unixguide/infohtml/gdb/Forks.html">Reference</a></p><p>By default, when a program forks, gdb will continue to debug the parent process and the child process will run unimpeded.</p><p>If you want to follow the child process instead of the parent process, use the command set <code>follow-fork-mode</code>.</p><p><code>set follow-fork-mode mode</code><br>Set the debugger response to a program call of <code>fork</code> or <code>vfork</code>. A call to fork or vfork creates a new process. The mode argument can be:<br><code>parent</code><br>The original process is debugged after a fork. The child process runs unimpeded. This is the default.<br><code>child</code><br>The new process is debugged after a fork. The parent process runs unimpeded.<br><code>ask</code><br>gdb 会提示让你选择 <code>parent</code> 还是 <code>child</code> 。</p><p><code>show follow-fork-mode</code><br>Display the current debugger response to a fork or vfork call.<br>On Linux, if you want to debug both the parent and child processes, use the command set detach-on-fork.</p><p><code>set detach-on-fork mode</code><br>Tells gdb whether to detach one of the processes after a fork, or retain debugger control over them both.<br><code>on</code><br>The child process (or parent process, depending on the value of follow-fork-mode) will be detached and allowed to run independently. This is the default.<br><code>off</code><br>Both processes will be held under the control of gdb. One process (child or parent, depending on the value of follow-fork-mode) is debugged as usual, while the other is held suspended.</p><p><code>show detach-on-fork</code><br>Show whether detach-on-fork mode is on&#x2F;off.</p><p>If you issue a run command to gdb after an exec call executes, the new target restarts. To restart the parent process, use the file command with the parent executable name as its argument. By default, after an exec call executes, gdb discards the symbols of the previous executable image. You can change this behaviour with the set follow-exec-mode command.</p><p>set follow-exec-mode mode<br>Set debugger response to a program call of exec. An exec call replaces the program image of a process.<br>follow-exec-mode can be:</p><p><code>new</code><br>gdb creates a new inferior and rebinds the process to this new inferior. The program the process was running before the exec call can be restarted afterwards by restarting the original inferior.<br>For example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info inferiors</span><br><span class="line">(gdb) info inferior</span><br><span class="line">  Id   Description   Executable</span><br><span class="line">* 1    &lt;null&gt;        prog1</span><br><span class="line">(gdb) run</span><br><span class="line">process 12020 is executing new program: prog2</span><br><span class="line">Program exited normally.</span><br><span class="line">(gdb) info inferiors</span><br><span class="line">  Id   Description   Executable</span><br><span class="line">* 2    &lt;null&gt;        prog2</span><br><span class="line">  1    &lt;null&gt;        prog1</span><br></pre></td></tr></table></figure><p><code>same</code><br>gdb keeps the process bound to the same inferior. The new executable image replaces the previous executable loaded in the inferior. Restarting the inferior after the exec call, with e.g., the run command, restarts the executable the process was running after the exec call. This is the default mode.<br>For example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info inferiors</span><br><span class="line">  Id   Description   Executable</span><br><span class="line">* 1    &lt;null&gt;        prog1</span><br><span class="line">(gdb) run</span><br><span class="line">process 12020 is executing new program: prog2</span><br><span class="line">Program exited normally.</span><br><span class="line">(gdb) info inferiors</span><br><span class="line">  Id   Description   Executable</span><br><span class="line">* 1    &lt;null&gt;        prog2</span><br></pre></td></tr></table></figure><h2 id="Setting-Catchpoints"><a href="#Setting-Catchpoints" class="headerlink" title="Setting Catchpoints"></a>Setting Catchpoints</h2><p><a href="https://www-zeuthen.desy.de/unix/unixguide/infohtml/gdb/Set-Catchpoints.html#Set-Catchpoints">Reference</a></p><h2 id="gdb-redirect-to-a-log-file"><a href="#gdb-redirect-to-a-log-file" class="headerlink" title="gdb redirect to a log file"></a>gdb redirect to a log file</h2><p>You need to enable logging:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set logging on</span><br><span class="line">Now GDB will log to ./gdb.txt. You can tell it which file to use:</span><br><span class="line"></span><br><span class="line">(gdb) set logging file my_god_object.log</span><br><span class="line">And you can examine the current logging configuration:</span><br><span class="line"></span><br><span class="line">(gdb) show logging</span><br></pre></td></tr></table></figure><p>记录输入的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set trace-commands on</span><br></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/5941158/gdb-print-to-file-instead-of-stdout">Refercence</a></p>]]></content>
      
      
      <categories>
          
          <category> c/cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcc 入门</title>
      <link href="/blog/2024/01/23/cplusplus/gcc%E5%85%A5%E9%97%A8/"/>
      <url>/blog/2024/01/23/cplusplus/gcc%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="递归处理顺序"><a href="#递归处理顺序" class="headerlink" title="递归处理顺序"></a>递归处理顺序</h2><p>gcc 的输入文件和库是从左往右处理的。也就是说，以下命令是错误的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -L. -la main.cc</span><br></pre></td></tr></table></figure><p>链接器处理到某个目标文件（如 main.cc 编译后的目标代码）时，如果遇到未解析的符号（比如 f() ），<br>它会从接下来的库中查找这些符号。因此顺序非常重要。</p><p>这里，-L. -la 选项在 main.cc 之前，链接器会首先尝试从 liba.so 中查找引用的符号，<br>但是，因为此时 main.cc 还未被处理，所以链接器还不知道有对 liba.so 中的函数 f() 的引用。<br>到了 main.cc ，链接器解析出引用，但它不会回头再去 liba.so 中查找，导致报错：”undefined reference to f()”。</p><p>正确的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.cc -L. -la</span><br></pre></td></tr></table></figure><p>注意：liba.so 的指定必须去掉 lib 和 .so ，也就是说不允许直接指定“库文件名”，而是只能指定“库名”。<br>如果想直接指定库文件名，那么应该把 liba.so 当成输入文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.cc ./liba.so</span><br></pre></td></tr></table></figure><h2 id="属性语法（Attribute-Syntax）"><a href="#属性语法（Attribute-Syntax）" class="headerlink" title="属性语法（Attribute Syntax）"></a>属性语法（Attribute Syntax）</h2><p>参考：<a href="https://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Attribute-Syntax.html#Attribute%20Syntax">官方文档</a>。</p><h3 id="函数属性（Function-Attributes）"><a href="#函数属性（Function-Attributes）" class="headerlink" title="函数属性（Function Attributes）"></a>函数属性（Function Attributes）</h3><p>参考：</p><ul><li><a href="https://stackoverflow.com/questions/11621043/how-should-i-properly-use-attribute-format-printf-x-y-inside-a-class">stackoverflow</a></li><li><a href="https://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Function-Attributes.html">gcc官方文档：Function Attributes</a></li></ul><p>属性列举：</p><ul><li><p><code>format (archetype, string-index, first-to-check)</code></p><p>  format 属性，指定函数采用 printf、scanf、strftime 或 strfmon 风格的参数，<br>  这些参数应根据格式字符串（format string）进行类型检查（type-checked）。<br>  类型检查发生在编译期。</p><p>  举例：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">my_printf</span> <span class="params">(<span class="type">void</span> *my_object, <span class="type">const</span> <span class="type">char</span> *my_format, ...)</span></span></span><br><span class="line"><span class="function">    __<span class="title">attribute__</span> <span class="params">((format (printf, <span class="number">2</span>, <span class="number">3</span>)))</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>archetype</code>决定format string应该如何解释。<br>可选为<code>printf</code>、<code>scanf</code>、<code>strftime</code>或<code>strfmon</code>（也可以使用<code>__printf__</code>、<code>__scanf__</code>、<code>__strftime__</code>或<code>__strfmon__</code>）。</li><li><code>string-index</code>指定哪个参数是format string（从1开始）。</li><li><code>first-to-check</code>指定format string对应的第一个参数的序号。<br>对于那些无法检查参数的函数（比如<code>vprintf</code>），该参数指定为<code>0</code>。在这种情况下，编译器仅检查format string的一致性。对于<code>strftime</code>格式，该参数必须为<code>0</code>。</li></ul></li></ul><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><ul><li><code>-save-temps</code>: 可以保留所有中间文件，例如预编译文件、汇编文件、目标文件等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> c/cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gcc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>core dump</title>
      <link href="/blog/2024/01/23/cplusplus/core-dump/"/>
      <url>/blog/2024/01/23/cplusplus/core-dump/</url>
      
        <content type="html"><![CDATA[<h2 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a><code>ulimit</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看配置</span></span><br><span class="line"><span class="built_in">ulimit</span> -a</span><br><span class="line"><span class="comment">#设置core file size</span></span><br><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br></pre></td></tr></table></figure><p><code>ulimit</code>只对当前终端有效。</p><p>以下两种方法对所有用户和终端有效：</p><ol><li>在<code>/etc/security/limits.conf</code>中设置（redhat衍生系linux）。</li><li>或注释掉<code>/etc/profile</code>中的这一行： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># No core files by default</span></span><br><span class="line"><span class="built_in">ulimit</span> -S -c 0 &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure></li></ol><h2 id="core-pattern"><a href="#core-pattern" class="headerlink" title="core_pattern"></a>core_pattern</h2><h3 id="core-pattern解释"><a href="#core-pattern解释" class="headerlink" title="core_pattern解释"></a>core_pattern解释</h3><p>见<a href="https://stackoverflow.com/questions/2065912/core-dumped-but-core-file-is-not-in-the-current-directory">链接</a>。</p><p>Read <a href="http://www.kernel.org/doc/Documentation/sysctl/kernel.txt">&#x2F;usr&#x2F;src&#x2F;linux&#x2F;Documentation&#x2F;sysctl&#x2F;kernel.txt</a>.</p><pre><code>core_pattern is used to specify a core dumpfile pattern name.</code></pre><p>在系统启动时，<a href="https://wiki.ubuntu.com/Apport">Apport</a>（crash reporting service）会生成配置文件<code>/proc/sys/kernel/core_pattern</code>。参考<a href="https://askubuntu.com/questions/420410/how-to-permanently-edit-the-core-pattern-file">这里</a>。</p><p>Apport uses <code>/proc/sys/kernel/core_pattern</code> to directly pipe the core dump into <code>apport</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /proc/sys/kernel/core_pattern</span><br><span class="line">|/usr/share/apport/apport %p %s %c</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><p>Note that even if <code>ulimit</code> is set to disabled core files (by specyfing a core file size of zero using <code>ulimit -c 0</code>), <code>apport</code> will still capture the crash.</p><p>For intercepting Python crashes it installs a <code>/etc/python*/sitecustomize.py</code> to call apport on unhandled exceptions.</p><p>其中，<code>/usr/share/apport/apport</code>是一个python脚本。</p><p>以下是core_pattern文件的参数说明（参考Linux Manual Page：<code>man core</code>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%c - Core file size soft resource limit of crashing process (since Linux 2.6.24).</span><br><span class="line">%p - insert pid into filename 添加pid</span><br><span class="line">%u - insert current uid into filename 添加当前uid</span><br><span class="line">%g - insert current gid into filename 添加当前gid</span><br><span class="line">%s - insert signal that caused the coredump into the filename 添加导致产生core的信号</span><br><span class="line">%t - insert UNIX time that the coredump occurred into filename 添加core文件生成时的unix时间</span><br><span class="line">%h - insert hostname where the coredump happened into filename 添加主机名</span><br><span class="line">%e - insert coredumping executable name into filename 添加命令名</span><br><span class="line"></span><br><span class="line">If the first character of the pattern is a &#x27;|&#x27;, the kernel will treat the rest of the pattern as a command to run. The core dump will be written to the standard input of that program instead of to a file.</span><br></pre></td></tr></table></figure><p>Apport的拦截组件默认是关闭的：</p><p>Apport itself is running at all times because it collects crash data for whoopsie (see <a href="https://wiki.ubuntu.com/ErrorTracker">ErrorTracker</a>). However, the crash interception component is still disabled. To enable it permanently, do:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/apport/crashdb.conf</span><br></pre></td></tr></table></figure><p>… and add a hash symbol # in the beginning of the following line:</p><pre><code>&#39;problem_types&#39;: [&#39;Bug&#39;, &#39;Package&#39;],</code></pre><p>To disable crash reporting just remove the hash symbol.</p><h3 id="设置core-pattern"><a href="#设置core-pattern" class="headerlink" title="设置core_pattern"></a>设置core_pattern</h3><p>见<a href="https://www.cnblogs.com/xiaodoujiaohome/p/6222895.html">链接</a>。</p><ol><li><p>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_uses_pid可以控制产生的core文件的文件名中是否添加pid作为扩展，如果添加则文件内容为1，否则为0；</p></li><li><p>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern可以设置格式化的core文件保存位置或文件名：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /proc/sys/kernel/core_pattern</span><br><span class="line">|/usr/share/apport/apport %p %s %c</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;/corefile/core-%e-%p-%t&quot;</span> &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure><p> 你可以用下列方式来完成：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看所有sysctl所有变量的值。</span></span><br><span class="line">sysctl -a</span><br><span class="line"><span class="comment">#设置变量kernel.core_pattern为如下值。</span></span><br><span class="line">sudo sysctl -w kernel.core_pattern=/tmp/core-%e.%p.%h.%t</span><br></pre></td></tr></table></figure><p> 这些操作一旦计算机重启，则会丢失，如果你想持久化这些操作，可以在 &#x2F;etc&#x2F;sysctl.conf文件中增加：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.core_pattern=/tmp/core%p</span><br></pre></td></tr></table></figure><p> 加好后，如果你想不重启看看效果的话，则用下面的命令：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p /etc/sysctl.conf</span><br></pre></td></tr></table></figure></li></ol><h2 id="相关命令行工具"><a href="#相关命令行工具" class="headerlink" title="相关命令行工具"></a>相关命令行工具</h2><p>参考资料：</p><p>Linux Manual Page: <a href="https://man7.org/linux/man-pages/man5/core.5.html"><code>man core</code></a></p><pre><code>SEE ALSO    bash(1),  coredumpctl(1),  gdb(1),  getrlimit(2), mmap(2), prctl(2), sigaction(2), elf(5), proc(5), pthreads(7), signal(7), systemd-coredump(8)</code></pre><h2 id="Segment-Fault排查"><a href="#Segment-Fault排查" class="headerlink" title="Segment Fault排查"></a>Segment Fault排查</h2><p>参考<a href="https://www.wtango.com/%E6%AE%B5%E9%94%99%E8%AF%AFsegmentation-fault%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/">链接</a>。</p><ol><li><p>dmesg + nm + addr2line</p><p>addr2line只能找出executable的行号；如果是shared libraries，请使用gdb。参考<a href="https://stackoverflow.com/questions/2549214/interpreting-segfault-messages">这里</a>。</p><p>dmesg输出的含义：</p><p>ip: 表示instruction pointer.</p></li><li><p>fprintf</p></li><li><p>gdb</p></li><li><p>signal(SIGSEGV,handler)</p></li><li><p>valgrind<br>参考：<br> <a href="https://jvns.ca/blog/2018/04/28/debugging-a-segfault-on-linux/">博客</a><br> <a href="https://valgrind.org/docs/manual/ms-manual.html">文档</a><br> <a href="https://courses.cs.washington.edu/courses/cse326/05wi/valgrind-doc/ms_main.html">可以使用PostScript查看图形化结果</a></p></li><li><p>heaptrack</p><p> 见<a href="https://github.com/KDE/heaptrack">github仓库</a></p></li><li><p>Jemalloc</p><p> 见<a href="https://jemalloc.net/">官网</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> c/cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理</title>
      <link href="/blog/2024/01/23/cplusplus/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
      <url>/blog/2024/01/23/cplusplus/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="编译主要步骤"><a href="#编译主要步骤" class="headerlink" title="编译主要步骤"></a>编译主要步骤</h2><p>参考<a href="https://blog.csdn.net/chen1415886044/article/details/104537547">博客</a></p><ol><li>预处理</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E test.c -o test.i</span><br></pre></td></tr></table></figure><ol start="2"><li><p>编译</p><p> 编译是将高级语言（例如C、C++、Jave等）代码转换成机器码的过程。<br> 编译可以分成多个阶段，包括词法分析、语法分析、语义分析、优化和代码生成。<br> 编译器首先将源代码转换一种中间表示（通常是汇编代码或字节码），然后再将其转换为目标机器的机器代码。<br> 经过编译的代码通常是二进制的，可以直接在目标机器上执行。</p></li></ol><p>先生成汇编代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S test.i -o test.s</span><br></pre></td></tr></table></figure><ol start="3"><li><p>汇编</p><p> 将汇编代码转成机器码。</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c test.s -o test.o</span><br></pre></td></tr></table></figure><ol start="4"><li><p>链接</p><p> 该目标文件与其他目标文件、库文件、启动文件等链接起来生成可执行文件。</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.o -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>Note: 可以使用 <code>-save-temps</code> 选项以保留编译过程中的所有中间文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -save-temps test.c</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h2 id="C-名称修饰"><a href="#C-名称修饰" class="headerlink" title="C++名称修饰"></a>C++名称修饰</h2><p><code>Name mangling (C++ only)</code>: 名称修饰，也称为名称重整、名称改编。参见链接<a href="https://www.ibm.com/docs/en/i/7.2?topic=linkage-name-mangling-c-only">1</a>、<a href="https://zh.wikipedia.org/wiki/%E5%90%8D%E5%AD%97%E4%BF%AE%E9%A5%B0">2</a>。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>参考：<code>man ld.so</code></p><pre><code>PATHLD_LIBRARY_PATHLD_PRELOAD</code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>参考：<code>man ld.so</code>, <code>man vdso</code>, <code>man elf</code>, <a href="https://linux.die.net/man/1/scanelf">scanelf</a></p><pre><code>ld(1), ldd(1), pldd(1), sprof(1), dlopen(3),getauxval(3), elf(5), capabilities(7),rtld-audit(7), ldconfig(8), sln(8), vdso(7), as(1), elfedit(1), gdb(1), nm(1),objcopy(1), objdump(1), patchelf(1), readelf(1), size(1), strings(1), strip(1),execve(2), dl_iterate_phdr(3), core(5), ld.so(8)</code></pre><p>ldconfig</p><pre><code>配置动态连接器（dynamic linker）的运行时绑定（dynamic bindings）。如果你刚刚安装好共享库，可能需要运行ldconfig：    sudo ldconfig通常需要超级用户来运行ldconfig，因为可能对需要某些root用户所有的目录和文件有写入权限。lddconfig 为从以下目录找到的共享库创建必要的 links 和 cache ：    command line指定的目录；    /etc/ld.so.conf文件中指定的目录；    受信任的目录: /lib, /lib64, /usr/lib, /usr/lib64 。该 cache 被运行时连接器（run-time linker） ld.so 或 ld-linux.so 使用。ldconfig 尝试基于该库连接的 C 库来推断 ELF 库（比如 libc5 或 libc6/glibc）的类型。一些现有的库没有包含足够的信息来推断其类型。因此， /etc/ld.so.conf 文件格式允许指定期望的类型。这只在这些 ELF 库不能被解决的情况下使用。ldconfig 期望的符号链接有某种特定的形式，比如：    libfoo.so -&gt; libfoo.so.1 -&gt; libfoo.so.1.12其中，中间的文件 libfoo.so.1 是库的 SONAME 。如果不遵循这种格式可能会导致升级后的兼容性问题。</code></pre><p>ldd</p><pre><code>描述：    ldd调用标准动态连接器（见 ld.so(8)），并且将环境变量 LD_TRACE_LODADED_OBJECTS 为 1 。    这会让动态连接器检查程序的动态依赖，并且寻找（根据 ld.so(8) 描述的规则）    和加载满足这些依赖的目标。对于每一条依赖，    ldd 显示匹配的目标的位置和其载入处的16进制地址。    （linux-vdso和ld-linux共享依赖是特殊的；见vdso(7)和ld.so(8)）安全性：    注意，在某些情况下，一些版本的ldd可能会尝试通过直接运行程序（可能导致程序中的ELF解释器    或程序本身的运行）来获取依赖信息。    因此，永远不要在不受信任的可执行文件上使用ldd，因为会导致随意代码的运行。更安全替代方法为：        $ objdump -p /path/to/program | grep NEEDED    注意，这种替代方法只会显示该可执行文件的直接依赖，而ldd显示该可执行文件的整个依赖树。解释ldd的输出:$ ldd -v libibsupport_real.so ./libibsupport_real.so: /usr/lib64/libibverbs.so.1: version `IBVERBS_1.8&#39; not found (required by ./libibsupport_real.so)    linux-vdso.so.1 =&gt;  (0x00002ad3e49e3000)    libibverbs.so.1 =&gt; /usr/lib64/libibverbs.so.1 (0x00002ad3e589b000)    ...    Version information:    ./libibsupport_real.so:            libgcc_s.so.1 (GCC_3.0) =&gt; /usr/lib64/libgcc_s.so.1            libibverbs.so.1 (IBVERBS_1.8) =&gt; not found            libibverbs.so.1 (IBVERBS_1.1) =&gt; /usr/lib64/libibverbs.so.1            ...    /usr/lib64/libnl-3.so.200:                libm.so.6 (GLIBC_2.2.5) =&gt; /usr/lib64/libm.so.6                ...在&quot;Version information&quot;中，&quot;libgcc_s.so.1 (GCC_3.0) =&gt; /usr/lib64/libgcc_s.so.1&quot;表示：    &quot;libgcc_s.so.1&quot;指定一个shared library的名字（libgcc_s.so.1是GCC runtime library的一部分），该shared library为&quot;./libibsupport_real.so&quot;所依赖；    &quot;(GCC_3.0)&quot;表明&quot;libgcc_s.so.1&quot;需要3.0版本及以上的GNU Compiler Collection (GCC)；    &quot;=&gt;&quot;指出满足依赖的shared library；    &quot;/usr/lib64/libgcc_s.so.1&quot;是满足要求的shared library的路径。</code></pre><p>  <a href="https://stackoverflow.com/questions/34428037/how-to-interpret-the-output-of-the-ldd-program">ldd output说明</a></p><p>sprof</p><p>参考：<a href="https://stackoverflow.com/questions/881074/how-to-use-sprof">stackoverflows</a></p><p>objdump</p><pre><code>[-p|--private-headers][-x|--all-headers]</code></pre><p>readelf</p><pre><code>[-d|--dynamic]</code></pre><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><pre><code>/lib/ld.so    Run-time linker/loader./etc/ld.so.conf    File containing a list of directories, one per line, in which to search for libraries./etc/ld.so.cache    File containing an ordered list of libraries found in the directories specified in /etc/ld.so.conf, as well as those found in the trusted directories.The trusted directories:    /lib    /lib64    /usr/lib    /usr/lib64</code></pre><p>ld.so</p><pre><code>名字    ld.so, ld-linux.so - 动态连接/加载器。简介    动态连接器可以被间接运行或直接运行。    间接运行：        运行某些动态连接程序或共享库。在这种情况下，不能向动态连接器传递命令行选项；并且在ELF情况下，存储在程序的.interp section中的动态连接器被执行。    直接运行：        /lib/ld-linux.so.* [OPTIONS] [PRAGRAM [ARGUMENTS]]描述    ld.so 和 ld-linux.so* 寻找和加载程序所需的共享对象（共享库），准备程序的运行，然后运行它。    如果在编译期没有向 ld(1) 指定 -static 选项，则Linux二进制文件需要动态连接（在运行时连接）。</code></pre><h3 id="SONAME"><a href="#SONAME" class="headerlink" title="SONAME"></a>SONAME</h3><p>参考：<code>man ldconfig</code><br>参考：<a href="https://en.wikipedia.org/wiki/Soname">SONAME Wiki</a></p><blockquote><p>GNU linker使用 -hname 或 -soname&#x3D;name 来指定该库的library name field。<br>在内部，linker会创建一个 DT_SONAME field并且用 name 来填充它。</p></blockquote><ol><li>指定SONAME：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Use ld:</span></span><br><span class="line">$ ld -shared -soname libexample.so.1 -o libexample.so.1.2.3 file1.o file2.o</span><br><span class="line"><span class="comment">#Use gcc or g++:</span></span><br><span class="line">$ gcc -shared -Wl,-soname,libexample.so.1 -o libexample.so.1.2.3 file1.o file2.o</span><br></pre></td></tr></table></figure><ol start="2"><li>安装时创建软链接：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s libexample.so.1.2.3 libexample.so.1</span><br><span class="line"><span class="built_in">ln</span> -s libexample.so.1 libexample.so</span><br></pre></td></tr></table></figure><ol start="3"><li>查看SONAME：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Use objdump</span></span><br><span class="line">$ objdump -p libexample.so.1.3 | grep SONAME</span><br><span class="line">  SONAME               libexample.so.1</span><br><span class="line"><span class="comment">#Use readelf</span></span><br><span class="line">$ readelf -d libexample.so | grep SONAME</span><br><span class="line"> 0x000000000000000e (SONAME)             Library soname: [libexample.so.1]</span><br></pre></td></tr></table></figure><h3 id="符号版本控制（symbol-versioning）"><a href="#符号版本控制（symbol-versioning）" class="headerlink" title="符号版本控制（symbol versioning）"></a>符号版本控制（symbol versioning）</h3><h4 id="定制函数版本："><a href="#定制函数版本：" class="headerlink" title="定制函数版本："></a>定制函数版本：</h4><ol><li>example.c中定义函数<code>my_printf</code>：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, format);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>version_script.txt中定义函数的版本为<code>VERSION_1</code>：</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VERSION_1 &#123;</span><br><span class="line"> global:</span><br><span class="line">   my_printf;</span><br><span class="line"> local:</span><br><span class="line">   *;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>编译时指定<code>version_script.txt</code>为version-script：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -Wl,--version-script=version_script.txt -o libexample.so example.o</span><br></pre></td></tr></table></figure><p>其中，<code>-Wl,</code>引出连接器选项。</p><ol start="4"><li>查看：<ol><li>使用<code>readelf -sW libexample.so</code>查看函数<code>my_printf</code>的版本号（”VERSION_1”）：</li></ol></li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Symbol table &#x27;.dynsym&#x27; contains 8 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTable</span><br><span class="line">     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND printf@GLIBC_2.2.5 (3)</span><br><span class="line">     3: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">     4: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable</span><br><span class="line">     5: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@GLIBC_2.2.5 (3)</span><br><span class="line">     6: 0000000000001105    39 FUNC    GLOBAL DEFAULT   13 my_printf@@VERSION_1</span><br><span class="line">     7: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  ABS VERSION_1</span><br></pre></td></tr></table></figure><ol start="2"><li>使用<code>objdump -T libexample.so</code></li><li>使用<code>nm -D libexample.so</code></li></ol><h4 id="实现同一个函数有多个版本"><a href="#实现同一个函数有多个版本" class="headerlink" title="实现同一个函数有多个版本"></a>实现同一个函数有多个版本</h4><ol><li>编写源代码</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;foo version 1.0\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo_v2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;foo_v2 version 2.0\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>编写版本脚本</li></ol><p>例如，version_script.map文件如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">VERS_1.0 &#123;</span><br><span class="line">    global: <span class="comment"># global表示符号全局可见；默认为局部（也可能通过local显式声明为局部），不会被导出</span></span><br><span class="line">        foo;</span><br><span class="line">&#125; VERS_1.1;</span><br><span class="line"></span><br><span class="line">VERS_1.1 &#123;</span><br><span class="line">    global:</span><br><span class="line">        foo_v2;</span><br><span class="line">    foo; <span class="comment"># VER_1.1继承自VER_1.0</span></span><br><span class="line">         <span class="comment"># 1. foo在VER_1.0中已经声明为了global，不需要再次声明global</span></span><br><span class="line">         <span class="comment"># 2. 当然可以再次显式声明为global，但是这不是推荐的做法</span></span><br><span class="line">         <span class="comment"># 3. 假设foo在VER_1.0中不是global，此处声明为global，</span></span><br><span class="line">         <span class="comment"># 会将原本不是global的foo变得全局可见</span></span><br><span class="line">         <span class="comment"># 4. 我们其实无需再次导出foo，因为除非我们显式隐藏（使用local关键字），foo就在</span></span><br><span class="line">         <span class="comment"># VER_1.1是和VER_1.0中的可见性保持一致</span></span><br><span class="line">         <span class="comment"># 5. 如果希望在VER_1.1中的foo与VER_1.0有不同的行为，那么需要再次将其导出</span></span><br><span class="line">&#125; VERS_2.0;</span><br><span class="line"></span><br><span class="line">VERS_2.0 &#123;</span><br><span class="line">    global:</span><br><span class="line">        foo_v2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>VER_1.1继承了VER_1.0的全部符号，同时VER_1.1可以增加或修改符号。</p><p>VER_1.0：第一个版本，导出foo符号；<br>VER_1.1：第二个版本，引入foo_v2，并重新导出foo；</p><h4 id="程序依赖的库版本"><a href="#程序依赖的库版本" class="headerlink" title="程序依赖的库版本"></a>程序依赖的库版本</h4><p>有如下简单代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: main.cc</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cc -o a.out</span><br></pre></td></tr></table></figure><p>查看符号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings a.out</span><br></pre></td></tr></table></figure><p>你会发现其中有一些版本信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">GLIBC_2.2.5</span><br><span class="line">GLIBC_2.34</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这是因为编译器和链接器生成库或可执行文件时，会根据系统上安装的glibc版本（因为库和可执行文件依赖glibc），<br>为库或可执行文件的函数符号附加上特定的版本信息。<br>为了保证向下兼容，glibc通过符号控制保留了多个版本的符号，支持老版本的软件能在较新的系统上运行。<br>例如，如果某个函数在glibc2.2.5中引入，它可以继续保留在之后的版本中，但符号标记为GLIBC_2.2.5。</p><h3 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h3><pre><code>ELF - Executable and Linking Format.ELF描述了normal executable files、relocatable object files、core files和shared objects的格式。</code></pre><p>参考：<code>man elf</code>, <a href="http://chuquan.me/2018/05/21/elf-introduce/">博客:elf介绍</a>。</p><h3 id="链接名"><a href="#链接名" class="headerlink" title="链接名"></a>链接名</h3><p>参考：<a href="https://littlebee1024.github.io/learning_book/booknotes/cxydzwxy/link/dynamic/#_16">程序员的自我修养</a>, <code>man ld</code></p><p>GCC的提供了不同的方法指定链接的共享库：</p><ul><li><p><code>l&lt;link_name&gt;</code>参数</p><p>  指定需要链接的共享库lib<link_name>.so</p></li><li><p><code>l:&lt;filename&gt;</code>参数</p><p>  通过文件名指定共享库，参考LD手册</p></li><li><p>全路径指定</p></li><li><p><code>Wl,-static</code>参数</p><p>  指定查找静态库，通过-Wl,-Bdynamic恢复成动态库查找</p></li></ul><h3 id="链接器选项"><a href="#链接器选项" class="headerlink" title="链接器选项"></a>链接器选项</h3><p>参考：<code>man ld</code></p><pre><code>ld - The GNU linker</code></pre><p>选项：</p><pre><code>-rpath=dir    添加一个目录到运行时库搜寻路径中。</code></pre><p>gcc通过 <code>-Wl</code> 前缀指定链接器选项，例如：</p><pre><code> gcc -Wl,--start-group foo.o bar.o -Wl,--end-group gcc -Wl,-rpath,&#39;$ORIGIN/../lib&#39;</code></pre><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ol><li><a href="https://unix.stackexchange.com/questions/120015/how-to-find-out-the-dynamic-libraries-executables-loads-when-run">How to find out the dynamic libraries are loaded when running an executable?</a></li></ol><p>Answer:</p><ul><li><code>ldd /path/to/program</code></li><li><code>objdump -p /path/to/program | grep NEEDED</code></li><li><code>lddtree</code> (from <code>pax-utils</code>) or <code>readelf -d /bin/ls | grep &#39;NEEDED&#39;</code></li><li><code>lsof -p PID | grep mem</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ pidof nginx</span><br><span class="line">6920 6919</span><br><span class="line"></span><br><span class="line">$ lsof -p 6919 | grep mem</span><br></pre></td></tr></table></figure><ul><li><code>strace -e trace=open myprogram</code></li></ul><p><code>ldd</code> and <code>lsof</code> show the libraries loaded either directly or at a given moment. They do not account for libraries loaded via <code>dlopen</code> (or discarded by <code>dlclose</code>). You can get a better picture of this using <code>strace</code>.</p><ul><li><code>pmap &lt;pid&gt; -p</code></li></ul><h3 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h3><ol><li><p>生成so时，链接器不会寻找其so依赖；executable会寻找so的依赖关系。换句话说，即使so生成过程不报错，但是executable生成时可能会报错。</p></li><li><p>生成so时，如果引用了其他 so ，只要 include 其他 so 的头文件，引用头文件中的符号时，就能编译通过。但是这样生成的 so 没有加上对应符号的依赖。<br>此时用 readelf -s 查看对应的符号，其 type 为 NOTYPE 。</p> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -sW libb.so</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.dynsym&#x27; contains 14 entries:</span><br><span class="line">Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line"> 6: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _Z1fv</span><br></pre></td></tr></table></figure></li><li><p>如果加上对应 -la 选项，就会从 liba.so 中寻找依赖的符号，如果找到，则添加进入 so 的依赖项中。当运行时则会加载 liba.so ，否则运行时不会加载。<br>用 readelf -s 查看对应的符号，其 type 不再时 NOTYPE ，而是 FUNC （如果该符号是一个函数的话）。</p> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _Z1fv</span><br></pre></td></tr></table></figure><p>如果没有找到符号，或者说 liba.so 中根本没有实现这个函数，那么其 type 依然是 NOTYPE ，此时也不会报错。<br>注意：如果只是 include 头文件，也就说只有某个符号的声明，并没有其定义或引用它，那么 so 中不会生成其信息。</p></li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="运行时错误：”-path-to-a-out-usr-lib-x86-64-linux-gnu-libstdc-so-6-version-GLIBCXX-3-4-30’-not-found-required-by-path-to-libxxx-so-”"><a href="#运行时错误：”-path-to-a-out-usr-lib-x86-64-linux-gnu-libstdc-so-6-version-GLIBCXX-3-4-30’-not-found-required-by-path-to-libxxx-so-”" class="headerlink" title="运行时错误：”&#x2F;path&#x2F;to&#x2F;a.out: &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libstdc++.so.6: version &#96;GLIBCXX_3.4.30’ not found (required by &#x2F;path&#x2F;to&#x2F;libxxx.so)”"></a>运行时错误：”&#x2F;path&#x2F;to&#x2F;a.out: &#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libstdc++.so.6: version &#96;GLIBCXX_3.4.30’ not found (required by &#x2F;path&#x2F;to&#x2F;libxxx.so)”</h3><p>解释：<code>libxxx.so</code> 引用了一个 <code>GLIBCXX_3.4.30</code> 的符号（可能是全局变量或函数），但是在系统的 <code>/usr/lib/x86_64-linux-gnu/libstdc++.so.6</code> 中没有这个版本的符号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ strings /usr/lib/x86_64-linux-gnu/libstdc++.so.6 | grep <span class="string">&#x27;GLIBCXX_3.4.&#x27;</span></span><br><span class="line">GLIBCXX_3.4.1</span><br><span class="line">...</span><br><span class="line">GLIBCXX_3.4.27</span><br><span class="line">GLIBCXX_3.4.28</span><br><span class="line"><span class="comment"># 没有 GLIBCXX_3.4.30</span></span><br><span class="line"></span><br><span class="line">$ strings /path/to/libxxx.so | grep <span class="string">&#x27;GLIBCXX_3.4.30&#x27;</span> | c++filt</span><br><span class="line">GLIBCXX_3.4.30</span><br><span class="line">std::condition_variable::<span class="built_in">wait</span>(std::unique_lock&lt;std::mutex&gt;&amp;)@@GLIBCXX_3.4.30</span><br></pre></td></tr></table></figure><p>这往往是因为原始的版本中，<code>libxxx.so</code> 是在一台机器中编译的，此时将该机器的 <code>GLIBCXX_3.4.30</code> 符号编译到其中了。但是运行时的机器是另一台，该机器上<br>不存在 <code>GLIBCXX_3.4.30</code> 版本，所以运行时报错。</p><p>或者，因为环境变量的配置错误，编译时和运行时引用的 <code>libstdc++.so.6</code> 不是同一个，这也会导致运行时可能找不到编译时的 <code>GLIBCXX_3.4.30</code> 版本。</p><p>可以在源文件中使用指定的版本（使用运行时的版本，比如 <code>GLIBCXX_3.4.11</code> ）：</p><ol><li>查找版本：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -T /usr/lib/x86_64-linux-gnu/libstdc++.so.6 | grep condition_variable | c++filt</span><br><span class="line">00000000000d52d0 g    DF .text  000000000000000c  GLIBCXX_3.4.30 std::condition_variable::<span class="built_in">wait</span>(std::unique_lock&lt;std::mutex&gt;&amp;)</span><br><span class="line">00000000000ac730 g    DF .text  000000000000001c (GLIBCXX_3.4.11) std::condition_variable::<span class="built_in">wait</span>(std::unique_lock&lt;std::mutex&gt;&amp;)</span><br><span class="line"></span><br><span class="line">$ objdump -T /usr/lib/x86_64-linux-gnu/libstdc++.so.6 | grep condition_variable</span><br><span class="line">00000000000d52d0 g    DF .text  000000000000000c  GLIBCXX_3.4.30 _ZNSt18condition_variable4waitERSt11unique_lockISt5mutexE</span><br><span class="line">00000000000ac730 g    DF .text  000000000000001c (GLIBCXX_3.4.11) _ZNSt18condition_variable4waitERSt11unique_lockISt5mutexE</span><br></pre></td></tr></table></figure><p>可以确定符号为 <code>_ZNSt18condition_variable4waitERSt11unique_lockISt5mutexE</code> ，版本为 <code>GLIBCXX_3.4.11</code> 。</p><p>在源文件中指定版本</p><figure class="highlight cpp"><figcaption><span>symver</span><a href="/blog/downloads/code/symver.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 指定特定版本的符号 START */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> {</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/** __cplusplus */</span></span></span><br><span class="line"></span><br><span class="line">__asm__ (<span class="string">&quot;.symver _ZNSt18condition_variable4waitERSt11unique_lockISt5mutexE, _ZNSt18condition_variable4waitERSt11unique_lockISt5mutexE@GLIBCXX_3.4.11&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/** __cplusplus */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 指定特定版本的符号 END */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后就可以使用 std::condition_variable::wait(std::unique_lock&lt;std::mutex&gt;&amp;) 就是 GLIBCXX_3.4.11 的</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"> </span><br><span class="line">std::mutex m;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::string data;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> processed = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// wait until main() sends data</span></span><br><span class="line">    <span class="function">std::unique_lock <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lk, []{ <span class="keyword">return</span> ready; });</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// after the wait, we own the lock</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker thread is processing data\n&quot;</span>;</span><br><span class="line">    data += <span class="string">&quot; after processing&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// send data back to main()</span></span><br><span class="line">    processed = <span class="literal">true</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker thread signals data processing completed\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// manual unlocking is done before notifying, to avoid waking up</span></span><br><span class="line">    <span class="comment">// the waiting thread only to block again (see notify_one for details)</span></span><br><span class="line">    lk.<span class="built_in">unlock</span>();</span><br><span class="line">    cv.<span class="built_in">notify_one</span>();</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(worker_thread)</span></span>;</span><br><span class="line"> </span><br><span class="line">    data = <span class="string">&quot;Example data&quot;</span>;</span><br><span class="line">    <span class="comment">// send data to the worker thread</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function">std::lock_guard <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;main() signals data ready for processing\n&quot;</span>;</span><br><span class="line">    }</span><br><span class="line">    cv.<span class="built_in">notify_one</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// wait for the worker</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function">std::unique_lock <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lk, []{ <span class="keyword">return</span> processed; });</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Back in main(), data = &quot;</span> &lt;&lt; data &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    worker.<span class="built_in">join</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ symver.cpp</span><br></pre></td></tr></table></figure><p>验证符号版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ strings a.out | grep condition_variable | c++filt</span><br><span class="line">std::condition_variable::<span class="built_in">wait</span>(std::unique_lock&lt;std::mutex&gt;&amp;)</span><br><span class="line">std::condition_variable::<span class="built_in">wait</span>(std::unique_lock&lt;std::mutex&gt;&amp;)@GLIBCXX_3.4.11</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c/cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> compile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 缺陷</title>
      <link href="/blog/2024/01/23/cplusplus/C++%E7%BC%BA%E9%99%B7/"/>
      <url>/blog/2024/01/23/cplusplus/C++%E7%BC%BA%E9%99%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="basic-string-M-construct-null-not-valid"><a href="#basic-string-M-construct-null-not-valid" class="headerlink" title="basic_string::_M_construct null not valid"></a>basic_string::_M_construct null not valid</h2><p>C++有一个缺陷，请看以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cpp defeat: basic_string::_M_construct null not valid</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;fun&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>(<span class="number">0</span>); <span class="comment">// Run-time error: basic_string::_M_construct null not valid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>fun(0)</code>的<code>0</code>会被视为<code>const char*</code>类型，也就是<code>nullptr</code>，所以在编译期可以通过。<br>但是运行期会触发<code>string</code>对象的构造错误“basic_string::_M_construct null not valid”。</p><p>隐蔽一点的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">get_a_string</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Attention: Alaways take care that a parameter to a string should not be NULL!</span></span><br><span class="line">    <span class="built_in">fun</span>(<span class="built_in">get_a_string</span>()); <span class="comment">// Run-time error: basic_string::_M_construct null not valid</span></span><br><span class="line">    <span class="comment">// Better code</span></span><br><span class="line">    <span class="type">char</span> * str = <span class="built_in">get_a_string</span>();</span><br><span class="line">    <span class="built_in">fun</span>(str != <span class="literal">NULL</span>? str : <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c/cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 调试工具</title>
      <link href="/blog/2024/01/23/cplusplus/C++%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
      <url>/blog/2024/01/23/cplusplus/C++%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="Unit-testing-framework"><a href="#Unit-testing-framework" class="headerlink" title="Unit testing framework"></a>Unit testing framework</h2><p><a href="https://cpptest.sourceforge.io/tutorial.html">CppTest</a></p><h2 id="Memory-check"><a href="#Memory-check" class="headerlink" title="Memory check"></a>Memory check</h2><p>valgrind<br>参考：<br>    <a href="https://jvns.ca/blog/2018/04/28/debugging-a-segfault-on-linux/">博客</a><br>    <a href="https://valgrind.org/docs/manual/ms-manual.html">文档</a><br>    <a href="https://courses.cs.washington.edu/courses/cse326/05wi/valgrind-doc/ms_main.html">可以使用PostScript查看图形化结果</a></p><p><a href="https://github.com/google/sanitizers/wiki/AddressSanitizer">AddressSanitizer</a></p><h2 id="Performance-analyzer"><a href="#Performance-analyzer" class="headerlink" title="Performance analyzer"></a>Performance analyzer</h2><p>Oracle Developer Studio：</p><p><a href="https://www.oracle.com/application-development/technologies/developerstudio-features.html#performance-analyzer-tab">Performance Analyzer</a>：<a href="https://docs.oracle.com/cd/E77782_01/html/E77798/afagg.html#OSSPAgrkam">手册</a></p><p><a href="https://www.oracle.com/application-development/technologies/developerstudio-features.html#thread-analyzer-tab">Thread Analyzer</a></p><p><a href="https://ftp.gnu.org/old-gnu/Manuals/gprof-2.9.1/html_mono/gprof.html">gprof</a>: <a href="https://blog.csdn.net/luronggui/article/details/118141262">使用方法</a></p><h3 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/bin/time -p <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>Or,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ time <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>其中（参考<a href="https://ostechnix.com/how-to-find-the-execution-time-of-a-command-or-process-in-linux/">链接</a>），</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">type</span> -a time</span><br><span class="line">time is a shell keyword</span><br><span class="line">time is /usr/bin/time</span><br></pre></td></tr></table></figure><h3 id="CPU时间"><a href="#CPU时间" class="headerlink" title="CPU时间"></a>CPU时间</h3><p>Function’s CPU time:</p><pre><code>* Inclusive time: total cpu time, include all functions it calls.* Exclusive time: only the time used by the function itself, exclusive all its children.Refer to [here](https://stackoverflow.com/questions/15760447/what-is-the-meaning-of-incl-cpu-time-excl-cpu-time-incl-real-cpu-time-excl-re/74426370).</code></pre><ol><li><p>Wall time: total time the process used, containing IO time.</p></li><li><p>CPU usage (CPU利用率) &#x3D; CPU time &#x2F; Wall time.</p></li><li><p>real&#x2F;user&#x2F;system time</p><ul><li><strong>Real</strong> is wall clock time - time from start to finish of the call. This is all elapsed time including time slices used by other processes and time the process spends blocked (for example if it is waiting for I&#x2F;O to complete).</li><li><strong>User</strong> is the amount of CPU time spent in user-mode code (outside the kernel) within the process. This is only actual CPU time used in executing the process. Other processes and time the process spends blocked do not count towards this figure.</li><li><strong>Sys</strong> is the amount of CPU time spent in the kernel within the process. This means executing CPU time spent in system calls within the kernel, as opposed to library code, which is still running in user-space. Like ‘user’, this is only CPU time used by the process. See below for a brief description of kernel mode (also known as ‘supervisor’ mode) and the system call mechanism.</li></ul><p> Refer to <a href="https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1">here</a>.</p></li><li><p>CPU 时间可能大于墙上时间：</p><p>这是因为 CPU 时间是所有 CPU 核的运行时间的累加和，墙上时间则是实际的时间。此时 CPU 利用率大于 100%. （这是自己的理解）</p></li><li><p>TODO: Is CPU time in flame graph sum of all the CPU time? Or is it the wall time when CPU works?</p></li></ol><h2 id="debug-tool"><a href="#debug-tool" class="headerlink" title="debug tool"></a>debug tool</h2><h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) breakpoint exit</span><br><span class="line">(gdb) breakpoint _exit</span><br><span class="line">(gdb) breakpoint atexit</span><br><span class="line">(gdb) breakpoint abort</span><br></pre></td></tr></table></figure><p>Enable coredump: <a href="https://medium.com/@sourabhedake/core-dumps-how-to-enable-them-73856a437711">how to do</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br></pre></td></tr></table></figure><p>Where is the core dumped file:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&#x27;kernel.core_pattern&#x27;</span> /etc/sysctl.conf</span><br></pre></td></tr></table></figure><h3 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h3><p>Example:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -f -o strace.log -tt -y -yy -e trace=desc,process,network</span><br></pre></td></tr></table></figure><p>Refer to <a href="https://gist.github.com/graste/929bb122c353bdd90c20">here</a></p><blockquote><p>-e trace&#x3D;ipc – communication between processes (IPC)<br>-e trace&#x3D;memory – memory syscalls<br>-e trace&#x3D;network – network syscalls<br>-e trace&#x3D;process – process calls (like fork, exec)<br>-e trace&#x3D;signal – process signal handling (like HUP, exit)<br>-e trace&#x3D;file – file related syscalls<br>-e trace&#x3D;desc – all file descriptor related system calls</p></blockquote><h3 id="DDT"><a href="#DDT" class="headerlink" title="DDT"></a>DDT</h3><p><a href="https://www.linaroforge.com/linaroDdt">DDT</a></p>]]></content>
      
      
      <categories>
          
          <category> c/cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mkdocs Configuration</title>
      <link href="/blog/2024/01/23/personal_site/Mkdocs-Configuration/"/>
      <url>/blog/2024/01/23/personal_site/Mkdocs-Configuration/</url>
      
        <content type="html"><![CDATA[<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><p><code>mkdocs.yml</code> 文件是 MkDocs 文档生成器的配置文件。</p><p>示例：<a href="https://github.com/squidfunk/mkdocs-material/blob/master/mkdocs.yml"><code>mkdocs.yml</code></a></p><h3 id="theme"><a href="#theme" class="headerlink" title="theme"></a>theme</h3><p>该文件中的 <code>theme</code> 部分用于指定用于生成文档的主题。</p><p>在这种情况下，使用的主题是 Material。 <code>name</code> 字段指定主题的名称，而 <code>custom_dir</code> 字段指定包含主题自定义内容的目录。 <code>features</code> 字段指定可以为主题启用的可选功能列表。</p><p>以下是在此配置文件中列出的可选功能：</p><ul><li><code>announce.dismiss</code>: 启用可关闭的公告横幅，显示在文档的每个页面顶部。</li><li><code>content.action.edit</code>: 在每个页面上启用“编辑”按钮，以便用户可以轻松编辑页面内容。</li><li><code>content.action.view</code>: 在每个页面上启用“查看源代码”按钮，以便用户可以查看页面的源代码。</li><li><code>content.code.annotate</code>: 启用代码注释功能，使用户可以添加注释以解释代码。</li><li><code>content.code.copy</code>: 启用代码复制功能，使用户可以轻松复制代码。</li><li><code>content.tooltips</code>: 启用工具提示功能，使用户可以在鼠标悬停时查看有关页面元素的信息。</li><li><code>navigation.footer</code>: 在每个页面上启用页脚导航栏。</li><li><code>navigation.indexes</code>: 启用索引导航栏，使用户可以轻松浏览文档中的索引。</li><li><code>navigation.sections</code>: 启用部分导航栏，使用户可以轻松浏览文档中的各个部分。</li><li><code>navigation.tabs</code>: 启用选项卡导航栏，使用户可以轻松浏览文档中的各个选项卡。</li><li><code>navigation.top</code>: 在每个页面上启用顶部导航栏。</li><li><code>navigation.tracking</code>: 启用导航跟踪功能，使用户可以跟踪他们在文档中的位置。</li><li><code>search.highlight</code>: 启用搜索结果高亮显示功能。</li><li><code>search.share</code>: 启用共享搜索结果功能，使用户可以轻松共享搜索结果。</li><li><code>search.suggest</code>: 启用搜索建议功能，使用户可以在输入搜索查询时获得建议。</li><li><code>toc.follow</code>: 启用目录跟随功能，使目录始终保持可见。</li></ul><p><code>palette</code> 字段指定了一个颜色方案，该方案包含以下内容：</p><ul><li><code>scheme</code>: 指定颜色方案的名称。</li><li><code>primary</code>: 指定主要颜色。</li><li><code>accent</code>: 指定强调颜色。</li><li><code>toggle</code>: 指定切换到暗模式时使用的图标和名称。</li></ul><p>第一个方案名为 default，其中主要颜色和强调颜色均为 indigo。切换到暗模式时，使用的图标为 material&#x2F;brightness-7，名称为“切换到暗模式”。</p><p>第二个方案名为 slate，其中主要颜色和强调颜色均为 indigo。切换到亮模式时，使用的图标为 material&#x2F;brightness-4，名称为“切换到亮模式”。</p><p>font 字段指定了用于文本和代码的字体。在此配置文件中，文本字体为 Roboto，代码字体为 Roboto Mono。 favicon 字段指定了网站图标的路径。 icon 字段指定了网站标志的路径。</p><p>favicon 和 icon 是网站的两个不同元素。</p><p>favicon 是网站的图标，通常显示在浏览器标签页上。它可以是一个小的图像文件，通常是 .ico 格式。在 mkdocs.yml 文件中，可以使用 favicon 字段来指定网站图标的路径。</p><p>icon 是网站的标志，通常显示在网站的标题栏或页眉中。它可以是一个图像文件，例如 .png 或 .jpg 文件。在 mkdocs.yml 文件中，可以使用 icon 字段来指定网站标志的路径。</p><h3 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h3><p>这里列出了三个插件：blog、search和minify。其中，blog插件用于支持博客功能，search插件用于支持搜索功能，而minify插件用于压缩HTML文件。在search插件中，separator参数指定了搜索时的分隔符，这里的分隔符包括空格、连字符、逗号、冒号、等号、感叹号、方括号、括号、引号、反引号和斜杠等。</p><h3 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h3><h4 id="analytics"><a href="#analytics" class="headerlink" title="analytics"></a>analytics</h4><p>analytics参数用于指定网站分析服务提供商和属性ID，例如衡量网站流量。</p><ul><li><a href="https://squidfunk.github.io/mkdocs-material/setup/setting-up-site-analytics/">Setting up site analytics</a></li><li><a href="https://analytics.google.com/analytics/academy/course/6">google免费课程</a></li></ul><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>See <a href="https://mkdocs.readthedocs.io/en/0.10/user-guide/configuration/">the doc</a>.</p><ol><li>Keep underscore in file name</li></ol><p>refer to: </p><ul><li><a href="https://pypi.org/project/mkdocs-gen-nav-plugin/">https://pypi.org/project/mkdocs-gen-nav-plugin/</a></li><li><a href="https://github.com/mkdocs/mkdocs/issues/2017">https://github.com/mkdocs/mkdocs/issues/2017</a></li><li><a href="https://github.com/squidfunk/mkdocs-material/discussions/5977">https://github.com/squidfunk/mkdocs-material/discussions/5977</a></li><li><a href="https://www.mkdocs.org/user-guide/writing-your-docs/#meta-data">https://www.mkdocs.org/user-guide/writing-your-docs/#meta-data</a></li><li>No help: <a href="https://www.mkdocs.org/user-guide/custom-themes/#pagetitle">https://www.mkdocs.org/user-guide/custom-themes/#pagetitle</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mkdocs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>File System</title>
      <link href="/blog/2024/01/23/linux/File-System/"/>
      <url>/blog/2024/01/23/linux/File-System/</url>
      
        <content type="html"><![CDATA[<h2 id="文件示例"><a href="#文件示例" class="headerlink" title="文件示例"></a>文件示例</h2><ul><li><p><code>/proc</code>: 查看手册 <code>man proc</code>。</p></li><li><p><code>/proc/self/exe</code>: 是指向当前进程的程序文件的软链接。</p></li><li><p><code>/proc/&lt;pid&gt;/exe</code>: 是指向进程<code>&lt;pid&gt;</code>的程序文件的软链接。</p><p>  <a href="https://docs.oracle.com/cd/E19455-01/805-7228/bkuptasks2-78540/index.html">How to Find File System Names</a></p></li><li><p><code>/proc/[pid]/status</code>：可查看进程的内存使用峰值等信息，关键字为”VmHWM”、”VmPeak”、”VmRSS”。</p></li><li><p><code>/proc/[pid]/stat</code>：get current memory</p></li><li><p><code>/dev/shm</code>:</p><p>  <a href="https://www.cyberciti.biz/tips/what-is-devshm-and-its-practical-usage.html">What Is &#x2F;dev&#x2F;shm And Its Practical Usage</a></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure><p>  Sample outputs:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Filesystem            Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/wks01-root</span><br><span class="line">                    444G   70G  351G  17% /</span><br><span class="line">tmpfs                 3.9G     0  3.9G   0% /lib/init/rw</span><br><span class="line">udev                  3.9G  332K  3.9G   1% /dev</span><br><span class="line">tmpfs                 3.9G  168K  3.9G   1% /dev/shm</span><br><span class="line">/dev/sda1             228M   32M  184M  15% /boot</span><br></pre></td></tr></table></figure></li></ul><h2 id="分区-Partition-和文件系统-Filesystem"><a href="#分区-Partition-和文件系统-Filesystem" class="headerlink" title="分区(Partition)和文件系统(Filesystem)"></a>分区(Partition)和文件系统(Filesystem)</h2><p>本小节内容来自 <a href="https://www.linuxfordevices.com/tutorials/linux/partitions-and-filesystems">参考链接</a> 。</p><h3 id="分区："><a href="#分区：" class="headerlink" title="分区："></a>分区：</h3><p>Linux上的分区指：存储设备中划分出来的一个片段，该片段与其他片段逻辑上分离，好比一个个独立的房间。</p><h3 id="分区表-partition-table-："><a href="#分区表-partition-table-：" class="headerlink" title="分区表(partition table)："></a>分区表(partition table)：</h3><p>分区表存储各个分区的元数据，比如起始位置、终止位置、大小等。<br>有两种主要的分区表类型，MBR(older)和GPT(newer)：</p><table><thead><tr><th>Partition tables</th><th>Maximum primary partitions</th><th>Maximum size for each partition</th><th>Security</th><th>Operating system Support</th></tr></thead><tbody><tr><td>Master Boot Record (MBR)</td><td>4</td><td>2TB</td><td>No such security features</td><td>Supports most modern OS</td></tr><tr><td>Guid Partition Table (GPT)</td><td>No such limit</td><td>18 Exabytes</td><td>CRC32 checksum mechanism to verify the integrity of files</td><td>Supports most modern OS</td></tr></tbody></table><p>从上表可以很明显地看出，为什么GPT更推荐。</p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>文件系统是我们在每个分区中管理数据的方式。它负责索引、存储、检索、命名文件和维护文件的元数据（文件所有者、大小、权限等）。存储在分区中。</p><p>一个文件保存在多个连续的 <strong>扇区（sector）</strong> 中，现代每个扇区大约为4096字节。<br>文件系统负责组织哪些扇区准备好使用了、一个文件必须存储在哪个扇区、哪个扇区存储了什么文件。<br>如果没有这种组织，就无法无法检索任何文件，因为系统无法得知文件的位置（block，块）。</p><p>主要的文件系统分类：</p><ul><li>FAT</li></ul><p>文件分配表（FAT，File Allocation Table）是Microsoft开发的第一个文件系统。<br>从1997发布之后，有多个版本，称为FAT12、FAT16、FAT32，连续地增加了最大支持文件大小（file size）和驱动器大小（drive size）。</p><p>FAT32允许的最大文件大小为4Gb。直至WindowsXP，FAT32是默认的文件系统，之后被NTFS取代。<br>虽然FAT非常基础，但是它支持几乎所有的设备和操作系统。</p><p><strong>注：</strong> 驱动器（<a href="https://www.computerhope.com/jargon/d/drive.htm">drive</a>），是一个能存储和读取非易失信息的位置，比如磁盘（disk）或光盘（disc）。</p><p>如下图，驱动器A:是一个软盘（<a href="https://www.computerhope.com/jargon/f/fdd.htm">floppy drive</a>），<br>驱动器C:是主硬盘（primary hard drivce），<br>驱动器D:和E:是分区，F:是<a href="https://www.computerhope.com/jargon/c/cdrom.htm">CD-ROM</a>。<br>CD-ROM常常是最后一个盘符（drive letter）。<br>在多数情况下，硬盘是C:驱动器，CD-ROM或其他光盘是D:驱动器。</p><p><img src="/blog/my-compu-drive.webp" alt="驱动器示例" title="驱动器示例图"></p><ul><li>NTFS</li></ul><p>新技术文件系统（New Technology File System，NTFS）是FAT的现代替代者。<br>除了支持高达16EB（大于170亿GB）的驱动器大小和256TB的单文件大小外，还支持日志系统（<a href="https://en.wikipedia.org/wiki/Journaling_file_system">journaling system</a>）。</p><ul><li>ext&#x2F;ext2&#x2F;ext3&#x2F;ext4</li></ul><p>Linux的扩展文件系统（extended file system）或ext于1992年发布。之后有了3次更新：</p><p>ext2引入了文件属性（文件权限），ext3引入了日志功能（<a href="https://en.wikipedia.org/wiki/Journaling_file_system">journaling</a>）。</p><p>ext4对ext2和ext3向后兼容，增加了存储限制和一些性能调整。<br>可以支持高达1EB的卷（volumn），单个文件可以达16TB。</p><p>ext4也引入了延迟内存分配的概念，即在文件被强制刷新到存储设备时才为其分配扇区。<br>这提高了CPU的性能并减少了坏的扇区。<br>今天几乎所有的现代Linux发行版都使用ext4作为默认的文件系统。</p><ul><li><p>ZFS</p></li><li><p>Btrfs</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>下图是一个分区和文件系统的层次结构示例：</p><p><img src="/blog/Example-of-partition-and-filesystem1-768x340.png.webp" alt="分区和文件系统的层次结构示例图" title="分区和文件系统的层次结构示例图"></p><p>我有一个500GB的SSD，分成3个分区（boot、home、root），使用GPT作为分区表。</p><p>我没有分出swap分区。所有的分区都跑在ext4文件系统上。</p><p>在一个双启动（dual-booted）存储设备（Windows和Linux）上，还有几个适用于Windwows的NTFS分区。</p><p>你可以使用以下命令在任意存储设备上查看分区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure><p>更多资源请访问：</p><ul><li><a href="https://www.linuxfordevices.com/tutorials/ubuntu/install-zfs-on-ubuntu">How to install ZFS on Ubuntu – A Setup and Usage Guide</a></li><li><a href="https://www.linuxfordevices.com/tutorials/linux/ext4-vs-btrfs-filesystem">Ext4 vs Btrfs Filesystems – Which one should you choose?</a></li><li><a href="https://www.linuxfordevices.com/tutorials/linux/btrfs-on-ubuntu">How to install and format a partition with the Btrfs on Ubuntu?</a></li><li><a href="https://ext4.wiki.kernel.org/index.php/Frequently_Asked_Questions">Frequently Asked Questions regarding ext4</a></li></ul><h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><p>挂载：使设备上的文件和目录可以通过文件系统访问的一个过程。见<a href="https://zh.wikipedia.org/zh-cn/%E6%8C%82%E8%BD%BD">维基百科</a>。</p><p>挂载点：A mount point is a location in the partition used as a root filesystem.</p><h2 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h2><h2 id="相关命令一览表"><a href="#相关命令一览表" class="headerlink" title="相关命令一览表"></a>相关命令一览表</h2><p>lsblk</p><pre><code>lsblk [options] [device...]list all avaivable or specified block devices.Reads the sysfs filesystem to gather information.</code></pre><p>df</p><pre><code>df [OPTION]... [FILE]...report file system disk space usage on which each FILE resides.df -T 打印文件系统的类型。</code></pre><p>du</p><pre><code>du [OPTION]... [FILE]...estimate file space usage.</code></pre><p>quota</p><pre><code>quota -s -u user...display users&#39; disk usage and limits.quota reports the quotas of all the filesystems listed in /etc/mtab.For filesystems that are NFS-mounted a call to the rpc.rquotad on the server machine is performed to get the information.-s, --human-readable</code></pre><p>repquota</p><pre><code>prints a summary of disc usage and quotas for the specified file system.</code></pre><p>mount</p><p>lsof - list open files</p><pre><code>https://unix.stackexchange.com/questions/11238/how-to-get-over-device-or-resource-busy</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> filesystem </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introducation to RPC</title>
      <link href="/blog/2024/01/21/net/RPC/"/>
      <url>/blog/2024/01/21/net/RPC/</url>
      
        <content type="html"><![CDATA[<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><ul><li><a href="https://www.ibm.com/docs/ssw_ibm_i_72/rzahp/rzahppdf.pdf">libtirpc(Transport Independent RPC)</a></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dead Lock</title>
      <link href="/blog/2024/01/15/thread/Dead-Lock/"/>
      <url>/blog/2024/01/15/thread/Dead-Lock/</url>
      
        <content type="html"><![CDATA[<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://cloud.tencent.com/developer/article/1161103">关于线程死锁，活锁和饥饿问题</a></p>]]></content>
      
      
      <categories>
          
          <category> c/cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可重入</title>
      <link href="/blog/2024/01/14/misc/%E5%8F%AF%E9%87%8D%E5%85%A5/"/>
      <url>/blog/2024/01/14/misc/%E5%8F%AF%E9%87%8D%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>可重入函数</strong>：如果一个函数在执行过程中被中断服务程序打断，执行中断服务程序之后恢复执行，还能不妨碍之前的执行，就称该函数是<strong>可重入的</strong>。</p><p>可重入函数一般用于<strong>硬件中断处理</strong>或<strong>递归</strong>等应用程序中。</p><p><strong>可重入程序&#x2F;可重入子例程</strong>：在多个处理器上能被安全地多次并发调用。</p><p><strong>与线程安全的区别</strong>：可重入函数的概念在多任务操作系统出现之前就存在了，所以该概念仅仅针对的是单线程执行过程。<br>一个函数可以是线程安全但非可重入的，例如，该函数每次都使用互斥量来包裹。但是，如果该函数用于中断服务程序，那么，它可能在等待第一次执行过程释放互斥量时陷入饥饿。<strong>TODO：陷入饥饿为什么就不是可重入了？</strong></p><p>要实现可重入性，函数通常需要满足以下条件：</p><ul><li>不使用静态或全局变量：这些变量在多次调用之间共享，可能导致数据竞争。</li><li>不依赖于不可重入的函数：例如，标准库中的某些函数可能不是可重入的。</li><li>不使用动态内存分配：动态内存分配可能会导致竞争条件。</li><li>不使用信号处理：信号处理可能会中断函数的执行。</li></ul><p>可重入性在多线程编程和中断处理程序中尤为重要，因为它确保了函数在并发环境下的安全性。</p><h3 id="可重入-VS-线程安全"><a href="#可重入-VS-线程安全" class="headerlink" title="可重入 VS 线程安全"></a>可重入 VS 线程安全</h3><p>可重入性和线程安全虽然都涉及到并发编程，但它们有不同的侧重点：</p><p>可重入性：</p><p>定义：一个函数可以在被中断后安全地再次调用，而不会影响其执行结果。<br>条件：不使用静态或全局变量、不依赖不可重入的函数、不使用动态内存分配、不使用信号处理。<br>应用场景：主要用于中断处理程序和嵌入式系统。<br>线程安全：</p><p>定义：一个函数或代码块在多线程环境下可以安全地并发执行，而不会导致竞争条件或数据不一致。<br>条件：通常需要使用同步机制（如互斥锁、信号量）来保护共享资源。<br>应用场景：主要用于多线程编程。<br>总结来说，可重入性关注的是函数在被中断后能否安全地再次调用，而线程安全关注的是在多线程环境下能否安全地并发执行。可重入函数不一定是线程安全的，线程安全的函数也不一定是可重入的。</p><ol><li>可重入函数不一定是线程安全的</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reentrantFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> localCounter = counter;</span><br><span class="line">    localCounter++;</span><br><span class="line">    counter = localCounter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">reentrantFunction</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Counter: %d\n&quot;</span>, counter);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：</p><p>reentrantFunction 是可重入的，因为它满足以下条件：</p><p>不使用静态或全局变量：虽然 counter 是一个全局变量，但 reentrantFunction 中的操作都是基于局部变量 localCounter，并且没有依赖于函数外部的状态。<br>不依赖不可重入的函数：reentrantFunction 中没有调用任何不可重入的函数。<br>不使用动态内存分配：函数中没有使用 malloc 或其他动态内存分配函数。<br>不使用信号处理：函数中没有涉及信号处理。<br>因此，reentrantFunction 可以在被中断后安全地再次调用，而不会影响其执行结果。</p><p>然而，正因为它使用了全局变量 counter，在多线程环境下可能会导致竞争条件，所以它不是线程安全的。</p><ol start="2"><li>线程安全的函数不一定是可重入的</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">threadSafeFunction</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;lock);</span><br><span class="line">    counter++;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread1, thread2;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;thread1, <span class="literal">NULL</span>, threadSafeFunction, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;thread2, <span class="literal">NULL</span>, threadSafeFunction, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(thread1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(thread2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Counter: %d\n&quot;</span>, counter);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：</p><p>这个函数 threadSafeFunction 是线程安全的，因为它使用了互斥锁来保护对 counter 的访问。<br>然而，它不是可重入的，因为它使用了互斥锁，互斥锁在中断处理程序中可能会导致死锁：</p><p>互斥锁的使用：互斥锁用于确保线程安全，但它们在中断处理程序中可能会导致死锁。如果一个线程在持有锁时被中断，然后中断处理程序尝试再次调用该函数并试图获取同一个锁，就会发生死锁。</p><p>依赖于锁的状态：函数的执行依赖于锁的状态。如果锁已经被其他线程持有，函数就无法继续执行，必须等待锁释放。这种依赖性使得函数在中断后无法安全地再次调用。</p><p>不可重入的行为：由于锁的存在，函数在中断后重新进入时可能无法正确处理锁的状态，从而导致不可预期的行为。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.geeksforgeeks.org/reentrant-function/">Reentrant Function</a></li><li><a href="https://en.wikipedia.org/wiki/Reentrancy_(computing)">Reentrancy</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> c/cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> concepts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Network discovery</title>
      <link href="/blog/2024/01/09/net/%E7%BD%91%E7%BB%9C%E5%8F%91%E7%8E%B0/"/>
      <url>/blog/2024/01/09/net/%E7%BD%91%E7%BB%9C%E5%8F%91%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Get-IP-from-the-host-name"><a href="#Get-IP-from-the-host-name" class="headerlink" title="Get IP from the host name"></a>Get IP from the host name</h2><p>Key function: <code>getaddrinfo</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _POSIX_C_SOURCE 200112L</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">addrinfo</span> hints;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;hints, <span class="keyword">sizeof</span> hints);</span><br><span class="line">    <span class="comment">// hints.ai_family = AF_INET;</span></span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">    hints.ai_protocol = IPPROTO_TCP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">addrinfo</span> *res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// The following 3 hostnames are legal.</span></span><br><span class="line">    <span class="type">int</span> rc = <span class="built_in">getaddrinfo</span>(<span class="string">&quot;www.baidu.com&quot;</span>, <span class="literal">NULL</span>, &amp;hints, &amp;res);</span><br><span class="line">    <span class="comment">// int rc = getaddrinfo(&quot;localhost&quot;, NULL, &amp;hints, &amp;res);</span></span><br><span class="line">    <span class="comment">// int rc = getaddrinfo(&quot;PC-XXX&quot;, NULL, &amp;hints, &amp;res); // PC-XXX is a hostname</span></span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;getaddrinfo failed&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> addrinfo* res_i = res; res_i != <span class="literal">NULL</span>; res_i = res_i-&gt;ai_next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res_i-&gt;ai_addr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res_i-&gt;ai_addr-&gt;sa_family == AF_INET) &#123;</span><br><span class="line">                <span class="type">char</span> ip4[INET_ADDRSTRLEN];</span><br><span class="line">                <span class="built_in">inet_ntop</span>(AF_INET, &amp;(((<span class="keyword">struct</span> sockaddr_in*)(res_i-&gt;ai_addr))-&gt;sin_addr), ip4, INET_ADDRSTRLEN);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;IP: %s\n&quot;</span>, ip4);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">char</span> ip6[INET6_ADDRSTRLEN];</span><br><span class="line">                <span class="built_in">inet_ntop</span>(AF_INET6, &amp;(((<span class="keyword">struct</span> sockaddr_in6*)(res_i-&gt;ai_addr))-&gt;sin6_addr), ip6, INET_ADDRSTRLEN);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;IP: %s\n&quot;</span>, ip6);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcp/ip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 预处理</title>
      <link href="/blog/2024/01/07/cplusplus/C++%E9%A2%84%E5%A4%84%E7%90%86/"/>
      <url>/blog/2024/01/07/cplusplus/C++%E9%A2%84%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h2><p><code>#if defined(__linux)</code><br><code>#ifdef LINUX2</code></p><h2 id="C标准预定义宏"><a href="#C标准预定义宏" class="headerlink" title="C标准预定义宏"></a>C标准预定义宏</h2><ul><li><code>__LINE__</code></li><li><code>__func__</code></li><li><code>__FILE__</code></li><li><code>NDEBUG</code>：参考<a href="https://stackoverflow.com/questions/2290509/debug-vs-ndebug">_DEBUG和NDEBUG的区别</a>，其中，<code>_DEBUG</code>是Visual Studio定义的，<code>NDEBUG</code>是C&#x2F;C++标准。</li></ul><h2 id="GNU-C预定义宏"><a href="#GNU-C预定义宏" class="headerlink" title="GNU C预定义宏"></a>GNU C预定义宏</h2><p><a href="https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html">官方文档</a></p><ul><li><p><code>__COUNTER__</code>: 扩展为从<code>0</code>开始的连续整数值，每次在源码中出现，则加<code>1</code>。不同源文件的<code>__COUNTER__</code>互不影响。</p><p>可以用来生成唯一的命名。<br>参考<a href="https://stackoverflow.com/questions/652815/has-anyone-ever-had-a-use-for-the-counter-pre-processor-macro">链接</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONCAT_IMPL(x,y) x##y</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONCAT(x,y) CONCAT_IMPL(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VAR(name) CONCAT(name,__COUNTER__)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">VAR</span><span class="params">(myvar)</span></span>; <span class="comment">// 展开为 int myvar0;</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">VAR</span><span class="params">(myvar)</span></span>; <span class="comment">// 展开为 int myvar1;</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">VAR</span><span class="params">(myvar)</span></span>; <span class="comment">// 展开为 int myvar2;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>program_invocation_name</code>：参考<a href="https://man7.org/linux/man-pages/man3/program_invocation_name.3.html">man page</a></p></li><li></li></ul><h2 id="pragma"><a href="#pragma" class="headerlink" title="#pragma"></a>#pragma</h2><h3 id="pragma-weak"><a href="#pragma-weak" class="headerlink" title="#pragma weak"></a>#pragma weak</h3><h4 id="Synopsis"><a href="#Synopsis" class="headerlink" title="Synopsis"></a>Synopsis</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> weak function-name1 [= function-name2]</span></span><br></pre></td></tr></table></figure><p><code>#pragma weak</code> means that even if the definition of the symbol is not found, no error will be reported.</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// It is not an error for symbol to never be defined at all.</span></span><br><span class="line"><span class="comment">// Without this line, the address of &quot;foo&quot; will always evaluate to &quot;true&quot;,</span></span><br><span class="line"><span class="comment">// so the linker will report an &quot;undefined reference to &#x27;foo&#x27;&quot; error.</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> weak foo</span></span><br><span class="line"><span class="comment">// The declaration is needed.</span></span><br><span class="line"><span class="comment">/* extern */</span> <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (foo)</span><br><span class="line">        <span class="built_in">foo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Reference: <a href="https://alberand.com/weak-directive.html">1</a>、<a href="https://gcc.gnu.org/onlinedocs/gcc-4.5.4/gcc/Weak-Pragmas.html">2</a>、<a href="https://docs.oracle.com/cd/E19059-01/wrkshp50/805-4955/auto6/index.html">3</a></p>]]></content>
      
      
      <categories>
          
          <category> c/cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> syntax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建个人网站</title>
      <link href="/blog/2024/01/03/personal_site/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"/>
      <url>/blog/2024/01/03/personal_site/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h2 id="Host-site"><a href="#Host-site" class="headerlink" title="Host site"></a>Host site</h2><p>有两个托管个人站点的网站：<code>Github pages</code>和<code>reathedocs</code>.</p><h3 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h3><p>使用<a href="https://docs.github.com/en/pages">github pages</a>可以搭建个人主页。</p><p>github pages简介：<a href="https://docs.github.com/en/pages/getting-started-with-github-pages/about-github-pages">官方链接</a>。</p><p>github pages使用了<a href="https://en.wikipedia.org/wiki/CNAME_record">CNAME record</a>技术，参考：<a href="https://www.zhihu.com/question/39301250">链接1</a>、<a href="https://www.zhihu.com/question/26609475">链接2</a>、<a href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/about-custom-domains-and-github-pages#using-a-subdomain-for-your-github-pages-site">Custom domains in Github Pages</a>。</p><p>注：<a href="https://readthedocs.org/">Read the Docs</a>也是一个很好的搭建个人主页的网站。</p><h4 id="Github-Pages-站点类型"><a href="#Github-Pages-站点类型" class="headerlink" title="Github Pages 站点类型"></a>Github Pages 站点类型</h4><p>有3种类型的 Github Pages 站点（sites）：project, user 和 organization 。</p><p>Project sites 连接到 github 上特定 project ，比如 Javascript library 或 recipe collection。user 或 organization sites 连接到 github.com 的特定账户。</p><p>发布 user site ，你必须创建一个你的个人账户下的一个名为 <code>&lt;username&gt;.github.io</code> 的 repository 。发布 organization site ，你必须创建一个组织所有的名为 <code>&lt;organization&gt;.github.io</code> 的 repository 。除非你使用 custom domain ，否则 user 和 organization sites 将位于 <code>http(s)://&lt;username&gt;.github.io</code> 或 <code>http(s)://&lt;organization&gt;.github.io</code> 。</p><p>project site 的源文件存储在作为 project 的相同的 repository 中。除非使用 custom domain ， 否则 project sites 将位于 <code>http(s)://&lt;username&gt;.github.io/&lt;repository&gt;</code> 或 <code>http(s)://&lt;organization&gt;.github.io/&lt;repository&gt;</code> 。</p><p>有关如何自定义影响您网站的域名的更多信息，参见”<a href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/about-custom-domains-and-github-pages">About custom domains and GitHub Pages</a>“。</p><p>每个 github 账户允许创建 1 个 user 或 organization 站点。无论是被组织还是个人所有，project 站点的个数不限制。</p><h4 id="GitHub-Pages-访问方法"><a href="#GitHub-Pages-访问方法" class="headerlink" title="GitHub Pages 访问方法"></a>GitHub Pages 访问方法</h4><p>参考<a href="https://docs.github.com/en/pages/getting-started-with-github-pages/creating-a-github-pages-site#next-steps">官方文档</a>。</p><p>例如，你的project站点配置的发布源是<code>gh-pages</code>分支，然后在<code>gh-pages</code>分支上创建了一个<code>about/contact-us.md</code>文件，你将可以在<code>https://&lt;user&gt;.github.io/&lt;repository&gt;/about/contact-us.html</code>访问它。</p><p>你也可以使用<code>Jekyll</code>等静态站点生成器来给你的github page配置一个主题。</p><h4 id="站点发布常见问题的解决方法"><a href="#站点发布常见问题的解决方法" class="headerlink" title="站点发布常见问题的解决方法"></a>站点发布常见问题的解决方法</h4><ul><li><a href="https://stackoverflow.com/questions/72851548/permission-denied-to-github-actionsbot">Permission denied to github-actions[bot]</a></li></ul><h4 id="Github-workflows"><a href="#Github-workflows" class="headerlink" title="Github workflows"></a>Github workflows</h4><p>参考<a href="https://docs.github.com/zh/actions/using-workflows/workflow-syntax-for-github-actions">官方文档</a>。</p><h4 id="Github个人访问令牌"><a href="#Github个人访问令牌" class="headerlink" title="Github个人访问令牌"></a>Github个人访问令牌</h4><p><a href="https://docs.github.com/zh/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens">Github个人访问令牌</a></p><h3 id="readthedocs"><a href="#readthedocs" class="headerlink" title="readthedocs"></a>readthedocs</h3><p>Similar to the github pages.</p><p><a href="https://docs.readthedocs.io/en/stable/tutorial/">Tutorial</a></p><h2 id="配置前准备"><a href="#配置前准备" class="headerlink" title="配置前准备"></a>配置前准备</h2><h3 id="Markdown编辑器"><a href="#Markdown编辑器" class="headerlink" title="Markdown编辑器"></a>Markdown编辑器</h3><p>推荐的<a href="https://www.zhihu.com/tardis/zm/art/103348449?source_id=1003">markdown编辑器</a>：</p><ul><li>VSCode：免费。VSCode原生支持Markdown，安装一些插件可以帮助更快地编写markdown文件。</li><li>Typora：现在已经开始收费。</li></ul><p>VSCode markdown插件：</p><ul><li>Mardown All in One: 提供快捷键，帮助更快的编写markdown文件。</li><li>Markdown+Math：提供数学公式支持。</li><li>Markdown Preview Enhanced: 将原生markdown预览的黑色背景改成白色。</li><li>Markdown Preview Github Styling：提供Github风格的预览。</li></ul><p><a href="https://www.tablesgenerator.com/markdown_tables">在线表格生成器</a>：可以生成Markdown、Text、HTML、LaTex、MediaWiki格式的表格。</p><h3 id="轻量级虚拟机WSL"><a href="#轻量级虚拟机WSL" class="headerlink" title="轻量级虚拟机WSL"></a>轻量级虚拟机WSL</h3><p>WSL，<a href="https://learn.microsoft.com/en-us/windows/wsl/install">Windows Subsystem for Linux</a>，是Windows提供的轻量级Linux虚拟机。</p><p>安装教程：见<a href="https://zhuanlan.zhihu.com/p/170210673">链接</a>。</p><h4 id="WSL默认没有启用systemctl："><a href="#WSL默认没有启用systemctl：" class="headerlink" title="WSL默认没有启用systemctl："></a>WSL默认没有启用systemctl：</h4><p>启用systemctl的方法：<a href="https://askubuntu.com/questions/1379425/system-has-not-been-booted-with-systemd-as-init-system-pid-1-cant-operate">链接</a>。</p><p>替代方法：不需要启动systemctl，因为会比较占用资源，启动也会变慢。可以使用service命令替代。</p><h4 id="WSL默认没有安装openssl-server："><a href="#WSL默认没有安装openssl-server：" class="headerlink" title="WSL默认没有安装openssl-server："></a>WSL默认没有安装openssl-server：</h4><p>使用ssh连接到服务器时，需要服务器运行着sshd程序，否则连接不上，会出现”<a href="https://www.makeuseof.com/fix-ssh-connection-refused-error-linux/">Connection refused</a>“错误。</p><p>参考<a href="https://askubuntu.com/questions/1339980/enable-ssh-in-wsl-system">链接</a>。</p><p>查看openssh-server有没有安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg --list | grep ssh</span><br></pre></td></tr></table></figure><p>注：如果安装了openssh-server，执行which sshd可以看到路径。</p><p>WSL默认没有安装openssh-server，安装方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><p>启动ssh：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service ssh start</span><br></pre></td></tr></table></figure><h4 id="ssh-keygen"><a href="#ssh-keygen" class="headerlink" title="ssh-keygen"></a>ssh-keygen</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除错误的 know_hosts 项</span></span><br><span class="line">ssh-keygen -f <span class="string">&quot;/home/&lt;user&gt;/.ssh/known_hosts&quot;</span> -R <span class="string">&quot;ubuntu&quot;</span></span><br></pre></td></tr></table></figure><h4 id="通过https登录到github"><a href="#通过https登录到github" class="headerlink" title="通过https登录到github"></a>通过https登录到github</h4><p><code>git push</code>不再支持输入用户名和密码，当提示输入密码时，需要输入personal access token.</p><p>步骤1：在github上<a href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#creating-a-personal-access-token-classic">创建personal access token</a>；</p><p>步骤2：<a href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#using-a-personal-access-token-on-the-command-line">在命令行上使用personal access token</a>；</p><p>步骤3：为了避免每次都需要输入personal access token，可以将其<a href="https://docs.github.com/en/get-started/getting-started-with-git/caching-your-github-credentials-in-git">缓存在git client上</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gh auth login</span><br></pre></td></tr></table></figure><p>注：使用<code>gh</code>命令需要先安装GitHub CLI：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gh</span><br></pre></td></tr></table></figure><h3 id="WSL常见问题"><a href="#WSL常见问题" class="headerlink" title="WSL常见问题"></a>WSL常见问题</h3><ul><li><a href="https://stackoverflow.com/questions/73673804/npm-show-npm-elf-not-found-error-in-wsl">npm show “NPM ELF : not found error” in WSL</a></li><li><a href="https://www.reddit.com/r/bashonubuntuonwindows/comments/8teo9i/is_there_a_way_to_open_a_file_in_a_browser_from/">WSL打开html的方法</a></li></ul><p>在WSL的Linux下，在.bashrc中加入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">browser</span></span>() &#123;</span><br><span class="line">    explorer.exe $(wslpath -w $(<span class="built_in">realpath</span> <span class="variable">$1</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">export</span> -f browser</span><br></pre></td></tr></table></figure><p>打开html：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browser index.html</span><br></pre></td></tr></table></figure><h2 id="静态站点生成器"><a href="#静态站点生成器" class="headerlink" title="静态站点生成器"></a>静态站点生成器</h2><p>以下几种<a href="https://docs.github.com/en/pages/getting-started-with-github-pages/about-github-pages">静态站点生成器</a>都可以用来搭建个人主页。如果使用除JekyII外的工具，则需要配置<a href="https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions">Github Actions</a>以构建和发布你的站点。</p><h3 id="mkdocs"><a href="#mkdocs" class="headerlink" title="mkdocs"></a>mkdocs</h3><p><a href="https://www.mkdocs.org/">mkdocs</a>是一个快速的静态网页生成器。</p><p><code>mkdocs.yml</code> 文件是 MkDocs 文档生成器的配置文件，其格式说明参见<a href="mkdocs.yml.md">这里</a>。</p><h3 id="JekyII"><a href="#JekyII" class="headerlink" title="JekyII"></a>JekyII</h3><p>Jekyll 是一个静态站点生成器，内置对 GitHub Pages 的支持和简化的构建进程。</p><p>参见 <a href="https://docs.github.com/en/pages/setting-up-a-github-pages-site-with-jekyll/about-github-pages-and-jekyll">About GitHub Pages and Jekyll</a> 。</p><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><ul><li><a href="https://hexo.io/docs/">Hexo博客框架</a></li><li><a href="https://hexo.io/zh-cn/docs/">Hexo中文文档</a></li><li><a href="https://malekbenz.com/blog/2016/09/10/Create-Host-Blog-for-free-with-Hexo-Github">Create and host your blog for free with hexo &amp; Github</a></li></ul><h3 id="Sphinx"><a href="#Sphinx" class="headerlink" title="Sphinx"></a>Sphinx</h3><p><a href="https://www.sphinx-doc.org/en/master/usage/installation.html">Install Sphinx</a><br><a href="https://sphinx-intro-tutorial.readthedocs.io/en/latest/docs_hosting.html">Hosting the documentation</a></p><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>python建立个人站点</p><pre><code>python -m http.server</code></pre><h2 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h2><h3 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h3><ul><li><a href="https://daringfireball.net/projects/markdown">Markdown Documentation</a></li><li><a href="https://squidfunk.github.io/mkdocs-material/reference/diagrams/">Diagrams Reference</a></li></ul><h3 id="reStructuredText"><a href="#reStructuredText" class="headerlink" title="reStructuredText"></a>reStructuredText</h3><p><code>.rst</code></p><h2 id="大型文件存储"><a href="#大型文件存储" class="headerlink" title="大型文件存储"></a>大型文件存储</h2><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>Postimages</p><ul><li>网站: <a href="https://postimages.org/">https://postimages.org/</a></li><li>特点:</li><li>适合快速上传和生成图片链接。</li><li>不需要注册，可以直接上传图片并获得链接。</li><li>提供图片缩略图和直接链接。</li><li>上传后图片会长期存储，适用于网站和博客图片托管。</li></ul><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><p>TinyPic (由 Photobucket 提供)</p><ul><li>网站: <a href="https://tinypic.com/">https://tinypic.com/</a></li><li>特点:</li><li>支持上传并生成快速共享链接。</li><li>上传后，链接可以嵌入到社交媒体、论坛、博客中。</li><li>图片和视频都支持托管，但TinyPic已关闭，现由Photobucket服务接管。</li></ul><h3 id="Git-LFS"><a href="#Git-LFS" class="headerlink" title="Git LFS"></a>Git LFS</h3><p>GitHub 提供的用于存储大型文件的服务叫 Git LFS（Git Large File Storage）。</p><h4 id="什么是-Git-LFS？"><a href="#什么是-Git-LFS？" class="headerlink" title="什么是 Git LFS？"></a>什么是 Git LFS？</h4><p>Git LFS 是一个 Git 扩展，用于处理 Git 仓库中的大型文件（如图片、视频、音频等），它通过将大型文件存储在 GitHub 的独立存储区来解决 Git 的性能瓶颈。</p><h4 id="Git-LFS-的免费额度："><a href="#Git-LFS-的免费额度：" class="headerlink" title="Git LFS 的免费额度："></a>Git LFS 的免费额度：</h4><p>GitHub 为免费账户提供一定的 LFS 存储和带宽额度：</p><p>免费存储：每个 GitHub 账户提供 1GB 的 LFS 存储。</p><p>免费带宽：每个月 1GB 的下载带宽。</p><p>如果超出免费额度，你可以选择购买更多的存储和带宽。</p><h4 id="Git-LFS-的工作原理："><a href="#Git-LFS-的工作原理：" class="headerlink" title="Git LFS 的工作原理："></a>Git LFS 的工作原理：</h4><p>文件替代：Git LFS 用一个指向大文件的指针来替代文件内容，将文件本身存储在 GitHub 提供的 LFS 存储空间中。</p><p>文件存储：实际的文件内容存储在 GitHub 的 LFS 存储中，Git 只会管理这些文件的指针。</p><p>下载&#x2F;上传：当你从仓库克隆或拉取代码时，Git LFS 会自动下载大文件，反之，当你提交大文件时，Git LFS 会将其上传到 GitHub。</p><h4 id="如何使用-Git-LFS？"><a href="#如何使用-Git-LFS？" class="headerlink" title="如何使用 Git LFS？"></a>如何使用 Git LFS？</h4><ol><li>安装 Git LFS：<br>首先需要安装 Git LFS，可以通过 Git LFS 官方网站 下载和安装。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git lfs install</span><br></pre></td></tr></table></figure><ol start="2"><li>初始化 Git LFS：<br>在你的 Git 仓库中初始化 Git LFS。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git lfs track <span class="string">&quot;*.jpg&quot;</span>   <span class="comment"># 例如跟踪所有 jpg 格式的图片</span></span><br><span class="line">git add .gitattributes   <span class="comment"># 添加 .gitattributes 文件</span></span><br><span class="line">git add &lt;large-file&gt;     <span class="comment"># 添加大型文件</span></span><br><span class="line">git commit -m <span class="string">&quot;Add large file&quot;</span></span><br><span class="line">git push origin main     <span class="comment"># 推送到 GitHub</span></span><br></pre></td></tr></table></figure><ol start="3"><li>使用 Git LFS 进行提交：<br>每次提交时，Git LFS 会自动处理大文件，并将它们上传到 GitHub LFS 存储区。</li></ol><h5 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h5><p>减少仓库体积：通过将大文件存储在 Git LFS 中，可以避免将大文件直接存储在 Git 仓库中，从而提高 Git 的性能。</p><p>适用于大文件：适合管理图像、视频、二进制文件等大型文件，避免 Git 克隆和拉取过程变得过于缓慢。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>Git LFS 是 GitHub 提供的用于管理和存储大型文件的扩展服务，适合存储需要频繁更改或管理的大文件（如图片、音频、视频等）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> site </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown Syntax</title>
      <link href="/blog/2024/01/03/personal_site/Markdown-Syntax/"/>
      <url>/blog/2024/01/03/personal_site/Markdown-Syntax/</url>
      
        <content type="html"><![CDATA[<h2 id="Mermaid"><a href="#Mermaid" class="headerlink" title="Mermaid"></a>Mermaid</h2><p><a href="https://mermaid.js.org/syntax/flowchart.html">Flowchart</a></p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="转义反引号"><a href="#转义反引号" class="headerlink" title="转义反引号"></a>转义反引号</h3><p>参考<a href="https://www.growingwiththeweb.com/2015/06/escaping-backtick-in-markdown.html">链接</a>。</p><ol><li>在code block之外，使用”&quot;转义即可：</li></ol><pre>\`</pre><ol start="2"><li>用将反引号放入双反引号中，即</li></ol><pre>`` ` ``</pre><ol start="3"><li>在代码块开始前缩进4个空格，即</li></ol><pre>    `</pre><ol start="4"><li>使用fenced代码块：</li></ol><pre>```<br>`<br>```</pre><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.jetbrains.com/help/hub/markdown-syntax.html">JetBrains: Markdown Syntax</a></li><li><a href="https://www.markdownguide.org/extended-syntax/">Markdown Guide: Extended Syntax</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Book List</title>
      <link href="/blog/2024/01/01/misc/Book-List/"/>
      <url>/blog/2024/01/01/misc/Book-List/</url>
      
        <content type="html"><![CDATA[<h2 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h2><ol><li>多人在线游戏架构实战：基于C++的分布式游戏编程&#x2F;彭放编著. –北京：机械工业出版社，2020.11 （ISBN 978-7-111-66792-6）</li></ol>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm</title>
      <link href="/blog/2023/12/29/personal_site/npm/"/>
      <url>/blog/2023/12/29/personal_site/npm/</url>
      
        <content type="html"><![CDATA[<h2 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h2><p><code>npm root</code> - Current installation root path.<br><code>npm root -g</code> - The global installation root path.<br><code>npm uninstall</code> - After executing this command, you should also remove the items in the <code>package.json</code> file and delete the <code>package-lock.json</code> file and the <code>node_modules</code> directory.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://stackoverflow.com/questions/5926672/where-does-npm-install-packages">Where does npm install packages?</a><br><a href="https://stackoverflow.com/questions/66978786/cannot-uninstall-two-npm-packages">Cannot Uninstall two npm Packages</a></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络检测工具</title>
      <link href="/blog/2023/12/29/net/%E7%BD%91%E7%BB%9C%E6%8E%A2%E6%B5%8B%E5%B7%A5%E5%85%B7/"/>
      <url>/blog/2023/12/29/net/%E7%BD%91%E7%BB%9C%E6%8E%A2%E6%B5%8B%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>sudo apt install net-tools</code></pre><h2 id="手册"><a href="#手册" class="headerlink" title="手册"></a>手册</h2><pre><code>man 7 socket - socket optionsman 7 tcp - tcp options</code></pre><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><pre><code>/proc/sys/net/ipv4/ip_local_port_range</code></pre><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="网关（Gateway）"><a href="#网关（Gateway）" class="headerlink" title="网关（Gateway）"></a>网关（Gateway）</h3><p>网关（Gateway）是一个网络节点，它充当其他网络之间的访问点或网关。网关通常用于连接不同的网络，并且可以在不同的协议之间进行转换。网关设备可以是路由器、服务器或其他网络设备。当本地网络中的设备需要与外部网络通信时，它们会将数据包发送到网关，网关再将数据包转发到目标网络。</p><p>举例： 假设你的本地网络使用的IP地址范围是192.168.1.0&#x2F;24，而你的网关IP地址是192.168.1.1。当你的计算机需要访问外部网络（例如互联网）时，它会将数据包发送到网关（192.168.1.1），然后由网关将数据包转发到目标网络。</p><p>在Linux系统中，你可以使用<code>ip route</code>命令查看默认网关。例如：</p><p>在这个例子中，<code>default via 192.168.1.1 dev eth0</code>表示默认网关是<code>192.168.1.1</code>，你的计算机通过网络接口<code>eth0</code>与网关连接。</p><h3 id="子网（CIDR表示法）"><a href="#子网（CIDR表示法）" class="headerlink" title="子网（CIDR表示法）"></a>子网（CIDR表示法）</h3><p>CIDR（Classless Inter-Domain Routing，无类别域间路由）是一种用于分配IP地址和路由的标准，使用斜杠（&#x2F;）后跟一个数字来表示子网掩码的位数。</p><p>在CIDR表示法中，<code>192.168.1.0/24</code>表示一个子网，其中<code>/24</code>表示子网掩码为255.255.255.0。这意味着子网中有256个IP地址（从0到255），但其中两个地址是保留的：</p><ol><li><strong>网络地址</strong>：<code>192.168.1.0</code>，用于标识子网本身。</li><li><strong>广播地址</strong>：<code>192.168.1.255</code>，用于向子网中的所有设备发送广播消息。</li></ol><p>因此，有效的主机IP地址范围是从<code>192.168.1.1</code>到<code>192.168.1.254</code>，共254个可用的IP地址。</p><h3 id="Link-local-Adress"><a href="#Link-local-Adress" class="headerlink" title="Link-local Adress"></a>Link-local Adress</h3><p>The link-local address range refers to IP addresses that are used for communication within a single network segment or link. These addresses are not routable, meaning they are not intended to be used for communication beyond the local network segment.</p><p>For IPv4, the link-local address range is 169.254.0.0&#x2F;16. This range is automatically assigned to network interfaces when no other IP address is available (e.g., when DHCP fails). Devices on the same local network can communicate with each other using these addresses without requiring a router.</p><p>For IPv6, the link-local address range is fe80::&#x2F;10. These addresses are automatically configured on all IPv6-enabled interfaces and are used for local network communication.</p><p>The IP address range 169.254.0.0&#x2F;16 is regarded as link-local because it is reserved for link-local addresses by the Internet Assigned Numbers Authority (IANA). These addresses are used for communication within a single network segment or link and are not routable beyond that segment.</p><p>Characteristics of Link-Local Addresses:</p><ul><li>Automatic Assignment: Devices automatically assign themselves an IP address from the 169.254.0.0&#x2F;16 range if they cannot obtain an IP address through DHCP.</li><li>Non-Routable: These addresses are not meant to be routed across different network segments. They are only valid within the local network.</li><li>Zero Configuration: Link-local addresses allow devices to communicate without manual configuration or a DHCP server.</li></ul><p>Example:<br>When a device fails to get an IP address from a DHCP server, it might assign itself an address like 169.254.1.2. Other devices on the same local network segment will also have addresses in the 169.254.0.0&#x2F;16 range, allowing them to communicate directly.</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h3><p>NAME</p><pre><code>ip - show / manipulate routing, devices, policy routing and tunnels.</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ip route get 8.8.8.8</span><br><span class="line">8.8.8.8 via 192.168.1.1 dev eth0 src 192.168.1.100 uid 1000</span><br><span class="line">    cache</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>8.8.8.8</code>: The destination IP address for which the route is being queried.</li><li><code>via 192.168.1.1</code>: The gateway IP address through which the destination can be reached.</li><li><code>dev eth0</code>: The network interface (e.g., <code>eth0</code>) used to reach the destination.</li><li><code>src 192.168.1.100</code>: The source IP address used for sending packets to the destination.</li><li><code>uid 1000</code>: The user ID of the process that issued the command.</li><li><code>cache</code>: Indicates that the route information is cached.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ip route show</span><br><span class="line">default via 192.168.1.1 dev eth0 </span><br><span class="line">192.168.1.0/24 dev eth0 proto kernel scope <span class="built_in">link</span> src 192.168.1.100</span><br><span class="line">169.254.0.0/16 dev idrac proto kernel scope <span class="built_in">link</span> src 169.254.1.2</span><br></pre></td></tr></table></figure><p>说明：该命令用于显示路由表：</p><ul><li><code>default via 192.168.1.1 dev eth0</code>: The default route, packets to any destination not in the routing table will be sent to <code>192.168.1.1</code> via the <code>eth0</code> interface.</li><li><code>192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.100</code>: A route for the <code>192.168.1.0/24</code> network (destination network), directly reachable via the <code>eth0</code> interface, with the source IP <code>192.168.1.100</code>.</li><li><code>192.168.1.0/24</code>: Destination network.</li><li><code>dev eth0</code>: Interface <code>eth0</code>.</li><li><code>proto kernel</code>: Added by the kernel.</li><li><code>scope link</code>: Directly reachable.</li><li><code>src 192.168.1.100</code>: Source IP address.</li><li><code>169.254.0.0/16</code>: Link-local address range.</li></ul><h3 id="netstat-ss"><a href="#netstat-ss" class="headerlink" title="netstat &#x2F; ss"></a>netstat &#x2F; ss</h3><p>NAME</p><pre><code>ss - another to investigate sockets.</code></pre><p>Reference</p><p><a href="https://zhuanlan.zhihu.com/p/45920111">查看进程占用的端口</a></p><p>COMMANDS</p><pre><code>ss -lnpt</code></pre><p>OPTIONS</p><pre><code>-n, --numberic-l, --listening-t, --tcp    Note: Only established (non-listening) connections.-a, --all    Display both listening and non-linstening (for TCP this means established connections) sockets.-u, --udp-p, --process</code></pre><h3 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h3><p>Options:</p><pre><code>-n inhibits the conversion of network numbers to host names for network files.-P inhibits the conversion of port numbers to port names for network files.-i specifies the Internet addresses    multiple addresses (up to a limit of 100) may be specified with multiple options.    An Internet address is specified in the form (Items in square brackets are optional.):    [46][protocol][@hostname|hostaddr][:service|port]    where:    46 specifies the IP version, IPv4 or IPv6        that applies to the following address.        &#39;6&#39; may be be specified only if the UNIX        dialect supports IPv6.  If neither &#39;4&#39; nor        &#39;6&#39; is specified, the following address        applies to all IP versions.    protocol is a protocol name - TCP, UDP    hostname is an Internet host name.  Unless a        specific IP version is specified, open        network files associated with host names        of all versions will be selected.    hostaddr is a numeric Internet IPv4 address in        dot form; or an IPv6 numeric address in        colon form, enclosed in brackets, if the        UNIX dialect supports IPv6.  When an IP        version is selected, only its numeric        addresses may be specified.    service is an /etc/services name - e.g., smtp -        or a list of them.    port is a port number, or a list of them.-s list file size-s p:s  exclude(^)|select protocol (p = TCP|UDP) states by name(s).</code></pre><p>Examples:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lsof -i:&lt;port&gt;</span><br><span class="line">lsof -i -P -n | grep LISTEN</span><br><span class="line">lsof -nP -iTCP -sTCP:LISTEN</span><br></pre></td></tr></table></figure><h3 id="nc-netcat-nmap"><a href="#nc-netcat-nmap" class="headerlink" title="nc&#x2F;netcat&#x2F;nmap"></a>nc&#x2F;netcat&#x2F;nmap</h3><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>Create a TCP or a UNIX domain socket and connect to stdin&#x2F;out.</p><p>Installation:</p><pre><code>sudo apt-get install socket</code></pre>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcp/ip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Written in Blood</title>
      <link href="/blog/2023/12/23/english/Written-in-Blood/"/>
      <url>/blog/2023/12/23/english/Written-in-Blood/</url>
      
        <content type="html"><![CDATA[<h2 id="电影链接"><a href="#电影链接" class="headerlink" title="电影链接"></a>电影链接</h2><p><a href="https://tubitv.com/tv-shows/520415/s01-e02-written-in-blood">Midsomer Murders： Season 1 Episode 2 - Written in Blood</a></p><h2 id="台词"><a href="#台词" class="headerlink" title="台词"></a>台词</h2><p>Phoenix turned and fired twice, the 34 millimetre bullets spitting through the air and splintering the brickwork two inches to the left of the Russia thug’s shoulder. A moment later came the reply of the Uzi semiautomatic and Phoenix twisted round. 菲尼克斯转身开了两枪，34毫米的子弹在空中喷射，将俄罗斯暴徒肩膀左侧两英寸砖墙击碎。过一会儿，乌兹半自动冲锋枪回应了，菲尼克斯扭过身来。</p><p>Her lips, searching in the sapphire, honeyscented darkness, found his; cool, forceful, unresisting, and as the frozen waves crashed down. 当冰冷、有力、不可抗拒的浪汹涌而下的时候，她的嘴唇在蓝宝石般散发着蜜香的夜色中寻找，找到了他的嘴唇。</p><p>-Got your meeting, have you? 你要去开会，对吗？<br>-Yes, I’m on my way. 是的，我正在去。</p><p>He pulled her towards him, his powerful, masculine hands tearing at the silk faric of her Gaultier nightshirt.</p><p>The repetitive beat of the innercity drum.</p><p>1887, Sebastian Lyddiard, greatgrandson of Herbert Lyddiard, who served under Sir John Jervis against Napoleon. 对抗拿破仑。</p><p>The Right Honourable William Lyddiard. 威廉·利迪亚德阁下。</p><p>-Do you ever regret marrying hime, Amy? I wonder if you ever think that but for you he might still be alive? 你后悔嫁给他吗，埃米？我不知道你是否想过，如果不是因为你，他可能现在还活着？<br>-(Amy) No. 没有想过。<br>-Well I do. 我想过。</p><p>-So we come to the question of which writer we invite to address us? 所以我们打算请哪位作家来给我们做演讲呢？<br>-How about Jilly Cooper?<br>-I think he said a writer.<br>-Do you think we could interest Frederick Forsythe?<br>-I rather doubt it.<br>-Oh, it’s a wonderful idea, Gerald. Especially since you’re writing a thriller. I think Frederick Forsythe would be first rate! 我认为Frederick Forsythe是第一流的。<br>-He’d never come. He’d just pretend he didn’t have time. They always do.<br>-I’d like Seamus Heaney.<br>-The poet?<br>-Not another poet. That last one was such a ghastly little man.</p><h2 id="词汇"><a href="#词汇" class="headerlink" title="词汇"></a>词汇</h2><p>screenplay by 剧本由……写成<br>millimetre 毫米<br>phoenix 凤凰，这里是人名，菲尼克斯<br>spit 吐，唾<br>thug 恶棍，暴徒<br>twist 扭，拧，捻<br>brickwork 砖砌体，砖墙<br>splinter n. 碎片，弹片； v. 碎裂。<br>Uzi semiautomatic 乌兹半自动冲锋枪（<a href="https://en.wikipedia.org/wiki/Uzi">Uzi</a> submachine gun）。Uzi 冲锋枪是由以色列国防军 (IDF) 上尉（后来的少校）Uziel Gal 在 1948 年阿以战争后设计的。<br>sapphire 蓝宝石<br>honey 蜂蜜，蜜<br>scent 香味（a pleasant natural smell）；scented 散发香味的<br>resist 抗拒的；unresisted 不可抗拒的。<br>masculine 男性的。<br>tear 撕，撕破，撕毁；拆；泪水。<br>nightshirt 睡衣<br>scum 浮渣<br>scum-bag 渣子袋，这里应该是“渣男”、“人渣”的意思，骂人的话。<br>hum 哼声<br>greatgrandson 曾孙<br>Sir 爵士<br>Napoleon 拿破仑<br>The Right Honourable <a href="https://en.wikipedia.org/wiki/The_Right_Honourable">阁下</a>。其中，Right是副词，意思是’very’ or ‘fully’。从语法上说，The Right Honourable 是形容短语，直接用来称呼人名或者某人用来自称都是不正确的，应该与其引用的名称或名称一起使用第三人称。<br>address 演讲<br>first rate 第一流<br>pretend 假装<br>ghastly US:&#x2F;ˈɡæst.li&#x2F; UK:&#x2F;ˈɡɑːst.li&#x2F; 阴森的，可怕的，非常坏的<br>bestseller 畅销书</p>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> movie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cmake 入门</title>
      <link href="/blog/2023/12/07/cplusplus/cmake%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/blog/2023/12/07/cplusplus/cmake%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Specify the search path for <code>pkg_check_modules</code>: <a href="https://stackoverflow.com/questions/44487053/set-pkg-config-path-in-cmake">Solution</a></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(ENV&#123;PKG_CONFIG_PATH&#125; <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/libs/opencv-install/lib/pkgconfig&quot;</span>)</span><br></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/97369704">find_package</a></p>]]></content>
      
      
      <categories>
          
          <category> c/cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> build </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Documentation</title>
      <link href="/blog/2023/12/07/personal_site/Hexo-Documentation/"/>
      <url>/blog/2023/12/07/personal_site/Hexo-Documentation/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo修改默认端口号"><a href="#hexo修改默认端口号" class="headerlink" title="hexo修改默认端口号"></a>hexo修改默认端口号</h2><p>参考<a href="https://www.jianshu.com/p/8398621502fd">博客</a></p><h2 id="添加目录"><a href="#添加目录" class="headerlink" title="添加目录"></a>添加目录</h2><p><a href="https://blog.ligos.net/2016-07-25/Writing-Content-On-Hexo.html">https://blog.ligos.net/2016-07-25/Writing-Content-On-Hexo.html</a><br><a href="https://medium.com/employbl/create-a-custom-blog-theme-with-hexo-js-b24c82eb9271#.viurzqeac">https://medium.com/employbl/create-a-custom-blog-theme-with-hexo-js-b24c82eb9271#.viurzqeac</a><br><a href="https://hexo.io/docs/themes">https://hexo.io/docs/themes</a><br><a href="https://hexo.io/docs/templates">https://hexo.io/docs/templates</a><br><a href="https://hexo.io/docs/helpers">https://hexo.io/docs/helpers</a></p><h2 id="Add-pages"><a href="#Add-pages" class="headerlink" title="Add pages"></a>Add pages</h2><p>Commands</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The following command generate a &#x27;categories/index.md&#x27; file</span></span><br><span class="line">hexo new page categories</span><br><span class="line"></span><br><span class="line">hexo new page tags</span><br><span class="line">hexo new page about</span><br></pre></td></tr></table></figure><p>Refers to <a href="https://stackoverflow.com/questions/60759559/hexo-next-theme-categories-and-tags-page">Hexo NeXT Theme categories and tags page</a></p><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p><a href="https://blog.csdn.net/wugenqiang/article/details/88377669">Display PDF</a></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Getting Started with IB</title>
      <link href="/blog/2023/12/06/net/IB/"/>
      <url>/blog/2023/12/06/net/IB/</url>
      
        <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="ibv-fork-init"><a href="#ibv-fork-init" class="headerlink" title="ibv_fork_init"></a><code>ibv_fork_init</code></h3><p>文档 <a href="https://docs.nvidia.com/networking/display/rdmaawareprogrammingv17/ibv_fork_init">ibv_fork_init</a></p><p><strong>模板</strong>: <code>int ibv_fork_init(void)</code></p><p><strong>输入参数</strong>: 无</p><p><strong>输出参数</strong>: 无</p><p><strong>返回值</strong>: <code>0</code> on success, <code>-1</code> on error. If the call fails, errno will be set to indicate the reason for the failure.</p><p><strong>描述</strong>: <code>ibv_fork_init</code> 初始化 libverbs 的数据结构来安全地处理 <code>fork()</code> 并避免数据损坏，不论 <code>fork()</code> 是被显式调用还是隐式调用（比如在 <code>system()</code> 中被调用）。<br>如果所有的父进程总是阻塞直至所有的子进程结束或使用 <code>exec()</code> 改变地址空间，那么 <code>ibv_fork_init</code> 可以不被调用。</p><p>该函数在支持 <code>madvise</code> 的 <code>MADV_DONTFORK</code> 标记的 Linux 内核（2.6.17或更高）上可以工作。</p><p>设置环境变量 <code>RDMAV_FORK_SAFE</code> 或 <code>IBV_FORK_SAFE</code> 环境变量为任意值，有着与 <code>ibv_fork_init</code> 相同的效果。</p><p>设置 <code>RDMAV_HUGEPAGES_SAFE</code> 为任意值，以告诉库需要检查内核为内存域（memory regions）使用的底层内存页的大小。如果应用程序直接或通过库（如 libhugtlbfs ）间接使用大内存页（博主注：即大于4KB）时，该环境变量是必须的。（博主注：<code>ibv_fork_init</code> 将检查 <code>RDMAV_HUGEPAGES_SAFE</code> ）</p><p>调用 <code>ibv_fork_init</code> 将降低性能，因为每个内存注册都将有一个额外的系统调用和分配附加的内存以追踪内存域（memory regions）。<br>确切的性能损失取决于工作负载，通常不会很大。</p><p>设置 <code>RDMAV_HUGEPAGES_SAFE</code> 会为所有的内存注册增加更多的开销。</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><a href="https://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=346D319BA2A9F06B8C49B2C0AAFD28D9?doi=10.1.1.668.4459&rep=rep1&type=pdf">Documentation: RDMA Aware Networks Programming User Manual v1.6</a></p><p><a href="/blog/documents/RDMA-Aware-Networks-Programming.pdf">Local Documentation</a></p><p><a href="https://docs.oracle.com/cd/E19671-01/835-0793-03/z40000419112.html#scrolltoc">Sun Network QDR InfiniBand Gateway Switch Topic Set</a></p><p><a href="https://www.zhihu.com/column/c_1231181516811390976">RDMA知乎专栏</a></p><p>用户态的Verbs API手册跟代码在一个仓库维护，手册地址：<a href="https://github.com/linux-rdma/rdma-core/tree/master/libibverbs/man">https://github.com/linux-rdma/rdma-core/tree/master/libibverbs/man</a></p><p>有很多在线的man page网站可以查阅这些接口的说明，比如官方的连接：<a href="https://man7.org/linux/man-pages/man3/ibv_post_send.3.html">https://man7.org/linux/man-pages/man3/ibv_post_send.3.html</a></p><p>也有一些其他非官方网页，支持在线搜索：<a href="https://linux.die.net/man/3/ibv">https://linux.die.net/man/3/ibv</a></p><p>查阅系统man page<br>如果你使用的商用OS安装了rdma-core或者libibverbs库，那么可以直接用man命令查询接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man ibv_post_send</span><br></pre></td></tr></table></figure><p>查询Mellanox的编程手册<br>《<a href="https://docs.nvidia.com/networking/display/rdmaawareprogrammingv17">RDMA Aware Networks Programming User Manual Rev 1.7</a>》，最新版是2015年更新的。该手册写的比较详尽，并且附有示例程序，但是可能与最新的接口有一些差异。Mellanox VPI®（Virtual Procotol Interconnect）架构为同时支持InfiniBand和以太网语义的网络适配器和交换机提供高性能、低延迟和可靠的方法。</p><p>Book: <a href="https://github.com/faquir-1990/itBooks/blob/master/Linux%20Kernel%20Networking%20-%20Implementation%20and%20Theory.pdf">Linux Kernel Networking - Implementation and Theory</a></p><p><a href="http://www.rdmamojo.com/">Dotan’s blog</a>: Dotan Barak, an InfiniBand Expert. Dotan is a Senior Software Manager at Mellanox Technologies working on RDMA Technologies.</p><h2 id="性能分析工具（profiling）"><a href="#性能分析工具（profiling）" class="headerlink" title="性能分析工具（profiling）"></a>性能分析工具（profiling）</h2><p>Blog: <a href="https://www.rdmamojo.com/2013/06/08/tips-and-tricks-to-optimize-your-rdma-code/">Tips and tricks to optimize your RDMA code</a></p><p><a href="https://github.com/mellanox-hpc/libibprof">libibprof</a></p><h2 id="IB简介"><a href="#IB简介" class="headerlink" title="IB简介"></a>IB简介</h2><p>RDMA - Remote Direct Memory Access 远程直接内存存取。</p><p>InfiniBand是一种高性能计算机网络通信标准，它具有极高的吞吐量和极低的延迟。如果您需要使用InfiniBand进行编程，您需要使用支持InfiniBand的编程语言（如C++）来编写代码。</p><p>机构和组织：</p><p>OFA: <a href="https://www.openfabrics.org/">Open Fabrics Alliance</a>.</p><p>IBTA: <a href="https://www.infinibandta.org/">InfiniBand Trade Association</a>.</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><code>CQ</code> - Complete Queue 完成队列</li><li><code>WQ</code> - Work Queue 工作队列</li><li><code>WR</code> - Work Request 工作请求</li><li><code>QP</code> - Queue Pairs 队列对（Send-Receive）</li><li><code>SQ</code> - Send Queue 发送队列</li><li><code>RQ</code> - Receive Queue 接收队列</li><li><code>PD</code> - Protection Domain 保护域，将QP和MR结合在一起</li><li><code>MR</code> - Memory Region 内存区域。一块经注册过的且本地网卡可以读写的内存区域。包含R_Key和L_Key。</li><li><code>SGE</code> - Scatter&#x2F;Gather Elements 分散&#x2F;聚集元素。</li><li><code>R_Key</code> - Remote Key</li><li><code>L_Key</code> - Local Key</li><li><code>CA</code> - (Host) Channel Adapter, an inifiniband network interface card.</li><li><code>NIC</code> - Network Interface Card 网卡。</li><li><code>LID</code> - Local Identifier.</li><li><code>CM</code> - Connection Manager.</li></ul><p>其他常见缩写：</p><ul><li><code>RC</code> - reliable connected.</li><li><code>SCSI</code> - Small Computer System Interface 小型计算机系统接口。</li><li><code>SRP</code> - SCSI RDMA Protocol. &#x2F; Secure Remote Password.</li></ul><p>博客：<a href="https://blog.51cto.com/liangchaoxi/4044818">https://blog.51cto.com/liangchaoxi/4044818</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/networking_guide/sec-infiniband_and_rdma_related_software_packages">InfiniBand 和 RDMA 相关软件包</a></p><pre><code>sudo apt-get install infiniband-diagssudo apt install ibverbs-utils</code></pre><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ul><li><a href="https://insujang.github.io/2020-02-09/introduction-to-programming-infiniband/">introduction to programming infiniband</a></li><li><a href="https://indico.cern.ch/event/218156/attachments/351725/490089/RDMA_Aware_Programming_user_manual.pdf">RDMA Aware Programming user manual (PDF)</a></li></ul><p>以下是一些支持InfiniBand的C++库：</p><p>Infinity：这是一个轻量级的C++ RDMA库，用于InfiniBand网络。它提供了对两侧（发送&#x2F;接收）和单侧（读&#x2F;写&#x2F;原子）操作的支持，并且是一个简单而强大的面向对象的ibVerbs抽象。该库使用户能够构建使用RDMA的复杂应用程序，而不会影响性能<a href="https://github.com/claudebarthels/infinity">1</a>。</p><p>OFED：这是一个开放式Fabrics Enterprise Distribution，它提供了对InfiniBand和RoCE（RDMA over Converged Ethernet）技术的支持。OFED提供了一组用户空间库和驱动程序，可用于构建支持RDMA的应用程序<a href="https://zhuanlan.zhihu.com/p/337461037">2</a>。</p><p>以下是使用Infinity库编写支持InfiniBand的C++代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建新上下文</span></span><br><span class="line">infinity::core::Context *context = <span class="keyword">new</span> infinity::core::<span class="built_in">Context</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建队列对</span></span><br><span class="line">infinity::queues::QueuePairFactory *qpFactory = <span class="keyword">new</span> infinity::queues::<span class="built_in">QueuePairFactory</span>(context);</span><br><span class="line">infinity::queues::QueuePair *qp = qpFactory-&gt;<span class="built_in">connectToRemoteHost</span>(SERVER_IP, PORT_NUMBER);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并向网络注册缓冲区</span></span><br><span class="line">infinity::memory::Buffer *localBuffer = <span class="keyword">new</span> infinity::memory::<span class="built_in">Buffer</span>(context, BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从远程缓冲区读取（单向）并等待完成</span></span><br><span class="line">infinity::memory::RegionToken *remoteBufferToken = <span class="keyword">new</span> infinity::memory::<span class="built_in">RegionToken</span>(REMOTE_BUFFER_INFO);</span><br><span class="line">infinity::<span class="function">requests::RequestToken <span class="title">requestToken</span><span class="params">(context)</span></span>;</span><br><span class="line">qp-&gt;<span class="built_in">read</span>(localBuffer, remoteBufferToken, &amp;requestToken);</span><br><span class="line">requestToken.<span class="built_in">waitUntilCompleted</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将本地缓冲区的内容写入远程缓冲区（单向）并等待完成</span></span><br><span class="line">qp-&gt;<span class="built_in">write</span>(localBuffer, remoteBufferToken, &amp;requestToken);</span><br><span class="line">requestToken.<span class="built_in">waitUntilCompleted</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将本地缓冲区的内容通过队列对发送（双向）并等待完成</span></span><br><span class="line">qp-&gt;<span class="built_in">send</span>(localBuffer, &amp;requestToken);</span><br><span class="line">requestToken.<span class="built_in">waitUntilCompleted</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line"><span class="keyword">delete</span> remoteBufferToken;</span><br><span class="line"><span class="keyword">delete</span> localBuffer;</span><br><span class="line"><span class="keyword">delete</span> qp;</span><br><span class="line"><span class="keyword">delete</span> qpFactory;</span><br><span class="line"><span class="keyword">delete</span> context;</span><br></pre></td></tr></table></figure><p>以下是使用OFED库编写支持InfiniBand的C++代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建新上下文</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ibv_context</span> *context = <span class="built_in">ibv_open_device</span>(*device);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建完成端口</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ibv_pd</span> *pd = <span class="built_in">ibv_alloc_pd</span>(context);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建队列对</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ibv_qp_init_attr</span> qp_init_attr;</span><br><span class="line"><span class="built_in">memset</span>(&amp;qp_init_attr, <span class="number">0</span>, <span class="built_in">sizeof</span>(qp_init_attr));</span><br><span class="line">qp_init_attr.send_cq = cq;</span><br><span class="line">qp_init_attr.recv_cq = cq;</span><br><span class="line">qp_init_attr.qp_type = IBV_QPT_RC;</span><br><span class="line">qp_init_attr.cap.max_send_wr = <span class="number">1</span>;</span><br><span class="line">qp_init_attr.cap.max_recv_wr = <span class="number">1</span>;</span><br><span class="line">qp_init_attr.cap.max_send_sge = <span class="number">1</span>;</span><br><span class="line">qp_init_attr.cap.max_recv_sge = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ibv_qp</span> *qp = <span class="built_in">ibv_create_qp</span>(pd, &amp;qp_init_attr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并向网络注册缓冲区</span></span><br><span class="line"><span class="type">char</span> *localBuffer = (<span class="type">char</span> *)<span class="built_in">malloc</span>(BUFFER_SIZE);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ibv_mr</span> *mr = <span class="built_in">ibv_reg_mr</span>(pd, localBuffer, BUFFER_SIZE, IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接到远程主机</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> remoteAddress;</span><br><span class="line"><span class="built_in">memset</span>(&amp;remoteAddress, <span class="number">0</span>, <span class="built_in">sizeof</span>(remoteAddress));</span><br><span class="line">remoteAddress.sin_family = AF_INET;</span><br><span class="line">remoteAddress.sin_port = <span class="built_in">htons</span>(PORT_NUMBER);</span><br><span class="line"><span class="built_in">inet_pton</span>(AF_INET, SERVER_IP, &amp;remoteAddress.sin_addr);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rdma_cm_id</span> *cmId;</span><br><span class="line"><span class="built_in">rdma_create_id</span>(*eventChannel, &amp;cmId, <span class="literal">NULL</span>, RDMA_PS_TCP);</span><br><span class="line"><span class="built_in">rdma_resolve_addr</span>(cmId, <span class="literal">NULL</span>, (<span class="keyword">struct</span> sockaddr *)&amp;remoteAddress, RESOLVE_TIMEOUT_MS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待连接完成</span></span><br><span class="line"><span class="built_in">rdma_wait_event</span>(*eventChannel, RDMA_CM_EVENT_ESTABLISHED);</span><br><span class="line"><span class="built_in">rdma_ack_cm_event</span>(cmEvent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取远程缓冲区信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ibv_wc</span> wc;</span><br><span class="line"><span class="built_in">ibv_post_recv</span>(qp, &amp;recvWr, &amp;badRecvWr);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">ibv_poll_cq</span>(cq, <span class="number">1</span>, &amp;wc);</span><br><span class="line">&#125; <span class="keyword">while</span> (wc.status != IBV_WC_SUCCESS || wc.opcode != IBV_WC_RECV_RDMA_WITH_IMM || wc.imm_data != <span class="built_in">htonl</span>(IMM_DATA));</span><br><span class="line">remoteBufferInfo.rkey = <span class="built_in">ntohl</span>(wc.imm_data &gt;&gt; <span class="number">8</span>);</span><br><span class="line">remoteBufferInfo.vaddr = wc.wr_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将本地缓冲区的内容写入远程缓冲区（单向）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ibv_send_wr</span> sendWr;</span><br><span class="line"><span class="built_in">memset</span>(&amp;sendWr, <span class="number">0</span>, <span class="built_in">sizeof</span>(sendWr));</span><br><span class="line">sendWr.wr_id = <span class="number">0</span>;</span><br><span class="line">sendWr.opcode = IBV_WR_RDMA_WRITE_WITH_IMM;</span><br><span class="line">sendWr.sg_list = &amp;localSge;</span><br><span class="line">sendWr.num_sge = <span class="number">1</span>;</span><br><span class="line">sendWr.send_flags = IBV_SEND_SIGNALED;</span><br><span class="line">sendWr.wr.rdma.remote_addr = remoteBufferInfo.vaddr;</span><br><span class="line">sendWr.wr.rdma.rkey = remoteBufferInfo.rkey;</span><br><span class="line">localSge.addr = (<span class="type">uintptr_t</span>)localBuffer;</span><br><span class="line">localSge.length = BUFFER_SIZE;</span><br><span class="line">localSge.lkey = mr-&gt;lkey;</span><br><span class="line"><span class="built_in">ibv_post_send</span>(qp, &amp;sendWr, &amp;badSendWr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line"><span class="built_in">ibv_dereg_mr</span>(mr);</span><br><span class="line"><span class="built_in">free</span>(localBuffer);</span><br><span class="line"><span class="built_in">ibv_destroy_qp</span>(qp);</span><br><span class="line"><span class="built_in">ibv_dealloc_pd</span>(pd);</span><br><span class="line"><span class="built_in">ibv_close_device</span>(context);</span><br></pre></td></tr></table></figure><ul><li>入门级文档：<a href="https://zhuanlan.zhihu.com/p/337461037">https://zhuanlan.zhihu.com/p/337461037</a></li><li>文档：<a href="https://docs.kernel.org/infiniband/index.html">https://docs.kernel.org/infiniband/index.html</a></li><li>文档：<a href="http://blog.foool.net/wp-content/uploads/linuxdocs/infiniband.pdf">http://blog.foool.net/wp-content/uploads/linuxdocs/infiniband.pdf</a></li><li>文档：<a href="https://support.bull.com/documentation/byproduct/infra/sw-extremcomp/sw-extremcomp-com/g">https://support.bull.com/documentation/byproduct/infra/sw-extremcomp/sw-extremcomp-com/g</a></li><li>文档：<a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/configuring_infiniband_and_rdma_networks/index">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/configuring_infiniband_and_rdma_networks/index</a></li><li>博客：<a href="https://zhuanlan.zhihu.com/p/337461037">https://zhuanlan.zhihu.com/p/337461037</a></li><li>文档：<a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/networking_guide/ch-configure_infiniband_and_rdma_networks">https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/networking_guide/ch-configure_infiniband_and_rdma_networks</a></li><li>知乎专栏：<a href="https://www.zhihu.com/column/c_1231181516811390976">https://www.zhihu.com/column/c_1231181516811390976</a></li><li>知乎专栏：<a href="https://www.zhihu.com/column/rdmatechnology">https://www.zhihu.com/column/rdmatechnology</a></li></ul><p><a href="https://man7.org/linux/man-pages/man3/ibv_reg_mr.3.html">Linux manual page</a></p><h2 id="Command-Line"><a href="#Command-Line" class="headerlink" title="Command-Line"></a>Command-Line</h2><p>文档：<a href="https://docs.nvidia.com/networking/pages/viewpage.action?pageId=43719572">https://docs.nvidia.com/networking/pages/viewpage.action?pageId=43719572</a></p><ul><li><p><code>ibstat</code></p></li><li><p><code>ibhosts</code> - 查看所有的IB hosts。</p></li><li><p><code>ibnetdiscover</code> - discover InfiniBand topology.</p></li><li><p><code>ibv_devices</code> - list RDMA devices.</p></li><li><p><code>ibv_devinof</code> - Print information about RDMA devices available for use from userspace.</p></li><li><p><code>ibv_rc_pingpong</code> - Run a simple ping-pong test over InfiniBand via the reliable connected (RC) transport.</p></li><li><p><code>targetcli</code> - administration shell for storage targets</p><p>  <code>targetcli</code> is  a  shell for viewing, editing, and saving the configuration of the kernel’s target subsystem,<br>  also known as LIO. It enables the administrator to assign local storage resources backed by either files,<br>  volumes, local SCSI devices, or ramdisk, and export them to remote systems via network fabrics, such as iSCSI or FCoE.</p></li><li><p><code>srp_daemon</code> - Discovers and connects to InfiniBand SCSI RDMA Protocol (SRP) targets in an IB fabric.</p></li><li><p><code>ibsrpdm</code> - List InfiniBand SCSI RDMA Protocol (SRP) targets on an IB fabric.</p></li></ul><h2 id="liraries"><a href="#liraries" class="headerlink" title="liraries"></a>liraries</h2><p>devid: device ID library. Refer to <a href="https://docs.oracle.com/cd/E86824_01/html/E54772/libdevid-3lib.html">here</a>.</p><p>ibverbs: 使得用户空间进程能够使用RDMA verbs（即进行RDMA操作）。Refer to <a href="https://www.ibm.com/docs/en/aix/7.2?topic=ofed-libibverbs-library">here</a>.</p><p>dl: Dynamic Loader.</p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/blog/2023/11/30/cplusplus/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2023/11/30/cplusplus/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://stackoverflow.com/questions/8623657/multiple-instances-of-singleton-across-shared-libraries-on-linux">Multiple instances of singleton across shared libraries on Linux</a></p>]]></content>
      
      
      <categories>
          
          <category> c/cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> syntax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>printf</title>
      <link href="/blog/2023/11/27/cplusplus/printf/"/>
      <url>/blog/2023/11/27/cplusplus/printf/</url>
      
        <content type="html"><![CDATA[<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><p><a href="https://cpp.hotexamples.com/zh/examples/-/-/lprintf/cpp-lprintf-function-examples.html">https://cpp.hotexamples.com/zh/examples/-/-/lprintf/cpp-lprintf-function-examples.html</a></p><ul><li>printf</li><li>lprintf</li><li>fprintf</li><li>sprintf</li><li>vsprintf</li></ul><p>字符串处理函数<br>bcopy</p><h2 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h2><p>参见 <a href="https://en.cppreference.com/w/cpp/language/escape">Escape sequeneces</a>.</p><pre><code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;\x1E&quot;</span>; <span class="comment">// &quot;0x1E&quot; 是一个非打印字符</span></span><br></pre></td></tr></table></figure></code></pre>]]></content>
      
      
      <categories>
          
          <category> c/cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> syntax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket Programming</title>
      <link href="/blog/2023/11/27/net/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/"/>
      <url>/blog/2023/11/27/net/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h2><p><code>/etc/services</code>: 端口列表<br><code>/etc/protocols</code>: 协议列表</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://zhuanlan.zhihu.com/p/392820963">端口0的作用</a></p>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcp/ip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile入门</title>
      <link href="/blog/2023/11/17/cplusplus/Makefile%E5%85%A5%E9%97%A8/"/>
      <url>/blog/2023/11/17/cplusplus/Makefile%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Makefile默认shell"><a href="#Makefile默认shell" class="headerlink" title="Makefile默认shell"></a>Makefile默认shell</h2><p>Makefile 默认的 shell 是 &#x2F;bin&#x2F;sh:<br>查看 Makefile 默认的 shell:<br>$(warning ${SHELL}) # 查看默认 shell</p><p>如果在 Makefile 开头加上以下语句，可以指定 shell:<br>SHELL :&#x3D; &#x2F;bin&#x2F;bash</p><p>Makefile 的 shell 命令似乎每一条都会新开辟一个 shell 环境来执行，因为每条 shell 命令似乎都执行了一次 .cshrc 脚本。<br>要想在同一个 shell 环境中执行所有命令，则需要使用分号分割并转义换行符。</p><h2 id="Makefile环境变量"><a href="#Makefile环境变量" class="headerlink" title="Makefile环境变量"></a>Makefile环境变量</h2><p>你可以通过设置环境变量 MAKEFLAGS 来让所有的子shell都将 make 认作 make -n：<br>export MAKEFLAGS&#x3D;”-n”<br>注：-n, –dry-run 表示只打印将要执行的命令，但是不真正执行它们。</p><p>Makefile 设置 PATH 环境变量：<br>PATH :&#x3D; mypath:$(PATH)<br>必须使用 “:&#x3D;” ，因为 “:&#x3D;” 是简单赋值，但是 “&#x3D;” 会递归展开，会导致报错 “Recursive variable &#96;PATH’ references itself (eventually)”。</p><p>Makefile 定义多行变量：使用 define 语句。<br>Makefile 接收命令行参数</p><p>非常奇特的现象：<br>$ make clean<br>cat clean.sh &gt;clean<br>chmod a+x clean<br>因为 Makefile 文件中没有 clean 的 recipe，但是当前目录下有个 clean.sh 文件。<br>但是，当再次执行 make clean，clean 脚本还是不会被执行：<br>$ make clean<br>make: &#96;clean’ is up to date.</p><h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><p>Makefile对空格的处理，似乎是：从第一个非空格开始，到明确的截止符（换行、逗号、括号、注释标记’#’等）为止。<br>a &#x3D;   b   #注意末尾有3个空格<br>$(warning a&#x3D;$(a)c)</p><p>结果：<br>a&#x3D;    b   c</p><p>Makefile转义符：<br>字符转义方法<br>$$$<br>##<br>\\</p><p>注意：这里说的是Makefile中的转义符，不是bash中的转义符。</p><h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><p>引用变量时，Shell使用大括号，Makefile则大括号和小括号都行。但是在命令中使用Shell变量就需要使用大括号。</p><p><a href="https://blog.csdn.net/bigmarco/article/details/6687337">参考</a></p><h2 id="Makefile调试方法"><a href="#Makefile调试方法" class="headerlink" title="Makefile调试方法"></a>Makefile调试方法</h2><p>要调试 Makefile 并查看其执行过程，可以使用以下几种方法：<br>    1. 使用 make 的 -n 或 –dry-run 选项：这将显示 Makefile 中的所有命令，而不会真正执行它们。<br>make -n<br>    1. 使用 make 的 -d 或 –debug 选项：这将显示详细的调试信息，包括变量的展开和规则的匹配过程。<br>make -d<br>    1. 使用 make 的 -p 或 –print-data-base 选项：这将打印所有的变量、规则和隐含规则。<br>make -p<br>    1. 在 Makefile 中添加调试信息：你可以在 Makefile 中添加一些调试信息，例如使用 $(info …) 来打印变量的值。<br>print:<br>    @$(foreach V, $(.VARIABLES), $(info $(V) &#x3D; $($(V))))<br>    1. 使用 make 的 -j 选项：如果你使用并行执行，可以使用 -j 选项来限制并行任务的数量，并更容易地跟踪输出。<br>make -j1</p><p>makefile打印所有变量的值：<br>debug:<br>    @$(foreach V, $(.VARIABLES), $(info $(V) &#x3D; $($(V))))<br>然后在命令行中运行：<br>make debug<br>这将打印所有变量及其值。</p><p>print-%:<br>    @echo $* &#x3D; $($*)</p><p>print-% 是一个 Makefile 目标，用于打印变量的值。具体步骤如下：<br>    1. 定义一个目标 print-%，其中 % 是一个通配符，表示任意变量名。<br>    2. 使用 @echo $* &#x3D; $($*) 打印变量名和变量值。</p><p>示例代码：<br>print-%:<br>    @echo $* &#x3D; $($*)<br>使用方法：<br>在命令行中运行：<br>make print-VARIABLE_NAME<br>例如：<br>make print-XTENSA_SW_RELEASE<br>这将打印 XTENSA_SW_RELEASE 变量的值。</p><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>See <a href="https://stackoverflow.com/questions/2214575/passing-arguments-to-make-run">here</a>.</p><p><code>@:</code> See <a href="https://unix.stackexchange.com/questions/92978/what-does-this-2-mean-in-shell-scripting">here</a>.</p><p>This works fine for me:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If the first argument is &quot;run&quot;...</span></span><br><span class="line"><span class="keyword">ifeq</span> (run,<span class="variable">$(<span class="built_in">firstword</span> <span class="variable">$(MAKECMDGOALS)</span>)</span>)</span><br><span class="line">  <span class="comment"># use the rest as arguments for &quot;run&quot;</span></span><br><span class="line">  RUN_ARGS := <span class="variable">$(<span class="built_in">wordlist</span> 2,$(words <span class="variable">$(MAKECMDGOALS)</span>)</span>,<span class="variable">$(MAKECMDGOALS)</span>)</span><br><span class="line">  <span class="comment"># ...and turn them into do-nothing targets</span></span><br><span class="line">  <span class="comment"># <span class="doctag">TODO:</span> What does the following line mean?</span></span><br><span class="line">  <span class="comment"># $(eval $(RUN_ARGS):;@:)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &quot;cmd&quot; refers to any command</span></span><br><span class="line"><span class="section">run:</span></span><br><span class="line">cmd <span class="variable">$(RUN_ARGS)</span></span><br></pre></td></tr></table></figure><h2 id="makefile同名目标处理方式"><a href="#makefile同名目标处理方式" class="headerlink" title="makefile同名目标处理方式"></a>makefile同名目标处理方式</h2><p>参考：</p><ul><li><a href="https://blog.csdn.net/lixiangminghate/article/details/50448664">链接</a></li><li><a href="https://stackoverflow.com/questions/43718595/two-targets-with-the-same-name-in-a-makefile">链接</a></li></ul><p><a href="https://stackoverflow.com/questions/2019989/how-to-assign-the-output-of-a-command-to-a-makefile-variable">makefile将命令结果赋值给变量</a></p><h2 id="Makefile中短划线"><a href="#Makefile中短划线" class="headerlink" title="Makefile中短划线"></a>Makefile中短划线</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">-/bin/rm -rf *.log</span><br></pre></td></tr></table></figure><p>其中，”<code>-/bin/rm</code>“的短划线”<code>-</code>“是一个特殊前缀，表示忽略命令执行过程的错误。</p><h2 id="为每个源文件生成一个可执行程序"><a href="#为每个源文件生成一个可执行程序" class="headerlink" title="为每个源文件生成一个可执行程序"></a>为每个源文件生成一个可执行程序</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SRCS = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: $(SRCS:.c=)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Unnecessary, as the default rules are adequate.</span></span><br><span class="line"><span class="section">.c:</span></span><br><span class="line">gcc <span class="variable">$(CPFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>最后两行其实不需要，默认规则已经足够了。</p><p>其中，<code>$(SRCS:.c=.o)</code>表示将变量<code>SRCS</code>中的每个单词（以空格分割）中的<code>.c</code>替换为<code>.o</code>。以上代码则是将所有<code>.c</code>都去掉。</p>]]></content>
      
      
      <categories>
          
          <category> c/cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> build </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell Configuration</title>
      <link href="/blog/2023/11/13/linux/Shell-Configuration/"/>
      <url>/blog/2023/11/13/linux/Shell-Configuration/</url>
      
        <content type="html"><![CDATA[<h2 id="Color-Scheme"><a href="#Color-Scheme" class="headerlink" title="Color Scheme"></a>Color Scheme</h2><p>Refer to <a href="https://askubuntu.com/questions/466198/how-do-i-change-the-color-for-directories-with-ls-in-the-console">the link</a>.</p><p>Add these three lines to ~&#x2F;.bashrc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vi ~/.bashrc</span><br><span class="line"><span class="built_in">export</span> LS_OPTIONS=<span class="string">&#x27;--color=auto&#x27;</span></span><br><span class="line"><span class="comment"># dircolors - color set for ls</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(dircolors -b)</span>&quot;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">ls</span>=<span class="string">&#x27;ls $LS_OPTIONS&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟内存</title>
      <link href="/blog/2023/11/07/linux/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
      <url>/blog/2023/11/07/linux/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="1-术语"><a href="#1-术语" class="headerlink" title="1. 术语"></a>1. 术语</h2><p>resident set size (RSS)</p><h2 id="2-文件系统"><a href="#2-文件系统" class="headerlink" title="2. 文件系统"></a>2. 文件系统</h2><p>&#x2F;proc&#x2F;self&#x2F;statm</p><h2 id="3-相关命令"><a href="#3-相关命令" class="headerlink" title="3. 相关命令"></a>3. 相关命令</h2><h3 id="3-1-top"><a href="#3-1-top" class="headerlink" title="3.1. top"></a>3.1. top</h3><h4 id="3-1-1-Fields"><a href="#3-1-1-Fields" class="headerlink" title="3.1.1. Fields"></a>3.1.1. Fields</h4><table><thead><tr><th>TIME+<sup><a href="%5Bwhat-does-time-cpu-time-hundredth-in-top-mean%5D(https://superuser.com/questions/1148884/what-does-time-cpu-time-hundredth-in-top-mean/)">1</a></sup></th><th>TIME</th></tr></thead><tbody><tr><td><code>5432:01</code> means “5432 minutes and 1 second”</td><td><code>90,32</code> means “90 hours and 32 minutes”</td></tr><tr><td><code>25:15.20</code> means “25 minutes, 15 seconds and 20% of 1 second”</td><td><code>25:15</code> means “25 minutes and 15 seconds”</td></tr></tbody></table><h3 id="3-2-ps"><a href="#3-2-ps" class="headerlink" title="3.2. ps"></a>3.2. ps</h3><h4 id="3-2-1-输出说明"><a href="#3-2-1-输出说明" class="headerlink" title="3.2.1. 输出说明"></a>3.2.1. 输出说明</h4><p><code>TIME</code>: the cumulated CPU time in [DD-]hh:mm:ss format (time&#x3D;TIME)</p><table><thead><tr><th>Field</th><th>value &amp; means</th></tr></thead><tbody><tr><td><code>TIME</code></td><td><code>1-18:09:38</code> means “1 day, 18 hours, 9 minutes and 38 seconds”</td></tr></tbody></table><h2 id="4-相关系统调用"><a href="#4-相关系统调用" class="headerlink" title="4. 相关系统调用"></a>4. 相关系统调用</h2><h3 id="4-1-fork"><a href="#4-1-fork" class="headerlink" title="4.1. fork"></a>4.1. fork</h3><p>子进程是父进程的副本，获取了父进程的数据空间、堆和栈的副本，但是他们共享正文段。</p><p>写时复制（Copy-On-Write，COW）：不复制父进程的完全副本，只有在父或子进程尝试修改这些区域时，则为修改区域的那块内存制作一个副本，通常是虚拟内存的一页。</p><p><strong>博主注：</strong> 如果父进程尝试修改共享的内存页，内核会为父进程同样制作副本，而把原本的内存页留给子进程使用，这会导致即使在父进程中，原本的内存页的物理地址也会发生改变，从而使得 RDMA 等机制发生错误（要求物理地址保持不变），所以此时需要使用 <code>madise</code> 设置 <code>MADV_DONTFORK</code> 标志。</p><p>在 Linux 中，写时复制（Copy-On-Write, COW）机制主要通过页表和内存管理单元（MMU）来实现。以下是 COW 在 Linux 中的具体实现步骤：</p><p>页表标记：当进程调用 fork() 创建子进程时，父进程和子进程的页表会标记共享的内存页为只读。这意味着这些页在初始状态下是共享的，且无法被写入。</p><p>页错误处理：如果父进程或子进程尝试写入这些只读页，会触发页错误（page fault）。操作系统内核会捕获这个页错误，并执行 COW 机制。</p><p>内存页复制：在页错误发生时，操作系统会分配一个新的物理内存页，并将原始页的内容复制到这个新页中。然后，页表会更新，以指向新的可写内存页。</p><p>页表更新：操作系统更新进程的页表，使得写入操作可以在新的内存页上进行，而不会影响其他进程共享的原始页。</p><p>引用计数：操作系统维护每个内存页的引用计数，以跟踪有多少进程共享该页。当引用计数减少到零时，内存页可以被释放。</p><h3 id="4-2-mmap"><a href="#4-2-mmap" class="headerlink" title="4.2. mmap"></a>4.2. mmap</h3><p>TODO</p><h3 id="4-3-madvise"><a href="#4-3-madvise" class="headerlink" title="4.3. madvise"></a>4.3. madvise</h3><p><code>madvise</code> 是一个系统调用，用于向内核提供关于内存使用的建议。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">madvise</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> advice)</span>;</span><br></pre></td></tr></table></figure><h4 id="4-3-1-选项-advice："><a href="#4-3-1-选项-advice：" class="headerlink" title="4.3.1. 选项 advice："></a>4.3.1. 选项 advice：</h4><h5 id="4-3-1-1-MADV-DONTFORK"><a href="#4-3-1-1-MADV-DONTFORK" class="headerlink" title="4.3.1.1. MADV_DONTFORK"></a>4.3.1.1. <code>MADV_DONTFORK</code></h5><p><code>MADV_DONTFORK</code> 阻止 <code>fork()</code> 后的子进程看见这些范围的内存页。</p><p>这意味该内存不会被复制，即在 <code>fork()</code> 调用时，指定的内存区域不会被子进程继承，避免写时复制导致的页物理地址发生变化。在 fork() 之后，如果父进程对共享内存页进行写操作，写时复制（COW）机制会将这些页复制到新的物理位置。这会导致 RDMA 操作使用的内存地址不一致，从而引发数据错误。</p><p><strong>拓展：</strong> RDMA 中，<code>ibv_fork_init</code> 和 <code>RDMAV_HUGEPAGES_SAFE</code> 会调用 <code>madvise()</code> 来为 IB 卡的 DMA 内存页设置 <code>MADV_DONTFORK</code> ，以避免数据损坏。</p><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h2><p><a href="https://serverfault.com/questions/138427/what-does-virtual-memory-size-in-top-mean">what-does-virtual-memory-size-in-top-mean</a><br>[2]: <a href="https://blog.csdn.net/weixin_42319496/article/details/125940896">https://blog.csdn.net/weixin_42319496/article/details/125940896</a><br>[3]: <a href="https://docs.nvidia.com/networking/display/rdmaawareprogrammingv17/ibv_fork_init">https://docs.nvidia.com/networking/display/rdmaawareprogrammingv17/ibv_fork_init</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KiB vs KB vs kB</title>
      <link href="/blog/2023/11/07/misc/KiB-vs-KB-vs-kB/"/>
      <url>/blog/2023/11/07/misc/KiB-vs-KB-vs-kB/</url>
      
        <content type="html"><![CDATA[<p>See the article: <a href="https://physics.nist.gov/cuu/Units/binary.html">Prefixes for binary multiples</a></p><p>Table:</p><table border="0" cellspacing="0" cellpadding="3"><tbody><tr><td colspan="5"><center><hr noshade="" size="2"><b><font face="Myriad Roman,Syntax,Arial,Helvetica"><font color="#006633"><font size="+1">Prefixesfor binary multiples</font></font></font></b><hr></center></td></tr><tr><td colspan="5"><table border="0" cellspacing="0" cellpadding="3"><tbody><tr><td><b>&nbsp;Factor&nbsp;</b></td><td><b>Name&nbsp;</b></td><td><b>Symbol&nbsp;</b></td><td><b>Origin</b></td><td><b>Derivation&nbsp;</b></td></tr><tr bgcolor="#D0F0C8"><td>&nbsp;2<sup>10</sup></td><td>kibi</td><td>Ki</td><td>kilobinary: (2<sup>10</sup>)<sup>1</sup></td><td>kilo: (10<sup>3</sup>)<sup>1</sup></td></tr><tr><td>&nbsp;2<sup>20</sup></td><td>mebi</td><td>Mi</td><td>megabinary: (2<sup>10</sup>)<sup>2&nbsp;</sup></td><td>mega: (10<sup>3</sup>)<sup>2</sup></td></tr><tr bgcolor="#D0F0C8"><td>&nbsp;2<sup>30</sup></td><td>gibi</td><td>Gi</td><td>gigabinary: (2<sup>10</sup>)<sup>3</sup></td><td>giga: (10<sup>3</sup>)<sup>3</sup></td></tr><tr><td>&nbsp;2<sup>40</sup></td><td>tebi</td><td>Ti</td><td>terabinary: (2<sup>10</sup>)<sup>4</sup></td><td>tera: (10<sup>3</sup>)<sup>4</sup></td></tr><tr bgcolor="#D0F0C8"><td>&nbsp;2<sup>50</sup></td><td>pebi</td><td>Pi</td><td>petabinary: (2<sup>10</sup>)<sup>5</sup></td><td>peta: (10<sup>3</sup>)<sup>5</sup></td></tr><tr><td>&nbsp;2<sup>60</sup></td><td>exbi</td><td>Ei</td><td>exabinary: (2<sup>10</sup>)<sup>6</sup></td><td>exa: (10<sup>3</sup>)<sup>6</sup></td></tr></tbody></table></td></tr><tr><td colspan="5"><hr noshade="" size="1"></td></tr><tr><td align="CENTER" colspan="5"><table border="0" cellspacing="0" cellpadding="3" width="100%"><tbody><tr><td align="CENTER" colspan="2"><b>Examples and comparisons with SI prefixes</b></td></tr><tr><td align="RIGHT" bgcolor="#D0F0C8">one <b>kibibit</b></td><td bgcolor="#D0F0C8">&nbsp;1 Kibit = 2<sup>10</sup> bit = <b>1024 bit</b></td></tr><tr><td align="RIGHT">one <b>kilobit</b></td><td>&nbsp;1 kbit = 10<sup>3</sup> bit = <b>1000 bit</b></td></tr><tr>  <td align="RIGHT" bgcolor="#D0F0C8">one <strong>byte</strong></td>    <td bgcolor="#D0F0C8">&nbsp;1 B = 2<sup>3</sup> bit = <strong>8 bit</strong></td></tr><tr><td align="RIGHT">one <b>mebibyte</b></td><td>&nbsp;1 MiB = 2<sup>20</sup> B = <b>1 048 576 B</b></td></tr><tr><td align="RIGHT" bgcolor="#D0F0C8">one <b>megabyte</b></td><td bgcolor="#D0F0C8">&nbsp;1 MB = 10<sup>6</sup> B = <b>1 000 000 B</b></td></tr><tr><td align="RIGHT">one <b>gibibyte</b></td><td>&nbsp;1 GiB = 2<sup>30</sup> B = <b>1 073 741 824B</b></td></tr><tr><td align="RIGHT" bgcolor="#D0F0C8">one <b>gigabyte</b></td><td bgcolor="#D0F0C8">&nbsp;1 GB = 10<sup>9</sup> B = <b>1 000 000 000 B</b></td></tr></tbody></table><hr noshade="" size="1"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> concepts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变参函数</title>
      <link href="/blog/2023/11/03/cplusplus/%E5%8F%98%E5%8F%82%E5%87%BD%E6%95%B0/"/>
      <url>/blog/2023/11/03/cplusplus/%E5%8F%98%E5%8F%82%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Variadic-function-in-C"><a href="#Variadic-function-in-C" class="headerlink" title="Variadic function in C"></a>Variadic function in C</h2><p>See more: <a href="https://www.geeksforgeeks.org/variadic-functions-in-c/">Variadic functions in C</a></p><h3 id="vprintf"><a href="#vprintf" class="headerlink" title="vprintf"></a><code>vprintf</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span> </span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="built_in">va_start</span>(args, format);</span><br><span class="line">    <span class="built_in">vprintf</span>(format, args);</span><br><span class="line">    <span class="built_in">va_end</span>(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> time = <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">myPrintf</span>(<span class="string">&quot;Elapsed time is: %ld seconds.\n&quot;</span>, time);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out </span><br><span class="line">Elapsed time is: 100 seconds.</span><br></pre></td></tr></table></figure><h3 id="ap-list-vsnprintf"><a href="#ap-list-vsnprintf" class="headerlink" title="ap_list + vsnprintf"></a><code>ap_list</code> + <code>vsnprintf</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span> <span class="comment">// gettimeofday</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> id, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> MAXLEN = <span class="number">1024</span>;</span><br><span class="line">    <span class="type">char</span> buf[MAXLEN];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">snprintf</span>(buf, MAXLEN, <span class="string">&quot;INFO(%d): &quot;</span>, id);</span><br><span class="line"></span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="comment">// ap will be the pointer to the last fixed argument of the variadic function.</span></span><br><span class="line">    <span class="built_in">va_start</span>(ap, fmt);</span><br><span class="line">    n += <span class="built_in">vsnprintf</span>(buf + n, MAXLEN - n, fmt, ap);</span><br><span class="line">    <span class="comment">// This ends the traversal of the variadic function arguments.</span></span><br><span class="line">    <span class="built_in">va_end</span>(ap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> tv;</span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> tm;</span><br><span class="line">    <span class="built_in">localtime_r</span>(&amp;tv.tv_sec, &amp;tm);</span><br><span class="line">    <span class="type">char</span> timebuf[<span class="number">64</span>];</span><br><span class="line">    <span class="comment">// size_t strftime(char *s, size_t max, const char *format, const struct tm *tm);</span></span><br><span class="line">    <span class="built_in">snprintf</span>(timebuf, MAXLEN - n, <span class="string">&quot;%d-%02d-%02d %d:%d:%d.%ld %s&quot;</span>,</span><br><span class="line">             tm.tm_year + <span class="number">1900</span>, tm.tm_mon + <span class="number">1</span>, tm.tm_mday,</span><br><span class="line">             tm.tm_hour, tm.tm_min, tm.tm_sec, tv.tv_usec, tm.tm_zone);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(buf, timebuf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;Tony&quot;</span>;</span><br><span class="line">    <span class="comment">// &quot;%%s&quot; is a placeholder of the timestamp for the vsnprintf function.</span></span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">123</span>, <span class="string">&quot;Hello %s at %%s\n&quot;</span>, name);</span><br><span class="line">    <span class="comment">// Will print:</span></span><br><span class="line">    <span class="comment">// INFO(123): Hello Tony at 2023-10-04 21:25:23.682853 CST</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="va-list-va-arg"><a href="#va-list-va-arg" class="headerlink" title="va_list + va_arg"></a><code>va_list</code> + <code>va_arg</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> debug = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">printDebugLog</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* fmt, ...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">        <span class="comment">// The first argument doesn&#x27;t need to traverse via va_list.</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fmt=%s\n&quot;</span>, fmt);</span><br><span class="line">        va_list ap;</span><br><span class="line">        <span class="built_in">va_start</span>(ap, fmt);</span><br><span class="line">        <span class="type">long</span> <span class="type">int</span> t = <span class="built_in">va_arg</span>(ap, <span class="type">long</span> <span class="type">int</span>);</span><br><span class="line">        <span class="built_in">va_end</span>(ap);</span><br><span class="line">        <span class="built_in">printf</span>(fmt, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> time = <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">printDebugLog</span>(<span class="string">&quot;Elapsed time is: %ld seconds.\n&quot;</span>, time);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out </span><br><span class="line"><span class="built_in">fmt</span>=Elapsed time is: %ld seconds.</span><br><span class="line"></span><br><span class="line">Elapsed time is: 100 seconds.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c/cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> syntax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 命名空间</title>
      <link href="/blog/2023/11/02/cplusplus/C++%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
      <url>/blog/2023/11/02/cplusplus/C++%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="inline-namespace"><a href="#inline-namespace" class="headerlink" title="inline namespace"></a>inline namespace</h2><p>You can define and specialize members of an <code>inline namespace</code> as if they were also members of the enclosing namespace.<br><code>inline namespace</code> 表示该命名空间也是上级命名空间的成员。<br>参考: <a href="https://www.ibm.com/docs/en/zos/2.2.0?topic=only-inline-namespace-definitions-c11">Inline namespace definitions (C++11)</a></p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_INLINE_B</span></span><br><span class="line">   <span class="keyword">inline</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">   <span class="keyword">namespace</span> B &#123;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">bool</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> A::<span class="built_in">foo</span>(<span class="literal">true</span>); <span class="comment">// 如果USE_INLINE_B为0，则该句出错：找不到定义。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Unnamed-anonymous-namespaces-vs-static-in-namespace"><a href="#Unnamed-anonymous-namespaces-vs-static-in-namespace" class="headerlink" title="Unnamed &#x2F; anonymous namespaces vs static in namespace"></a>Unnamed &#x2F; anonymous namespaces vs static in namespace</h2><p>Refer to: <a href="https://medium.com/pranayaggarwal25/unnamed-namespaces-static-f1498741c527">Unnamed &#x2F; anonymous namespaces vs static in namespace</a></p>]]></content>
      
      
      <categories>
          
          <category> c/cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> syntax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>English idiom</title>
      <link href="/blog/2023/11/02/english/english-idiom/"/>
      <url>/blog/2023/11/02/english/english-idiom/</url>
      
        <content type="html"><![CDATA[<ol><li>at a drop of a hat: 毫不犹豫。见<a href="(https://dictionary.cambridge.org/us/dictionary/english/at-the-drop-of-a-hat)">Cambridge dict</a>.</li><li>beyond your ken: 超过你的认知范畴<br>ken: the range of perception, understanding or knowledge. 参考<a href="https://www.merriam-webster.com/dictionary/ken">词典</a>。</li></ol><blockquote><p>Sheldon: Woman, you’re playing with forces beyond your ken.<br>Penny: Yeah, your ken can kiss my Barbie.</p></blockquote><p>Penny想要气气Sheldon，她故意把ken曲解成玩偶，说：你的ken可以和我芭比娃娃谈恋爱。<br>出处: <a href="https://forum.wordreference.com/threads/your-ken-can-kiss-my-barbie.3999874/">word reference</a>。</p><ol start="3"><li>a rule of thumb: 经验法则。见<a href="https://www.collinsdictionary.com/zh/dictionary/english/a-rule-of-thumb">柯林斯词典</a>。</li><li>vice versa: 反之亦然。近义词：conversely.</li><li>on (a) par with: 相当，对等，可媲美。See more: <a href="https://www.merriam-webster.com/dictionary/on%20%28a%29%20par%20with">on (a) par with</a></li><li>IMHO: In my humble opinion 恕我直言。humble 谦逊的。</li><li>AFAIK: As far as I know 据我所知。</li><li>miss the forest for the trees. &#x2F; not see the forest for the trees. 只见树木、不见森林。参见<a href="https://dictionary.cambridge.org/us/dictionary/english/not-see-the-forest-for-the-trees">剑桥词典</a>：to be unable to get a general understanding of a situation because you are too worried about the details 因太注重细节而无法从整体角度看待问题。</li><li>irrespective of 不论</li><li>sell sb out. 出卖某人。</li><li>mood swings. 情绪波动。 swing v. 摇摆；swings n. 秋千。</li><li>buy that… 相信…… e.g. I didn’t think the doctor was gonna buy that…</li><li>Roger that. &#x2F; Copy that. <a href="https://medium.com/@methark/copy-that-or-roger-that-whats-the-difference-63ad1367ff22">参考</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vocabulary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Muder on The Orient Express</title>
      <link href="/blog/2023/10/28/english/Muder-on-The-Orient-Express/"/>
      <url>/blog/2023/10/28/english/Muder-on-The-Orient-Express/</url>
      
        <content type="html"><![CDATA[<h2 id="人物"><a href="#人物" class="headerlink" title="人物"></a>人物</h2><p>Daisy Armstrong<br>Miss Mary Debenham<br>Colonel Arbuthnott<br>Hercule Poirot<br>Lieutenant Dubosc</p><h2 id="台词"><a href="#台词" class="headerlink" title="台词"></a>台词</h2><p>1930<br>The Armstrong Home, Long Island, N.Y.</p><p>Armstrong Baby Kidnapped.<br>Crushed toys, crushed hopes.</p><p>Baby taken in dead of night.<br>Armstrong Household Turmoil.<br>Baby Daisy Taken from Armstrong Home.<br>Staff Wakened But Hopeless.</p><p>DAISY ARMSTRONG - Child of Colonel and Mrs. Hamish Armstrong was dramatically kidnapped last night while her parents were being driven to the airport by their chauffeur.</p><p>The discover of the missing child was made by the chauffeur on returning from the airport where he found the family nurse bound and gagged in the room next to Baby Daisy’s bedroom.</p><p>The police were informed immediately and investigations began at once. They described kidnapping as one of the most vicious crimous that can be commited.</p><p>Daisy found slain.</p><p>5 years later<br>The Asian side of Istanbul.</p><p>Miss Mary Debenham</p><p>Salacak</p><p>Welcome aboard.</p><p>Bosporus Ferry will shortly depart from Istanbul Sirkeci Station, connecting with the Orient Express.</p><p>Here’s your ticket, Monsieur Poirot. I’m afraid you’ve still got another hour.</p><p>Well, then, please do not wait.</p><p>Not wait? After all you’ve done for us, Monsieur Poriot? My general’s orders were to ensure your safe departure. He also wished me to thank you again for saving the honor of the British garrison in Jordan. The brigadier’s confession was opportune. I say, how did you do it? Was it the old thumbscrew, you know, the rack?</p><p>Chop-chop</p><p>I hope we did the right thing booking you into a hotel on the European side rather than the Asia side.<br>我希望我们给你预订的是欧洲酒店而不是亚洲酒店是正确的。</p><p>I have no prejudice with either continent.</p><p>The crossing should be pleasant. The Borporus is always calm.<br>穿行应该会很愉快。博斯普鲁斯海峡总是很平静。</p><p>You have crossed by the ferry?<br>你乘渡船穿渡过？</p><h2 id="词汇"><a href="#词汇" class="headerlink" title="词汇"></a>词汇</h2><p>Daisy: 雏菊；人名（黛西）。<br>kidnapped: 绑架<br>crushed: 破灭的，压碎的<br>dead of night: 深夜时分，the quietest, darkest part of the night.<br>household: 家庭；户；家；家族；家人<br>turmoil: n. 动荡；动乱<br>staff: 工作人员。<br>wakened: waken v. 醒来。wakened 是waken的过去式和过去分词。<br>chauffeur: 美&#x2F;ʃoʊˈfɝː&#x2F; 英&#x2F;ˈʃəʊ.fər&#x2F; 司机。<br>bound: 这里是bind的过去式和过去分词，绑定、捆绑。<br>gag: n.&#x2F;v. 堵嘴；插科打诨。<br>vicious: 恶毒的。<br>slay: To kill in a violent way. 残忍杀害。<br>Istanbul: 伊斯坦布尔，为土耳其首都直至1923年。<br>Salacak: garrison: A group of soliders living in or defending a town or building, or the building that the soliders live in. 守军；守备营地。<br>Jordan: 约旦（西亚国家）。<br>brigadier: 英&#x2F;ˌbrɪɡəˈdɪə(r)&#x2F; 美&#x2F;ˌbrɪɡəˈdɪr&#x2F; 准将。<br>confession: n. 坦白；忏悔；认罪。<br>opportune: 英&#x2F;ˈɒpətjuːn&#x2F; 美&#x2F;ˌɑːpərˈtuːn&#x2F; 适当的；及时的。<br>thumbscrew: 螺丝；拧紧 。<br>rack: chop-chop: chop v.&#x2F;n. 砍；向下猛击。chop-chop 赶快，快点。<br>Bosporus Strait: 博斯普鲁斯海峡，又称伊斯坦布尔海峡，介于欧洲与亚洲之间的海峡。它长约30公里，最宽处宽约3,700米，最窄处宽约700米。北连黑海，南通马尔马拉海（土耳其内海），土耳其第一大城伊斯坦堡即隔着博斯普鲁斯海峡与小亚细亚半岛相望，是黑海沿岸国家出海第一关口，也是连接黑海以及地中海的唯一航道。因此，俄罗斯的黑海舰队必须通过博斯普鲁斯海峡才能前往地中海。<br>ferry: n.&#x2F;v. 渡船；摆渡</p>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> movie </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
