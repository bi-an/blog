<!DOCTYPE html>
<html lang="en, zh_CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"bi-an.github.io","root":"/blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="江南人物的博客">
<meta property="og:url" content="https://bi-an.github.io/blog/index.html">
<meta property="og:site_name" content="江南人物的博客">
<meta property="og:locale">
<meta property="article:author" content="bi-an">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://bi-an.github.io/blog/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en, zh_CN'
  };
</script>

  <title>江南人物的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">江南人物的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/12/02/perf/numa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/12/02/perf/numa/" class="post-title-link" itemprop="url">NUMA节点详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-12-02 13:44:25 / Modified: 14:58:39" itemprop="dateCreated datePublished" datetime="2025-12-02T13:44:25+00:00">2025-12-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-NUMA概念"><a href="#1-NUMA概念" class="headerlink" title="1. NUMA概念"></a>1. NUMA概念</h2><p>NUMA（Non-Uniform Memory Access，非统一内存访问）是一种计算机内存设计架构，主要用于多处理器系统中。</p>
<p>在NUMA架构中：</p>
<ul>
<li>每个CPU处理器都有本地内存（Local Memory），访问速度较快</li>
<li>每个CPU也可以访问其他CPU的内存（Remote Memory），但访问速度较慢</li>
<li>多个CPU和其本地内存组成一个NUMA节点（NUMA Node）</li>
<li>系统通过NUMA拓扑来管理内存和CPU的分配</li>
</ul>
<p><strong>NUMA架构的优势：</strong></p>
<ul>
<li>减少内存访问延迟（本地内存访问更快）</li>
<li>提高系统整体性能</li>
<li>支持更大规模的多处理器系统</li>
</ul>
<p><strong>NUMA架构的挑战：</strong></p>
<ul>
<li>需要合理分配进程和内存到对应的NUMA节点</li>
<li>跨节点访问内存会带来性能损失</li>
<li>需要应用程序或系统管理员进行优化</li>
</ul>
<h2 id="2-CPU亲和性概念"><a href="#2-CPU亲和性概念" class="headerlink" title="2. CPU亲和性概念"></a>2. CPU亲和性概念</h2><p><strong>CPU亲和性（CPU Affinity）</strong>是指将进程或线程绑定到特定的CPU核心上运行的机制。通过设置CPU亲和性，可以：</p>
<ol>
<li><strong>提高缓存命中率</strong>：进程始终运行在同一个CPU核心上，可以更好地利用CPU的L1&#x2F;L2&#x2F;L3缓存</li>
<li><strong>减少进程迁移开销</strong>：避免进程在不同CPU核心间频繁迁移带来的性能损失</li>
<li><strong>资源隔离</strong>：将不同进程绑定到不同CPU核心，实现资源隔离和负载均衡</li>
</ol>
<p><strong>CPU亲和性的类型：</strong></p>
<ul>
<li><strong>硬亲和性（Hard Affinity）</strong>：强制绑定，进程&#x2F;线程<strong>只能</strong>运行在指定的CPU核心上，调度器会严格遵循这个限制<ul>
<li>例如：如果绑定到CPU 0，进程&#x2F;线程就<strong>只能</strong>调度到CPU 0上运行，<strong>不能</strong>调度到CPU 1或其他CPU核心上</li>
<li>通过 <code>sched_setaffinity()</code>、<code>taskset</code>、<code>numactl --cpunodebind</code>、<code>cgroup cpuset.cpus</code> 等方法设置</li>
</ul>
</li>
<li><strong>软亲和性（Soft Affinity）</strong>：偏好设置，系统会尽量将进程调度到指定的CPU核心，但不强制<ul>
<li>这是调度器的默认行为，在没有显式设置CPU亲和性时，调度器会尽量保持进程在同一个CPU核心上运行</li>
</ul>
</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li>CPU亲和性设置会影响操作系统的调度器行为</li>
<li>过度绑定可能导致CPU负载不均衡</li>
<li>即使通过硬亲和性强制绑定到单个CPU核心，进程仍可能创建多个线程，这些线程会在该CPU核心上通过时间片轮转的方式轮流调度执行</li>
</ul>
<p><strong>并行库适配说明：</strong></p>
<p>CPU绑定（如 <code>taskset</code>、<code>sched_setaffinity</code>、<code>numactl --cpunodebind</code>）是<strong>硬亲和性</strong>（强制性的），能有效限制并行库的线程数。例如，TBB（Threading Building Blocks）在初始化时会根据操作系统报告的硬件资源（通过 <code>sysconf(_SC_NPROCESSORS_ONLN)</code> 等API）来决定线程池大小和调度策略。如果使用 <code>taskset</code> 或 <code>numactl</code> 将进程绑定到部分CPU核心，TBB只会看到这些CPU核心，从而自动调整线程池大小。这意味着通过限制可见的CPU资源，可以间接控制并行库的行为。</p>
<p><strong>NUMA架构下CPU亲和性的特殊性：</strong></p>
<p>在NUMA架构系统中，CPU亲和性具有特殊的重要性：</p>
<ol>
<li><p><strong>内存访问性能依赖CPU位置</strong>：</p>
<ul>
<li>进程运行在节点A的CPU上，如果内存分配在节点B，会产生远程内存访问，性能显著下降</li>
<li>因此，NUMA架构下的CPU亲和性设置必须配合内存分配策略，才能获得最佳性能</li>
</ul>
</li>
<li><p><strong>节点级别的CPU绑定</strong>：</p>
<ul>
<li>在NUMA系统中，通常以NUMA节点为单位进行CPU绑定，而不是单个CPU核心</li>
<li>绑定到某个NUMA节点的CPU意味着可以使用该节点的所有CPU核心，同时配合该节点的本地内存</li>
</ul>
</li>
<li><p><strong>CPU亲和性与内存策略的协同</strong>：</p>
<ul>
<li>仅设置CPU亲和性而不设置内存策略可能导致远程内存访问</li>
<li>NUMA优化需要同时考虑CPU绑定和内存分配策略</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：NUMA架构是CPU亲和性在多处理器系统中的特殊应用场景。在NUMA系统中，CPU亲和性不仅影响CPU调度，还直接影响内存访问性能，因此需要与内存分配策略协同使用。</p>
<h2 id="3-CPU亲和性的设置"><a href="#3-CPU亲和性的设置" class="headerlink" title="3. CPU亲和性的设置"></a>3. CPU亲和性的设置</h2><h3 id="方法对比总览"><a href="#方法对比总览" class="headerlink" title="方法对比总览"></a>方法对比总览</h3><table>
<thead>
<tr>
<th>方法</th>
<th>易用性</th>
<th>NUMA感知</th>
<th>内存控制</th>
<th>CPU绑定类型</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>taskset</strong></td>
<td>⭐⭐⭐⭐⭐</td>
<td>❌</td>
<td>❌</td>
<td>✅ 硬亲和性</td>
<td>简单CPU绑定</td>
</tr>
<tr>
<td><strong>sched_setaffinity</strong></td>
<td>⭐⭐⭐</td>
<td>❌</td>
<td>❌</td>
<td>✅ 硬亲和性</td>
<td>程序内部控制</td>
</tr>
<tr>
<td><strong>cgroup</strong></td>
<td>⭐⭐</td>
<td>✅</td>
<td>✅</td>
<td>✅ 硬亲和性</td>
<td>系统级资源管理</td>
</tr>
<tr>
<td><strong>numactl</strong></td>
<td>⭐⭐⭐⭐</td>
<td>✅</td>
<td>✅</td>
<td>✅ 硬亲和性</td>
<td>NUMA优化（详见NUMA章节）</td>
</tr>
</tbody></table>
<h3 id="方法一：taskset（通用CPU绑定）"><a href="#方法一：taskset（通用CPU绑定）" class="headerlink" title="方法一：taskset（通用CPU绑定）"></a>方法一：taskset（通用CPU绑定）</h3><p><code>taskset</code> 是一个用于设置或查看进程CPU亲和性的命令行工具，适用于所有系统（包括非NUMA系统）。</p>
<p><strong>基本用法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看进程的CPU亲和性</span></span><br><span class="line">taskset -p &lt;pid&gt;</span><br><span class="line">taskset -<span class="built_in">cp</span> &lt;pid&gt;  <span class="comment"># 更易读的格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置进程的CPU亲和性（使用CPU掩码）</span></span><br><span class="line">taskset -p 0x3 &lt;pid&gt;  <span class="comment"># 绑定到CPU 0和1（二进制：11）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用CPU列表格式</span></span><br><span class="line">taskset -<span class="built_in">cp</span> 0,1,2,3 &lt;pid&gt;  <span class="comment"># 绑定到CPU 0,1,2,3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动新进程并设置CPU亲和性</span></span><br><span class="line">taskset -c 0-3 ./your_program  <span class="comment"># 绑定到CPU 0-3</span></span><br><span class="line">taskset -c 0,2,4,6 ./your_program  <span class="comment"># 绑定到CPU 0,2,4,6</span></span><br></pre></td></tr></table></figure>

<p><strong>taskset的特点：</strong></p>
<ul>
<li>✅ 简单易用，命令行工具</li>
<li>✅ 直接指定CPU编号，精确控制</li>
<li>✅ CPU绑定是<strong>硬亲和性</strong>（强制绑定）</li>
<li>❌ 不感知NUMA拓扑结构</li>
<li>❌ 无法控制内存分配策略</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>非NUMA系统（单节点系统）</li>
<li>只需要简单的CPU绑定，不关心内存位置</li>
<li>系统没有NUMA架构</li>
</ul>
<h3 id="方法二：sched-setaffinity系统调用"><a href="#方法二：sched-setaffinity系统调用" class="headerlink" title="方法二：sched_setaffinity系统调用"></a>方法二：sched_setaffinity系统调用</h3><p><code>sched_setaffinity()</code> 是Linux系统提供的系统调用，用于设置进程或线程的CPU亲和性。这是 <code>taskset</code> 命令的底层实现。</p>
<p><strong>C语言示例：</strong></p>
<figure class="highlight c"><figcaption><span>sched_setaffinity.c</span><a href="/blog/downloads/code/perf/numa/sched_setaffinity.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">cpu_set_t</span> cpuset;</span><br><span class="line">    CPU_ZERO(&amp;cpuset);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置CPU亲和性：绑定到CPU 0和1</span></span><br><span class="line">    CPU_SET(<span class="number">0</span>, &amp;cpuset);</span><br><span class="line">    CPU_SET(<span class="number">1</span>, &amp;cpuset);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置当前进程的CPU亲和性</span></span><br><span class="line">    <span class="keyword">if</span> (sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(cpuset), &amp;cpuset) != <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">&quot;sched_setaffinity failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证设置结果</span></span><br><span class="line">    CPU_ZERO(&amp;cpuset);</span><br><span class="line">    <span class="keyword">if</span> (sched_getaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(cpuset), &amp;cpuset) != <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">&quot;sched_getaffinity failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程绑定到CPU: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CPU_SETSIZE; i++) {</span><br><span class="line">        <span class="keyword">if</span> (CPU_ISSET(i, &amp;cpuset)) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p><strong>多线程示例：</strong></p>
<figure class="highlight c"><figcaption><span>sched_setaffinity_threads.c</span><a href="/blog/downloads/code/perf/numa/sched_setaffinity_threads.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREADS 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">worker_thread</span><span class="params">(<span class="type">void</span> *arg)</span> {</span><br><span class="line">    <span class="type">int</span> thread_id = *(<span class="type">int</span> *)arg;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpuset;</span><br><span class="line">    CPU_ZERO(&amp;cpuset);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每个线程绑定到不同的CPU</span></span><br><span class="line">    CPU_SET(thread_id, &amp;cpuset);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置线程的CPU亲和性</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_setaffinity_np(pthread_self(), <span class="keyword">sizeof</span>(cpuset), &amp;cpuset) != <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">&quot;pthread_setaffinity_np failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前运行的CPU</span></span><br><span class="line">    <span class="type">int</span> cpu = sched_getcpu();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程 %d 运行在CPU %d\n&quot;</span>, thread_id, cpu);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">    <span class="type">int</span> thread_ids[NUM_THREADS];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) {</span><br><span class="line">        thread_ids[i] = i;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, worker_thread, &amp;thread_ids[i]);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) {</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>编译命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o sched_affinity sched_affinity.c -lpthread</span><br></pre></td></tr></table></figure>

<p><strong>API说明：</strong></p>
<ul>
<li><code>sched_setaffinity(pid_t pid, size_t cpusetsize, const cpu_set_t *mask)</code>：设置进程的CPU亲和性<ul>
<li><code>pid = 0</code>：设置当前进程</li>
<li><code>pid &gt; 0</code>：设置指定进程</li>
</ul>
</li>
<li><code>sched_getaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask)</code>：获取进程的CPU亲和性</li>
<li><code>pthread_setaffinity_np(pthread_t thread, size_t cpusetsize, const cpu_set_t *mask)</code>：设置线程的CPU亲和性</li>
<li><code>pthread_getaffinity_np(pthread_t thread, size_t cpusetsize, cpu_set_t *mask)</code>：获取线程的CPU亲和性</li>
</ul>
<p><strong>sched_setaffinity的特点：</strong></p>
<ul>
<li>✅ 系统级API，功能强大</li>
<li>✅ 可以在程序内部精确控制CPU绑定</li>
<li>✅ 支持进程和线程级别的绑定</li>
<li>✅ CPU绑定是<strong>硬亲和性</strong>（强制绑定）</li>
<li>❌ 需要编写代码，不如命令行工具方便</li>
<li>❌ 不感知NUMA拓扑</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>需要在程序运行时动态调整CPU绑定</li>
<li>需要为不同线程设置不同的CPU亲和性</li>
<li>需要精确控制CPU绑定的应用程序</li>
</ul>
<h3 id="方法三：cgroup（系统级资源管理）"><a href="#方法三：cgroup（系统级资源管理）" class="headerlink" title="方法三：cgroup（系统级资源管理）"></a>方法三：cgroup（系统级资源管理）</h3><p>cgroup是Linux内核提供的资源管理机制，可以通过cgroup v1或cgroup v2来限制进程组的CPU使用。</p>
<p><strong>cgroup v1方法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建cgroup</span></span><br><span class="line">sudo <span class="built_in">mkdir</span> -p /sys/fs/cgroup/cpuset/mygroup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置可用的CPU核心（例如CPU 0-3）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0-3&quot;</span> | sudo <span class="built_in">tee</span> /sys/fs/cgroup/cpuset/mygroup/cpuset.cpus</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置内存节点（NUMA节点，如果系统支持）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0&quot;</span> | sudo <span class="built_in">tee</span> /sys/fs/cgroup/cpuset/mygroup/cpuset.mems</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将进程添加到cgroup</span></span><br><span class="line"><span class="built_in">echo</span> &lt;pid&gt; | sudo <span class="built_in">tee</span> /sys/fs/cgroup/cpuset/mygroup/cgroup.procs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者启动新进程</span></span><br><span class="line">sudo cgexec -g cpuset:mygroup ./your_program</span><br></pre></td></tr></table></figure>

<p><strong>cgroup v2方法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 挂载cgroup v2（如果未挂载）</span></span><br><span class="line">sudo mount -t cgroup2 none /sys/fs/cgroup2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建cgroup</span></span><br><span class="line">sudo <span class="built_in">mkdir</span> -p /sys/fs/cgroup2/mygroup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置CPU范围（例如CPU 0-3）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0-3&quot;</span> | sudo <span class="built_in">tee</span> /sys/fs/cgroup2/mygroup/cpuset.cpus</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置内存节点（如果系统支持）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0&quot;</span> | sudo <span class="built_in">tee</span> /sys/fs/cgroup2/mygroup/cpuset.mems</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将进程添加到cgroup</span></span><br><span class="line"><span class="built_in">echo</span> &lt;pid&gt; | sudo <span class="built_in">tee</span> /sys/fs/cgroup2/mygroup/cgroup.procs</span><br></pre></td></tr></table></figure>

<p><strong>systemd使用cgroup：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建systemd服务单元文件</span></span><br><span class="line">sudo systemd-run --unit=myapp --scope \</span><br><span class="line">    --property=CPUSetCPUs=0-3 \</span><br><span class="line">    --property=CPUSetMems=0 \</span><br><span class="line">    ./your_program</span><br></pre></td></tr></table></figure>

<p><strong>cgroup的特点：</strong></p>
<ul>
<li>✅ 系统级资源管理，功能强大</li>
<li>✅ 支持NUMA感知（可以设置内存节点）</li>
<li>✅ 可以同时管理CPU和内存</li>
<li>✅ 支持进程组管理</li>
<li>✅ <strong>硬亲和性</strong>（强制绑定），保证进程组只在指定CPU上运行</li>
<li>⚠️ 需要root权限</li>
<li>⚠️ 配置相对复杂</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>容器化环境（Docker、Kubernetes等）</li>
<li>需要同时管理多个进程的资源分配</li>
<li>需要持久化的资源限制配置</li>
<li>系统级资源管理需求</li>
</ul>
<h2 id="4-NUMA的设置"><a href="#4-NUMA的设置" class="headerlink" title="4. NUMA的设置"></a>4. NUMA的设置</h2><h3 id="查询和监控NUMA信息"><a href="#查询和监控NUMA信息" class="headerlink" title="查询和监控NUMA信息"></a>查询和监控NUMA信息</h3><h4 id="1-查看NUMA节点拓扑"><a href="#1-查看NUMA节点拓扑" class="headerlink" title="1. 查看NUMA节点拓扑"></a>1. 查看NUMA节点拓扑</h4><p>使用 <code>numactl --hardware</code> 命令查看NUMA硬件信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ numactl --hardware</span><br><span class="line">available: 2 nodes (0-1)</span><br><span class="line">node 0 cpus: 0 1 2 3 8 9 10 11</span><br><span class="line">node 0 size: 16384 MB</span><br><span class="line">node 0 free: 1024 MB</span><br><span class="line">node 1 cpus: 4 5 6 7 12 13 14 15</span><br><span class="line">node 1 size: 16384 MB</span><br><span class="line">node 1 free: 2048 MB</span><br><span class="line">node distances:</span><br><span class="line">node   0   1</span><br><span class="line">  0:  10  21</span><br><span class="line">  1:  21  10</span><br></pre></td></tr></table></figure>

<p><strong>结果说明：</strong></p>
<ul>
<li><code>available: 2 nodes (0-1)</code>: 系统有2个NUMA节点，编号为0和1</li>
<li><code>node 0 cpus: 0 1 2 3 8 9 10 11</code>: 节点0包含的CPU核心编号</li>
<li><code>node 0 size: 16384 MB</code>: 节点0的内存大小（16GB）</li>
<li><code>node 0 free: 1024 MB</code>: 节点0的可用内存</li>
<li><code>node distances</code>: 节点间访问距离矩阵<ul>
<li>节点0到节点0的距离是10（本地访问）</li>
<li>节点0到节点1的距离是21（远程访问，距离越大性能越差）</li>
</ul>
</li>
</ul>
<h4 id="2-查看CPU和NUMA节点的映射关系"><a href="#2-查看CPU和NUMA节点的映射关系" class="headerlink" title="2. 查看CPU和NUMA节点的映射关系"></a>2. 查看CPU和NUMA节点的映射关系</h4><p>使用 <code>lscpu</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ lscpu | grep -i numa</span><br><span class="line">NUMA node(s):          2</span><br><span class="line">NUMA node0 CPU(s):     0-3,8-11</span><br><span class="line">NUMA node1 CPU(s):     4-7,12-15</span><br></pre></td></tr></table></figure>

<h4 id="3-查看NUMA统计信息"><a href="#3-查看NUMA统计信息" class="headerlink" title="3. 查看NUMA统计信息"></a>3. 查看NUMA统计信息</h4><p>使用 <code>numastat</code> 查看NUMA统计信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ numastat</span><br><span class="line">                           node0           node1</span><br><span class="line">numa_hit             12345678901     23456789012</span><br><span class="line">numa_miss              123456789       234567890</span><br><span class="line">numa_foreign           234567890       123456789</span><br><span class="line">interleave_hit             12345           12345</span><br><span class="line">local_node           12345678901     23456789012</span><br><span class="line">other_node              123456789       234567890</span><br></pre></td></tr></table></figure>

<h4 id="4-查看进程的NUMA策略"><a href="#4-查看进程的NUMA策略" class="headerlink" title="4. 查看进程的NUMA策略"></a>4. 查看进程的NUMA策略</h4><p>使用 <code>numactl --show</code> 查看当前进程的NUMA策略：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ numactl --show</span><br><span class="line">policy: default</span><br><span class="line">preferred node: current</span><br><span class="line">physcpubind: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15</span><br><span class="line">cpubind: 0 1</span><br><span class="line">nodebind: 0 1</span><br><span class="line">membind: 0 1</span><br></pre></td></tr></table></figure>

<h4 id="5-查看系统NUMA节点详细信息"><a href="#5-查看系统NUMA节点详细信息" class="headerlink" title="5. 查看系统NUMA节点详细信息"></a>5. 查看系统NUMA节点详细信息</h4><p>查看 <code>/sys/devices/system/node/</code> 目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> /sys/devices/system/node/</span><br><span class="line">node0  node1</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> /sys/devices/system/node/node0/cpulist</span><br><span class="line">0-3,8-11</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> /sys/devices/system/node/node0/meminfo</span><br><span class="line">Node 0 MemTotal:       16777216 kB</span><br><span class="line">Node 0 MemFree:         1048576 kB</span><br><span class="line">Node 0 MemUsed:       15728640 kB</span><br></pre></td></tr></table></figure>

<h3 id="numactl：NUMA架构下的CPU亲和性和内存策略工具"><a href="#numactl：NUMA架构下的CPU亲和性和内存策略工具" class="headerlink" title="numactl：NUMA架构下的CPU亲和性和内存策略工具"></a>numactl：NUMA架构下的CPU亲和性和内存策略工具</h3><p><code>numactl</code> 是NUMA架构优化的首选工具，可以同时控制CPU和内存分配策略。</p>
<p><strong>基本用法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将进程绑定到节点0的CPU和内存（CPU是硬亲和性，内存是强制绑定）</span></span><br><span class="line">numactl --cpunodebind=0 --membind=0 ./your_program</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用节点0的CPU（硬亲和性），但允许使用所有节点的内存</span></span><br><span class="line">numactl --cpunodebind=0 ./your_program</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用节点0和1的CPU（硬亲和性），优先使用节点0的内存（偏好设置）</span></span><br><span class="line">numactl --cpunodebind=0,1 --preferred=0 ./your_program</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只绑定内存到节点0（强制绑定），CPU可以使用所有节点</span></span><br><span class="line">numactl --membind=0 ./your_program</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交错分配内存到多个节点</span></span><br><span class="line">numactl --interleave=all ./your_program</span><br></pre></td></tr></table></figure>

<p><strong>numactl选项说明：</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>CPU绑定类型</th>
<th>内存绑定类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>--cpunodebind=&lt;nodes&gt;</code></td>
<td>✅ <strong>硬亲和性（强制绑定）</strong></td>
<td>-</td>
<td>进程只能运行在指定节点的CPU上</td>
</tr>
<tr>
<td><code>--membind=&lt;nodes&gt;</code></td>
<td>-</td>
<td>✅ <strong>强制绑定</strong></td>
<td>内存只能从指定节点分配</td>
</tr>
<tr>
<td><code>--preferred=&lt;node&gt;</code></td>
<td>-</td>
<td>⚠️ <strong>偏好设置</strong></td>
<td>优先从指定节点分配内存，但允许从其他节点分配</td>
</tr>
<tr>
<td><code>--interleave=&lt;nodes&gt;</code></td>
<td>-</td>
<td>⚠️ <strong>交错分配</strong></td>
<td>在指定节点间轮询分配内存</td>
</tr>
<tr>
<td><code>--localalloc</code></td>
<td>-</td>
<td>⚠️ <strong>本地优先</strong></td>
<td>优先在本地节点分配内存</td>
</tr>
</tbody></table>
<p><strong>详细说明：</strong></p>
<ul>
<li><code>--cpunodebind=&lt;nodes&gt;</code>：将进程绑定到指定NUMA节点的CPU（硬亲和性，强制绑定）<ul>
<li>示例：<code>--cpunodebind=0</code> 绑定到节点0的所有CPU</li>
<li>示例：<code>--cpunodebind=0,1</code> 绑定到节点0和1的所有CPU</li>
</ul>
</li>
<li><code>--membind=&lt;nodes&gt;</code>：设置内存分配策略为强制绑定到指定节点（强制）<ul>
<li>示例：<code>--membind=0</code> 内存只能从节点0分配</li>
<li>如果节点0内存不足，进程可能无法运行</li>
</ul>
</li>
<li><code>--preferred=&lt;node&gt;</code>：设置内存分配偏好节点（偏好设置）<ul>
<li>示例：<code>--preferred=0</code> 优先从节点0分配内存</li>
<li>如果节点0内存不足，允许从其他节点分配</li>
</ul>
</li>
<li><code>--interleave=&lt;nodes&gt;</code>：在多个节点间交错分配内存<ul>
<li>示例：<code>--interleave=0,1</code> 在节点0和1间轮询分配</li>
<li>适用于需要均匀使用多个节点内存的场景</li>
</ul>
</li>
</ul>
<p><strong>taskset与numactl的区别：</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>taskset</th>
<th>numactl</th>
</tr>
</thead>
<tbody><tr>
<td><strong>主要功能</strong></td>
<td>CPU亲和性设置</td>
<td>NUMA节点和内存策略管理</td>
</tr>
<tr>
<td><strong>CPU绑定</strong></td>
<td>✅ 支持（基于CPU编号）</td>
<td>✅ 支持（基于NUMA节点）</td>
</tr>
<tr>
<td><strong>内存管理</strong></td>
<td>❌ 不支持</td>
<td>✅ 支持（内存节点绑定）</td>
</tr>
<tr>
<td><strong>NUMA感知</strong></td>
<td>❌ 不感知NUMA拓扑</td>
<td>✅ 完全NUMA感知</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>简单的CPU绑定需求</td>
<td>NUMA架构优化</td>
</tr>
</tbody></table>
<p><strong>关键区别：</strong></p>
<ol>
<li><p><strong>CPU绑定方式不同</strong>：</p>
<ul>
<li><code>taskset</code>：直接指定CPU编号（如CPU 0, 1, 2, 3）</li>
<li><code>numactl</code>：基于NUMA节点指定（如节点0，自动包含该节点的所有CPU）</li>
</ul>
</li>
<li><p><strong>内存管理能力</strong>：</p>
<ul>
<li><code>taskset</code>：<strong>无法控制内存分配</strong>，进程可能从任意NUMA节点分配内存</li>
<li><code>numactl</code>：可以控制内存分配策略，确保内存分配在特定NUMA节点</li>
</ul>
</li>
<li><p><strong>NUMA架构优化</strong>：</p>
<ul>
<li><code>taskset</code>：在NUMA系统中，即使绑定了CPU，内存仍可能从远程节点分配，导致性能问题</li>
<li><code>numactl</code>：可以同时绑定CPU和内存，确保本地内存访问，获得最佳性能</li>
</ul>
</li>
</ol>
<p><strong>实际示例对比：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用taskset：只绑定CPU，不控制内存</span></span><br><span class="line">taskset -c 0-3 ./program</span><br><span class="line"><span class="comment"># 问题：CPU在节点0，但内存可能从节点1分配（远程访问，性能差）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用numactl：同时绑定CPU和内存</span></span><br><span class="line">numactl --cpunodebind=0 --membind=0 ./program</span><br><span class="line"><span class="comment"># 优势：CPU和内存都在节点0（本地访问，性能好）</span></span><br></pre></td></tr></table></figure>

<h3 id="NUMA函数和命令对比"><a href="#NUMA函数和命令对比" class="headerlink" title="NUMA函数和命令对比"></a>NUMA函数和命令对比</h3><p>下表列出了常用的NUMA相关函数和命令，以及它们的作用和绑定类型：</p>
<table>
<thead>
<tr>
<th>函数&#x2F;命令</th>
<th>作用</th>
<th>绑定类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>numa_alloc_onnode()</code></td>
<td>在指定NUMA节点分配内存</td>
<td>✅ <strong>强制保证</strong></td>
<td>内存一定分配在指定节点上，失败返回NULL</td>
</tr>
<tr>
<td><code>numa_sched_setaffinity()</code></td>
<td>设置进程&#x2F;线程的CPU亲和性</td>
<td>✅ <strong>硬亲和性</strong></td>
<td>进程&#x2F;线程只能运行在指定的CPU核心上</td>
</tr>
<tr>
<td><code>numactl --cpunodebind</code></td>
<td>绑定进程到指定节点的CPU</td>
<td>✅ <strong>硬亲和性</strong></td>
<td>进程只能运行在指定节点的CPU上</td>
</tr>
<tr>
<td><code>numactl --membind</code></td>
<td>绑定进程的内存分配策略</td>
<td>✅ <strong>强制绑定</strong></td>
<td>内存只能从指定节点分配，失败则进程无法运行</td>
</tr>
<tr>
<td><code>numa_run_on_node()</code></td>
<td>绑定进程到指定节点（CPU+内存）</td>
<td>⚠️ <strong>混合</strong></td>
<td>CPU绑定是硬亲和性，内存分配是偏好设置</td>
</tr>
<tr>
<td><code>numactl --preferred</code></td>
<td>设置内存分配偏好节点</td>
<td>⚠️ <strong>偏好设置</strong></td>
<td>优先从指定节点分配，但允许从其他节点分配</td>
</tr>
<tr>
<td><code>malloc()</code> &#x2F; <code>calloc()</code></td>
<td>普通内存分配</td>
<td>⚠️ <strong>受策略影响</strong></td>
<td>在<code>numa_run_on_node()</code>后，会优先在绑定节点分配，但不保证</td>
</tr>
<tr>
<td><code>set_mempolicy()</code></td>
<td>设置内存分配策略</td>
<td>取决于策略类型</td>
<td><code>MPOL_BIND</code>强制，<code>MPOL_PREFERRED</code>偏好，<code>MPOL_INTERLEAVE</code>交错</td>
</tr>
<tr>
<td><code>numa_node_to_cpus()</code></td>
<td>获取节点的CPU列表</td>
<td>✅ <strong>查询函数</strong></td>
<td>仅查询，不设置任何策略</td>
</tr>
<tr>
<td><code>get_mempolicy()</code></td>
<td>获取内存策略</td>
<td>✅ <strong>查询函数</strong></td>
<td>仅查询，不设置任何策略</td>
</tr>
</tbody></table>
<p><strong>关键区别说明：</strong></p>
<ol>
<li><p><strong>强制保证 vs 偏好设置</strong>：</p>
<ul>
<li><strong>强制保证（硬亲和性）</strong>：系统会严格遵循设置，如果无法满足（如内存不足），操作会失败</li>
<li><strong>偏好设置（软亲和性）</strong>：系统会尽量满足设置，但在资源不足时允许从其他节点分配，不会失败</li>
</ul>
</li>
<li><p><strong><code>numa_run_on_node()</code>的特殊性</strong>：</p>
<ul>
<li>CPU绑定是<strong>强制的（硬亲和性）</strong>：进程只能运行在指定节点的CPU上</li>
<li>内存分配是<strong>偏好的</strong>：优先在指定节点分配，但允许从其他节点分配</li>
<li>这是为了平衡性能和可用性：如果绑定节点内存不足，进程仍能正常运行</li>
</ul>
</li>
<li><p><strong>内存分配策略类型</strong>：</p>
<ul>
<li><code>MPOL_BIND</code>（对应<code>--membind</code>）：强制绑定，内存必须从指定节点分配</li>
<li><code>MPOL_PREFERRED</code>（对应<code>--preferred</code>）：偏好设置，优先从指定节点分配</li>
<li><code>MPOL_INTERLEAVE</code>：交错分配，在多个节点间轮询分配</li>
<li><code>MPOL_DEFAULT</code>：默认策略，由系统决定</li>
</ul>
</li>
</ol>
<p><strong>使用建议：</strong></p>
<ul>
<li>需要<strong>严格保证</strong>内存位置：使用 <code>numa_alloc_onnode()</code> 或 <code>numactl --membind</code></li>
<li>需要<strong>高性能但允许灵活性</strong>：使用 <code>numa_run_on_node()</code> 或 <code>numactl --preferred</code></li>
<li>需要<strong>精确控制CPU（硬亲和性）</strong>：使用 <code>numactl --cpunodebind</code>、<code>numa_sched_setaffinity()</code> 或 <code>taskset</code></li>
<li>需要<strong>系统级强制CPU绑定（硬亲和性）</strong>：使用 <code>cgroup</code> 的 <code>cpuset.cpus</code></li>
</ul>
<h3 id="编程示例"><a href="#编程示例" class="headerlink" title="编程示例"></a>编程示例</h3><h4 id="示例1：C语言中使用libnuma库"><a href="#示例1：C语言中使用libnuma库" class="headerlink" title="示例1：C语言中使用libnuma库"></a>示例1：C语言中使用libnuma库</h4><figure class="highlight c"><figcaption><span>numa_basic.c</span><a href="/blog/downloads/code/perf/numa/numa_basic.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numa.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numaif.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 检查NUMA是否可用</span></span><br><span class="line">    <span class="keyword">if</span> (numa_available() &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NUMA不可用\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取NUMA节点数量</span></span><br><span class="line">    <span class="type">int</span> max_node = numa_max_node();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;系统有 %d 个NUMA节点\n&quot;</span>, max_node + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前进程运行的节点</span></span><br><span class="line">    <span class="type">int</span> current_node = numa_node_of_cpu(sched_getcpu());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前CPU属于节点: %d\n&quot;</span>, current_node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存到指定NUMA节点</span></span><br><span class="line">    <span class="type">size_t</span> size = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>; <span class="comment">// 100MB</span></span><br><span class="line">    <span class="type">void</span> *mem = numa_alloc_onnode(size, <span class="number">0</span>); <span class="comment">// 在节点0上分配内存</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="literal">NULL</span>) {</span><br><span class="line">        perror(<span class="string">&quot;内存分配失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取内存所在的节点</span></span><br><span class="line">    <span class="type">int</span> mem_node;</span><br><span class="line">    <span class="keyword">if</span> (get_mempolicy(&amp;mem_node, <span class="literal">NULL</span>, <span class="number">0</span>, mem, MPOL_F_NODE | MPOL_F_ADDR) == <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;分配的内存位于节点: %d\n&quot;</span>, mem_node);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用内存...</span></span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    numa_free(mem, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>编译命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o numa_example numa_basic.c -lnuma</span><br></pre></td></tr></table></figure>

<h4 id="示例2：Python中使用numa库"><a href="#示例2：Python中使用numa库" class="headerlink" title="示例2：Python中使用numa库"></a>示例2：Python中使用numa库</h4><figure class="highlight py"><figcaption><span>numa_python.py</span><a href="/blog/downloads/code/perf/numa/numa_python.py">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_numa_nodes</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取NUMA节点信息&quot;&quot;&quot;</span></span><br><span class="line">    result = subprocess.run([<span class="string">&#x27;numactl&#x27;</span>, <span class="string">&#x27;--hardware&#x27;</span>], </span><br><span class="line">                          capture_output=<span class="literal">True</span>, text=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> result.stdout</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bind_to_numa_node</span>(<span class="params">node_id, command</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将命令绑定到指定的NUMA节点执行&quot;&quot;&quot;</span></span><br><span class="line">    cmd = [<span class="string">&#x27;numactl&#x27;</span>, <span class="string">&#x27;--cpunodebind={}&#x27;</span>.<span class="built_in">format</span>(node_id),</span><br><span class="line">           <span class="string">&#x27;--membind={}&#x27;</span>.<span class="built_in">format</span>(node_id)] + command</span><br><span class="line">    <span class="keyword">return</span> subprocess.run(cmd)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：获取NUMA信息</span></span><br><span class="line"><span class="built_in">print</span>(get_numa_nodes())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：在节点0上运行Python脚本</span></span><br><span class="line">bind_to_numa_node(<span class="number">0</span>, [<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;your_script.py&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h4 id="示例3：多线程程序中的NUMA优化"><a href="#示例3：多线程程序中的NUMA优化" class="headerlink" title="示例3：多线程程序中的NUMA优化"></a>示例3：多线程程序中的NUMA优化</h4><p><strong>方法一：不同线程绑定到不同NUMA节点</strong></p>
<p>当不同线程需要绑定到不同NUMA节点时，需要在线程内部手动设置CPU亲和性和内存分配：</p>
<figure class="highlight c"><figcaption><span>numa_threads_different_nodes.c</span><a href="/blog/downloads/code/perf/numa/numa_threads_different_nodes.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numa.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREADS 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_SIZE 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">int</span> thread_id;</span><br><span class="line">    <span class="type">int</span> numa_node;</span><br><span class="line">    <span class="type">double</span> *<span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">} <span class="type">thread_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">worker_thread</span><span class="params">(<span class="type">void</span> *arg)</span> {</span><br><span class="line">    <span class="type">thread_data_t</span> *data = (<span class="type">thread_data_t</span> *)arg;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法1：手动设置CPU亲和性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmask</span> *<span class="title">cpuset</span> =</span> numa_allocate_cpumask();</span><br><span class="line">    numa_node_to_cpus(data-&gt;numa_node, cpuset);</span><br><span class="line">    numa_sched_setaffinity(<span class="number">0</span>, cpuset);</span><br><span class="line">    numa_free_cpumask(cpuset);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在指定节点上分配内存</span></span><br><span class="line">    data-&gt;<span class="built_in">array</span> = (<span class="type">double</span> *)numa_alloc_onnode(</span><br><span class="line">        data-&gt;size * <span class="keyword">sizeof</span>(<span class="type">double</span>), data-&gt;numa_node);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (data-&gt;<span class="built_in">array</span> == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;线程 %d: 内存分配失败\n&quot;</span>, data-&gt;thread_id);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行计算（使用本地内存）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; data-&gt;size; i++) {</span><br><span class="line">        data-&gt;<span class="built_in">array</span>[i] = i * <span class="number">1.0</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cpu = sched_getcpu();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程 %d 在CPU %d (节点 %d) 上完成计算\n&quot;</span>, </span><br><span class="line">           data-&gt;thread_id, cpu, data-&gt;numa_node);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (numa_available() &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;NUMA不可用\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> max_node = numa_max_node();</span><br><span class="line">    <span class="type">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">    <span class="type">thread_data_t</span> thread_data[NUM_THREADS];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建线程，每个线程分配到不同的NUMA节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) {</span><br><span class="line">        thread_data[i].thread_id = i;</span><br><span class="line">        thread_data[i].numa_node = i % (max_node + <span class="number">1</span>);</span><br><span class="line">        thread_data[i].size = ARRAY_SIZE;</span><br><span class="line">        </span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, worker_thread, &amp;thread_data[i]);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) {</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (thread_data[i].<span class="built_in">array</span>) {</span><br><span class="line">            numa_free(thread_data[i].<span class="built_in">array</span>, </span><br><span class="line">                     thread_data[i].size * <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p><strong>方法二：所有线程绑定到同一NUMA节点</strong></p>
<p><code>numa_run_on_node()</code> 是一个便捷函数，它会将当前进程绑定到指定NUMA节点的所有CPU上，并设置内存分配偏好策略为该节点。<strong>注意</strong>：CPU绑定是<strong>硬亲和性</strong>（强制的），但内存分配只是偏好设置（不强制保证）。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>需要将整个进程（包括所有线程）绑定到特定NUMA节点</li>
<li>希望简化代码，避免手动管理CPU掩码和内存策略</li>
<li>在进程启动时进行NUMA绑定</li>
</ul>
<p>如果所有线程都需要绑定到同一个NUMA节点，可以在主线程中使用 <code>numa_run_on_node()</code> 统一绑定：</p>
<figure class="highlight c"><figcaption><span>numa_threads_same_node.c</span><a href="/blog/downloads/code/perf/numa/numa_threads_same_node.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numa.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREADS 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_SIZE 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">int</span> thread_id;</span><br><span class="line">    <span class="type">double</span> *<span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">} <span class="type">thread_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">worker_thread</span><span class="params">(<span class="type">void</span> *arg)</span> {</span><br><span class="line">    <span class="type">thread_data_t</span> *data = (<span class="type">thread_data_t</span> *)arg;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意：numa_run_on_node在主线程中调用后，</span></span><br><span class="line">    <span class="comment">// 所有线程都会继承这个绑定，但每个线程仍可能运行在不同CPU上</span></span><br><span class="line">    <span class="comment">// 内存分配会优先在绑定的节点上进行（偏好设置，不强制保证）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分配内存（会优先在绑定的节点上分配，但不保证）</span></span><br><span class="line">    data-&gt;<span class="built_in">array</span> = (<span class="type">double</span> *)<span class="built_in">malloc</span>(data-&gt;size * <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (data-&gt;<span class="built_in">array</span> == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;线程 %d: 内存分配失败\n&quot;</span>, data-&gt;thread_id);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行计算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; data-&gt;size; i++) {</span><br><span class="line">        data-&gt;<span class="built_in">array</span>[i] = i * <span class="number">1.0</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cpu = sched_getcpu();</span><br><span class="line">    <span class="type">int</span> node = numa_node_of_cpu(cpu);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程 %d 在CPU %d (节点 %d) 上完成计算\n&quot;</span>, </span><br><span class="line">           data-&gt;thread_id, cpu, node);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (numa_available() &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;NUMA不可用\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> target_node = <span class="number">0</span>; <span class="comment">// 所有线程绑定到节点0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在主线程中绑定到目标节点</span></span><br><span class="line">    <span class="comment">// 这会影响到所有后续创建的线程</span></span><br><span class="line">    <span class="keyword">if</span> (numa_run_on_node(target_node) != <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">&quot;绑定到NUMA节点失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主进程绑定到节点 %d，创建 %d 个工作线程\n&quot;</span>, target_node, NUM_THREADS);</span><br><span class="line">    </span><br><span class="line">    <span class="type">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">    <span class="type">thread_data_t</span> thread_data[NUM_THREADS];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建线程（会自动继承NUMA绑定）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) {</span><br><span class="line">        thread_data[i].thread_id = i;</span><br><span class="line">        thread_data[i].size = ARRAY_SIZE;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, worker_thread, &amp;thread_data[i]);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) {</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (thread_data[i].<span class="built_in">array</span>) {</span><br><span class="line">            <span class="built_in">free</span>(thread_data[i].<span class="built_in">array</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p><strong>numa_run_on_node的特点：</strong></p>
<ul>
<li>✅ <strong>优点</strong>：代码简单，一个函数调用完成绑定</li>
<li>✅ <strong>优点</strong>：CPU绑定是<strong>硬亲和性</strong>（强制的），进程只能运行在指定节点的CPU上</li>
<li>⚠️ <strong>注意</strong>：内存分配是<strong>偏好设置</strong>，会优先在绑定的节点上分配，但不强制保证</li>
<li>⚠️ <strong>限制</strong>：所有线程都绑定到同一个节点，无法为不同线程分配不同节点</li>
<li>⚠️ <strong>注意</strong>：<code>numa_run_on_node()</code> 会影响整个进程及其所有线程</li>
</ul>
<p><strong>选择建议：</strong></p>
<ul>
<li>如果所有线程需要绑定到<strong>同一个NUMA节点</strong>：使用 <code>numa_run_on_node()</code>（方法二）</li>
<li>如果不同线程需要绑定到<strong>不同的NUMA节点</strong>：使用手动设置CPU亲和性（方法一）</li>
</ul>
<p>编译命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o numa_threads_different_nodes numa_threads_different_nodes.c -lnuma -lpthread</span><br><span class="line">gcc -o numa_threads_same_node numa_threads_same_node.c -lnuma -lpthread</span><br></pre></td></tr></table></figure>

<h3 id="NUMA优化建议"><a href="#NUMA优化建议" class="headerlink" title="NUMA优化建议"></a>NUMA优化建议</h3><ol>
<li><strong>进程绑定</strong>：将进程绑定到特定的NUMA节点，减少跨节点访问</li>
<li><strong>内存本地化</strong>：在进程运行的节点上分配内存</li>
<li><strong>数据局部性</strong>：确保数据访问模式与NUMA拓扑匹配</li>
<li><strong>监控工具</strong>：使用 <code>numastat</code> 和 <code>numactl</code> 监控和调整NUMA策略</li>
<li><strong>应用程序设计</strong>：在应用程序设计时考虑NUMA架构，合理分配线程和内存</li>
<li><strong>并行库适配</strong>：注意并行库（如TBB、OpenMP）在初始化时会根据操作系统报告的硬件资源来决定线程池大小，通过限制可见的CPU资源可以间接控制并行库的线程数</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><code>man numactl</code> - numactl命令手册</li>
<li><code>man numa</code> - NUMA库函数手册</li>
<li><code>/proc/sys/kernel/numa_balancing</code> - NUMA平衡配置</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/11/26/concurrency/%E5%B9%B6%E5%8F%91%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/11/26/concurrency/%E5%B9%B6%E5%8F%91%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">并发调试工具</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-11-26 10:32:15" itemprop="dateCreated datePublished" datetime="2025-11-26T10:32:15+00:00">2025-11-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-02 14:58:39" itemprop="dateModified" datetime="2025-12-02T14:58:39+00:00">2025-12-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="常用-C-并发调试工具-ThreadSanitizer-TSan"><a href="#常用-C-并发调试工具-ThreadSanitizer-TSan" class="headerlink" title="常用 C++ 并发调试工具 ThreadSanitizer (TSan)"></a>常用 C++ 并发调试工具 ThreadSanitizer (TSan)</h2><ul>
<li>LLVM&#x2F;Clang 提供的运行时检测工具<ul>
<li>能精准捕获 数据竞争，输出冲突内存地址、访问栈回溯和涉及线程</li>
</ul>
</li>
<li>Helgrind (Valgrind 工具集)<ul>
<li>专门用于检测 死锁 和 锁误用</li>
<li>通过监视线程对共享内存的访问来发现潜在冲突</li>
</ul>
</li>
<li>rr (Record and Replay Debugger)<ul>
<li>可以记录程序执行过程并重放</li>
<li>适合调试 难以复现的并发 bug，如竞态条件和原子性问题</li>
</ul>
</li>
<li>Clang Static Analyzer<ul>
<li>静态分析工具，在编译阶段发现潜在的并发问题</li>
<li>可检测未加锁访问共享变量、内存序错误等</li>
</ul>
</li>
<li>PVS-Studio<ul>
<li>商业静态分析工具</li>
<li>能在 CI 流程中提前发现并发安全隐患</li>
</ul>
</li>
</ul>
<p>适用场景</p>
<ul>
<li>数据竞争 (Data Race) → 使用 ThreadSanitizer</li>
<li>死锁 (Deadlock) → 使用 Helgrind</li>
<li>难复现的竞态条件 → 使用 rr</li>
</ul>
<p>编译阶段预防 → 使用 Clang Static Analyzer &#x2F; PVS-Studio</p>
<p>这些工具往往需要结合使用：例如 TSan + Helgrind + rr 的组合拳，可以覆盖运行时检测、死锁分析和重放调试<br>，从而大幅提升并发问题定位效率</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>语言&#x2F;平台</th>
<th>主要功能</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>ThreadSanitizer</td>
<td>C&#x2F;C++ (Clang&#x2F;LLVM)</td>
<td>数据竞争检测</td>
<td>运行时发现共享变量冲突</td>
</tr>
<tr>
<td>Helgrind</td>
<td>C&#x2F;C++ (Valgrind)</td>
<td>死锁检测、锁误用</td>
<td>多线程同步问题</td>
</tr>
<tr>
<td>rr</td>
<td>C&#x2F;C++ (Linux)</td>
<td>执行记录与重放</td>
<td>难复现的竞态条件</td>
</tr>
<tr>
<td>Clang Static Analyzer</td>
<td>C&#x2F;C++</td>
<td>静态分析并发隐患</td>
<td>编译阶段预防</td>
</tr>
<tr>
<td>PVS-Studio</td>
<td>C&#x2F;C++</td>
<td>商业静态分析</td>
<td>CI 流程集成</td>
</tr>
<tr>
<td><strong>Oracle Thread Analyzer</strong></td>
<td>Java (Oracle 工具链)</td>
<td>线程可视化、死锁检测</td>
<td>Java 并发调试</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/11/26/perf/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/11/26/perf/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">性能分析工具</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-11-26 10:12:33" itemprop="dateCreated datePublished" datetime="2025-11-26T10:12:33+00:00">2025-11-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-02 14:58:39" itemprop="dateModified" datetime="2025-12-02T14:58:39+00:00">2025-12-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="性能分析工具"><a href="#性能分析工具" class="headerlink" title="性能分析工具"></a>性能分析工具</h2><table>
<thead>
<tr>
<th>工具</th>
<th align="center">类型&#x2F;定位</th>
<th align="center">attach 支持</th>
<th align="center">分析范围</th>
<th align="center">特点</th>
<th align="center">与 perf 的关系</th>
<th align="center">开源&#x2F;商业授权</th>
<th align="center">适用人群</th>
</tr>
</thead>
<tbody><tr>
<td>Oracle Performance Analyzer (PA)</td>
<td align="center">企业级性能分析器，Oracle Developer Studio 套件</td>
<td align="center">✅</td>
<td align="center">用户态程序 (C&#x2F;C++&#x2F;Java&#x2F;Fortran&#x2F;Scala)，并行应用</td>
<td align="center">GUI 丰富，低开销采样，函数&#x2F;源代码&#x2F;指令级分析</td>
<td align="center">独立工具</td>
<td align="center">商业软件 (Oracle Developer Studio)</td>
<td align="center">企业&#x2F;科研环境下的应用开发者</td>
</tr>
<tr>
<td>perf</td>
<td align="center">Linux 内核自带性能分析框架</td>
<td align="center">✅</td>
<td align="center">用户态 + 内核态 + 硬件事件</td>
<td align="center">功能全面，支持调用链、硬件计数器，生态丰富 (eBPF, flamegraph)</td>
<td align="center">基础框架</td>
<td align="center">开源 (GPL，Linux 内核自带)</td>
<td align="center">系统工程师，底层性能调优</td>
</tr>
<tr>
<td>gprofng</td>
<td align="center">GNU 新一代应用性能分析器</td>
<td align="center">✅</td>
<td align="center">用户态程序 (C&#x2F;C++&#x2F;Java&#x2F;Scala)，跨平台</td>
<td align="center">基于实验目录，支持 GUI，跨语言，继承 Oracle PA 思路</td>
<td align="center">独立工具</td>
<td align="center">开源 (GNU 工具链)</td>
<td align="center">应用开发者，跨平台性能优化</td>
</tr>
<tr>
<td>gprof</td>
<td align="center">经典 GNU 性能分析器 (1980s)</td>
<td align="center">❌</td>
<td align="center">用户态程序 (C&#x2F;C++)</td>
<td align="center">需编译时 -pg，生成 gmon.out，功能有限，不支持多线程&#x2F;attach</td>
<td align="center">独立工具</td>
<td align="center">开源 (GNU 工具链)</td>
<td align="center">学术&#x2F;教学场景，简单函数级分析</td>
</tr>
<tr>
<td>Intel PMU Tools</td>
<td align="center">Intel 提供的硬件性能计数器工具集</td>
<td align="center">✅</td>
<td align="center">硬件事件 (CPU pipeline、cache、branch、memory)</td>
<td align="center">基于 PMU，提供 top-down 分析，解释微架构瓶颈</td>
<td align="center">依赖 perf 收集数据，属于 perf 的增强解释层</td>
<td align="center">开源 (MIT&#x2F;Apache 许可，Intel GitHub 提供)</td>
<td align="center">系统&#x2F;性能工程师，硬件级调优</td>
</tr>
<tr>
<td>Intel Advisor</td>
<td align="center">高级性能优化工具 (Intel oneAPI 套件)</td>
<td align="center">✅</td>
<td align="center">用户态程序，尤其是 HPC 应用</td>
<td align="center">提供矢量化分析、内存访问优化、并行化建议，GUI 支持</td>
<td align="center">独立工具</td>
<td align="center">商业软件 (Intel oneAPI 套件，部分免费版)</td>
<td align="center">HPC 开发者，科学计算优化</td>
</tr>
<tr>
<td>Intel VTune Profiler</td>
<td align="center">深度性能分析器</td>
<td align="center">✅</td>
<td align="center">CPU&#x2F;GPU&#x2F;FPGA、内存、线程、I&#x2F;O、微架构</td>
<td align="center">微架构级剖析，支持 cache、pipeline、分支预测，功能全面</td>
<td align="center">独立工具，但可结合 perf 数据</td>
<td align="center">商业软件 (Intel oneAPI 套件，提供免费社区版)</td>
<td align="center">系统&#x2F;性能工程师，硬件与应用优化</td>
</tr>
<tr>
<td>Linaro MAP (Arm Forge MAP)</td>
<td align="center">HPC 并行应用性能分析器</td>
<td align="center">✅</td>
<td align="center">MPI、OpenMP、UPC 等大规模并行应用</td>
<td align="center">低开销采样，跨节点整体分析，源代码行级耗时展示，GUI 可视化</td>
<td align="center">独立工具</td>
<td align="center">商业软件 (Arm Forge 套件，需许可证)</td>
<td align="center">HPC 开发者，超级计算机环境</td>
</tr>
</tbody></table>
<p><strong>差异总结</strong></p>
<ul>
<li>Oracle PA &#x2F; gprofng：应用层性能分析，强调 GUI 和跨语言支持。</li>
<li>perf：系统级通用工具，是底层框架。</li>
<li>gprof：老工具，功能有限，不支持 attach。</li>
<li>Intel PMU Tools：基于 perf，提供 Intel CPU 微架构解释，是 perf 的增强解释层。</li>
<li>Intel Advisor：智能优化建议工具，适合 HPC 和科学计算。</li>
<li>Intel VTune Profiler：深度剖析工具，能揭示硬件微架构瓶颈，适合单节点和复杂应用。</li>
<li>Linaro MAP：专为 HPC 并行应用设计，低开销，跨节点整体性能分析。</li>
</ul>
<p><strong>结论</strong></p>
<ul>
<li>应用层性能分析：Oracle PA、gprofng</li>
<li>系统&#x2F;内核级调优：perf</li>
<li>硬件级微架构分析：Intel PMU Tools、Intel VTune Profiler</li>
<li>智能优化建议 (HPC)：Intel Advisor</li>
<li>大规模并行应用分析 (HPC)：Linaro MAP</li>
</ul>
<p>👉 可以把它们看作一个层次结构：</p>
<ul>
<li>gprof → gprofng&#x2F;Oracle PA → perf → Intel PMU Tools&#x2F;VTune → Advisor&#x2F;MAP</li>
<li>逐步从函数级分析 → 应用性能 → 系统级 → 硬件级 → HPC 并行整体优化。</li>
</ul>
<h3 id="Performance-Analyzer"><a href="#Performance-Analyzer" class="headerlink" title="Performance Analyzer"></a>Performance Analyzer</h3><p>Oracle Developer Studio 提供了多种工具：Performance Analyzer、Thread Analyzer。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E77782_01/html/E77798/afagg.html#OSSPAgrkam">Performance Analyzer 官方文档</a></p>
</blockquote>
<h4 id="收集数据"><a href="#收集数据" class="headerlink" title="收集数据"></a>收集数据</h4><p>使用 <code>collect</code> 命令收集数据<br>（<a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E77782_01/html/E77798/afadn.html#scrolltoc">官方文档</a>）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collect collect-options program program-arguments</span><br></pre></td></tr></table></figure>

<h4 id="开始性能分析"><a href="#开始性能分析" class="headerlink" title="开始性能分析"></a>开始性能分析</h4><p>使用 <code>analyzer</code> 命令进行性能分析<br>（<a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E77782_01/html/E77798/afafs.html#scrolltoc">官方文档</a>）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyzer [control-options] [experiment | experiment-list]</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyzer -c test.1.er test.4.er</span><br></pre></td></tr></table></figure>

<h3 id="Thread-Analyzer"><a href="#Thread-Analyzer" class="headerlink" title="Thread Analyzer"></a>Thread Analyzer</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.oracle.com/application-development/technologies/developerstudio-features.html#thread-analyzer-tab">Thread Analyzer 官方文档</a></p>
</blockquote>
<h2 id="计时"><a href="#计时" class="headerlink" title="计时"></a>计时</h2><h3 id="计时工具-time"><a href="#计时工具-time" class="headerlink" title="计时工具 time"></a>计时工具 <code>time</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/bin/time -p <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p>Or,</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ time <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p>其中（参<br>考<a target="_blank" rel="noopener" href="https://ostechnix.com/how-to-find-the-execution-time-of-a-command-or-process-in-linux/">链接</a>），</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">type</span> -a time</span><br><span class="line">time is a shell keyword</span><br><span class="line">time is /usr/bin/time</span><br></pre></td></tr></table></figure>

<h3 id="软件和硬件定时器"><a href="#软件和硬件定时器" class="headerlink" title="软件和硬件定时器"></a>软件和硬件定时器</h3><p><a target="_blank" rel="noopener" href="https://weedge.github.io/perf-book-cn/zh/chapters/2-Measuring-Performance/2-5_SW_and_HW_Timers_cn.html">https://weedge.github.io/perf-book-cn/zh/chapters/2-Measuring-Performance/2-5_SW_and_HW_Timers_cn.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/11/21/perf/Bad-Speculation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/11/21/perf/Bad-Speculation/" class="post-title-link" itemprop="url">Bad Speculation</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-11-21 15:29:24" itemprop="dateCreated datePublished" datetime="2025-11-21T15:29:24+00:00">2025-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-02 14:58:39" itemprop="dateModified" datetime="2025-12-02T14:58:39+00:00">2025-12-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Bad Speculation 指不好的预测，尤其是分支预测。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/11/21/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/11/21/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/" class="post-title-link" itemprop="url">分支预测</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-11-21 15:29:02" itemprop="dateCreated datePublished" datetime="2025-11-21T15:29:02+00:00">2025-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-02 14:58:39" itemprop="dateModified" datetime="2025-12-02T14:58:39+00:00">2025-12-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/11/21/perf/core-bound/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/11/21/perf/core-bound/" class="post-title-link" itemprop="url">Core Bound</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-11-21 14:05:58" itemprop="dateCreated datePublished" datetime="2025-11-21T14:05:58+00:00">2025-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-02 14:58:39" itemprop="dateModified" datetime="2025-12-02T14:58:39+00:00">2025-12-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Core Bound 指 CPU 核心计算能力受限。包括两种：</p>
<ol>
<li>硬件的计算资源不足（吞吐量受限）</li>
</ol>
<ul>
<li>port 冲突：例如 Intel Skylake 架构上，除法和平方根运算都会被分配到 port 0 上，如果大量的类似耗时操<br>作排队，那么就会体现为硬件算力的限制。</li>
</ul>
<p><strong>Port 指的是 CPU 内部的 执行端口（execution ports）。</strong></p>
<blockquote>
<p>现代 CPU（尤其是 Intel、AMD 的 x86-64 架构）采用 超标量、乱序执行，有多个功能单元可以并行执行不同<br>类型的指令。</p>
<p>每个功能单元挂在一个 端口 (port) 上，负责特定类型的操作，比如：</p>
<ul>
<li>整数运算端口（加减、逻辑运算）</li>
<li>浮点运算端口（乘法、除法、加法）</li>
<li>加载端口（从内存读取数据）</li>
<li>存储端口（写数据到内存）</li>
</ul>
<p>CPU 的调度器会把指令分配到合适的端口执行。</p>
<p>如果某类端口资源不足，就会出现 port bound（端口受限），性能瓶颈来自于某个端口的拥塞。</p>
<p>👉 举例： Intel Skylake 架构有 8 个端口：</p>
<ul>
<li>Port 0&#x2F;1：整数和浮点运算</li>
<li>Port 2&#x2F;3：加载（Load）</li>
<li>Port 4：存储地址计算</li>
<li>Port 5：存储数据</li>
<li>Port 6：分支预测</li>
<li>Port 7：整数运算</li>
</ul>
</blockquote>
<ol start="2">
<li>指令间的依赖（增加延迟）</li>
</ol>
<p>例如链表的遍历，CPU 无法对其并行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (n) &#123;</span><br><span class="line">    n = n-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>第 1 种计算能力受限的问题，最好的办法是升级 CPU，换成具有更多除数的型号，或者将计算任务卸载到加速器<br>上。</p>
<p>第 2 种数据依赖链的问题，可能需要重写算法。下面介绍一些有名的优化方法：</p>
<ol>
<li>向量化</li>
<li>函数 inline 化</li>
<li>循环转换</li>
<li>编译器内建函数</li>
<li>其他</li>
</ol>
<p>目的是减少执行的指令或用更好的汇编指令替代。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/11/20/perf/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%8C%87%E6%A0%87%E5%92%8C%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/11/20/perf/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%8C%87%E6%A0%87%E5%92%8C%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">性能分析指标和概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-11-20 15:54:29" itemprop="dateCreated datePublished" datetime="2025-11-20T15:54:29+00:00">2025-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-02 14:58:39" itemprop="dateModified" datetime="2025-12-02T14:58:39+00:00">2025-12-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%80%A7%E8%83%BD/" itemprop="url" rel="index"><span itemprop="name">性能</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="CPU-硬件层次概念"><a href="#CPU-硬件层次概念" class="headerlink" title="CPU 硬件层次概念"></a>CPU 硬件层次概念</h2><ul>
<li>Package → 整个处理器封装，包含一个或多个 die。</li>
<li>Socket (S) → 主板上的物理 CPU 插槽</li>
<li>Die (D) → 封装里的裸片（可能有多个 chiplet&#x2F;die）</li>
<li>Core (C) → die 上的计算核心</li>
<li>Thread (T) → 核心里的硬件线程（SMT&#x2F;超线程），即逻辑处理器</li>
</ul>
<p>假设一台双路服务器，每个 socket 上的 CPU 封装里有两个 die，每个 die 有 8 个核心：</p>
<ul>
<li><code>S0-D0-C0</code> → Socket 0 上 Die 0 的 Core 0</li>
<li><code>S0-D1-C3</code> → Socket 0 上 Die 1 的 Core 3</li>
<li><code>S1-D0-C7</code> → Socket 1 上 Die 0 的 Core 7</li>
</ul>
<p>如果开启超线程，还可能进一步细分为：</p>
<ul>
<li><code>S0-D0-C0-T0</code> → Socket 0, Die 0, Core 0, Thread 0</li>
<li><code>S0-D0-C0-T1</code> → Socket 0, Die 0, Core 0, Thread 1</li>
</ul>
<p>可以用命令 <code>lscpu</code> 或 <code>cat /proc/cpuinfo</code> 来查看逻辑 CPU ID 与 Socket&#x2F;Core&#x2F;Thread 的对应关系。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ lscpu</span><br><span class="line">...</span><br><span class="line">    Thread(s) per core:  2</span><br><span class="line">    Core(s) per socket:  4</span><br><span class="line">    Socket(s):           1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总逻辑 CPU 数量 = 1 × 4 × 2 = 8</span><br></pre></td></tr></table></figure>

<p>nproc 输出的是 逻辑 CPU 数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">nproc</span></span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<h2 id="CPU-微架构概念"><a href="#CPU-微架构概念" class="headerlink" title="CPU 微架构概念"></a>CPU 微架构概念</h2><ul>
<li>Pipeline：指令执行的分阶段过程（取指、解码、执行、写回）。</li>
<li>Width：每周期最多能发射多少条 uops（如 4‑wide）。</li>
<li>Slot：每周期的发射机会，宽度决定 slot 数。</li>
<li>ROB (Reorder Buffer)：乱序执行的关键结构，保证指令按程序顺序退休。</li>
<li>Scheduler：调度器，决定哪些 uops 在某周期进入执行端口。</li>
<li>Execution Ports：后端的执行单元入口，比如整数 ALU、浮点 FPU、Load&#x2F;Store。</li>
<li>Branch Predictor：预测分支走向，减少流水线停顿。</li>
</ul>
<h2 id="存储与层次结构"><a href="#存储与层次结构" class="headerlink" title="存储与层次结构"></a>存储与层次结构</h2><ul>
<li>Registers：CPU 内部的寄存器，最快的存储。</li>
<li>Cache：分层缓存（L1、L2、L3），用于减少访存延迟。</li>
<li>LLC (Last Level Cache)：最后一级缓存，通常是 L3，多个核心共享。</li>
<li>Memory Controller：负责和 DRAM 通信。</li>
<li>NUMA (Non-Uniform Memory Access)：多 socket 系统里，内存访问延迟因位置不同而不同。</li>
</ul>
<h2 id="性能分析相关"><a href="#性能分析相关" class="headerlink" title="性能分析相关"></a>性能分析相关</h2><ul>
<li>IPC (Instructions Per Cycle)：每周期平均执行的指令数。</li>
<li>ILP (Instruction-Level Parallelism)：指令级并行度，程序能提供多少独立指令。</li>
<li>Topdown Metrics：Retiring、Bad Speculation、Frontend Bound、Backend Bound。</li>
<li>BE&#x2F;Core vs BE&#x2F;Mem：后端瓶颈是算力不足还是访存延迟。</li>
<li>CPI (Cycles Per Instruction)：每条指令平均耗费的周期数。</li>
</ul>
<h2 id="Top-Down-Microarchitecture-Analysis-TMA"><a href="#Top-Down-Microarchitecture-Analysis-TMA" class="headerlink" title="Top-Down Microarchitecture Analysis (TMA)"></a>Top-Down Microarchitecture Analysis (TMA)</h2><p>这是 Intel 提出的一个 CPU 性能瓶颈分析框架。它的核心思想是：把 CPU 每个周期的 发射机会（slot） 分门<br>别类，逐层细分，最终定位到性能瓶颈的根源。</p>
<p>Topdown 是分层树状结构：</p>
<ul>
<li>Level 1：Retiring &#x2F; Bad Speculation &#x2F; Frontend Bound &#x2F; Backend Bound</li>
<li>Level 2：Backend Bound → BE&#x2F;Core、BE&#x2F;Mem</li>
<li>Level 3：BE&#x2F;Mem → L1 Bound、L2 Bound、DRAM Bound</li>
</ul>
<ol>
<li>Level 1: 顶层四大分类</li>
</ol>
<p>在每个周期的 slot 中，CPU 的工作被划分为四类：</p>
<ul>
<li><p>Retiring</p>
<ul>
<li>指令成功退休（完成执行并写回结果）。</li>
<li>这是“有用工作”，比例越高说明 CPU 利用率越好。</li>
</ul>
</li>
<li><p>Bad Speculation</p>
<ul>
<li>由于错误预测（如分支预测失败、错误路径执行）导致的浪费。</li>
<li>这些 slot 最终没有产生有效结果。</li>
</ul>
</li>
<li><p>Frontend Bound (FE)</p>
<ul>
<li>前端受限：取指、解码、指令缓存不足。</li>
<li>CPU 等待指令进入流水线。</li>
</ul>
</li>
<li><p>Backend Bound (BE)</p>
<ul>
<li>后端受限：执行单元或数据不可用。</li>
<li>CPU 等待算力资源或内存数据。</li>
</ul>
</li>
</ul>
<p>这四类加起来 ≈ 100%，覆盖了所有 slot 的去向。</p>
<ol start="2">
<li>Level 2: Backend 的进一步细分</li>
</ol>
<ul>
<li>BE&#x2F;Core<ul>
<li>后端瓶颈主要来自核心执行资源不足（算术逻辑单元、浮点单元、端口冲突）。</li>
<li>程序算力密集。</li>
</ul>
</li>
<li>BE&#x2F;Mem<ul>
<li>后端瓶颈主要来自访存延迟（缓存未命中、DRAM 访问慢）。</li>
<li>程序内存密集。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>Level 3: BE&#x2F;Mem 的进一步细分</li>
</ol>
<ul>
<li>L1 Bound</li>
<li>L2 Bound</li>
<li>L3 Bound</li>
<li>DRAM Bound</li>
</ul>
<h3 id="Roofline"><a href="#Roofline" class="headerlink" title="Roofline"></a>Roofline</h3><h2 id="性能分析工具"><a href="#性能分析工具" class="headerlink" title="性能分析工具"></a>性能分析工具</h2><ol>
<li>perf (Linux)</li>
<li><a target="_blank" rel="noopener" href="https://github.com/andikleen/pmu-tools">Intel® pmu-tools</a> ：对 perf 的封装</li>
<li><a target="_blank" rel="noopener" href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/advisor-download.html">Intel Advisor</a></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>perf-ninja: <a target="_blank" rel="noopener" href="https://github.com/dendibakh/perf-ninja">代码</a> +<br><a target="_blank" rel="noopener" href="https://www.youtube.com/playlist?list=PLRWO2AL1QAV6bJAU2kgB4xfodGID43Y5d">视频</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/09/24/concurrency/memory_order%E5%AE%9E%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/09/24/concurrency/memory_order%E5%AE%9E%E9%AA%8C/" class="post-title-link" itemprop="url">memory_order测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-09-24 14:32:53" itemprop="dateCreated datePublished" datetime="2025-09-24T14:32:53+00:00">2025-09-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-02 14:58:39" itemprop="dateModified" datetime="2025-12-02T14:58:39+00:00">2025-12-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="relaxed"><a href="#relaxed" class="headerlink" title="relaxed"></a>relaxed</h2><ul>
<li>问：load(relaxed) 看到的是不是最新值？</li>
<li>答：是的。</li>
</ul>
<p>经过多次测试（包括 TSAN），CAS(relaxed) 计数器都是正确的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -fsanitize=thread test_memory_order_relaxed.cpp -lpthread</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>test_memory_order_relaxed.cpp</span><a href="/blog/downloads/code/atomic/test_memory_order_relaxed.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> run_times = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">uint32_t</span> num_threads = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">uint64_t</span> increments_per_thread = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">32</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">uint64_t</span> max_count = increments_per_thread * num_threads;</span><br><span class="line"></span><br><span class="line">atomic&lt;<span class="type">uint64_t</span>&gt; counter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Random Delay in microseonds */</span></span><br><span class="line">std::random_device rd;</span><br><span class="line"><span class="function"><span class="keyword">thread_local</span> std::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line"><span class="keyword">thread_local</span> std::uniform_int_distribution&lt;&gt; <span class="built_in">dis</span>(<span class="number">0</span>, <span class="number">4095</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unpredictableDelay</span><span class="params">(<span class="type">int</span> extra = <span class="number">0</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dis</span>(gen) == <span class="number">0</span>) {</span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">nanoseconds</span>(<span class="number">2000</span> + extra));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/** thread function for counting */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(<span class="type">int</span> id)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; increments_per_thread; ++i) {</span><br><span class="line">        <span class="type">uint64_t</span> old = counter.<span class="built_in">load</span>(memory_order_relaxed);</span><br><span class="line">        <span class="comment">// 如果 load(relaxed) 不能看到当前最新值</span></span><br><span class="line">        <span class="comment">// 那么 CAS 就会加多次，最终结果会大于 max_count</span></span><br><span class="line">        <span class="keyword">while</span> (old &lt; max_count &amp;&amp;</span><br><span class="line">               !counter.<span class="built_in">compare_exchange_weak</span>(old, old + <span class="number">1</span>, memory_order_relaxed)) {</span><br><span class="line">            <span class="comment">// old is updated with the current value of counter</span></span><br><span class="line">            <span class="built_in">unpredictableDelay</span>(<span class="built_in">dis</span>(gen));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;Worker &quot; &lt;&lt; id &lt;&lt; &quot; done.&quot; &lt;&lt; endl;</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/** main function */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> run = <span class="number">0</span>; run &lt; run_times; ++run) {</span><br><span class="line">        counter.<span class="built_in">store</span>(<span class="number">0</span>, memory_order_relaxed);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Run &quot;</span> &lt;&lt; run &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        thread threads[num_threads];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) {</span><br><span class="line">            threads[i] = <span class="built_in">thread</span>(worker, i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) {</span><br><span class="line">            threads[i].<span class="built_in">join</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; (max_count == counter.<span class="built_in">load</span>() ? <span class="string">&quot;Correct&quot;</span> : <span class="string">&quot;Wrong&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/09/23/rdma/RDMA_RC%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/09/23/rdma/RDMA_RC%E9%80%9A%E4%BF%A1/" class="post-title-link" itemprop="url">RDMA RC 通信</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-09-23 16:30:08" itemprop="dateCreated datePublished" datetime="2025-09-23T16:30:08+00:00">2025-09-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-02 14:58:39" itemprop="dateModified" datetime="2025-12-02T14:58:39+00:00">2025-12-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/RDMA/" itemprop="url" rel="index"><span itemprop="name">RDMA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="RDMA-vs-TCP-IP-连接标识字段"><a href="#RDMA-vs-TCP-IP-连接标识字段" class="headerlink" title="RDMA vs TCP&#x2F;IP 连接标识字段"></a>RDMA vs TCP&#x2F;IP 连接标识字段</h2><table>
<thead>
<tr>
<th align="center">字段名称</th>
<th align="center">全称</th>
<th align="center">作用说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GID</td>
<td align="center">Global Identifier</td>
<td align="center">标识设备，类似于 IP 地址，128 位；RoCEv2 中为 IPv6 映射地址，InfiniBand 中由设备 GUID + 路由信息生成</td>
</tr>
<tr>
<td align="center">QPN</td>
<td align="center">Queue Pair Number</td>
<td align="center">标识会话，每个 RDMA 会话使用一个 QP，QPN 是其唯一编号，类似于 TCP 的端口号</td>
</tr>
<tr>
<td align="center">PSN</td>
<td align="center">Packet Sequence Number</td>
<td align="center">初始化连接时使用，用于数据包排序和连接建立，类似于 TCP 的序列号</td>
</tr>
<tr>
<td align="center">LID</td>
<td align="center">Local Identifier（可选）</td>
<td align="center">InfiniBand fabric 中的本地路由地址，类似于交换机端口编号，仅在 InfiniBand 中使用</td>
</tr>
</tbody></table>
<h2 id="InfiniBand-的连接建立流程（RC-模式）"><a href="#InfiniBand-的连接建立流程（RC-模式）" class="headerlink" title="InfiniBand 的连接建立流程（RC 模式）"></a>InfiniBand 的连接建立流程（RC 模式）</h2><table>
<thead>
<tr>
<th align="center">阶段</th>
<th align="center">状态</th>
<th align="center">含义</th>
<th align="center">关键配置项</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1️⃣ INIT</td>
<td align="center">IBV_QPS_INIT</td>
<td align="center">初始化 QP</td>
<td align="center">本地端口、访问权限、P_Key 等</td>
</tr>
<tr>
<td align="center">2️⃣ RTR</td>
<td align="center">IBV_QPS_RTR</td>
<td align="center">Ready to Receive</td>
<td align="center">远端 QPN、LID&#x2F;GID、PSN、MTU 等</td>
</tr>
<tr>
<td align="center">3️⃣ RTS</td>
<td align="center">IBV_QPS_RTS</td>
<td align="center">Ready to Send</td>
<td align="center">本地 PSN、重试参数、超时设置等</td>
</tr>
</tbody></table>
<p>类比 TCP 的三次握手。</p>
<p>为什么不像 TCP 那样自动握手？ InfiniBand 的设计目标是：</p>
<ul>
<li>极低延迟：避免协议协商，直接由应用控制连接建立。</li>
<li>高吞吐：硬件直接处理数据流，减少内核干预。</li>
<li>可预测性强：状态转换明确，调试和优化更容易。</li>
<li>适用于受控环境：如 HPC、AI 训练、数据库加速，通常用于 HPC 或数据中心，不像 TCP 那样暴露在公网，不<br>需要防止恶意连接。（所以 QPN 一般是用户指定，且常常是顺序的；这与 TCP 的初始序列号截然不同）</li>
</ul>
<p>注：MTU 对比表</p>
<table>
<thead>
<tr>
<th align="center">技术类型</th>
<th align="center">支持的 MTU 值（字节）</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Ethernet（标准）</td>
<td align="center">1500</td>
<td align="center">最常见的默认值，适用于大多数网络设备</td>
</tr>
<tr>
<td align="center">InfiniBand</td>
<td align="center">256, 512, 1024, 2048, 4096</td>
<td align="center">固定值，由硬件和驱动支持</td>
</tr>
<tr>
<td align="center">RoCE (RDMA over Converged Ethernet)</td>
<td align="center">通常 ≤ Ethernet MTU（如 1500 或 9000）</td>
<td align="center">实际使用值需减去 RoCE 协议头和 CRC，常见为 1024 或 4096</td>
</tr>
<tr>
<td align="center">iWARP</td>
<td align="center">受 TCP&#x2F;IP 栈限制，通常 ≤ 1500</td>
<td align="center">依赖传统以太网 MTU，性能受限</td>
</tr>
</tbody></table>
<p>InfiniBand 的 MTU 值由头文件 <code>&lt;infiniband/verbs.h&gt;</code> 定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ibv_mtu</span> &#123;</span></span><br><span class="line">	IBV_MTU_256  = <span class="number">1</span>,</span><br><span class="line">	IBV_MTU_512  = <span class="number">2</span>,</span><br><span class="line">	IBV_MTU_1024 = <span class="number">3</span>,</span><br><span class="line">	IBV_MTU_2048 = <span class="number">4</span>,</span><br><span class="line">	IBV_MTU_4096 = <span class="number">5</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p><a target="_blank" rel="noopener" href="https://infiniband-doc.readthedocs.io/zh-cn/latest/8_ibv_examples/8_2_RDMA_RC_code.html">源码</a></p>
<h3 id="resources-create"><a href="#resources-create" class="headerlink" title="resources_create"></a>resources_create</h3><ol>
<li>TCP 建立连接 → 保存到 res.sock</li>
<li>ibv_get_device_list</li>
<li>ibv_get_device_name → 保存到 res.dev_name</li>
<li>ibv_open_device → 保存到 res.ib_ctx</li>
<li>ibv_query_port → 保存到 res.ib_port, res.port_attr</li>
<li>ibv_alloc_pd → 保存到 res.pd</li>
<li>ibv_create_cq → 保存到 res.cq</li>
<li>malloc → 保存到 res.buf</li>
<li>ibv_reg_mr → 保存到 res.mr</li>
<li>ibv_create_qp → 保存到 res.qp</li>
</ol>
<h3 id="connect-qp"><a href="#connect-qp" class="headerlink" title="connect_qp"></a>connect_qp</h3><ol>
<li>如果指定 gid_idx ，则以 ib_ctx 和 ib_port 调用 ibv_query_gid 查询本地的 gid；否则用 0 初始化<br>gid。</li>
<li>填充 cm_con_data_t 结构体：<code>addr</code>(即 <code>res.buf</code>)、<code>mr-&gt;rkey</code>、<code>qp-&gt;qp_num</code>、<code>port_attr.lid</code></li>
<li>通过 TCP socket 交换 cm_con_data_t 的信息，将远端 cm_con_data_t 保存到 res.remote_props</li>
<li>调用 modify_qp_to_init（使用 ibv_modify_qp 修改 QP 的状态：RESET → INIT）</li>
</ol>
<table>
<thead>
<tr>
<th align="center">参数字段</th>
<th>作用描述</th>
<th>是否必须设置</th>
<th>设置原因</th>
</tr>
</thead>
<tbody><tr>
<td align="center">attr.qp_state &#x3D; IBV_QPS_INIT</td>
<td>设置 QP 的目标状态为 INIT</td>
<td>是</td>
<td>明确告诉 HCA 要将 QP 转换到 INIT 状态</td>
</tr>
<tr>
<td align="center">attr.port_num &#x3D; config.ib_port</td>
<td>指定使用的物理端口号</td>
<td>是</td>
<td>多端口设备必须指定端口，否则无法建立连接</td>
</tr>
<tr>
<td align="center">attr.pkey_index &#x3D; 0</td>
<td>设置 P_Key 索引</td>
<td>是</td>
<td>InfiniBand 使用 P_Key 进行分区管理，默认使用索引 0</td>
</tr>
<tr>
<td align="center"><code>attr.qp_access_flags = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE</code></td>
<td>设置本地和远程访问权限</td>
<td>是</td>
<td>决定远程节点是否能读写你的内存，必须在 INIT 状态设置</td>
</tr>
<tr>
<td align="center"><code>flags = IBV_QP_STATE | IBV_QP_PKEY_INDEX | IBV_QP_PORT | IBV_QP_ACCESS_FLAGS</code></td>
<td>指定哪些字段有效并应用到 QP 属性结构体中</td>
<td>是</td>
<td>ibv_modify_qp 需要知道哪些字段是有效的，否则不会应用这些设置</td>
</tr>
</tbody></table>
<p>注：InfiniBand 的分区类似以太网的 VLAN</p>
<ul>
<li>同一分区内的节点可以互通</li>
<li>不同分区之间默认无法通信</li>
<li>分区成员可以通过默认分区与 Subnet Manager 通信（如 IO 节点）</li>
</ul>
<ol start="5">
<li>客户端调用 post_receive<ol>
<li>准备 scatter&#x2F;gather entry：sge.addr, sge.length, seg.lkey</li>
<li>准备 receive work request: wr_id, next（多个 receive wr 可以组成一个链表，一起提交）,<br>sge_list（sge 数组，多个不同内存区域的 sge 可一起提交）。</li>
<li>调用 ibv_post_recv 提交 receive wr。</li>
</ol>
</li>
<li>modify_qp_to_rtr：修改 QP 状态为 Readay to Receive：INIT → RTR</li>
</ol>
<table>
<thead>
<tr>
<th align="center">字段&#x2F;参数名</th>
<th align="center">类型&#x2F;值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">remote_qpn</td>
<td align="center">uint32_t</td>
<td align="center">远端 QP 编号，用于建立连接。</td>
</tr>
<tr>
<td align="center">dlid</td>
<td align="center">uint16_t</td>
<td align="center">Destination LID：远端设备的本地标识符，用于本地路由。d 表示 destination（目的地）。</td>
</tr>
<tr>
<td align="center">dgid</td>
<td align="center">uint8_t*</td>
<td align="center">Destination GID：远端设备的全局标识符，用于全局寻址。d 表示 destination（目的地）。</td>
</tr>
<tr>
<td align="center">attr.qp_state</td>
<td align="center">IBV_QPS_RTR</td>
<td align="center">设置 QP 状态为 Ready to Receive。</td>
</tr>
<tr>
<td align="center">attr.path_mtu</td>
<td align="center">IBV_MTU_256</td>
<td align="center">设置路径最大传输单元为 256 字节。</td>
</tr>
<tr>
<td align="center">attr.dest_qp_num</td>
<td align="center">remote_qpn</td>
<td align="center">指定远端 QP 编号。</td>
</tr>
<tr>
<td align="center">attr.rq_psn</td>
<td align="center">0</td>
<td align="center">接收队列的初始包序号。</td>
</tr>
<tr>
<td align="center">attr.max_dest_rd_atomic</td>
<td align="center">1</td>
<td align="center">远端最多可处理的 RDMA Read&#x2F;Atomic 请求数。</td>
</tr>
<tr>
<td align="center">attr.min_rnr_timer</td>
<td align="center">0x12</td>
<td align="center">最小 RNR 重试等待时间（单位为 655.36 微秒）。</td>
</tr>
<tr>
<td align="center">attr.ah_attr.is_global</td>
<td align="center">0 或 1</td>
<td align="center">是否启用全局路由（GID）。</td>
</tr>
<tr>
<td align="center">attr.ah_attr.dlid</td>
<td align="center">dlid</td>
<td align="center">设置远端 LID。</td>
</tr>
<tr>
<td align="center">attr.ah_attr.sl</td>
<td align="center">0</td>
<td align="center">服务等级（Service Level）。</td>
</tr>
<tr>
<td align="center">attr.ah_attr.src_path_bits</td>
<td align="center">0</td>
<td align="center">源路径位，通常为 0。</td>
</tr>
<tr>
<td align="center">attr.ah_attr.port_num</td>
<td align="center">config.ib_port</td>
<td align="center">本地端口号。</td>
</tr>
<tr>
<td align="center">attr.ah_attr.grh.dgid</td>
<td align="center">dgid</td>
<td align="center">设置远端 GID（如果启用全局路由）。</td>
</tr>
<tr>
<td align="center">attr.ah_attr.grh.flow_label</td>
<td align="center">0</td>
<td align="center">GRH 流标签。</td>
</tr>
<tr>
<td align="center">attr.ah_attr.grh.hop_limit</td>
<td align="center">1</td>
<td align="center">GRH 跳数限制。</td>
</tr>
<tr>
<td align="center">attr.ah_attr.grh.sgid_index</td>
<td align="center">config.gid_idx</td>
<td align="center">本地 GID 索引。</td>
</tr>
<tr>
<td align="center">attr.ah_attr.grh.traffic_class</td>
<td align="center">0</td>
<td align="center">GRH 流量类别。</td>
</tr>
<tr>
<td align="center">flags</td>
<td align="center">多个宏组合</td>
<td align="center">指定哪些属性字段有效。</td>
</tr>
<tr>
<td align="center">ibv_modify_qp()</td>
<td align="center">函数调用</td>
<td align="center">执行 QP 状态修改操作。</td>
</tr>
</tbody></table>
<ol start="7">
<li>modify_qp_to_rts</li>
</ol>
<table>
<thead>
<tr>
<th align="center">参数字段</th>
<th align="center">含义</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">attr.qp_state &#x3D; IBV_QPS_RTS</td>
<td align="center">设置 QP 状态为 RTS</td>
<td align="center">表示该 QP 已准备好发送数据，是连接建立的最后一步</td>
</tr>
<tr>
<td align="center">attr.timeout &#x3D; 0x12</td>
<td align="center">超时时间</td>
<td align="center">单位为 4.096μs，表示发送请求等待 ACK 的最大时间。0x12 ≈ 75μs</td>
</tr>
<tr>
<td align="center">attr.retry_cnt &#x3D; 6</td>
<td align="center">重试次数</td>
<td align="center">如果未收到 ACK，最多重试 6 次</td>
</tr>
<tr>
<td align="center">attr.rnr_retry &#x3D; 0</td>
<td align="center">RNR 重试次数</td>
<td align="center">对方未准备好接收时的重试次数。0 表示不重试（通常用于 UC 类型）</td>
</tr>
<tr>
<td align="center">attr.sq_psn &#x3D; 0</td>
<td align="center">Send Queue 的初始 PSN</td>
<td align="center">PSN（Packet Sequence Number）用于包顺序控制，需与远端匹配</td>
</tr>
<tr>
<td align="center">attr.max_rd_atomic &#x3D; 1</td>
<td align="center">最大 RDMA Read 请求数</td>
<td align="center">表示本端最多允许一个未完成的 RDMA Read 请求</td>
</tr>
<tr>
<td align="center">flags</td>
<td align="center">标志位</td>
<td align="center">指定哪些字段在 ibv_modify_qp() 中有效，必须与设置的字段匹配</td>
</tr>
</tbody></table>
<ol start="8">
<li>用 TCP socket 同步交换 dummy 数据，以确保双方都进入 RTS 状态。</li>
</ol>
<h3 id="post-send"><a href="#post-send" class="headerlink" title="post_send"></a>post_send</h3><ol>
<li>准备 scatter&#x2F;gather entry: addr, length, lkey</li>
<li>准备 send work request: remote_addr, rkey, opcode, send_flags</li>
</ol>
<p><code>IBV_SEND_SIGNALED</code> 的作用</p>
<table>
<thead>
<tr>
<th align="center">功能</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">请求生成 CQE</td>
<td>告诉 HCA：这个发送请求完成后，请在 CQ 中生成一个完成事件。</td>
</tr>
<tr>
<td align="center">用于异步通知</td>
<td>应用程序可以通过轮询或事件机制检测哪些请求完成了。</td>
</tr>
<tr>
<td align="center">提高可控性</td>
<td>你可以选择只对关键请求设置该标志，减少 CQE 数量，降低开销。</td>
</tr>
</tbody></table>
<p>性能考虑：每个 CQE 都会占用资源，频繁生成会增加 CQ 处理负担。</p>
<ul>
<li>周期性 Signaled WR：可以只对每 N 个请求设置 IBV_SEND_SIGNALED，比如每 64 个请求生成一个 CQE。</li>
<li>通过检查这个 WC 的 wr_id，你可以间接推断前面的 N 个 WR 已经完成（因为 InfiniBand 保证顺序完成）。</li>
<li>避免 CQ 溢出：如果 CQ 太小而你对每个请求都设置了 SIGNALED，可能导致 CQ 溢出（CQ overrun）。</li>
</ul>
<ol start="3">
<li>调用 ibv_post_send</li>
</ol>
<p>RNR 状态： Receiver Not Ready（接收方未准备好）</p>
<p>触发条件：</p>
<ul>
<li>当发送方发送消息时，接收方的接收队列中没有足够的接收请求（Receive Request）来处理该消息。</li>
<li>接收方会返回一个 RNR NACK（Negative Acknowledgement） 给发送方，表示暂时无法接收。</li>
</ul>
<p>发送方的处理流程：</p>
<ul>
<li>收到 RNR NACK 后，发送方会根据该 NACK 中指定的 RNR 重试等待时间（RNR Timer）进行等待。</li>
<li>等待时间结束后，发送方会尝试重新发送消息。</li>
<li>如果接收方在重试期间发布了新的接收请求，消息将被成功接收并返回 ACK。</li>
<li>如果多次重试后仍未成功（超过最大 RNR 重试次数），发送方会报告一个 RNR 重试错误 的工作完成状态<br>（Work Completion）。</li>
</ul>
<h3 id="poll-completion"><a href="#poll-completion" class="headerlink" title="poll_completion"></a>poll_completion</h3><p>ibv_poll_cq</p>
<h3 id="resources-destroy"><a href="#resources-destroy" class="headerlink" title="resources_destroy"></a>resources_destroy</h3><ul>
<li>ibv_destroy_qp</li>
<li>ibv_dereg_mr</li>
<li>ibv_destroy_cq</li>
<li>ibv_dealloc_pd</li>
<li>ibv_close_device</li>
<li>close: socket</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/09/19/rdma/RDMA%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/09/19/rdma/RDMA%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">RDMA 性能测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-09-19 12:10:57" itemprop="dateCreated datePublished" datetime="2025-09-19T12:10:57+00:00">2025-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-02 14:58:39" itemprop="dateModified" datetime="2025-12-02T14:58:39+00:00">2025-12-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/RDMA/" itemprop="url" rel="index"><span itemprop="name">RDMA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="命令速查表"><a href="#命令速查表" class="headerlink" title="命令速查表"></a>命令速查表</h2><ul>
<li><code>ib_</code> → <strong>Benchmark</strong>：性能测试工具</li>
<li><code>ibv_</code> → <strong>Verbs</strong>：编程与设备信息</li>
<li><code>ib</code> → <strong>Fabric</strong>：网络拓扑与诊断</li>
<li><code>opensm</code> → <strong>管理器</strong>：子网控制核心</li>
</ul>
<h3 id="网络拓扑与状态诊断（ib-前缀）"><a href="#网络拓扑与状态诊断（ib-前缀）" class="headerlink" title="网络拓扑与状态诊断（ib 前缀）"></a>网络拓扑与状态诊断（<code>ib</code> 前缀）</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">功能说明</th>
<th align="center">推荐场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ibstat</td>
<td align="center">查看本地 HCA 的端口状态和速率</td>
<td align="center">快速确认端口是否 LinkUp</td>
</tr>
<tr>
<td align="center">iblinkinfo</td>
<td align="center">显示整个网络的链路连接拓扑</td>
<td align="center">检查交换机与节点连接情况</td>
</tr>
<tr>
<td align="center">ibnetdiscover</td>
<td align="center">构建子网拓扑图（基于 SM）</td>
<td align="center">网络可视化、拓扑分析</td>
</tr>
<tr>
<td align="center">ibdiagnet</td>
<td align="center">深度诊断 InfiniBand 网络问题</td>
<td align="center">性能瓶颈、错误帧分析</td>
</tr>
<tr>
<td align="center">ibsysstat</td>
<td align="center">查看系统级 InfiniBand 状态</td>
<td align="center">多节点状态汇总</td>
</tr>
</tbody></table>
<h3 id="RDMA-编程与设备信息（ibv-前缀）"><a href="#RDMA-编程与设备信息（ibv-前缀）" class="headerlink" title="RDMA 编程与设备信息（ibv_ 前缀）"></a>RDMA 编程与设备信息（<code>ibv_</code> 前缀）</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">功能说明</th>
<th align="center">推荐场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ibv_devinfo</td>
<td align="center">查看本地 RDMA 网卡设备信息</td>
<td align="center">网卡识别、端口状态确认</td>
</tr>
<tr>
<td align="center">ibv_devices</td>
<td align="center">列出所有支持 RDMA 的设备</td>
<td align="center">多网卡环境初始化</td>
</tr>
<tr>
<td align="center">ibv_rc_pingpong</td>
<td align="center">使用 RC QP 测试点对点通信</td>
<td align="center">RDMA 编程验证</td>
</tr>
<tr>
<td align="center">ibv_srq_pingpong</td>
<td align="center">使用共享接收队列测试通信</td>
<td align="center">SRQ 场景验证</td>
</tr>
<tr>
<td align="center">ibv_ud_pingpong</td>
<td align="center">使用 UD QP 测试通信</td>
<td align="center">多播或无连接场景测试</td>
</tr>
</tbody></table>
<h3 id="性能测试与基准评估（ib-前缀）"><a href="#性能测试与基准评估（ib-前缀）" class="headerlink" title="性能测试与基准评估（ib_ 前缀）"></a>性能测试与基准评估（<code>ib_</code> 前缀）</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th>功能说明</th>
<th>推荐场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ib_send_bw</td>
<td>测试 RDMA 发送带宽</td>
<td>点对点性能评估</td>
</tr>
<tr>
<td align="center">ib_read_bw</td>
<td>测试 RDMA 读带宽</td>
<td>存储访问场景评估</td>
</tr>
<tr>
<td align="center">ib_write_bw</td>
<td>测试 RDMA 写带宽</td>
<td>写密集型应用测试</td>
</tr>
<tr>
<td align="center">ib_send_lat</td>
<td>测试发送延迟</td>
<td>延迟敏感应用调优</td>
</tr>
<tr>
<td align="center">ib_read_lat</td>
<td>测试读延迟</td>
<td>存储延迟分析</td>
</tr>
<tr>
<td align="center">ib_write_lat</td>
<td>测试写延迟</td>
<td>写延迟分析</td>
</tr>
<tr>
<td align="center">ib_pingpong</td>
<td>简单点对点通信测试（旧版）</td>
<td>快速连通性验证</td>
</tr>
</tbody></table>
<h3 id="管理与配置辅助工具"><a href="#管理与配置辅助工具" class="headerlink" title="管理与配置辅助工具"></a>管理与配置辅助工具</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">功能说明</th>
<th align="center">推荐场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">opensm</td>
<td align="center">启动子网管理器（SM）</td>
<td align="center">小规模集群或测试环境</td>
</tr>
<tr>
<td align="center">perfquery</td>
<td align="center">查询端口性能计数器</td>
<td align="center">错误帧、丢包分析</td>
</tr>
<tr>
<td align="center">saquery</td>
<td align="center">查询子网代理信息</td>
<td align="center">LID&#x2F;GID 映射验证</td>
</tr>
<tr>
<td align="center">sminfo</td>
<td align="center">查看 SM 状态信息</td>
<td align="center">SM 健康检查</td>
</tr>
</tbody></table>
<h2 id="物理硬件"><a href="#物理硬件" class="headerlink" title="物理硬件"></a>物理硬件</h2><ul>
<li>HCA 可能有多个物理端口 (port)：每个 port 有一个 LID 。</li>
<li>每个 port 可能有多个通道 (lane) ：用 <code>1x</code>, <code>2x</code>, <code>4x</code>, <code>8x</code> 等表示。</li>
<li>总速率：<code>总速率 = 每个 port 的 lane 数 × 每个 lane 的速率 × port 数量</code>。</li>
<li>port 和 lane 是有物理硬件决定的。</li>
</ul>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><ul>
<li><p>通道是物理层的能力</p>
<ul>
<li>每个 InfiniBand 或 PCIe 接口由若干个 lane 组成，每个 lane 是一对差分信号线（发送 + 接收）。</li>
<li>比如：<ul>
<li>x1 表示 1 个 lane → 最低带宽</li>
<li>x4 表示 4 个 lane → 常见于 EDR（100G）</li>
<li>x8 表示 8 个 lane → HDR&#x2F;NDR（200G&#x2F;400G）</li>
<li>x12 是更高端的聚合方式 → 超大带宽（如 600G）</li>
</ul>
</li>
</ul>
</li>
<li><p>“部署”决定你能否用满这些通道</p>
<ul>
<li>如果你部署的是 x4 的 HCA + x4 的交换机 + x4 的线缆，你就能跑满 4 个 lane。</li>
<li>如果你部署的是 x8 的 HCA，但只用了 x4 的线缆，你只能跑 4 个 lane，剩下的通道闲置。</li>
<li>如果你部署的是 x12 的交换机，但 HCA 只有 x4，你也只能用其中一部分。</li>
</ul>
</li>
</ul>
<p>举个例子：HDR 200G 的部署选择</p>
<table>
<thead>
<tr>
<th align="center">部署方式</th>
<th align="center">通道数</th>
<th align="center">实际带宽</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>HCA: x4</code> + <code>Cable: x4</code> + <code>Switch: x4</code></td>
<td align="center">4</td>
<td align="center">200 Gbps</td>
</tr>
<tr>
<td align="center"><code>HCA: x8</code> + <code>Cable: x4</code> + <code>Switch: x4</code></td>
<td align="center">4</td>
<td align="center">200 Gbps（x8 闲置一半）</td>
</tr>
<tr>
<td align="center"><code>HCA: x8</code> + <code>Cable: x8</code> + <code>Switch: x8</code></td>
<td align="center">8</td>
<td align="center">400 Gbps</td>
</tr>
</tbody></table>
<p>只有在部署中三者都匹配时，才能真正跑满所有通道。</p>
<h3 id="程序员关注的层面"><a href="#程序员关注的层面" class="headerlink" title="程序员关注的层面"></a>程序员关注的层面</h3><table>
<thead>
<tr>
<th align="center">层级</th>
<th align="center">程序员是否需要控制</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Lane（物理通道）</td>
<td align="center">❌ 不需要</td>
</tr>
<tr>
<td align="center">Port（物理接口）</td>
<td align="center">✅ 可选（如多 port HCA）</td>
</tr>
<tr>
<td align="center">QP（逻辑通信通道）</td>
<td align="center">✅ 必须管理</td>
</tr>
<tr>
<td align="center">Memory Region（MR）</td>
<td align="center">✅ 必须注册</td>
</tr>
<tr>
<td align="center">Completion Queue（CQ）</td>
<td align="center">✅ 必须轮询或处理</td>
</tr>
</tbody></table>
<h2 id="带宽测试"><a href="#带宽测试" class="headerlink" title="带宽测试"></a>带宽测试</h2><h3 id="理论带宽"><a href="#理论带宽" class="headerlink" title="理论带宽"></a>理论带宽</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci | grep -i infiniband</span><br></pre></td></tr></table></figure>

<p>然后通过阅读产品说明书，确定理论带宽。</p>
<h3 id="协商带宽"><a href="#协商带宽" class="headerlink" title="协商带宽"></a>协商带宽</h3><p>实际部署的速率，可能与 HCA 、线缆、交换机都相关，所以实际会有一个协商速率。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibstat</span><br></pre></td></tr></table></figure>

<h3 id="实际带宽测试"><a href="#实际带宽测试" class="headerlink" title="实际带宽测试"></a>实际带宽测试</h3><p>发送速率：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Server 端（等待连接）</span></span><br><span class="line">ib_send_bw -d mlx5_0 -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># Client 端（发起连接）</span></span><br><span class="line">ib_send_bw -d mlx5_0 -a &lt;server_ip&gt;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/12/">12</a><a class="extend next" rel="next" href="/blog/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="bi-an"
      src="/blog/images/avatar.gif">
  <p class="site-author-name" itemprop="name">bi-an</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">115</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/bi-an" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;bi-an" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ah_zzg@126.com" title="E-Mail → mailto:ah_zzg@126.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://cuda-doc.readthedocs.io/" title="https:&#x2F;&#x2F;cuda-doc.readthedocs.io" rel="noopener" target="_blank">CUDA中文手册</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://infiniband-doc.readthedocs.io/" title="https:&#x2F;&#x2F;infiniband-doc.readthedocs.io&#x2F;" rel="noopener" target="_blank">InfiniBand中文手册</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bi-an</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>




  




  
<script src="/blog/js/local-search.js"></script>













  

  

</body>
</html>
