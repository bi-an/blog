<!DOCTYPE html>
<html lang="en, zh_CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"bi-an.github.io","root":"/blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="江南人物的博客">
<meta property="og:url" content="https://bi-an.github.io/blog/index.html">
<meta property="og:site_name" content="江南人物的博客">
<meta property="og:locale">
<meta property="article:author" content="bi-an">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://bi-an.github.io/blog/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en, zh_CN'
  };
</script>

  <title>江南人物的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">江南人物的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-resource">

    <a href="/blog/resources/" rel="section"><i class="fa fa-paperclip fa-fw"></i>Resource</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/19/concurrency/TBB%E5%85%B8%E5%9E%8B%E5%9C%BA%E6%99%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/19/concurrency/TBB%E5%85%B8%E5%9E%8B%E5%9C%BA%E6%99%AF/" class="post-title-link" itemprop="url">TBB典型场景</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-19 22:48:38" itemprop="dateCreated datePublished" datetime="2025-08-19T22:48:38+00:00">2025-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-20 11:25:01" itemprop="dateModified" datetime="2025-08-20T11:25:01+00:00">2025-08-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="IO-CPU-密集-IO"><a href="#IO-CPU-密集-IO" class="headerlink" title="IO + CPU 密集 + IO"></a>IO + CPU 密集 + IO</h2><p>tasks</p>
<figure class="highlight cpp"><figcaption><span>tasks.hpp</span><a href="/blog/downloads/code/tbb/pipeline/tasks.hpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟 IO 和 CPU 任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataChunk</span> {</span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; data;</span><br><span class="line">    <span class="built_in">DataChunk</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">DataChunk</span><span class="params">(<span class="type">size_t</span> size)</span> : data(size) {</span>}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CompressedChunk</span> {</span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; data;</span><br><span class="line">    <span class="built_in">CompressedChunk</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CompressedChunk</span><span class="params">(<span class="type">size_t</span> size)</span> : data(size) {</span>}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟数据读取函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">read_from_network</span><span class="params">(DataChunk&amp; chunk)</span> </span>{</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);  <span class="comment">// 模拟 IO 延迟</span></span><br><span class="line"></span><br><span class="line">    chunk.data.<span class="built_in">resize</span>(<span class="number">100</span>);  <span class="comment">// 模拟每个数据块有 100 个字节</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (count++ &gt;= <span class="number">10</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 模拟读取 10 个数据块后结束</span></span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">generate</span>(chunk.data.<span class="built_in">begin</span>(), chunk.data.<span class="built_in">end</span>(),</span><br><span class="line">                  []() { <span class="keyword">return</span> <span class="built_in">rand</span>() % <span class="number">256</span>; });</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟压缩函数</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">compress_byte</span><span class="params">(<span class="type">char</span> byte)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10&#x27;000ll</span>; ++i)</span><br><span class="line">        ;               <span class="comment">// 模拟 CPU busy</span></span><br><span class="line">    <span class="keyword">return</span> byte % <span class="number">128</span>;  <span class="comment">// 简单压缩算法示例</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟写入函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_to_file</span><span class="params">(<span class="type">const</span> CompressedChunk&amp; chunk)</span> </span>{</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);  <span class="comment">// 模拟 IO 延迟</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Writing chunk of size &quot;</span> &lt;&lt; chunk.data.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>方案一</p>
<figure class="highlight cpp"><figcaption><span>1_message_queue.cpp</span><a href="/blog/downloads/code/tbb/pipeline/1_message_queue.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方案 1：异步队列 + TBB 流水线</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/tbb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tasks.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局队列</span></span><br><span class="line">std::queue&lt;std::vector&lt;<span class="type">char</span>&gt;&gt; readQueue;</span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::atomic_bool stop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">networkReader</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (!stop) {</span><br><span class="line">        DataChunk chunk;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">read_from_network</span>(chunk))  <span class="comment">// 阻塞 I/O</span></span><br><span class="line">        {</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        {</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            readQueue.<span class="built_in">push</span>(std::<span class="built_in">move</span>(chunk.data));</span><br><span class="line">        }</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩任务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compressor</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (!stop) {</span><br><span class="line">        DataChunk chunk;</span><br><span class="line">        {</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [] { <span class="keyword">return</span> !readQueue.<span class="built_in">empty</span>(); });</span><br><span class="line">            chunk.data = std::<span class="built_in">move</span>(readQueue.<span class="built_in">front</span>());</span><br><span class="line">            readQueue.<span class="built_in">pop</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CPU 密集计算，使用 TBB 并行</span></span><br><span class="line">        <span class="function">CompressedChunk <span class="title">compressed</span><span class="params">(chunk.data.size())</span></span>;</span><br><span class="line">        tbb::<span class="built_in">parallel_for</span>(<span class="built_in">size_t</span>(<span class="number">0</span>), chunk.data.<span class="built_in">size</span>(), [&amp;](<span class="type">size_t</span> i) {</span><br><span class="line">            compressed.data[i] = <span class="built_in">compress_byte</span>(chunk.data[i]);  <span class="comment">// 假设单字节压缩</span></span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="built_in">write_to_file</span>(compressed);  <span class="comment">// 可以异步</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::thread <span class="title">reader</span><span class="params">(networkReader)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(compressor)</span></span>;</span><br><span class="line"></span><br><span class="line">    reader.<span class="built_in">join</span>();</span><br><span class="line">    worker.<span class="built_in">join</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>方案二</p>
<figure class="highlight cpp"><figcaption><span>2_flow_graph.cpp</span><a href="/blog/downloads/code/tbb/pipeline/2_flow_graph.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方案 2：TBB Flow Graph</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/flow_graph.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/tbb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tasks.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tbb;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tbb::flow;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    graph g;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 读取节点（串行）</span></span><br><span class="line">    <span class="function">input_node&lt;DataChunk&gt; <span class="title">reader</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        g,</span></span></span><br><span class="line"><span class="params"><span class="function">        [](flow_control&amp; fc) -&gt; DataChunk {</span></span></span><br><span class="line"><span class="params"><span class="function">            DataChunk chunk(<span class="number">1024</span>);  <span class="comment">// 1KB数据块</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (!read_from_network(chunk)) {</span></span></span><br><span class="line"><span class="params"><span class="function">                fc.stop();</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">return</span> DataChunk();</span></span></span><br><span class="line"><span class="params"><span class="function">            }</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">return</span> chunk;</span></span></span><br><span class="line"><span class="params"><span class="function">        })</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 并行处理节点（无限制并发）</span></span><br><span class="line">    <span class="function">function_node&lt;DataChunk, CompressedChunk&gt; <span class="title">processor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        g, unlimited,</span></span></span><br><span class="line"><span class="params"><span class="function">        [](<span class="type">const</span> DataChunk&amp; input) -&gt; CompressedChunk {</span></span></span><br><span class="line"><span class="params"><span class="function">            CompressedChunk output(input.data.size());</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            tbb::parallel_for(</span></span></span><br><span class="line"><span class="params"><span class="function">                tbb::blocked_range&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>, input.data.size()),</span></span></span><br><span class="line"><span class="params"><span class="function">                [&amp;](<span class="type">const</span> tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r) {</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">for</span> (<span class="type">size_t</span> i = r.begin(); i != r.end(); ++i) {</span></span></span><br><span class="line"><span class="params"><span class="function">                        output.data[i] = compress_byte(input.data[i]);</span></span></span><br><span class="line"><span class="params"><span class="function">                    }</span></span></span><br><span class="line"><span class="params"><span class="function">                });</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">return</span> output;</span></span></span><br><span class="line"><span class="params"><span class="function">        })</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 写入节点（串行保证写入顺序）</span></span><br><span class="line">    <span class="function">function_node&lt;CompressedChunk&gt; <span class="title">writer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        g, serial,</span></span></span><br><span class="line"><span class="params"><span class="function">        [](<span class="type">const</span> CompressedChunk&amp; output) {</span></span></span><br><span class="line"><span class="params"><span class="function">            write_to_file(output);</span></span></span><br><span class="line"><span class="params"><span class="function">        })</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建数据流管道</span></span><br><span class="line">    <span class="built_in">make_edge</span>(reader, processor);</span><br><span class="line">    <span class="built_in">make_edge</span>(processor, writer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动管道</span></span><br><span class="line">    reader.<span class="built_in">activate</span>();</span><br><span class="line">    g.<span class="built_in">wait_for_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>方案三</p>
<figure class="highlight cpp"><figcaption><span>3_pipeline.cpp</span><a href="/blog/downloads/code/tbb/pipeline/3_pipeline.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方案 3: TBB 流水线</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/tbb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tasks.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    tbb::<span class="built_in">parallel_pipeline</span>(</span><br><span class="line">        <span class="comment">/* max_number_of_live_token */</span> <span class="number">4</span>,</span><br><span class="line">        <span class="comment">// Stage 1: 读网络数据</span></span><br><span class="line">        tbb::<span class="built_in">make_filter</span>&lt;<span class="type">void</span>, DataChunk&gt;(</span><br><span class="line">            tbb::filter_mode::serial_in_order,</span><br><span class="line">            [](tbb::flow_control&amp; fc) -&gt; DataChunk {</span><br><span class="line">                DataChunk chunk;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">read_from_network</span>(chunk)) {  <span class="comment">// 返回 false 时结束</span></span><br><span class="line">                    fc.<span class="built_in">stop</span>();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> chunk;</span><br><span class="line">            }) &amp;</span><br><span class="line">            <span class="comment">// Stage 2: CPU 压缩</span></span><br><span class="line">            tbb::<span class="built_in">make_filter</span>&lt;DataChunk, CompressedChunk&gt;(</span><br><span class="line">                tbb::filter_mode::parallel,</span><br><span class="line">                [](DataChunk chunk) -&gt; CompressedChunk {</span><br><span class="line">                    CompressedChunk <span class="built_in">out</span>(chunk.data.<span class="built_in">size</span>());</span><br><span class="line">                    tbb::<span class="built_in">parallel_for</span>(<span class="built_in">size_t</span>(<span class="number">0</span>), chunk.data.<span class="built_in">size</span>(), [&amp;](<span class="type">size_t</span> i) {</span><br><span class="line">                        out.data[i] = <span class="built_in">compress_byte</span>(chunk.data[i]);</span><br><span class="line">                    });</span><br><span class="line">                    <span class="keyword">return</span> out;</span><br><span class="line">                }) &amp;</span><br><span class="line">            <span class="comment">// Stage 3: 写文件</span></span><br><span class="line">            tbb::<span class="built_in">make_filter</span>&lt;CompressedChunk, <span class="type">void</span>&gt;(</span><br><span class="line">                tbb::filter_mode::serial_in_order,</span><br><span class="line">                [](CompressedChunk out) {</span><br><span class="line">                    <span class="built_in">write_to_file</span>(out);  <span class="comment">// 可以异步</span></span><br><span class="line">                }));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/19/os/%E5%BC%82%E6%AD%A5IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/19/os/%E5%BC%82%E6%AD%A5IO/" class="post-title-link" itemprop="url">异步IO</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-19 20:26:00" itemprop="dateCreated datePublished" datetime="2025-08-19T20:26:00+00:00">2025-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-20 11:25:01" itemprop="dateModified" datetime="2025-08-20T11:25:01+00:00">2025-08-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="IO模型概念"><a href="#IO模型概念" class="headerlink" title="IO模型概念"></a>IO模型概念</h2><p>IO 模型通常按两条维度划分：</p>
<ol>
<li><p>阻塞 vs 非阻塞</p>
<ul>
<li>阻塞 IO（Blocking IO）：调用 read&#x2F;recv 等函数时，如果数据没准备好，进程会被挂起，直到数据就绪。</li>
<li>非阻塞 IO（Non-blocking IO）：调用 read&#x2F;recv 时，如果数据没准备好，直接返回 EAGAIN 或 EWOULDBLOCK，进程继续做别的事情。</li>
</ul>
</li>
<li><p>同步 vs 异步</p>
<ul>
<li><p>同步（Synchronous）：调用者要等待操作完成才能继续。</p>
<ul>
<li>阻塞 IO + 同步：最常见，比如普通 read(fd, buf, n)</li>
<li>非阻塞 IO + 同步：调用立即返回，如果没数据则报错或返回 0</li>
</ul>
</li>
<li><p>异步（Asynchronous）：调用者发起操作后，不需要等待，操作完成时通过回调、信号、事件通知等告知结果。</p>
</li>
</ul>
</li>
</ol>
<p>⚡ 关键：异步 IO 的核心是不阻塞当前线程，而结果通知是通过事件或回调完成的。</p>
<h2 id="Linux-常见异步-IO-方式"><a href="#Linux-常见异步-IO-方式" class="headerlink" title="Linux 常见异步 IO 方式"></a>Linux 常见异步 IO 方式</h2><p>Linux 下主要有四种机制：</p>
<ol>
<li><p>POSIX AIO（aio_* 系列）</p>
<ul>
<li><p>系统调用：aio_read(), aio_write()</p>
</li>
<li><p>完成通知方式：</p>
<ul>
<li>轮询 aio_error()</li>
<li>信号通知 SIGIO</li>
<li>回调函数 sigevent.sigev_notify &#x3D; SIGEV_THREAD</li>
</ul>
</li>
<li><p>使用场景：文件 IO，可以在后台发起读写请求，主线程继续工作。</p>
</li>
<li><p>⚠️ 目前性能不如 epoll + 线程池模拟异步。</p>
</li>
</ul>
</li>
<li><p>信号驱动 IO（SIGIO）</p>
<ul>
<li>进程或文件描述符注册 F_SETOWN，开启 O_ASYNC</li>
<li>当 fd 可读写时，内核发信号给进程</li>
<li>通常用于少量 fd 的异步事件</li>
</ul>
</li>
<li><p>I&#x2F;O 多路复用（select, poll, epoll）</p>
<ul>
<li><p>本质是非阻塞 + 事件通知</p>
</li>
<li><p>Epoll + 非阻塞 IO 可以模拟高效的异步 IO</p>
</li>
<li><p>适合网络服务器、socket 编程</p>
</li>
<li><p>典型流程：</p>
<ul>
<li>设置 fd 为非阻塞（否则 read&#x2F;write 可能阻塞，因为 epoll 本质是同步的）</li>
<li>注册 fd 到 epoll，关注 EPOLLIN &#x2F; EPOLLOUT</li>
<li>调用 epoll_wait 等待事件</li>
<li>事件触发时读取或写入数据</li>
</ul>
</li>
</ul>
</li>
<li><p>Linux AIO（io_uring）</p>
<ul>
<li>新一代高性能异步 IO 接口</li>
<li>支持文件、网络 IO</li>
<li>提供 提交队列 + 完成队列，几乎零系统调用开销</li>
<li>可以真正做到线程几乎不阻塞等待</li>
</ul>
</li>
</ol>
<h3 id="异步-IO-的优点"><a href="#异步-IO-的优点" class="headerlink" title="异步 IO 的优点"></a>异步 IO 的优点</h3><ul>
<li>不阻塞主线程，提高吞吐量</li>
<li>可同时处理大量 IO（特别是网络&#x2F;文件服务器）</li>
<li>与多线程相比，降低线程上下文切换开销</li>
</ul>
<h3 id="异步-IO-的缺点"><a href="#异步-IO-的缺点" class="headerlink" title="异步 IO 的缺点"></a>异步 IO 的缺点</h3><ul>
<li>编程复杂度高（需要事件驱动、回调或状态机）</li>
<li>错误处理和信号安全问题复杂</li>
<li>文件异步 IO 性能在传统 AIO 下不一定比多线程高</li>
</ul>
<h3 id="Linux-下常见异步-I-O-机制对比"><a href="#Linux-下常见异步-I-O-机制对比" class="headerlink" title="Linux 下常见异步 I&#x2F;O 机制对比"></a>Linux 下常见异步 I&#x2F;O 机制对比</h3><table>
<thead>
<tr>
<th>特性 &#x2F; 机制</th>
<th>POSIX AIO</th>
<th>epoll + 非阻塞 IO</th>
<th>io_uring</th>
<th>信号驱动 IO (SIGIO)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>类型</strong></td>
<td>异步文件 IO</td>
<td>多路复用 + 非阻塞网络 IO</td>
<td>高性能异步 IO</td>
<td>异步事件通知</td>
</tr>
<tr>
<td><strong>支持对象</strong></td>
<td>文件</td>
<td>文件描述符（socket、管道等）</td>
<td>文件 + 网络 + 其他 IO</td>
<td>文件描述符（socket、pipe）</td>
</tr>
<tr>
<td><strong>用户态&#x2F;内核态</strong></td>
<td>系统调用提交，内核异步处理</td>
<td>用户态轮询&#x2F;等待事件，内核检查 fd</td>
<td>用户态 SQ + 内核 CQ</td>
<td>用户注册 fd，内核通过信号通知</td>
</tr>
<tr>
<td><strong>提交方式</strong></td>
<td>aio_read&#x2F;aio_write</td>
<td>写入 fd 并通过 epoll_wait 检查</td>
<td>写入 SQ（批量可提交）</td>
<td>设置 O_ASYNC + F_SETOWN</td>
</tr>
<tr>
<td><strong>完成通知</strong></td>
<td>信号 &#x2F; 回调 &#x2F; aio_error轮询</td>
<td>epoll_wait 返回就绪事件</td>
<td>完成队列 (CQ)，阻塞或非阻塞读取</td>
<td>信号处理函数 (SIGIO)</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>中等，系统调用多</td>
<td>高，单线程处理大量 fd</td>
<td>很高，几乎零系统调用，批量提交</td>
<td>较低，信号开销大，适合少量 fd</td>
</tr>
<tr>
<td><strong>编程复杂度</strong></td>
<td>中等偏复杂</td>
<td>中等，需要状态机处理</td>
<td>高，但灵活，可批量和链式操作</td>
<td>高，信号处理函数限制多，必须信号安全</td>
</tr>
<tr>
<td><strong>适合场景</strong></td>
<td>文件异步读写</td>
<td>高并发网络服务器</td>
<td>高性能文件和网络 IO</td>
<td>少量异步事件或控制信号触发场景</td>
</tr>
</tbody></table>
<h2 id="Linux-io-uring"><a href="#Linux-io-uring" class="headerlink" title="Linux io_uring"></a>Linux io_uring</h2><p>io_uring 是 Linux 内核自 5.1 版本引入的一个异步 I&#x2F;O 框架，它提供了 低延迟、高吞吐的异步文件和网络 I&#x2F;O。它的特点是：</p>
<ul>
<li>零拷贝提交：应用程序可以直接向内核提交 I&#x2F;O 请求，无需系统调用每次阻塞。</li>
<li>环形队列机制：通过共享内存的 提交队列（Submission Queue, SQ） 和 完成队列（Completion Queue, CQ），用户态和内核态可以高效交互。</li>
<li>支持多种 I&#x2F;O 类型：文件读写、网络收发、文件同步、缓冲区操作等。</li>
<li>批量提交和完成：可以一次提交多个 I&#x2F;O 请求，并批量获取完成结果。</li>
</ul>
<p>简单理解：它把传统阻塞 I&#x2F;O 的 “系统调用来回” 改成了 共享环形队列 + 异步通知。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li>方法一：从 APT 安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install liburing-dev</span><br></pre></td></tr></table></figure>

<p>检查安装路径</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /usr/include/liburing.h</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>方法二：从源码安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/axboe/liburing.git</span><br><span class="line"><span class="built_in">cd</span> liburing</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h3 id="io-uring-的核心数据结构"><a href="#io-uring-的核心数据结构" class="headerlink" title="io_uring 的核心数据结构"></a>io_uring 的核心数据结构</h3><p>Submission Queue（SQ）</p>
<ul>
<li>用户态将 I&#x2F;O 请求放入 SQ。</li>
<li>SQ 是一个环形数组，存放 io_uring_sqe（I&#x2F;O 请求条目）。</li>
<li>用户通过 系统调用 io_uring_enter 将 SQ 中的新请求通知内核。</li>
<li>内核会按顺序处理 SQ 中的 I&#x2F;O 请求。</li>
</ul>
<table>
<thead>
<tr>
<th>字段</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>opcode</code></td>
<td>I&#x2F;O 类型，如读、写、fsync、accept、sendmsg</td>
</tr>
<tr>
<td><code>fd</code></td>
<td>文件描述符</td>
</tr>
<tr>
<td><code>off</code></td>
<td>偏移量（文件 I&#x2F;O）</td>
</tr>
<tr>
<td><code>addr</code></td>
<td>用户缓冲区地址</td>
</tr>
<tr>
<td><code>len</code></td>
<td>I&#x2F;O 数据长度</td>
</tr>
<tr>
<td><code>flags</code></td>
<td>请求标志，如 <code>IOSQE_FIXED_FILE</code>、<code>IOSQE_IO_LINK</code></td>
</tr>
</tbody></table>
<p>Completion Queue（CQ）</p>
<ul>
<li>内核完成 I&#x2F;O 后，将结果写入 CQ。</li>
<li>CQ 也是一个环形数组，存放 io_uring_cqe（完成条目）。</li>
<li>用户可以轮询或等待 CQ 获取完成结果。</li>
</ul>
<table>
<thead>
<tr>
<th>字段</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>res</code></td>
<td>I&#x2F;O 结果，成功为正数（读写字节数），失败为负错误码</td>
</tr>
<tr>
<td><code>user_data</code></td>
<td>用户自定义数据，方便识别请求</td>
</tr>
</tbody></table>
<h3 id="io-uring-工作流程"><a href="#io-uring-工作流程" class="headerlink" title="io_uring 工作流程"></a>io_uring 工作流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+-----------+          +-----------+</span><br><span class="line">| User App  | &lt;-----&gt;  |  Kernel  |</span><br><span class="line">+-----------+          +-----------+</span><br><span class="line">      |                     |</span><br><span class="line">      |  write SQE to SQ    | &lt;- Submission Queue</span><br><span class="line">      |--------------------&gt;|</span><br><span class="line">      |                     |</span><br><span class="line">      |   io_uring_enter    | &lt;- 通知内核处理</span><br><span class="line">      |--------------------&gt;|</span><br><span class="line">      |                     |</span><br><span class="line">      | &lt;------------------ | &lt;- CQE 放入 CQ</span><br><span class="line">      |  read CQE from CQ   |</span><br></pre></td></tr></table></figure>

<ul>
<li>用户态填充 SQE（Submission Queue Entry）。</li>
<li>调用 io_uring_enter() 提交 SQE （不阻塞）。</li>
<li>内核处理 I&#x2F;O 请求。</li>
<li>内核把完成结果写入 CQ。</li>
<li>用户态可以：<ul>
<li>轮询 CQ：主动读取 CQE（Completion Queue Entry）</li>
<li>注册回调（liburing 新版本支持 IORING_SETUP_IOPOLL + IORING_SETUP_SQPOLL 或自己封装）</li>
</ul>
</li>
</ul>
<p>注意：</p>
<ul>
<li>异步 I&#x2F;O ≠ 必须用回调。关键是提交后不阻塞等待，可以同步轮询完成结果，也可以异步触发回调。</li>
<li>回调是一种可选的使用方式。</li>
<li>最核心的是 共享环形队列 + 完成队列，用户可以同步取结果也可以异步通知。</li>
</ul>
<h3 id="为什么-io-uring-没有强制回调"><a href="#为什么-io-uring-没有强制回调" class="headerlink" title="为什么 io_uring 没有强制回调"></a>为什么 io_uring 没有强制回调</h3><p>传统异步 I&#x2F;O（比如 Windows IOCP）必须注册回调或事件句柄，因为内核不会给你“主动通知”。</p>
<p>Linux io_uring 的设计哲学是：</p>
<ul>
<li>用户态和内核共享内存 → 用户态可以自己轮询完成队列。</li>
<li>减少系统调用次数 → 不依赖信号或回调触发。</li>
<li>需要回调时，用户可以自己封装一个事件循环。</li>
</ul>
<p>所以你看到 io_uring 的官方示例都是 顺序写代码，但是仍然是异步 I&#x2F;O，因为：</p>
<ul>
<li>提交后内核可以并行处理多个 I&#x2F;O。</li>
<li>用户态无需阻塞等待内核完成处理（可以去做别的事）。</li>
</ul>
<h3 id="io-uring-的使用示例（C-语言）"><a href="#io-uring-的使用示例（C-语言）" class="headerlink" title="io_uring 的使用示例（C 语言）"></a>io_uring 的使用示例（C 语言）</h3><figure class="highlight cpp"><figcaption><span>io_uring_hello.c</span><a href="/blog/downloads/code/io/io_uring_hello.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;liburing.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE_DEPTH  8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE  1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">io_uring</span> ring;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">io_uring_sqe</span> *sqe;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">io_uring_cqe</span> *cqe;</span><br><span class="line">    <span class="type">int</span> ret, fd;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 io_uring</span></span><br><span class="line">    ret = <span class="built_in">io_uring_queue_init</span>(QUEUE_DEPTH, &amp;ring, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;io_uring_queue_init&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取提交队列条目</span></span><br><span class="line">    sqe = <span class="built_in">io_uring_get_sqe</span>(&amp;ring);</span><br><span class="line">    <span class="keyword">if</span> (!sqe) {</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;io_uring_get_sqe failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备读取操作</span></span><br><span class="line">    <span class="built_in">io_uring_prep_read</span>(sqe, fd, buf, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交到内核</span></span><br><span class="line">    ret = <span class="built_in">io_uring_submit</span>(&amp;ring);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;io_uring_submit&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待完成</span></span><br><span class="line">    ret = <span class="built_in">io_uring_wait_cqe</span>(&amp;ring, &amp;cqe);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;io_uring_wait_cqe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取结果</span></span><br><span class="line">    <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Async read failed: %d\n&quot;</span>, cqe-&gt;res);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read %d bytes: %.*s\n&quot;</span>, cqe-&gt;res, cqe-&gt;res, buf);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知内核完成</span></span><br><span class="line">    <span class="built_in">io_uring_cqe_seen</span>(&amp;ring, cqe);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭</span></span><br><span class="line">    <span class="built_in">io_uring_queue_exit</span>(&amp;ring);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>这个例子展示了 最基本的异步文件读取：</p>
<ul>
<li>初始化 ring。</li>
<li>获取一个 SQE 并填充读请求。</li>
<li>提交 SQE。</li>
<li>等待 CQE 获取结果。</li>
<li>标记完成并清理。</li>
</ul>
<h2 id="Boost-asio"><a href="#Boost-asio" class="headerlink" title="Boost asio"></a>Boost asio</h2><p>要区分 操作系统级别的异步 I&#x2F;O 和 asio 的抽象，因为 asio 并不是单一机制，而是根据平台选择最优实现。具体分析如下：</p>
<h3 id="asio-的工作原理"><a href="#asio-的工作原理" class="headerlink" title="asio 的工作原理"></a>asio 的工作原理</h3><p>asio 提供 异步接口（async_read, async_write 等），程序不会阻塞线程</p>
<p>内部实现方式根据平台不同而不同：</p>
<table>
<thead>
<tr>
<th>平台</th>
<th>异步方式</th>
</tr>
</thead>
<tbody><tr>
<td>Linux</td>
<td>基于 <strong>epoll &#x2F; io_uring &#x2F; AIO</strong>，是真正的内核异步 I&#x2F;O（零拷贝，内核通知完成）</td>
</tr>
<tr>
<td>Windows</td>
<td>基于 <strong>IOCP</strong>（I&#x2F;O Completion Ports），内核异步 I&#x2F;O</td>
</tr>
<tr>
<td>Mac &#x2F; BSD</td>
<td>基于 <strong>kqueue &#x2F; poll</strong>，有些情况下是模拟异步（多线程或事件轮询）</td>
</tr>
</tbody></table>
<p>要确认 asio 在你的 Linux 机器上选择了哪种底层 I&#x2F;O 机制，可以按下面几个方法操作：</p>
<ol>
<li>查看 asio 使用的 I&#x2F;O 对象</li>
</ol>
<p>asio 有两个主要 I&#x2F;O 后端：</p>
<ul>
<li>旧版 AIO &#x2F; epoll（select_reactor &#x2F; epoll_reactor）</li>
<li>io_uring（在新版本 Boost.Asio 或 standalone Asio 支持）</li>
</ul>
<p>在 编译时，asio 会检测系统特性：</p>
<ul>
<li>如果 Linux 内核 ≥ 5.1，asio 默认启用 io_uring</li>
<li>否则使用 epoll</li>
</ul>
<ol start="2">
<li>通过宏或配置查看</li>
</ol>
<p>在你的 asio 头文件中，可能有如下宏：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(BOOST_ASIO_HAS_IOURING)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;asio will use io_uring\n&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(BOOST_ASIO_HAS_EPOLL)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;asio will use epoll\n&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这些宏在 boost&#x2F;asio&#x2F;detail&#x2F;config.hpp 或 asio&#x2F;config.hpp 中定义，表示底层机制。</p>
<ol start="3">
<li>运行时确认</li>
</ol>
<p>asio 本身没有公开 API 显示底层 I&#x2F;O 类型，但可以通过系统调用监控判断：</p>
<p>使用 strace 观察程序 I&#x2F;O：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -f ./your_program 2&gt;&amp;1 | grep io_uring</span><br></pre></td></tr></table></figure>

<ul>
<li>如果看到 io_uring_setup、io_uring_enter 系统调用，就说明启用了 io_uring</li>
<li>如果没有，只看到 epoll_wait &#x2F; epoll_ctl，说明使用的是 epoll</li>
</ul>
<p>对 epoll，strace 会显示 epoll_create1 &#x2F; epoll_ctl &#x2F; epoll_wait</p>
<h3 id="阻塞-vs-异步"><a href="#阻塞-vs-异步" class="headerlink" title="阻塞 vs 异步"></a>阻塞 vs 异步</h3><table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>asio 中的表现</th>
</tr>
</thead>
<tbody><tr>
<td>阻塞 I&#x2F;O</td>
<td>调用时线程被挂起，等待 I&#x2F;O 完成</td>
<td>不使用，线程会被阻塞，TBB 线程占用</td>
</tr>
<tr>
<td>模拟异步</td>
<td>内核不支持真正异步，用线程轮询或线程池实现</td>
<td>Mac&#x2F;BSD 某些场景下可能是模拟</td>
</tr>
<tr>
<td>真正异步 I&#x2F;O</td>
<td>内核支持，操作提交后立即返回，完成由内核通知</td>
<td>Linux&#x2F;io_uring、Windows IOCP 就是真正异步</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/19/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/19/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-19 20:12:58" itemprop="dateCreated datePublished" datetime="2025-08-19T20:12:58+00:00">2025-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-20 11:25:01" itemprop="dateModified" datetime="2025-08-20T11:25:01+00:00">2025-08-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><p>malloc 是线程安全的，但有一些细节需要注意。</p>
<ol>
<li>线程安全含义</li>
</ol>
<p>线程安全：多个线程同时调用 malloc&#x2F;free 不会破坏堆管理结构，也不会导致内存管理崩溃。</p>
<p>实现方法：</p>
<p>glibc malloc 在内部使用 锁（mutex 或 spinlock） 保护全局堆管理数据结构</p>
<p>不同线程同时申请或释放内存，内核保证堆表一致</p>
<ol start="2">
<li>限制与注意事项</li>
</ol>
<p>性能问题</p>
<p>多线程频繁 malloc&#x2F;free，锁竞争可能成为瓶颈</p>
<p>对性能敏感的程序可能使用：</p>
<p>线程本地缓存（thread-local cache） 的 jemalloc &#x2F; tcmalloc</p>
<p>避免全局锁竞争</p>
<p>信号处理上下文不安全</p>
<p>虽然线程安全，但 malloc 在信号处理函数里不安全</p>
<p>原因：</p>
<p>信号可能打断正在执行的 malloc</p>
<p>malloc 内部锁可能被持有 → 再次调用可能死锁</p>
<p>所以 signal handler 中不能直接调用 malloc&#x2F;free</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>malloc&#x2F;glibc</th>
</tr>
</thead>
<tbody><tr>
<td>多线程调用安全</td>
<td>✅ 是线程安全的</td>
</tr>
<tr>
<td>信号处理函数调用安全</td>
<td>❌ 不安全</td>
</tr>
<tr>
<td>性能</td>
<td>可能锁竞争，需要优化（jemalloc&#x2F;tcmalloc）</td>
</tr>
</tbody></table>
<h2 id="信号安全"><a href="#信号安全" class="headerlink" title="信号安全"></a>信号安全</h2><p>malloc &#x2F; free 内部会修改全局堆管理结构（如 free list）</p>
<p>如果信号到达时主程序正在调用 malloc 或 free，信号处理函数里再次调用 malloc&#x2F;free → 堆数据结构可能被破坏，<br>可能导致崩溃或内存泄漏</p>
<p>虽然线程安全，但 malloc 在信号处理函数里不安全</p>
<p>原因：</p>
<ul>
<li>信号可能打断正在执行的 malloc</li>
<li>malloc 内部锁可能被持有 → 再次调用可能死锁</li>
</ul>
<p>所以 signal handler 中不能直接调用 malloc&#x2F;free</p>
<h3 id="安全做法"><a href="#安全做法" class="headerlink" title="安全做法"></a>安全做法</h3><p>信号处理函数里只做：</p>
<ul>
<li>设置标志位（sig_atomic_t flag &#x3D; 1;）</li>
<li>写入 pipe &#x2F; eventfd</li>
<li>调用 async-signal-safe 系统调用（write(), _exit()）</li>
</ul>
<p>之后由主程序在安全上下文处理 malloc&#x2F;free 或其他复杂操作</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/19/os/%E4%BF%A1%E5%8F%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/19/os/%E4%BF%A1%E5%8F%B7/" class="post-title-link" itemprop="url">信号</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-19 20:08:39" itemprop="dateCreated datePublished" datetime="2025-08-19T20:08:39+00:00">2025-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-20 11:25:01" itemprop="dateModified" datetime="2025-08-20T11:25:01+00:00">2025-08-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="异步信号"><a href="#异步信号" class="headerlink" title="异步信号"></a>异步信号</h2><p>锁、malloc 等不能在信号处理函数里用。这里涉及到 异步信号安全 (async-signal-safe) 的概念。</p>
<ol>
<li>信号处理函数的执行环境</li>
</ol>
<p>当一个信号到达进程时，内核 异步中断当前执行流，立即跳转到信号处理函数执行。</p>
<p>这意味着：</p>
<p>当前线程可能 正在持有锁（mutex、spinlock 等）</p>
<p>当前线程可能 正在使用 malloc&#x2F;free，操作堆数据结构</p>
<ol start="2">
<li>为什么不能调用这些函数</li>
</ol>
<p>锁（mutex 等）</p>
<p>如果信号处理函数里调用 pthread_mutex_lock()：</p>
<p>线程可能已经在信号到达前持有这个锁</p>
<p>信号处理函数再次尝试加锁 → 死锁</p>
<p>malloc &#x2F; free</p>
<p>malloc 内部会修改全局堆管理结构（如 free list）</p>
<p>如果信号到达时主程序正在调用 malloc 或 free，信号处理函数里再次调用 malloc&#x2F;free → 堆数据结构可能被破坏</p>
<p>可能导致崩溃或内存泄漏</p>
<ol start="3">
<li>async-signal-safe 函数</li>
</ol>
<p>POSIX 定义了一组 “异步信号安全函数”（async-signal-safe functions）</p>
<p>信号处理函数中 只允许调用这些函数</p>
<p>常用安全函数示例：</p>
<p>_exit()</p>
<p>write()（低级系统调用，不会锁堆）</p>
<p>sig_atomic_t 类型变量赋值</p>
<p>总结</p>
<table>
<thead>
<tr>
<th>函数类型</th>
<th>可在信号处理函数里用？</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>pthread_mutex_lock</td>
<td>❌</td>
<td>可能已持锁 → 死锁</td>
</tr>
<tr>
<td>malloc&#x2F;free</td>
<td>❌</td>
<td>可能正在操作堆 → 数据结构破坏</td>
</tr>
<tr>
<td>write(fd, buf, n)</td>
<td>✅</td>
<td>系统调用，不会破坏用户态结构</td>
</tr>
<tr>
<td>_exit()</td>
<td>✅</td>
<td>安全终止进程</td>
</tr>
</tbody></table>
<blockquote>
<p>核心思想：信号是异步的，中断当前执行流，调用非 async-signal-safe 函数可能破坏正在执行的操作，导致不可预测的行为。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/19/concurrency/thread_local%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/19/concurrency/thread_local%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">thread_local的实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-19 19:41:37" itemprop="dateCreated datePublished" datetime="2025-08-19T19:41:37+00:00">2025-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-20 11:25:01" itemprop="dateModified" datetime="2025-08-20T11:25:01+00:00">2025-08-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/c-cpp/" itemprop="url" rel="index"><span itemprop="name">c/cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>thread_local 的基本语义</li>
</ol>
<p>C++11 引入的存储类型说明符：</p>
<p>thread_local int x &#x3D; 0;</p>
<p>表示 每个线程都有一份独立的 x，互不干扰。</p>
<p>生命周期：跟普通静态变量类似（全局存活直到线程退出）。</p>
<ol start="2">
<li>底层实现原理</li>
</ol>
<p>它的实现依赖于 TLS (Thread Local Storage, 线程局部存储) 机制。</p>
<p>在 ELF&#x2F;Linux 下：</p>
<p>编译器在 .tdata &#x2F; .tbss 段里为 thread_local 变量分配空间（就像全局变量在 .data &#x2F; .bss 段里）。</p>
<p>程序加载时，动态链接器（ld.so）会记录这些 TLS 变量的“模板布局”。</p>
<p>每个线程启动时，线程库（glibc&#x2F;pthread）会：</p>
<p>给这个线程分配一块 TLS 块（通常放在线程栈附近，或者专门的内存页）。</p>
<p>把 .tdata 里的初始值拷贝到这个线程的 TLS 块。</p>
<p>.tbss 部分（未初始化的 thread_local）则清零。</p>
<p>线程访问 thread_local 时，编译器生成的代码会通过 TLS 寄存器（如 x86-64 的 FS&#x2F;GS 段寄存器）+ 偏移量，找到对应线程的存储单元。</p>
<p>例如 x86-64 Linux 上，errno 就是：</p>
<p>#define errno (*__errno_location())</p>
<p>而 __errno_location() 内部就是通过 %fs:offset 找到 TLS 块里的 errno。</p>
<ol start="3">
<li>存放在哪里？</li>
</ol>
<p>Windows：在 TEB (Thread Environment Block) 里有 TLS 指针，__declspec(thread) 就用它。</p>
<p>Linux&#x2F;ELF：在每个线程的 TLS 块里（通常分配在线程栈附近的一片内存区域）。访问通过 FS&#x2F;GS 寄存器。</p>
<p>编译器细节：</p>
<p>GCC&#x2F;Clang 默认用 “动态 TLS 模型”（访问时通过动态链接器查询 TLS 偏移）。</p>
<p>如果加 -ftls-model&#x3D;initial-exec，编译器会直接用固定偏移访问 TLS，速度更快（但要求变量在主程序或静态库里）。</p>
<ol start="4">
<li>示例</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        counter++;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;: counter = &quot;</span> &lt;&lt; counter &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(worker, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(worker, <span class="number">2</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出大致是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread 1: counter = 1</span><br><span class="line">Thread 1: counter = 2</span><br><span class="line">Thread 1: counter = 3</span><br><span class="line">Thread 2: counter = 1</span><br><span class="line">Thread 2: counter = 2</span><br><span class="line">Thread 2: counter = 3</span><br></pre></td></tr></table></figure>

<p>说明 counter 在不同线程里独立。</p>
<p>✅ 总结：</p>
<p>thread_local 变量放在 TLS 段，每个线程有自己的拷贝。</p>
<p>访问是通过 线程局部存储寄存器（FS&#x2F;GS）+ 偏移量 实现的。</p>
<p>存储空间由线程库在创建线程时分配和初始化。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/18/%E5%AE%9E%E7%94%A8%E4%B9%A6%E7%B1%8D%E5%88%97%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/18/%E5%AE%9E%E7%94%A8%E4%B9%A6%E7%B1%8D%E5%88%97%E8%A1%A8/" class="post-title-link" itemprop="url">实用书籍列表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-18 21:25:16" itemprop="dateCreated datePublished" datetime="2025-08-18T21:25:16+00:00">2025-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-20 11:25:01" itemprop="dateModified" datetime="2025-08-20T11:25:01+00:00">2025-08-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Misc/" itemprop="url" rel="index"><span itemprop="name">Misc</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>.<br>├── AT&amp;T Assembly Manual.pdf<br>├── C++ Primer Plus 第五版中文版.pdf<br>├── C++.Primer.5th.Edition_2013.pdf<br>├── CplusplusConcurrencyInAction_PracticalMultithreading.pdf<br>├── Debug Hacks中文版：深入调试的技术和工具.pdf<br>├── IB-Host-and-Ports.pdf<br>├── IBTA-Overview-of-IBTA-Volume-1-Release-1.6-2022-07-15.pdf<br>├── InifiniBand Guide.pdf<br>├── LDAP Authentication Guide.pdf<br>├── Linux Kernel Networking - Implementation and Theory.pdf<br>├── Linux-UNIX系统编程手册（上、下册）.pdf<br>├── Linux内核设计与实现(第三版中文高清带目录).pdf<br>├── Linux多线程服务端编程 - 陈硕.pdf<br>├── Linux多线程服务端编程：使用muduo C++网络库.pdf<br>├── Linux高性能服务器编程.pdf<br>├── OKTA Multifactor Authentication (MFA) FAQ.pdf<br>├── Shell脚本学习指南.pdf<br>├── TBB<br>│   ├── Intel TBB.pdf<br>│   ├── TBBtutorial.pdf<br>│   ├── intel-tbb.pdf<br>│   ├── oneTBB-master.zip<br>│   └── onetbb_developer-guide-api-reference_2021.6-772616-772617.pdf<br>├── UNIX环境高级编程(第三版).pdf<br>├── UNIX网络编程卷1：套接字联网API（第3版）.pdf<br>├── ccia_code_samples-master.zip<br>├── dmtcp<br>│   ├── Be Kind, Rewind —Checkpoint &amp; Restore Capability for Improving Reliability of Large-scale Semiconductor Design.pdf<br>│   ├── dmtcp-mug-17.pdf<br>│   └── plugin-tutorial.pdf<br>├── gdb-and-assembly.pdf<br>├── gdb-refcard.pdf<br>├── gdb.pdf<br>├── p4-p4v-cheat-sheet_cn.pdf<br>├── thread-analyzer-193426.pdf<br>├── 并行编程<br>│   ├── C++ Concurrency in Action.pdf<br>│   ├── C++-Concurrency-In-Action-2ed-zh-v0.2.pdf<br>│   ├── C++并发编程实战(中文版).pdf<br>│   ├── C++并发编程实战.pdf<br>│   ├── C++并发编程实战源代码<br>│   ├── C++并发编程实战源代码.zip<br>│   ├── Patterns_for_Parallel_Programming.pdf<br>│   └── 高并发网络模型.png<br>└── 编译原理(龙书) 第二版.pdf</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/17/misc/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/17/misc/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/" class="post-title-link" itemprop="url">如何创建个人主页</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-17 16:14:48" itemprop="dateCreated datePublished" datetime="2025-08-17T16:14:48+00:00">2025-08-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-20 11:25:01" itemprop="dateModified" datetime="2025-08-20T11:25:01+00:00">2025-08-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-Github-Pages"><a href="#1-Github-Pages" class="headerlink" title="1. Github Pages"></a>1. Github Pages</h1><p>本文解释利用<a target="_blank" rel="noopener" href="https://docs.github.com/en/pages">github pages</a>搭建个人主页&#x2F;项目主页的方法。</p>
<p>github pages简介：<a target="_blank" rel="noopener" href="https://docs.github.com/en/pages/getting-started-with-github-pages/about-github-pages">官方链接</a>。</p>
<p>github pages使用了<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/CNAME_record">CNAME record</a>技术，参考：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/39301250">链接1</a>、<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/26609475">链接2</a>、<a target="_blank" rel="noopener" href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/about-custom-domains-and-github-pages#using-a-subdomain-for-your-github-pages-site">Custom domains in Github Pages</a>。</p>
<p>注：<a target="_blank" rel="noopener" href="https://readthedocs.org/">Read the Docs</a>也是一个很好的搭建个人主页的网站。</p>
<h2 id="Github-Pages-站点类型"><a href="#Github-Pages-站点类型" class="headerlink" title="Github Pages 站点类型"></a>Github Pages 站点类型</h2><p>有3种类型的 Github Pages 站点（sites）：project, user 和 organization 。</p>
<p>Project sites 连接到 github 上特定 project ，比如 Javascript library 或 recipe collection。user 或 organization sites 连接到 github.com 的特定账户。</p>
<p>发布 user site ，你必须创建一个你的个人账户下的一个名为 <code>&lt;username&gt;.github.io</code> 的 repository 。发布 organization site ，你必须创建一个组织所有的名为 <code>&lt;organization&gt;.github.io</code> 的 repository 。除非你使用 custom domain ，否则 user 和 organization sites 将位于 <code>http(s)://&lt;username&gt;.github.io</code> 或 <code>http(s)://&lt;organization&gt;.github.io</code> 。</p>
<p>project site 的源文件存储在作为 project 的相同的 repository 中。除非使用 custom domain ， 否则 project sites 将位于 <code>http(s)://&lt;username&gt;.github.io/&lt;repository&gt;</code> 或 <code>http(s)://&lt;organization&gt;.github.io/&lt;repository&gt;</code> 。</p>
<p>有关如何自定义影响您网站的域名的更多信息，参见”<a target="_blank" rel="noopener" href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/about-custom-domains-and-github-pages">About custom domains and GitHub Pages</a>“。</p>
<p>每个 github 账户允许创建 1 个 user 或 organization 站点。无论是被组织还是个人所有，project 站点的个数不限制。</p>
<h2 id="GitHub-Pages-访问方法"><a href="#GitHub-Pages-访问方法" class="headerlink" title="GitHub Pages 访问方法"></a>GitHub Pages 访问方法</h2><p>参考<a target="_blank" rel="noopener" href="https://docs.github.com/en/pages/getting-started-with-github-pages/creating-a-github-pages-site#next-steps">官方文档</a>。</p>
<p>例如，你的project站点配置的发布源是<code>gh-pages</code>分支，然后在<code>gh-pages</code>分支上创建了一个<code>about/contact-us.md</code>文件，你将可以在<code>https://&lt;user&gt;.github.io/&lt;repository&gt;/about/contact-us.html</code>访问它。</p>
<p>你也可以使用<code>Jekyll</code>等静态站点生成器来给你的github page配置一个主题。</p>
<h2 id="站点发布常见问题的解决方法"><a href="#站点发布常见问题的解决方法" class="headerlink" title="站点发布常见问题的解决方法"></a>站点发布常见问题的解决方法</h2><ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/72851548/permission-denied-to-github-actionsbot">Permission denied to github-actions[bot]</a></li>
</ul>
<h2 id="Github-workflows"><a href="#Github-workflows" class="headerlink" title="Github workflows"></a>Github workflows</h2><p>参考<a target="_blank" rel="noopener" href="https://docs.github.com/zh/actions/using-workflows/workflow-syntax-for-github-actions">官方文档</a>。</p>
<h1 id="2-配置前准备"><a href="#2-配置前准备" class="headerlink" title="2. 配置前准备"></a>2. 配置前准备</h1><h2 id="2-1-Markdown编辑器"><a href="#2-1-Markdown编辑器" class="headerlink" title="2.1. Markdown编辑器"></a>2.1. Markdown编辑器</h2><p>推荐的<a target="_blank" rel="noopener" href="https://www.zhihu.com/tardis/zm/art/103348449?source_id=1003">markdown编辑器</a>：</p>
<ul>
<li>VSCode：免费。VSCode原生支持Markdown，安装一些插件可以帮助更快地编写markdown文件。</li>
<li>Typora：现在已经开始收费。</li>
</ul>
<p>VSCode markdown插件：</p>
<ul>
<li>Mardown All in One: 提供快捷键，帮助更快的编写markdown文件。</li>
<li>Markdown+Math：提供数学公式支持。</li>
<li>Markdown Preview Enhanced: 将原生markdown预览的黑色背景改成白色。</li>
<li>Markdown Preview Github Styling：提供Github风格的预览。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.tablesgenerator.com/markdown_tables">在线表格生成器</a>：可以生成Markdown、Text、HTML、LaTex、MediaWiki格式的表格。</p>
<h2 id="2-2-轻量级虚拟机WSL"><a href="#2-2-轻量级虚拟机WSL" class="headerlink" title="2.2. 轻量级虚拟机WSL"></a>2.2. 轻量级虚拟机WSL</h2><p>WSL，<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/wsl/install">Windows Subsystem for Linux</a>，是Windows提供的轻量级Linux虚拟机。</p>
<p>安装教程：见<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/170210673">链接</a>。</p>
<h3 id="2-2-1-WSL默认没有启用systemctl："><a href="#2-2-1-WSL默认没有启用systemctl：" class="headerlink" title="2.2.1. WSL默认没有启用systemctl："></a>2.2.1. WSL默认没有启用systemctl：</h3><p>启用systemctl的方法：<a target="_blank" rel="noopener" href="https://askubuntu.com/questions/1379425/system-has-not-been-booted-with-systemd-as-init-system-pid-1-cant-operate">链接</a>。</p>
<p>替代方法：不需要启动systemctl，因为会比较占用资源，启动也会变慢。可以使用service命令替代。</p>
<h3 id="2-2-2-WSL默认没有安装openssl-server："><a href="#2-2-2-WSL默认没有安装openssl-server：" class="headerlink" title="2.2.2. WSL默认没有安装openssl-server："></a>2.2.2. WSL默认没有安装openssl-server：</h3><p>使用ssh连接到服务器时，需要服务器运行着sshd程序，否则连接不上，会出现”<a target="_blank" rel="noopener" href="https://www.makeuseof.com/fix-ssh-connection-refused-error-linux/">Connection refused</a>“错误。</p>
<p>参考<a target="_blank" rel="noopener" href="https://askubuntu.com/questions/1339980/enable-ssh-in-wsl-system">链接</a>。</p>
<p>查看openssh-server有没有安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg --list | grep ssh</span><br></pre></td></tr></table></figure>

<p>注：如果安装了openssh-server，执行which sshd可以看到路径。</p>
<p>WSL默认没有安装openssh-server，安装方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure>

<p>启动ssh：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service ssh start</span><br></pre></td></tr></table></figure>

<h3 id="2-2-3-通过https登录到github"><a href="#2-2-3-通过https登录到github" class="headerlink" title="2.2.3. 通过https登录到github"></a>2.2.3. 通过https登录到github</h3><p><code>git push</code>不再支持输入用户名和密码，当提示输入密码时，需要输入personal access token.</p>
<p>步骤1：在github上<a target="_blank" rel="noopener" href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#creating-a-personal-access-token-classic">创建personal access token</a>；</p>
<p>步骤2：<a target="_blank" rel="noopener" href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#using-a-personal-access-token-on-the-command-line">在命令行上使用personal access token</a>；</p>
<p>步骤3：为了避免每次都需要输入personal access token，可以将其<a target="_blank" rel="noopener" href="https://docs.github.com/en/get-started/getting-started-with-git/caching-your-github-credentials-in-git">缓存在git client上</a>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gh auth login</span><br></pre></td></tr></table></figure>

<p>注：使用<code>gh</code>命令需要先安装GitHub CLI：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gh</span><br></pre></td></tr></table></figure>

<h3 id="2-2-4-执行git-pull-push时，出现”The-authenticity-of-host-‘github-com-20-205-243-166-’-can’t-be-established-ED25519-key-fingerprint-is-SHA256-…”错误"><a href="#2-2-4-执行git-pull-push时，出现”The-authenticity-of-host-‘github-com-20-205-243-166-’-can’t-be-established-ED25519-key-fingerprint-is-SHA256-…”错误" class="headerlink" title="2.2.4 执行git pull&#x2F;push时，出现”The authenticity of host ‘github.com (20.205.243.166)’ can’t be established. ED25519 key fingerprint is SHA256:…”错误"></a>2.2.4 执行git pull&#x2F;push时，出现”The authenticity of host ‘github.com (20.205.243.166)’ can’t be established. ED25519 key fingerprint is SHA256:…”错误</h3><p>报错解释：</p>
<p>这个报错信息通常出现在使用SSH连接到一个新的主机时。它表示你的计算机无法验证远程服务器的身份，因为服务器的公钥不在你本地计算机的known_hosts文件中。这是SSH为了防止”中间人”攻击而进行的安全检查。</p>
<p>解决方法：</p>
<p>验证指纹信息：你可以查看远程主机的指纹信息，并与服务器gitee.com的公钥指纹进行对比，确保它们匹配。你可以在~&#x2F;.ssh&#x2F;known_hosts文件中找到已知主机的公钥指纹。</p>
<p>如果确认指纹正确无误，且你信任这个服务器，可以添加这个主机及其公钥到你的known_hosts文件中，以便SSH不再警告。执行以下命令：</p>
<p>ssh-keyscan -H gitee.com &gt;&gt; ~&#x2F;.ssh&#x2F;known_hosts</p>
<p>如果你不想添加到known_hosts文件中，可以在第一次连接时使用ssh -o StrictHostKeyChecking&#x3D;no来跳过这个检查。但这样做会降低安全性。</p>
<p>如果你是在多个服务器上使用相同的IP地址，并且之前已经添加过这个IP的记录，那么可能是服务器的公钥发生了变化，这种情况下你应该联系服务器管理员确认公钥的变更。</p>
<p>注意：在实际生产环境中，不建议无条件信任新的SSH指纹，除非你完全了解这个服务器的来源和身份。</p>
<h1 id="3-静态站点生成器"><a href="#3-静态站点生成器" class="headerlink" title="3. 静态站点生成器"></a>3. 静态站点生成器</h1><p>以下几种<a target="_blank" rel="noopener" href="https://docs.github.com/en/pages/getting-started-with-github-pages/about-github-pages">静态站点生成器</a>都可以用来搭建个人主页。如果使用除JekyII外的工具，则需要配置<a target="_blank" rel="noopener" href="https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions">Github Actions</a>以构建和发布你的站点。</p>
<h2 id="3-1-mkdocs"><a href="#3-1-mkdocs" class="headerlink" title="3.1. mkdocs"></a>3.1. mkdocs</h2><p><a target="_blank" rel="noopener" href="https://www.mkdocs.org/">mkdocs</a>是一个快速的静态网页生成器。</p>
<p>发布个人网站的方法：参见<a target="_blank" rel="noopener" href="https://squidfunk.github.io/mkdocs-material/publishing-your-site/">mkdocs-material官网</a>。</p>
<h2 id="3-2-JekyII"><a href="#3-2-JekyII" class="headerlink" title="3.2. JekyII"></a>3.2. JekyII</h2><p>Jekyll 是一个静态站点生成器，内置对 GitHub Pages 的支持和简化的构建进程。</p>
<p>参见 <a target="_blank" rel="noopener" href="https://docs.github.com/en/pages/setting-up-a-github-pages-site-with-jekyll/about-github-pages-and-jekyll">About GitHub Pages and Jekyll</a> 。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/17/concurrency/%E8%AF%A6%E8%A7%A3RCU%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/17/concurrency/%E8%AF%A6%E8%A7%A3RCU%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">详解RCU机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-17 10:39:19" itemprop="dateCreated datePublished" datetime="2025-08-17T10:39:19+00:00">2025-08-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-20 11:25:01" itemprop="dateModified" datetime="2025-08-20T11:25:01+00:00">2025-08-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="RCU-读-复制-更新"><a href="#RCU-读-复制-更新" class="headerlink" title="RCU (读-复制-更新)"></a>RCU (读-复制-更新)</h2><p>RCU（Read-Copy-Update，读-拷贝-更新）是 Linux 内核中一种高效的 并发读-写同步机制，专门用于在多核系统下实现 大量读、少量写 的场景。它的核心思想是：读操作完全无锁，写操作通过复制更新，最后再安全地回收旧版本。</p>
<p>RCU 的核心思想</p>
<ul>
<li>读操作直接访问数据结构，不加锁</li>
<li>写操作：<ul>
<li>先 复制原数据 → 修改副本</li>
<li>更新指针，使新数据生效</li>
<li>延迟回收旧数据，保证当前正在读取旧数据的线程不受影响</li>
</ul>
</li>
</ul>
<h3 id="rcu"><a href="#rcu" class="headerlink" title="__rcu"></a><code>__rcu</code></h3><p>它是 RCU 机制中非常关键的一环，用来让 编译器和内核知道某个指针是 RCU 保护的。</p>
<ol>
<li><code>__rcu</code> 的定义</li>
</ol>
<p>在 Linux 内核中（以 x86_64 为例）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __rcu</span></span><br></pre></td></tr></table></figure>

<p>实际上，它 本身对编译器不产生直接影响</p>
<p>主要用途是 标记类型，告诉 Sparse 静态分析工具 或 内核开发者：这个指针受 RCU 保护，不能随意直接读&#x2F;写</p>
<p>也就是说，<code>__rcu</code> 是 一个注释性质的宏，编译器编译时忽略，但静态分析工具会检查 RCU 访问规则。</p>
<ol start="2">
<li><code>__rcu</code> 的作用</li>
</ol>
<p>标记 RCU 保护的指针，常见用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> __<span class="title">rcu</span> *<span class="title">fdt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> *<span class="title">fd_array</span>[<span class="title">NR_OPEN_DEFAULT</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>含义：</p>
<ul>
<li><code>fdt</code> 是 RCU 指针</li>
<li>不能直接写 <code>fdt = new_ptr</code>; 或直接解引用 <code>fdt-&gt;xxx</code></li>
<li>必须通过 RCU API，如：<ul>
<li><code>rcu_assign_pointer(fdt, new_fdt);</code> → 安全更新指针</li>
<li><code>rcu_dereference(fdt)</code> → 安全读取指针</li>
</ul>
</li>
<li>这样可以保证：<ul>
<li>写线程更新指针时不会破坏读线程的访问</li>
<li>读线程可以无锁访问旧数据</li>
</ul>
</li>
</ul>
<ol start="3">
<li><code>__rcu</code> 与编译器和内核</li>
</ol>
<ul>
<li>静态检查（Sparse）<ul>
<li>Sparse 是 Linux 内核推荐的静态分析工具</li>
<li>它会检查：<ul>
<li>所有 <code>__rcu</code> 指针的写操作是否用 <code>rcu_assign_pointer</code></li>
<li>所有读取是否用 <code>rcu_dereference</code></li>
</ul>
</li>
<li>如果直接访问，就会报错，避免 RCU 访问错误</li>
</ul>
</li>
<li>内存屏障和优化<ul>
<li><code>rcu_assign_pointer</code> 内部会加上 适当的写屏障 (<code>smp_wmb()</code>)</li>
<li><code>rcu_dereference</code> 内部会加 读取屏障 (<code>smp_rmb()</code>)</li>
<li>防止编译器&#x2F;CPU 重排导致读写顺序错误</li>
</ul>
</li>
</ul>
<ol start="4">
<li><code>__rcu</code> 的核心原理总结</li>
</ol>
<table>
<thead>
<tr>
<th>方面</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>编译器作用</td>
<td>本身是空宏，不改变代码</td>
</tr>
<tr>
<td>静态分析</td>
<td>Sparse 检查 RCU 指针的安全读写</td>
</tr>
<tr>
<td>内存屏障</td>
<td>通过 <code>rcu_assign_pointer</code> &#x2F; <code>rcu_dereference</code> 添加屏障，保证并发安全</td>
</tr>
<tr>
<td>运行时</td>
<td>指针仍然是普通指针，实际存储和访问和普通指针一样</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/16/os/%E9%AB%98%E6%95%88IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/16/os/%E9%AB%98%E6%95%88IO/" class="post-title-link" itemprop="url">高效 IO</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-16 23:40:06" itemprop="dateCreated datePublished" datetime="2025-08-16T23:40:06+00:00">2025-08-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-20 11:25:01" itemprop="dateModified" datetime="2025-08-20T11:25:01+00:00">2025-08-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="高效的-IO-函数"><a href="#高效的-IO-函数" class="headerlink" title="高效的 IO 函数"></a>高效的 IO 函数</h2><ul>
<li>sendfile</li>
<li>mmap + write</li>
<li>splice</li>
<li>readv</li>
</ul>
<h3 id="零拷贝-Zero-copy"><a href="#零拷贝-Zero-copy" class="headerlink" title="零拷贝 (Zero copy)"></a>零拷贝 (Zero copy)</h3><ul>
<li>mmap + write</li>
<li>sendfile</li>
<li>splice</li>
</ul>
<h3 id="Page-cache-和异步-IO"><a href="#Page-cache-和异步-IO" class="headerlink" title="Page cache 和异步 IO"></a>Page cache 和异步 IO</h3><p><a target="_blank" rel="noopener" href="https://www.xiaolincoding.com/os/8_network_system/zero_copy.html#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%9B%B6%E6%8B%B7%E8%B4%9D">https://www.xiaolincoding.com/os/8_network_system/zero_copy.html#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%9B%B6%E6%8B%B7%E8%B4%9D</a></p>
<ul>
<li>O_DIRECT: 绕过操作系统缓存，直接读写磁盘，可以避免缓存延迟，提高性能。可用于：<ul>
<li>数据库系统：对性能要求极高，且直接操作磁盘数据。</li>
<li>存储设置：如 SSD、硬盘，直接与硬件设备进行高效的 I&#x2F;O 操作。</li>
<li>注意：由于绕过了缓存，所以 read 如果小于当前数据包的大小，则本次 read 后，内核会直接丢弃多余的数据。这是为了避免多余的数据在内存中驻留。</li>
</ul>
</li>
</ul>
<h3 id="散布读写-Scatter-read-write"><a href="#散布读写-Scatter-read-write" class="headerlink" title="散布读写 (Scatter read&#x2F;write)"></a>散布读写 (Scatter read&#x2F;write)</h3><ul>
<li>readv</li>
<li>writev</li>
</ul>
<p>散布读写支持一次性将数据从文件描述符读写到多个缓冲区：</p>
<ul>
<li>避免多次系统调用；</li>
<li>直接分块读取，不需要额外用户态 memcpy 到不同的块。</li>
</ul>
<h2 id="IO-复用"><a href="#IO-复用" class="headerlink" title="IO 复用"></a>IO 复用</h2><ul>
<li>select</li>
<li>poll</li>
<li>epoll</li>
<li>非阻塞 IO</li>
</ul>
<p>如果 select &#x2F; poll &#x2F; epoll 通知可读写，那么一定可读写吗？<br>答案是不一定。因为内核不是 ** 实时地 ** 检查内核缓冲区是否有空间或有数据，所以内核的通知有时间差和虚假性。<br>而 epoll 等函数只关注事件变化，不检查缓冲区。这样可以提高效率。<br>最终的结果就是鼓励用户程序尝试，但是不保证一定成功，也就是可能阻塞。所以需要非阻塞 IO 来进一步提高性能。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><ul>
<li>减少数据拷贝：select &#x2F; poll 只有一个函数，这会要求每次调用都必须将描述事件的数据从用户空间复制到内核空间；所以 epoll 拆分成三个函数，用户可以向内核直接注册事件数据；</li>
<li>红黑树：epoll 事件数据是用红黑树来记录，增删查改的时间复杂度为 O(logn) ；select &#x2F; poll 是线性扫描，时间复杂度 O(n) 。红黑树需要额外的空间，所以这是空间换时间的办法。</li>
</ul>
<h4 id="EPOLLONESHOT"><a href="#EPOLLONESHOT" class="headerlink" title="EPOLLONESHOT"></a><code>EPOLLONESHOT</code></h4><p>阅读 manual：</p>
<blockquote>
<p>Since  even  with  edge-triggered  epoll,  multiple events can be generated upon receipt of multiple chunks of data, the caller has the option to specify the EPOLLONESHOT flag, to tell epoll to disable the associated file descriptor after the receipt of an event  with  epoll_wait(2).   When the EPOLLONESHOT flag is specified, it is the caller’s responsibility to rearm the file descriptor using epoll_ctl(2) with EPOLL_CTL_MOD.</p>
</blockquote>
<p>如果某个文件描述符上有多个数据块到达，那么即使是边沿触发也无法保证事件只通知一次。这可能是由于数据包过大被分片，或者是新数据到达。</p>
<ul>
<li>这在单线程程序上不会有太大影响，因为对同一个 fd 不会造成重复读写。</li>
<li>多线程程序中，fd 准备好后，我们常常将这个 fd 交给某个线程去处理。此时如果 fd 有新的事件，会造成多线程处理同一个 fd 的情况。<ul>
<li>为了避免竞争，要么加锁；要么使用内核的 ONESHOT 机制。后者由内核保证，无锁，更高效。</li>
</ul>
</li>
<li><code>EPOLLONSHOT</code> 需要调用者自行 reset 这个标志。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/salmonwilliam/article/details/112347938">https://blog.csdn.net/salmonwilliam/article/details/112347938</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/16/os/%E6%96%87%E4%BB%B6IO%E4%B8%8E%E8%BF%9B%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/16/os/%E6%96%87%E4%BB%B6IO%E4%B8%8E%E8%BF%9B%E7%A8%8B/" class="post-title-link" itemprop="url">文件IO与进程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-16 20:50:37" itemprop="dateCreated datePublished" datetime="2025-08-16T20:50:37+00:00">2025-08-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-08-20 11:25:01" itemprop="dateModified" datetime="2025-08-20T11:25:01+00:00">2025-08-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="进程打开文件"><a href="#进程打开文件" class="headerlink" title="进程打开文件"></a>进程打开文件</h2><p><a href="https://postimages.org/" target="_blank"><img src="https://i.postimg.cc/50jyHyjJ/image.png" alt="image"/></a></p>
<ul>
<li><code>struct task_struct</code> (进程控制块)<ul>
<li>每个进程有一个 <code>task_struct</code>结构体，内核用它来描述进程。</li>
<li>里面有一个指针 <code>files</code> ，执行该进程的 <code>files_struct</code> 。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v6.16/source/include/linux/sched.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 进程控制块 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span> <span class="comment">// 进程当前打开的文件</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>files_struct</code> (进程的文件表)<ul>
<li>这里保存了一个指向 fd 数组 的指针。</li>
<li>fd 数组的下标就是 0, 1, 2…，每个元素指向一个 <code>file *</code> 结构体。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v6.16/source/include/linux/fdtable.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">files_struct</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">fdtable</span> __rcu *fdt;                          <span class="comment">// fd 表（动态管理）</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">file</span> __rcu    *fd_array[NR_OPEN_DEFAULT];    <span class="comment">// 固定大小数组（早期 fd 数组）</span></span><br><span class="line">                                                        <span class="comment">// NR_OPEN_DEFAULT 通常为 1024</span></span><br><span class="line">                                                        <span class="comment">// 早期没有设置 FD_CLOEXEC 新特性</span></span><br><span class="line">    <span class="comment">// 为什么 fdt 与 fd_array 同时存在？</span></span><br><span class="line">    <span class="comment">// 1. 性能优化：大多数程序，fd 都在 0~1023，直接访问数组更快</span></span><br><span class="line">    <span class="comment">// 2. 向后兼容：早期接口会访问fd_array</span></span><br><span class="line">    <span class="comment">// 3. 动态扩展：如果 fd 超过 NR_OPEN_DEFAULT，内核会复制 fd_array 到 fdt-&gt;fd 来保证一致性。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... `struct files_struct&#x27; 还有其他成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fd 表（动态管理）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fdtable</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        max_fds;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">file</span> __rcu **fd;             <span class="comment">/* 当前打开的 fd 指针数组 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>      *close_on_exec;  <span class="comment">// fd 标志，目前只有一个</span></span><br><span class="line">                                        <span class="comment">// FD_CLOEXEC 定义在 &lt;fcntl.h&gt; 中</span></span><br><span class="line">                                        <span class="comment">// close_on_exec 指向一个位图(bitmap)，每个bit代表一个fd</span></span><br><span class="line">                                        <span class="comment">// 如果bit=1，表示该fd设置了FD_CLOEXEC</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>      *open_fds;       <span class="comment">// 标记哪些fd是打开的，也是位图</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>      *full_fds_bits;  <span class="comment">// 辅助位图，用于快速找到空闲fd</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rcu_head</span>     rcu;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>struct file</code> (打开文件表项)<ul>
<li>内核为每次 <code>open()</code>、<code>pipe()</code>、<code>socket()</code> 创建一个 <code>struct file</code>。</li>
<li>它记录了文件状态（读写偏移、flag、引用计数等）。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v6.16/source/include/linux/fs.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="type">spinlock_t</span>                    f_lock;</span><br><span class="line">    <span class="type">fmode_t</span>                       f_mode;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>         *<span class="title">f_mapping</span>;</span></span><br><span class="line">    <span class="type">void</span>                         *private_data;  <span class="comment">// 比如 socket</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>                 *<span class="title">f_inode</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>                  f_flags;  <span class="comment">// 文件状态标志，如 O_RDONLY, O_NONBLOCK, O_APPEND 等</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>                  f_iocb_flags;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>            *<span class="title">f_cred</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>           *<span class="title">f_owner</span>;</span></span><br><span class="line">    <span class="comment">/* --- cacheline 1 boundary (64 bytes) --- */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">f_path</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="comment">/* regular files (with FMODE_ATOMIC_POS) and directories */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">f_pos_lock</span>;</span></span><br><span class="line">        <span class="comment">/* pipes */</span></span><br><span class="line">        u64 f_pipe;  <span class="comment">// 管道</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>inode &#x2F; pipe &#x2F; socket 内核对象<ul>
<li><p><code>struct file</code> 再指向更底层的对象，比如 inode（磁盘文件）、socket 缓冲区、pipe 缓冲区。</p>
</li>
<li><p>i-node 包含以下内容</p>
<ul>
<li>链接计数（指向该i节点的目录项数）；</li>
<li>文件类型、文件访问权限位、文件长度、指向文件数据块的指针等。<code>stat</code>结构中的大多数信息都取自i节点。</li>
<li>只有两项重要数据放在目录项中：文件名和i-node编号。</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="text-align: center">
<figure>
  <img src="https://i.postimg.cc/rFRyX7Rh/image.png" alt="磁盘、分区和文件系统">
  <figcaption>磁盘、分区和文件系统</figcaption>
</figure>
</div>

<div style="text-align: center">
<figure>
  <img src="https://i.postimg.cc/3xM8K9g3/i.png" alt="i节点和数据块">
  <figcaption>i节点和数据块</figcaption>
</figure>
</div>


<p>软链接与硬链接</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>硬链接 (Hard Link)</strong></td>
<td>表示有多少目录项（文件名）指向同一个 <strong>inode</strong> 。它们指向同一个文件内容。</td>
</tr>
<tr>
<td><strong>软链接 (Symbolic Link &#x2F; Symlink)</strong></td>
<td>类似快捷方式，是一个 <strong>独立文件</strong>，内容是指向目标文件的路径。</td>
</tr>
</tbody></table>
<ul>
<li>硬链接：当硬链接数降为0时，才从磁盘的数据块中删除该文件，所以删除文件（即目录项）称为<code>unlink</code>，而不是<code>delete</code>。</li>
<li>软链接：i-node中的文件类型是<code>S_IFLINK</code>，表明是符号链接。</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>硬链接</th>
<th>软链接</th>
</tr>
</thead>
<tbody><tr>
<td>是否指向 inode</td>
<td>是，直接指向同一 inode</td>
<td>否，指向目标路径</td>
</tr>
<tr>
<td>是否可以跨文件系统</td>
<td>否，只能在同一分区</td>
<td>可以跨分区</td>
</tr>
<tr>
<td>是否可以链接目录</td>
<td>通常不能（除非 root）</td>
<td>可以</td>
</tr>
<tr>
<td>删除目标文件后</td>
<td>文件内容仍可访问</td>
<td>链接会失效（称为“悬挂链接”）</td>
</tr>
<tr>
<td>占用空间</td>
<td>不占用额外数据空间（只是多了一个目录项）</td>
<td>占用少量空间存储路径信息</td>
</tr>
<tr>
<td>更新文件内容</td>
<td>所有硬链接同步可见</td>
<td>通过软链接修改目标文件内容时可见，软链接本身只是路径</td>
</tr>
</tbody></table>
<h2 id="两个独立进程各自打开同一个文件"><a href="#两个独立进程各自打开同一个文件" class="headerlink" title="两个独立进程各自打开同一个文件"></a>两个独立进程各自打开同一个文件</h2><p><a href="https://postimages.org/" target="_blank"><img src="https://i.postimg.cc/hG2hPTDM/image.png" alt="两个独立进程各自打开同一个文件"/></a></p>
<ul>
<li>O_APPEND：<ul>
<li>原子操作：如果使用 <code>O_APPEND</code> 标志打开一个文件，那么相应的标志也被设置到文件表项的文件状态标志中。每次对文件执行写操作时，文件表项中的当前文件偏移量首先会被设置为 i 节点表项中的文件长度（相对其他进程来说是<strong>原子</strong>操作，不论是两个独立的进程，还是父子进程）。这就使得每次写入的数据都追加到文件的当前尾端处。<a target="_blank" rel="noopener" href="https://blog.csdn.net/yangbodong22011/article/details/63064166">这里</a>有一个测试的例子，文章结论不见得正确，请参考评论的讨论。</li>
<li><code>PIPE_BUF</code>：只保证小于<code>PIPE_BUF</code>的内容是原子；如果大于则可能被多次多段写入。PIPE_BUF 是管道（pipe）单次写入保证原子的最大字节数，Linux 上是 4096 字节。</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 PIPE_BUF 大小</span></span><br><span class="line"><span class="comment"># `/tmp&#x27; 可以换成任意文件系统路径</span></span><br><span class="line">$ getconf PIPE_BUF /tmp</span><br><span class="line">4096</span><br><span class="line"><span class="comment"># 也可以查看所有文件系统相关的 PIPE_BUF 限制</span></span><br><span class="line">$ getconf -a PIPE_BUF</span><br></pre></td></tr></table></figure>

<p>  以下是 <code>man 2 write</code> 关于 <code>O_APPEND</code> 的说明：</p>
<blockquote>
<p>If the file was open(2)ed with O_APPEND, the file offset is first set to the end of the file before writing.  The adjustment of the file offset and the write operation are performed as an atomic step.</p>
</blockquote>
<ul>
<li>lseek：</li>
</ul>
<p>若一个文件用 <code>lseek</code> 定位到文件当前的尾端，则文件表项中的当前文件偏移量被设置为 i 节点表项中的当前文件长度（注意，此时，设置偏移量和写操作之间不是原子操作）。</p>
<hr>
<h2 id="dup-后的内核数据结构"><a href="#dup-后的内核数据结构" class="headerlink" title="dup()后的内核数据结构"></a><code>dup()</code>后的内核数据结构</h2><p><code>dup()</code> &#x2F; <code>dup2()</code> 只复制 fd ，也就是在 fd 数组中新增了一个 fd 项。一般用来重定向。</p>
<p><a href="https://postimages.org/" target="_blank"><img src="https://i.postimg.cc/s2mGQbcY/dup-1.png" alt="dup(1)"/></a></p>
<hr>
<h2 id="fork与文件共享"><a href="#fork与文件共享" class="headerlink" title="fork与文件共享"></a>fork与文件共享</h2><ul>
<li>进程每打开一个文件，都会新建一个 <code>struct file</code> ，并添加到 fd 数组或 fd 表中。<ul>
<li>对同一个文件，不同进程拥有各自的文件表项。</li>
<li>但是对每个文件，v节点表项在整个操作系统中只有一份。</li>
</ul>
</li>
<li><code>fork()</code> 后的子进程直接复制父进程的 fd 数组，<code>exec()</code> 也不能将其替换；<ul>
<li>子进程对 <code>struct task_struct</code> 是深拷贝，所以 fd 数组被复制；</li>
<li>但是子进程对 fd 数组是浅拷贝，fd 数组中的 <code>struct file*</code> 仍然指向父进程创建的 <code>struct file </code> （共享）；</li>
<li>所以子进程共享了文件状态标志 (O_APPEND, O_NONBLOCK, O_RDONLY 等)、当前文件偏移量。</li>
</ul>
</li>
<li>除非该文件描述符使用<code>fcntl()</code>设置了<code>FD_CLOEXEC</code>标志，此时 <code>exec</code> 会关闭继承的文件描述符。</li>
</ul>
<p><a href="https://postimages.org/" target="_blank"><img src="https://i.postimg.cc/TYbyqK0Y/fork.png" alt="fork"/></a></p>
<p><strong>子进程对文件表项的修改，会不会影响父进程？</strong></p>
<ul>
<li>shell进程启动时，会自动打开这三个文件描述符（可能由配置项决定）；</li>
<li>shell利用<code>fork()</code>开启用户进程（子进程），该子进程复制父进程shell的所有文件描述符，于是0, 1, 2文件描述符被打开；</li>
<li>由于子进程<strong>共享</strong>父进程的<strong>文件表项</strong>，子进程对文件状态标志（读、写、同步或非阻塞等）、文件偏移量的修改，将<strong>会影响父进程</strong>。</li>
</ul>
<p>测试代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> err_sys(x)                                                             \</span></span><br><span class="line"><span class="meta">  &#123;                                                                            \</span></span><br><span class="line"><span class="meta">    perror(x);                                                                 \</span></span><br><span class="line"><span class="meta">    exit(1);                                                                   \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pr_fl</span><span class="params">(<span class="type">int</span> fd)</span>;             <span class="comment">// 自定义函数：打印文件状态标志</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_fl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> flags)</span>; <span class="comment">// 自定义函数：设置文件状态标志</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  pr_fl(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  set_fl(<span class="number">0</span>, O_APPEND);</span><br><span class="line">  pr_fl(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_fl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((val = fcntl(fd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    err_sys(<span class="string">&quot;fcntl F_GETFL error&quot;</span>);</span><br><span class="line"></span><br><span class="line">  val |= flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fcntl(fd, F_SETFL, val) &lt; <span class="number">0</span>)</span><br><span class="line">    err_sys(<span class="string">&quot;fcntl F_SETFL error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pr_fl</span><span class="params">(<span class="type">int</span> fd)</span> &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do not guarantee success on certain system, check EINVAL first</span></span><br><span class="line">  <span class="keyword">if</span> ((val = fcntl(fd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    err_sys(<span class="string">&quot;fcntl F_GETFL error&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (val &amp; O_ACCMODE) &#123;</span><br><span class="line">  <span class="keyword">case</span> O_RDONLY:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read only&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> O_WRONLY:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write only&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> O_RDWR:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read write&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    err_sys(<span class="string">&quot;unknown open type&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (val &amp; O_CREAT)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;, create&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (val &amp; O_APPEND)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;, append&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (val &amp; O_NONBLOCK)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;, non-block&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (val &amp; O_SYNC)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;, synchronized file&quot;</span>);</span><br><span class="line">  <span class="comment">// if (val &amp; O_DSYNC)</span></span><br><span class="line">  <span class="comment">//   printf(&quot;, synchronize data&quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一次运行：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line"><span class="built_in">read</span> write</span><br><span class="line"><span class="built_in">read</span> write, append</span><br></pre></td></tr></table></figure>

<ul>
<li>第二次运行：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line"><span class="built_in">read</span> write, append</span><br><span class="line"><span class="built_in">read</span> write, append</span><br></pre></td></tr></table></figure>

<ul>
<li><p>分析</p>
<ul>
<li>第二次运行时，文件描述符0的初始状态保持了第一次运行的结果！</li>
<li>这是因为父进程shell的文件表项的文件状态标志被子进程<code>a.out</code>改变了。</li>
</ul>
</li>
<li><p>第三次运行：</p>
<p>重新启动shell，并运行<code>a.out</code></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line"><span class="built_in">read</span> write</span><br><span class="line"><span class="built_in">read</span> write, append</span><br></pre></td></tr></table></figure>

<ul>
<li><p>分析</p>
<ul>
<li>第三次运行，结果与第一次一致，这说明我们的猜测正确。</li>
<li>父进程shell关闭之后，所有文件描述符被关闭，文件IO被关闭，文件表被释放。重启shell也就重置了文件表。</li>
</ul>
</li>
<li><p>引申：<br>在此我们注意到，文件描述符0, 1, 2（标准输入、标准输出、标准错误）在一个shell及其所有子进程中，对应的文件（设备）是同一个。由于共享了文件表项，指向了同一个v-node表项，故都指向同一个虚拟终端。这与我们的平时观察一致，不然shell运行程序时，输入输出的入口在哪里呢？</p>
</li>
</ul>
<p><strong>如果进程打开文件，此时我们使用 rm &#x2F; unlink 删除文件，会发生什么？</strong></p>
<p>什么也不会发生。因为 Linux 文件系统的设计允许文件名（目录项）和文件内容（inode）分离。只有当所有引用（包括文件描述符和内存映射）都关闭后，inode 才会被删除。</p>
<p>在 Linux 中，一个文件由三部分组成：</p>
<ul>
<li>目录项（filename）：比如 <code>/lib/libexample.so</code></li>
<li>inode（元数据）：记录权限、大小、时间戳等</li>
<li>数据块（内容）：实际的文件内容</li>
</ul>
<p><code>rm</code> 只是删除了目录项（文件名），并没有删除 inode 或数据块，只要还有进程引用它。</p>
<p>引用 inode 的方式包括：</p>
<ul>
<li>打开文件（open()）</li>
<li>映射文件（mmap()）</li>
<li>动态链接器加载 .so 文件</li>
</ul>
<p>这些引用会让内核知道：这个 inode 仍然在使用中，不能释放。</p>
<p>这是为了支持非常重要的行为：</p>
<blockquote>
<p>✅ 允许进程继续使用已打开或已映射的文件，即使文件名被删除。</p>
</blockquote>
<p>这在很多场景下非常有用：</p>
<ul>
<li>日志轮转：删除旧日志文件，进程仍在写入</li>
<li>安全性：防止其他进程访问文件名，但当前进程仍可使用</li>
<li>临时文件：创建后立即删除，只让当前进程使用</li>
</ul>
<p>在 Linux 内核中，每个 inode 结构体有一个字段 <code>i_count</code>，表示该 inode 当前被引用的次数。这个引用包括：</p>
<ul>
<li>被文件系统挂载</li>
<li>被进程打开</li>
<li>被内核缓存使用</li>
</ul>
<p>这个字段不是用户空间可以直接查看的，但你可以通过以下方式间接观察：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">能看到什么</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>ls -li</code></td>
<td align="center">inode 号 + 硬链接引用计数</td>
</tr>
<tr>
<td align="center"><code>lsof -p &lt;PID&gt; | grep</code> &#x2F; <code>fuser &lt;/path/to/so&gt;</code></td>
<td align="center">是否有进程打开文件</td>
</tr>
<tr>
<td align="center"><code>/proc/&lt;PID&gt;/fd/</code></td>
<td align="center">查看文件描述符引用</td>
</tr>
<tr>
<td align="center"><code>/proc/&lt;PID&gt;/maps</code></td>
<td align="center">查看映射</td>
</tr>
<tr>
<td align="center"><code>ldd</code></td>
<td align="center">查看可执行文件依赖的 .so</td>
</tr>
<tr>
<td align="center"><code>strace</code></td>
<td align="center">跟踪运行时加载行为</td>
</tr>
<tr>
<td align="center">内核字段 <code>i_count</code></td>
<td align="center">真实引用计数（需内核调试）</td>
</tr>
</tbody></table>
<p>在本地文件系统（如 ext4）中：</p>
<ul>
<li>即使文件正在使用，<code>rm</code> 也能删除目录项</li>
<li>文件内容仍保留在 inode 中，直到所有引用关闭</li>
</ul>
<p>但在 NFS 文件系统 中：</p>
<ul>
<li>客户端不能立即删除正在被使用的文件</li>
<li>所以它会将文件重命名为 <code>.nfsXXXX</code></li>
<li>等引用释放后，自动删除该临时文件</li>
</ul>
<p>所以此时如果 <code>rm -rf</code> 目录，但是目录下某文件被使用，会提示 <code>xxx/.nfs000000004ec2d5e70000da89</code> 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ lsof -p &lt;PID&gt; | grep .nfs</span><br><span class="line">my_executable 283964 my_name  mem    REG  0,183  18371240 1321391591 /XXX/.nfs000000004ec2d5e70000da89 (xxx:/yyy/zzz)</span><br></pre></td></tr></table></figure>

<p>因为 so 被手动删除，此时引用的 so 被重命名成 <code>.nfsXXXX</code> 。</p>
<p>手动删除 .so 文件后，系统生成了 .nfsXXXX 文件，但进程仍然能继续使用它。进程怎么知道新文件名？</p>
<p>答案是：进程根本不知道新文件名，也不需要知道。</p>
<p>当一个进程打开一个文件（比如 <code>libexample.so</code>），它获得的是一个 文件描述符（fd），这个描述符指向的是内核中的 inode，而不是文件名。</p>
<p>那 <code>.nfsXXXX</code> 文件名是给谁看的？</p>
<p>它是 NFS 客户端自动创建的临时文件名，用于：</p>
<ul>
<li>保留 inode 内容，直到所有引用关闭</li>
<li>让系统知道这个文件还不能真正删除</li>
<li>让你可以用 lsof 或 fuser 查找谁在使用它</li>
</ul>
<p>📌 这个文件名不会被通知给进程，也不会影响进程的运行。</p>
<p>正常情况下：进程关闭后 .nfsXXXX 自动消失</p>
<ul>
<li>.nfsXXXX 文件是由 NFS客户端 创建的临时文件</li>
<li>当某个文件被打开后删除，客户端会将其重命名为 .nfsXXXX</li>
<li>一旦该文件的 打开引用计数为 0（即所有进程都关闭了该文件），客户端会自动删除 .nfsXXXX</li>
</ul>
<p>⚠️ 异常情况：文件可能残留</p>
<p>如果出现以下情况，.nfsXXXX 文件可能不会自动删除：</p>
<ul>
<li>客户端 crash 或断网，未能完成清理动作</li>
<li>使用 kill -9 强制终止进程，绕过了正常关闭流程</li>
<li>NFS 客户端或服务器之间同步延迟</li>
<li>文件被多个进程同时打开，只有部分进程关闭</li>
</ul>
<p>在这些情况下，.nfsXXXX 文件会残留在文件系统中，直到手动清理。</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>通过上文的叙述，我们很容易想到管道本质上也是一种特殊的文件，所以管道机制之所以可以进程间通信也是根据共享文件表项保证的。<br>管道和文件进行进程间通信的本质相同。</p>
<h2 id="Linux-文件锁与记录锁"><a href="#Linux-文件锁与记录锁" class="headerlink" title="Linux 文件锁与记录锁"></a>Linux 文件锁与记录锁</h2><p>TODO</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xuyh/p/3278881.html">链接1</a>、<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fortunely/p/15219611.html">链接2</a>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《UNIX 环境高级编程》</li>
<li>《Linux 内核设计与实现（原书第 3 版） - Linux Kernel Development, Third Edition》，（美）拉芙（Love, R.）著；陈莉君，康华译. ——北京：机械工业出版社，2011.9（2021.5 重印）</li>
<li><a target="_blank" rel="noopener" href="https://github.com/antsHub/task_struct/tree/main">图解进程控制块stask_struct</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/10/">10</a><a class="extend next" rel="next" href="/blog/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="bi-an"
      src="/blog/images/avatar.gif">
  <p class="site-author-name" itemprop="name">bi-an</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">92</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">43</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/bi-an" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;bi-an" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ah_zzg@126.com" title="E-Mail → mailto:ah_zzg@126.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://cuda-doc.readthedocs.io/" title="https:&#x2F;&#x2F;cuda-doc.readthedocs.io" rel="noopener" target="_blank">CUDA中文手册</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://infiniband-doc.readthedocs.io/" title="https:&#x2F;&#x2F;infiniband-doc.readthedocs.io&#x2F;" rel="noopener" target="_blank">InfiniBand中文手册</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bi-an</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>




  




  
<script src="/blog/js/local-search.js"></script>













  

  

</body>
</html>
