<!DOCTYPE html>
<html lang="en, zh_CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"bi-an.github.io","root":"/blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="江南人物的博客">
<meta property="og:url" content="https://bi-an.github.io/blog/index.html">
<meta property="og:site_name" content="江南人物的博客">
<meta property="og:locale">
<meta property="article:author" content="bi-an">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://bi-an.github.io/blog/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en, zh_CN'
  };
</script>

  <title>江南人物的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">江南人物的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/12/23/rdma/InfiniBand_Send_Recv%E4%B8%8ERead_Write%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/12/23/rdma/InfiniBand_Send_Recv%E4%B8%8ERead_Write%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">InfiniBand Send/Recv与Read/Write的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-12-23 16:32:46 / Modified: 11:34:45" itemprop="dateCreated datePublished" datetime="2025-12-23T16:32:46+00:00">2025-12-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/RDMA/" itemprop="url" rel="index"><span itemprop="name">RDMA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>InfiniBand&#x2F;RDMA 提供了两种截然不同的数据传输模式：<strong>Send&#x2F;Recv</strong> 和 <strong>Read&#x2F;Write</strong>。这两种模式在底层实现机制、CPU 参与度、对端感知性和传输控制策略方面存在根本性差异。</p>
<h2 id="核心差异对比"><a href="#核心差异对比" class="headerlink" title="核心差异对比"></a>核心差异对比</h2><h3 id="基本特性对比"><a href="#基本特性对比" class="headerlink" title="基本特性对比"></a>基本特性对比</h3><table>
<thead>
<tr>
<th align="center">维度</th>
<th align="center">Send&#x2F;Recv</th>
<th align="center">Read&#x2F;Write</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>操作码</strong></td>
<td align="center"><code>IBV_WR_SEND</code></td>
<td align="center"><code>IBV_WR_RDMA_WRITE</code><br><code>IBV_WR_RDMA_READ</code></td>
</tr>
<tr>
<td align="center"><strong>CPU 参与</strong></td>
<td align="center">接收端必须参与（post recv）</td>
<td align="center">对端 CPU 不参与</td>
</tr>
<tr>
<td align="center"><strong>对端感知</strong></td>
<td align="center">完全感知（CQ 事件）</td>
<td align="center">不感知（无事件）</td>
</tr>
<tr>
<td align="center"><strong>流控机制</strong></td>
<td align="center">有（RNR 机制）</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><strong>传输速率控制</strong></td>
<td align="center">受接收端节制</td>
<td align="center">不受对端节制</td>
</tr>
<tr>
<td align="center"><strong>内存注册要求</strong></td>
<td align="center">发送端和接收端都需要</td>
<td align="center">发起端和对端都需要（对端需设置 REMOTE 权限）</td>
</tr>
<tr>
<td align="center"><strong>远程地址信息</strong></td>
<td align="center">不需要</td>
<td align="center">需要（remote_addr + rkey）</td>
</tr>
<tr>
<td align="center"><strong>完成事件</strong></td>
<td align="center">双方都有</td>
<td align="center">仅发起端有</td>
</tr>
<tr>
<td align="center"><strong>使用复杂度</strong></td>
<td align="center">需要双方协调</td>
<td align="center">只需发起端操作</td>
</tr>
<tr>
<td align="center"><strong>性能</strong></td>
<td align="center">高（硬件加速）</td>
<td align="center">最高（零拷贝，无 CPU 参与）</td>
</tr>
</tbody></table>
<h3 id="工作机制对比"><a href="#工作机制对比" class="headerlink" title="工作机制对比"></a>工作机制对比</h3><table>
<thead>
<tr>
<th align="center">步骤</th>
<th align="center">Send&#x2F;Recv</th>
<th align="center">Read&#x2F;Write</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>1. 准备工作</strong></td>
<td align="center">接收端预先 post recv</td>
<td align="center">对端注册内存并传递 R_Key</td>
</tr>
<tr>
<td align="center"><strong>2. 发起操作</strong></td>
<td align="center">发送端 post send</td>
<td align="center">发起端 post RDMA Read&#x2F;Write</td>
</tr>
<tr>
<td align="center"><strong>3. 数据传输</strong></td>
<td align="center">HCA 匹配 Receive WR 并写入缓冲区</td>
<td align="center">HCA 直接访问远程内存</td>
</tr>
<tr>
<td align="center"><strong>4. 完成通知</strong></td>
<td align="center">双方 CQ 都有完成事件</td>
<td align="center">仅发起端 CQ 有完成事件</td>
</tr>
<tr>
<td align="center"><strong>5. 对端状态</strong></td>
<td align="center">接收端知道数据到达</td>
<td align="center">对端 CPU 完全无感知</td>
</tr>
</tbody></table>
<h3 id="CPU-参与度与对端感知性"><a href="#CPU-参与度与对端感知性" class="headerlink" title="CPU 参与度与对端感知性"></a>CPU 参与度与对端感知性</h3><table>
<thead>
<tr>
<th align="center">方面</th>
<th align="center">Send&#x2F;Recv</th>
<th align="center">Read&#x2F;Write</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>接收端操作</strong></td>
<td align="center">必须预先 post recv</td>
<td align="center">无需任何操作</td>
</tr>
<tr>
<td align="center"><strong>接收端 CPU</strong></td>
<td align="center">必须参与，处理 CQ 事件</td>
<td align="center">完全不参与</td>
</tr>
<tr>
<td align="center"><strong>接收端控制</strong></td>
<td align="center">可以控制接收速率</td>
<td align="center">无法控制传输速率</td>
</tr>
<tr>
<td align="center"><strong>对端 CPU 状态</strong></td>
<td align="center">需要处理接收事件</td>
<td align="center">可以执行其他任务或休眠</td>
</tr>
<tr>
<td align="center"><strong>数据到达感知</strong></td>
<td align="center">完全感知（CQ 事件）</td>
<td align="center">不感知</td>
</tr>
<tr>
<td align="center"><strong>传输时机控制</strong></td>
<td align="center">可以控制接收时机</td>
<td align="center">无法控制传输时机</td>
</tr>
<tr>
<td align="center"><strong>数据来源信息</strong></td>
<td align="center">知道数据来源（QP 编号）</td>
<td align="center">不知道数据来源</td>
</tr>
<tr>
<td align="center"><strong>数据大小信息</strong></td>
<td align="center">知道数据大小</td>
<td align="center">不知道传输大小</td>
</tr>
<tr>
<td align="center"><strong>传输完成感知</strong></td>
<td align="center">通过 CQ 事件知道</td>
<td align="center">无法直接知道</td>
</tr>
<tr>
<td align="center"><strong>同步机制</strong></td>
<td align="center">通过 CQ 事件同步</td>
<td align="center">需要额外机制（Send&#x2F;Recv 或轮询）</td>
</tr>
</tbody></table>
<h3 id="传输速率控制"><a href="#传输速率控制" class="headerlink" title="传输速率控制"></a>传输速率控制</h3><table>
<thead>
<tr>
<th align="center">方面</th>
<th align="center">Send&#x2F;Recv</th>
<th align="center">Read&#x2F;Write</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>流控机制</strong></td>
<td align="center">RNR（Receiver Not Ready）机制</td>
<td align="center">无流控机制</td>
</tr>
<tr>
<td align="center"><strong>速率控制方</strong></td>
<td align="center">接收端控制（通过 post recv 频率）</td>
<td align="center">发起端完全控制</td>
</tr>
<tr>
<td align="center"><strong>RNR 处理</strong></td>
<td align="center">发送端收到 RNR NACK，等待重试</td>
<td align="center">不适用</td>
</tr>
<tr>
<td align="center"><strong>对端限制能力</strong></td>
<td align="center">可以限制接收速率</td>
<td align="center">无法限制传输速率</td>
</tr>
<tr>
<td align="center"><strong>潜在风险</strong></td>
<td align="center">接收端可能过载（但可通过流控避免）</td>
<td align="center">对端可能被数据淹没</td>
</tr>
<tr>
<td align="center"><strong>性能特点</strong></td>
<td align="center">受接收端处理能力限制</td>
<td align="center">可达到网络带宽上限</td>
</tr>
</tbody></table>
<p><strong>RNR 机制参数</strong>：</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="left">说明</th>
<th align="left">典型值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>rnr_retry</code></td>
<td align="left">RNR 重试次数（0-7，7 表示无限重试）</td>
<td align="left">7</td>
</tr>
<tr>
<td align="center"><code>min_rnr_timer</code></td>
<td align="left">最小 RNR 等待时间（单位：655.36 微秒）</td>
<td align="left">0x12</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 modify_qp_to_rts 中设置</span></span><br><span class="line">attr.rnr_retry = <span class="number">7</span>;          <span class="comment">// RNR 重试次数</span></span><br><span class="line">attr.min_rnr_timer = <span class="number">0x12</span>;   <span class="comment">// 最小 RNR 等待时间</span></span><br></pre></td></tr></table></figure>

<h2 id="API-与代码示例"><a href="#API-与代码示例" class="headerlink" title="API 与代码示例"></a>API 与代码示例</h2><h3 id="关键函数"><a href="#关键函数" class="headerlink" title="关键函数"></a>关键函数</h3><h4 id="ibv-post-recv"><a href="#ibv-post-recv" class="headerlink" title="ibv_post_recv()"></a>ibv_post_recv()</h4><p>接收端必须预先调用此函数提交 Receive WR：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;infiniband/verbs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ibv_post_recv</span><span class="params">(<span class="keyword">struct</span> ibv_qp *qp, </span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> ibv_recv_wr *wr,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> ibv_recv_wr **bad_wr)</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>qp</code></td>
<td align="left">队列对句柄</td>
</tr>
<tr>
<td align="center"><code>wr</code></td>
<td align="left">Receive Work Request 链表头</td>
</tr>
<tr>
<td align="center"><code>bad_wr</code></td>
<td align="left">如果提交失败，返回失败的 WR 指针</td>
</tr>
</tbody></table>
<p><strong>返回值</strong>：成功返回 0，失败返回错误码</p>
<h4 id="ibv-post-send"><a href="#ibv-post-send" class="headerlink" title="ibv_post_send()"></a>ibv_post_send()</h4><p>发送端调用此函数提交 Send WR 或 RDMA Read&#x2F;Write WR：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ibv_post_send</span><span class="params">(<span class="keyword">struct</span> ibv_qp *qp,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> ibv_send_wr *wr,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> ibv_send_wr **bad_wr)</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>qp</code></td>
<td align="left">队列对句柄</td>
</tr>
<tr>
<td align="center"><code>wr</code></td>
<td align="left">Send Work Request 链表头</td>
</tr>
<tr>
<td align="center"><code>bad_wr</code></td>
<td align="left">如果提交失败，返回失败的 WR 指针</td>
</tr>
</tbody></table>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="Receive-Work-Request"><a href="#Receive-Work-Request" class="headerlink" title="Receive Work Request"></a>Receive Work Request</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_recv_wr</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>                wr_id;      <span class="comment">// 工作请求标识符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ibv_recv_wr</span>     *<span class="title">next</span>;</span>       <span class="comment">// 下一个 WR（可组成链表）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ibv_sge</span>         *<span class="title">sg_list</span>;</span>    <span class="comment">// Scatter/Gather 元素数组</span></span><br><span class="line">    <span class="type">int</span>                     num_sge;    <span class="comment">// SGE 数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Send-Work-Request"><a href="#Send-Work-Request" class="headerlink" title="Send Work Request"></a>Send Work Request</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_send_wr</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>                wr_id;           <span class="comment">// 工作请求标识符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ibv_send_wr</span>     *<span class="title">next</span>;</span>            <span class="comment">// 下一个 WR</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ibv_sge</span>         *<span class="title">sg_list</span>;</span>         <span class="comment">// Scatter/Gather 元素数组</span></span><br><span class="line">    <span class="type">int</span>                     num_sge;         <span class="comment">// SGE 数量</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">ibv_wr_opcode</span>      <span class="title">opcode</span>;</span>          <span class="comment">// 操作类型</span></span><br><span class="line">    <span class="type">int</span>                     send_flags;      <span class="comment">// 发送标志</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">uint64_t</span>        remote_addr;     <span class="comment">// 远程地址（RDMA 操作使用）</span></span><br><span class="line">            <span class="type">uint32_t</span>        rkey;            <span class="comment">// 远程密钥（RDMA 操作使用）</span></span><br><span class="line">        &#125; rdma;</span><br><span class="line">        <span class="comment">// ... 其他操作类型</span></span><br><span class="line">    &#125; wr;</span><br><span class="line">    <span class="type">uint32_t</span>                imm_data;        <span class="comment">// 立即数据（可选）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Scatter-Gather-Element"><a href="#Scatter-Gather-Element" class="headerlink" title="Scatter&#x2F;Gather Element"></a>Scatter&#x2F;Gather Element</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_sge</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>        addr;    <span class="comment">// 缓冲区地址</span></span><br><span class="line">    <span class="type">uint32_t</span>        length;  <span class="comment">// 缓冲区长度</span></span><br><span class="line">    <span class="type">uint32_t</span>        lkey;    <span class="comment">// 本地内存区域密钥</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="操作码与标志位"><a href="#操作码与标志位" class="headerlink" title="操作码与标志位"></a>操作码与标志位</h3><table>
<thead>
<tr>
<th align="center">操作码</th>
<th align="left">说明</th>
<th align="left">使用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>IBV_WR_SEND</code></td>
<td align="left">Send&#x2F;Recv 模式</td>
<td align="left">需要接收端确认的消息传递</td>
</tr>
<tr>
<td align="center"><code>IBV_WR_RDMA_WRITE</code></td>
<td align="left">RDMA Write</td>
<td align="left">将本地数据写入远程内存</td>
</tr>
<tr>
<td align="center"><code>IBV_WR_RDMA_WRITE_WITH_IMM</code></td>
<td align="left">RDMA Write with Immediate</td>
<td align="left">写入数据并通知对端</td>
</tr>
<tr>
<td align="center"><code>IBV_WR_RDMA_READ</code></td>
<td align="left">RDMA Read</td>
<td align="left">从远程内存读取数据</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">标志位</th>
<th align="left">说明</th>
<th align="left">使用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>IBV_SEND_FENCE</code></td>
<td align="left">栅栏标志，确保顺序</td>
<td align="left">需要保证操作顺序</td>
</tr>
<tr>
<td align="center"><code>IBV_SEND_SIGNALED</code></td>
<td align="left">请求完成通知</td>
<td align="left">需要知道操作完成</td>
</tr>
<tr>
<td align="center"><code>IBV_SEND_SOLICITED</code></td>
<td align="left">请求立即通知（用于 Send with Immediate）</td>
<td align="left">Send with Immediate</td>
</tr>
<tr>
<td align="center"><code>IBV_SEND_INLINE</code></td>
<td align="left">内联发送（小数据直接放在 WR 中）</td>
<td align="left">小数据快速发送</td>
</tr>
</tbody></table>
<h3 id="Send-Recv-代码示例"><a href="#Send-Recv-代码示例" class="headerlink" title="Send&#x2F;Recv 代码示例"></a>Send&#x2F;Recv 代码示例</h3><h4 id="接收端代码"><a href="#接收端代码" class="headerlink" title="接收端代码"></a>接收端代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 准备接收缓冲区</span></span><br><span class="line"><span class="type">char</span> *recv_buffer = <span class="built_in">malloc</span>(BUFFER_SIZE);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_mr</span> *<span class="title">recv_mr</span> =</span> ibv_reg_mr(pd, recv_buffer, BUFFER_SIZE,</span><br><span class="line">                                    IBV_ACCESS_LOCAL_WRITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 准备 Scatter/Gather Element</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_sge</span> <span class="title">recv_sge</span>;</span></span><br><span class="line">recv_sge.addr = (<span class="type">uintptr_t</span>)recv_buffer;</span><br><span class="line">recv_sge.length = BUFFER_SIZE;</span><br><span class="line">recv_sge.lkey = recv_mr-&gt;lkey;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 准备 Receive Work Request</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_recv_wr</span> <span class="title">recv_wr</span>, *<span class="title">bad_recv_wr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;recv_wr, <span class="number">0</span>, <span class="keyword">sizeof</span>(recv_wr));</span><br><span class="line">recv_wr.wr_id = (<span class="type">uintptr_t</span>)recv_buffer;</span><br><span class="line">recv_wr.sg_list = &amp;recv_sge;</span><br><span class="line">recv_wr.num_sge = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 提交 Receive WR（必须预先提交）</span></span><br><span class="line"><span class="keyword">if</span> (ibv_post_recv(qp, &amp;recv_wr, &amp;bad_recv_wr)) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to post receive WR\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 等待接收完成</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_wc</span> <span class="title">wc</span>;</span></span><br><span class="line"><span class="type">int</span> ne;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    ne = ibv_poll_cq(cq, <span class="number">1</span>, &amp;wc);</span><br><span class="line">&#125; <span class="keyword">while</span> (ne == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (wc.status != IBV_WC_SUCCESS) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Receive failed with status: %s\n&quot;</span>,</span><br><span class="line">            ibv_wc_status_str(wc.status));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="发送端代码"><a href="#发送端代码" class="headerlink" title="发送端代码"></a>发送端代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 准备发送缓冲区</span></span><br><span class="line"><span class="type">char</span> *send_buffer = <span class="built_in">malloc</span>(BUFFER_SIZE);</span><br><span class="line"><span class="built_in">memcpy</span>(send_buffer, data_to_send, data_size);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_mr</span> *<span class="title">send_mr</span> =</span> ibv_reg_mr(pd, send_buffer, BUFFER_SIZE,</span><br><span class="line">                                     IBV_ACCESS_LOCAL_WRITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 准备 Scatter/Gather Element</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_sge</span> <span class="title">send_sge</span>;</span></span><br><span class="line">send_sge.addr = (<span class="type">uintptr_t</span>)send_buffer;</span><br><span class="line">send_sge.length = data_size;</span><br><span class="line">send_sge.lkey = send_mr-&gt;lkey;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 准备 Send Work Request</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_send_wr</span> <span class="title">send_wr</span>, *<span class="title">bad_send_wr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;send_wr, <span class="number">0</span>, <span class="keyword">sizeof</span>(send_wr));</span><br><span class="line">send_wr.wr_id = (<span class="type">uintptr_t</span>)send_buffer;</span><br><span class="line">send_wr.opcode = IBV_WR_SEND;              <span class="comment">// Send/Recv 模式</span></span><br><span class="line">send_wr.send_flags = IBV_SEND_SIGNALED;    <span class="comment">// 请求完成通知</span></span><br><span class="line">send_wr.sg_list = &amp;send_sge;</span><br><span class="line">send_wr.num_sge = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 提交 Send WR</span></span><br><span class="line"><span class="keyword">if</span> (ibv_post_send(qp, &amp;send_wr, &amp;bad_send_wr)) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to post send WR\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 等待发送完成</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_wc</span> <span class="title">wc</span>;</span></span><br><span class="line"><span class="type">int</span> ne;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    ne = ibv_poll_cq(cq, <span class="number">1</span>, &amp;wc);</span><br><span class="line">&#125; <span class="keyword">while</span> (ne == <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Read-Write-代码示例"><a href="#Read-Write-代码示例" class="headerlink" title="Read&#x2F;Write 代码示例"></a>Read&#x2F;Write 代码示例</h3><h4 id="RDMA-Write-操作"><a href="#RDMA-Write-操作" class="headerlink" title="RDMA Write 操作"></a>RDMA Write 操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发起端代码</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_send_wr</span> <span class="title">write_wr</span>, *<span class="title">bad_wr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;write_wr, <span class="number">0</span>, <span class="keyword">sizeof</span>(write_wr));</span><br><span class="line"></span><br><span class="line">write_wr.wr_id = (<span class="type">uintptr_t</span>)local_buffer;</span><br><span class="line">write_wr.opcode = IBV_WR_RDMA_WRITE;        <span class="comment">// RDMA Write</span></span><br><span class="line">write_wr.send_flags = IBV_SEND_SIGNALED;</span><br><span class="line">write_wr.sg_list = &amp;sge;</span><br><span class="line">write_wr.num_sge = <span class="number">1</span>;</span><br><span class="line">write_wr.wr.rdma.remote_addr = remote_addr;  <span class="comment">// 远程内存地址</span></span><br><span class="line">write_wr.wr.rdma.rkey = remote_rkey;         <span class="comment">// 远程内存密钥</span></span><br><span class="line"></span><br><span class="line">ibv_post_send(qp, &amp;write_wr, &amp;bad_wr);</span><br></pre></td></tr></table></figure>

<h4 id="RDMA-Read-操作"><a href="#RDMA-Read-操作" class="headerlink" title="RDMA Read 操作"></a>RDMA Read 操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_send_wr</span> <span class="title">read_wr</span>, *<span class="title">bad_wr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;read_wr, <span class="number">0</span>, <span class="keyword">sizeof</span>(read_wr));</span><br><span class="line"></span><br><span class="line">read_wr.wr_id = (<span class="type">uintptr_t</span>)local_buffer;</span><br><span class="line">read_wr.opcode = IBV_WR_RDMA_READ;          <span class="comment">// RDMA Read</span></span><br><span class="line">read_wr.send_flags = IBV_SEND_SIGNALED;</span><br><span class="line">read_wr.sg_list = &amp;sge;</span><br><span class="line">read_wr.num_sge = <span class="number">1</span>;</span><br><span class="line">read_wr.wr.rdma.remote_addr = remote_addr;  <span class="comment">// 远程内存地址</span></span><br><span class="line">read_wr.wr.rdma.rkey = remote_rkey;         <span class="comment">// 远程内存密钥</span></span><br><span class="line"></span><br><span class="line">ibv_post_send(qp, &amp;read_wr, &amp;bad_wr);</span><br></pre></td></tr></table></figure>

<h4 id="内存注册要求"><a href="#内存注册要求" class="headerlink" title="内存注册要求"></a>内存注册要求</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对端注册内存（允许远程访问）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_mr</span> *<span class="title">remote_mr</span> =</span> ibv_reg_mr(pd, remote_buffer, BUFFER_SIZE,</span><br><span class="line">                                       IBV_ACCESS_LOCAL_WRITE |      <span class="comment">// 本地写权限</span></span><br><span class="line">                                       IBV_ACCESS_REMOTE_READ |      <span class="comment">// 允许远程读</span></span><br><span class="line">                                       IBV_ACCESS_REMOTE_WRITE);     <span class="comment">// 允许远程写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 R_Key 和地址传递给发起端</span></span><br><span class="line"><span class="comment">// remote_addr = (uint64_t)remote_buffer;</span></span><br><span class="line"><span class="comment">// remote_rkey = remote_mr-&gt;rkey;</span></span><br></pre></td></tr></table></figure>

<h2 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h2><h3 id="Send-Recv-同步机制"><a href="#Send-Recv-同步机制" class="headerlink" title="Send&#x2F;Recv 同步机制"></a>Send&#x2F;Recv 同步机制</h3><p><strong>关键问题</strong>：ibv_post_recv 必须在 ibv_post_send 之前吗？</p>
<p><strong>答案</strong>：不是必须在 <code>ibv_post_send</code> 之前调用，但必须在数据到达之前 post recv。</p>
<h4 id="调用顺序说明"><a href="#调用顺序说明" class="headerlink" title="调用顺序说明"></a>调用顺序说明</h4><table>
<thead>
<tr>
<th align="center">场景</th>
<th align="left">说明</th>
<th align="left">是否可行</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>预先 post recv</strong></td>
<td align="left">在发送端 post send 之前，接收端预先 post recv</td>
<td align="left">✅ 推荐做法</td>
</tr>
<tr>
<td align="center"><strong>同时调用</strong></td>
<td align="left">接收端和发送端同时调用（不同线程&#x2F;进程）</td>
<td align="left">✅ 可行，但需要确保 recv 先完成</td>
</tr>
<tr>
<td align="center"><strong>延迟 post recv</strong></td>
<td align="left">发送端先 post send，接收端后 post recv</td>
<td align="left">⚠️ 可能导致 RNR 错误</td>
</tr>
</tbody></table>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ol>
<li><p><strong>接收队列（RQ）机制</strong>：</p>
<ul>
<li>接收端调用 <code>ibv_post_recv()</code> 将 Receive WR 提交到接收队列（RQ）</li>
<li>当数据包到达时，HCA 硬件从 RQ 中取出一个 Receive WR</li>
<li>如果 RQ 中没有 Receive WR，HCA 返回 RNR（Receiver Not Ready）NACK</li>
</ul>
</li>
<li><p><strong>时序要求</strong>：</p>
<ul>
<li><strong>不是</strong>要求 <code>ibv_post_recv()</code> 必须在 <code>ibv_post_send()</code> 之前调用</li>
<li><strong>而是</strong>要求数据包到达时，RQ 中必须有可用的 Receive WR</li>
<li>由于网络延迟，通常可以预先 post recv</li>
</ul>
</li>
</ol>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p><strong>场景 1：预先批量 post recv（推荐）</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收端：预先批量提交多个 Receive WR</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; BATCH_SIZE; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ibv_recv_wr</span> <span class="title">recv_wr</span>, *<span class="title">bad_wr</span>;</span></span><br><span class="line">    <span class="comment">// ... 准备 recv_wr</span></span><br><span class="line">    ibv_post_recv(qp, &amp;recv_wr, &amp;bad_wr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时发送端可以随时 post send</span></span><br><span class="line"><span class="comment">// 发送端：随时发送数据</span></span><br><span class="line">ibv_post_send(qp, &amp;send_wr, &amp;bad_send_wr);</span><br></pre></td></tr></table></figure>

<p><strong>场景 2：RNR 错误处理</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送端处理 RNR 错误</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_wc</span> <span class="title">wc</span>;</span></span><br><span class="line">ibv_poll_cq(cq, <span class="number">1</span>, &amp;wc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (wc.status == IBV_WC_RNR_RETRY_EXC_ERR) &#123;</span><br><span class="line">    <span class="comment">// RNR 重试次数超限</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;RNR retry exceeded\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (wc.status == IBV_WC_REM_OP_ERR) &#123;</span><br><span class="line">    <span class="comment">// 可能是 RNR 错误</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Remote operation error, possibly RNR\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><table>
<thead>
<tr>
<th align="center">实践</th>
<th align="left">说明</th>
<th align="left">原因</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>预先批量 post recv</strong></td>
<td align="left">在连接建立后立即批量提交多个 Receive WR</td>
<td align="left">避免 RNR 错误，提高性能</td>
</tr>
<tr>
<td align="center"><strong>保持 RQ 中有足够的 WR</strong></td>
<td align="left">接收完成后立即重新 post recv</td>
<td align="left">确保持续接收能力</td>
</tr>
<tr>
<td align="center"><strong>使用应用层同步</strong></td>
<td align="left">如果必须延迟 post recv，使用同步机制</td>
<td align="left">避免 RNR 错误</td>
</tr>
<tr>
<td align="center"><strong>合理设置 RNR 参数</strong></td>
<td align="left">设置合适的 <code>rnr_retry</code> 和 <code>min_rnr_timer</code></td>
<td align="left">给接收端时间 post recv</td>
</tr>
</tbody></table>
<h3 id="Read-Write-同步机制"><a href="#Read-Write-同步机制" class="headerlink" title="Read&#x2F;Write 同步机制"></a>Read&#x2F;Write 同步机制</h3><p>由于 Read&#x2F;Write 操作对端无感知，需要额外的同步机制来保证数据一致性和操作顺序。</p>
<h4 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h4><table>
<thead>
<tr>
<th align="center">问题</th>
<th align="left">说明</th>
<th align="left">影响</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>数据写入完成通知</strong></td>
<td align="left">对端不知道数据何时写入完成</td>
<td align="left">可能读取到未完成的数据</td>
</tr>
<tr>
<td align="center"><strong>数据读取时机</strong></td>
<td align="left">对端不知道何时被读取</td>
<td align="left">可能在修改时被读取，导致数据不一致</td>
</tr>
<tr>
<td align="center"><strong>操作顺序保证</strong></td>
<td align="left">多个 RDMA 操作的顺序</td>
<td align="left">可能乱序执行，导致逻辑错误</td>
</tr>
<tr>
<td align="center"><strong>并发访问</strong></td>
<td align="left">本地 CPU 和远程 RDMA 同时访问</td>
<td align="left">可能导致数据竞争</td>
</tr>
</tbody></table>
<h4 id="同步机制对比"><a href="#同步机制对比" class="headerlink" title="同步机制对比"></a>同步机制对比</h4><table>
<thead>
<tr>
<th align="center">机制</th>
<th align="left">说明</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>RDMA Write with Immediate</strong></td>
<td align="left">写入数据的同时发送立即数据通知</td>
<td align="left">需要通知对端数据已写入</td>
</tr>
<tr>
<td align="center"><strong>Send&#x2F;Recv 通知</strong></td>
<td align="left">通过 Send&#x2F;Recv 发送完成通知</td>
<td align="left">需要确认和流控</td>
</tr>
<tr>
<td align="center"><strong>内存屏障（Fence）</strong></td>
<td align="left">使用 <code>IBV_SEND_FENCE</code> 保证顺序</td>
<td align="left">需要保证操作顺序</td>
</tr>
<tr>
<td align="center"><strong>原子操作</strong></td>
<td align="left">使用原子操作作为同步点</td>
<td align="left">需要细粒度同步</td>
</tr>
<tr>
<td align="center"><strong>版本号&#x2F;双缓冲</strong></td>
<td align="left">使用版本号或双缓冲机制</td>
<td align="left">需要检测数据变化或无锁读取</td>
</tr>
</tbody></table>
<h4 id="RDMA-Write-with-Immediate"><a href="#RDMA-Write-with-Immediate" class="headerlink" title="RDMA Write with Immediate"></a>RDMA Write with Immediate</h4><p>在写入数据的同时，发送立即数据通知对端：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发起端：写入数据并通知</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_send_wr</span> <span class="title">write_wr</span>, *<span class="title">bad_wr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;write_wr, <span class="number">0</span>, <span class="keyword">sizeof</span>(write_wr));</span><br><span class="line"></span><br><span class="line">write_wr.wr_id = (<span class="type">uintptr_t</span>)local_buffer;</span><br><span class="line">write_wr.opcode = IBV_WR_RDMA_WRITE_WITH_IMM;  <span class="comment">// 带立即数据的 Write</span></span><br><span class="line">write_wr.send_flags = IBV_SEND_SIGNALED;</span><br><span class="line">write_wr.sg_list = &amp;sge;</span><br><span class="line">write_wr.num_sge = <span class="number">1</span>;</span><br><span class="line">write_wr.wr.rdma.remote_addr = remote_addr;</span><br><span class="line">write_wr.wr.rdma.rkey = remote_rkey;</span><br><span class="line">write_wr.imm_data = htonl(NOTIFICATION_FLAG);  <span class="comment">// 立即数据（网络字节序）</span></span><br><span class="line"></span><br><span class="line">ibv_post_send(qp, &amp;write_wr, &amp;bad_wr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对端：接收立即数据通知（需要预先 post recv）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_recv_wr</span> <span class="title">recv_wr</span>, *<span class="title">bad_recv_wr</span>;</span></span><br><span class="line"><span class="comment">// ... 准备 Receive WR</span></span><br><span class="line">ibv_post_recv(qp, &amp;recv_wr, &amp;bad_recv_wr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 轮询 CQ，接收立即数据通知</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_wc</span> <span class="title">wc</span>;</span></span><br><span class="line">ibv_poll_cq(cq, <span class="number">1</span>, &amp;wc);</span><br><span class="line"><span class="keyword">if</span> (wc.opcode == IBV_WC_RECV_RDMA_WITH_IMM) &#123;</span><br><span class="line">    <span class="type">uint32_t</span> imm_data = ntohl(wc.imm_data);</span><br><span class="line">    <span class="comment">// 知道数据已经写入，可以安全读取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内存屏障（Fence）机制"><a href="#内存屏障（Fence）机制" class="headerlink" title="内存屏障（Fence）机制"></a>内存屏障（Fence）机制</h4><p>使用 <code>IBV_SEND_FENCE</code> 保证操作顺序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景：需要保证多个 RDMA Write 的顺序</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_send_wr</span> <span class="title">wr</span>[3], *<span class="title">bad_wr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WR 1: 写入元数据</span></span><br><span class="line">wr[<span class="number">0</span>].opcode = IBV_WR_RDMA_WRITE;</span><br><span class="line">wr[<span class="number">0</span>].send_flags = <span class="number">0</span>;</span><br><span class="line">wr[<span class="number">0</span>].next = &amp;wr[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// WR 2: Fence，确保前面的操作完成</span></span><br><span class="line">wr[<span class="number">1</span>].opcode = IBV_WR_RDMA_WRITE;</span><br><span class="line">wr[<span class="number">1</span>].send_flags = IBV_SEND_FENCE;  <span class="comment">// 栅栏标志</span></span><br><span class="line">wr[<span class="number">1</span>].next = &amp;wr[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// WR 3: 写入标志位（表示数据已准备好）</span></span><br><span class="line">wr[<span class="number">2</span>].opcode = IBV_WR_RDMA_WRITE;</span><br><span class="line">wr[<span class="number">2</span>].send_flags = IBV_SEND_SIGNALED;</span><br><span class="line">wr[<span class="number">2</span>].next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">ibv_post_send(qp, &amp;wr[<span class="number">0</span>], &amp;bad_wr);</span><br><span class="line"><span class="comment">// 保证：元数据写入 → Fence → 标志位写入（顺序执行）</span></span><br></pre></td></tr></table></figure>

<p><strong>Fence 的作用</strong>：</p>
<ul>
<li>确保 Fence 之前的所有操作在 Fence 之后的操作之前完成</li>
<li>保证操作的全局顺序（跨多个 QP）</li>
<li>适用于需要严格顺序的场景</li>
</ul>
<h4 id="原子操作同步"><a href="#原子操作同步" class="headerlink" title="原子操作同步"></a>原子操作同步</h4><p>使用原子操作作为同步点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对端：准备数据后，使用原子操作设置标志</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_send_wr</span> <span class="title">atomic_wr</span>, *<span class="title">bad_wr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;atomic_wr, <span class="number">0</span>, <span class="keyword">sizeof</span>(atomic_wr));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键操作码：Compare and Swap 原子操作</span></span><br><span class="line"><span class="comment">// 作用：原子地比较远程内存的值，如果等于期望值则交换为新值</span></span><br><span class="line"><span class="comment">// 特点：这是硬件保证的原子操作，不会被其他操作打断，用于实现同步原语</span></span><br><span class="line">atomic_wr.opcode = IBV_WR_ATOMIC_CMP_AND_SWP;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键标志位：请求完成通知</span></span><br><span class="line"><span class="comment">// 作用：操作完成后在 CQ 中生成完成事件，用于确认原子操作是否成功</span></span><br><span class="line"><span class="comment">// 注意：原子操作的成功/失败通过 Work Completion 的状态字段判断</span></span><br><span class="line">atomic_wr.send_flags = IBV_SEND_SIGNALED;</span><br><span class="line">atomic_wr.sg_list = &amp;sge;  <span class="comment">// 本地缓冲区，用于存储旧值</span></span><br><span class="line">atomic_wr.num_sge = <span class="number">1</span>;</span><br><span class="line">atomic_wr.wr.atomic.remote_addr = remote_flag_addr;  <span class="comment">// 远程标志位地址</span></span><br><span class="line">atomic_wr.wr.atomic.rkey = remote_rkey;</span><br><span class="line">atomic_wr.wr.atomic.compare_add = <span class="number">0</span>;      <span class="comment">// 期望值：0（未准备好）</span></span><br><span class="line">atomic_wr.wr.atomic.swap = <span class="number">1</span>;              <span class="comment">// 新值：1（已准备好）</span></span><br><span class="line"></span><br><span class="line">ibv_post_send(qp, &amp;atomic_wr, &amp;bad_wr);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">操作码</th>
<th align="left">说明</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>IBV_WR_ATOMIC_CMP_AND_SWP</code></td>
<td align="left">Compare and Swap</td>
<td align="left">条件更新标志位</td>
</tr>
<tr>
<td align="center"><code>IBV_WR_ATOMIC_FETCH_AND_ADD</code></td>
<td align="left">Fetch and Add</td>
<td align="left">计数器操作</td>
</tr>
</tbody></table>
<h4 id="Read-时的并发安全"><a href="#Read-时的并发安全" class="headerlink" title="Read 时的并发安全"></a>Read 时的并发安全</h4><p><strong>问题</strong>：如果 Read 时对端 CPU 正在修改数据，可能导致读取到不一致的数据。</p>
<p><strong>解决方案</strong>：</p>
<p><strong>版本号机制</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_with_version</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> version;      <span class="comment">// 版本号</span></span><br><span class="line">    <span class="type">char</span> data[BUFFER_SIZE]; <span class="comment">// 实际数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对端：修改数据时增加版本号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">update_data</span><span class="params">(<span class="keyword">struct</span> data_with_version *buf)</span> &#123;</span><br><span class="line">    prepare_new_data(buf-&gt;data);</span><br><span class="line">    __sync_synchronize();  <span class="comment">// 内存屏障</span></span><br><span class="line">    __sync_add_and_fetch(&amp;buf-&gt;version, <span class="number">1</span>);  <span class="comment">// 原子增加版本号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起端：读取时检查版本号</span></span><br><span class="line"><span class="type">uint64_t</span> old_version = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> version_before = read_version();</span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    read_data(buffer);</span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="type">uint64_t</span> version_after = read_version();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果版本号相同，说明读取期间数据未变化</span></span><br><span class="line">    <span class="keyword">if</span> (version_before == version_after &amp;&amp; version_before != old_version) &#123;</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// 数据一致，可以使用</span></span><br><span class="line">    &#125;</span><br><span class="line">    old_version = version_before;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><strong>双缓冲机制</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对端：使用两个缓冲区交替</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">double_buffer</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">2</span>][BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> active_index;  <span class="comment">// 当前活跃缓冲区索引</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对端：修改数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">update_data</span><span class="params">(<span class="keyword">struct</span> double_buffer *db)</span> &#123;</span><br><span class="line">    <span class="type">int</span> write_index = <span class="number">1</span> - db-&gt;active_index;  <span class="comment">// 写入非活跃缓冲区</span></span><br><span class="line">    prepare_data(db-&gt;buffer[write_index]);</span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    __sync_lock_test_and_set(&amp;db-&gt;active_index, write_index);  <span class="comment">// 切换缓冲区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起端：读取数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_data</span><span class="params">(<span class="keyword">struct</span> double_buffer *db)</span> &#123;</span><br><span class="line">    <span class="type">int</span> read_index = db-&gt;active_index;  <span class="comment">// 读取当前活跃缓冲区</span></span><br><span class="line">    rdma_read(db-&gt;buffer[read_index]);   <span class="comment">// RDMA Read</span></span><br><span class="line">    <span class="comment">// 即使对端切换缓冲区，读取的也是完整的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同步机制选择建议"><a href="#同步机制选择建议" class="headerlink" title="同步机制选择建议"></a>同步机制选择建议</h4><table>
<thead>
<tr>
<th align="center">场景</th>
<th align="left">推荐机制</th>
<th align="left">原因</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>需要通知对端数据已写入</strong></td>
<td align="left">RDMA Write with Immediate</td>
<td align="left">高性能 + 通知</td>
</tr>
<tr>
<td align="center"><strong>需要严格顺序</strong></td>
<td align="left">Fence + Send&#x2F;Recv</td>
<td align="left">保证操作顺序</td>
</tr>
<tr>
<td align="center"><strong>需要检测数据变化</strong></td>
<td align="left">版本号机制</td>
<td align="left">可以检测并发修改</td>
</tr>
<tr>
<td align="center"><strong>需要无锁读取</strong></td>
<td align="left">双缓冲机制</td>
<td align="left">避免锁竞争</td>
</tr>
<tr>
<td align="center"><strong>需要细粒度控制</strong></td>
<td align="left">原子标志位</td>
<td align="left">精确控制读写时机</td>
</tr>
</tbody></table>
<h2 id="应用与实践"><a href="#应用与实践" class="headerlink" title="应用与实践"></a>应用与实践</h2><h3 id="应用场景对比"><a href="#应用场景对比" class="headerlink" title="应用场景对比"></a>应用场景对比</h3><table>
<thead>
<tr>
<th align="center">场景类型</th>
<th align="center">Send&#x2F;Recv</th>
<th align="center">Read&#x2F;Write</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>请求-响应模式</strong></td>
<td align="center">✅ 适合（RPC、数据库查询）</td>
<td align="center">❌ 不适合</td>
</tr>
<tr>
<td align="center"><strong>需要流控</strong></td>
<td align="center">✅ 适合（接收端处理能力有限）</td>
<td align="center">❌ 不适合</td>
</tr>
<tr>
<td align="center"><strong>需要确认</strong></td>
<td align="center">✅ 适合（事务提交、状态同步）</td>
<td align="center">❌ 不适合</td>
</tr>
<tr>
<td align="center"><strong>小数据频繁交互</strong></td>
<td align="center">✅ 适合</td>
<td align="center">❌ 不适合</td>
</tr>
<tr>
<td align="center"><strong>协议实现</strong></td>
<td align="center">✅ 适合（分布式一致性协议）</td>
<td align="center">❌ 不适合</td>
</tr>
<tr>
<td align="center"><strong>高性能计算（HPC）</strong></td>
<td align="center">❌ 不适合</td>
<td align="center">✅ 适合（科学计算、数值模拟）</td>
</tr>
<tr>
<td align="center"><strong>AI 训练</strong></td>
<td align="center">❌ 不适合</td>
<td align="center">✅ 适合（参数同步，对端 CPU 繁忙）</td>
</tr>
<tr>
<td align="center"><strong>存储系统</strong></td>
<td align="center">❌ 不适合</td>
<td align="center">✅ 适合（块存储、文件系统）</td>
</tr>
<tr>
<td align="center"><strong>批量数据传输</strong></td>
<td align="center">❌ 不适合</td>
<td align="center">✅ 适合（大数据传输）</td>
</tr>
<tr>
<td align="center"><strong>零拷贝需求</strong></td>
<td align="center">❌ 不适合</td>
<td align="center">✅ 适合（避免 CPU 参与）</td>
</tr>
</tbody></table>
<h3 id="混合使用策略"><a href="#混合使用策略" class="headerlink" title="混合使用策略"></a>混合使用策略</h3><p>在实际应用中，可以混合使用两种模式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：使用 Send/Recv 进行控制，使用 Write 进行数据传输</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 通过 Send/Recv 交换元数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">metadata</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> data_addr;</span><br><span class="line">    <span class="type">uint32_t</span> data_rkey;</span><br><span class="line">    <span class="type">size_t</span> data_size;</span><br><span class="line">&#125; meta;</span><br><span class="line">send_metadata(&amp;meta);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过 RDMA Write 传输实际数据</span></span><br><span class="line">rdma_write_data(meta.data_addr, meta.data_rkey, data_buffer, meta.data_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 通过 Send/Recv 发送完成通知</span></span><br><span class="line">send_completion_notification();</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">用途</th>
<th align="left">使用的模式</th>
<th align="left">原因</th>
</tr>
</thead>
<tbody><tr>
<td align="center">元数据交换</td>
<td align="left">Send&#x2F;Recv</td>
<td align="left">需要确认和流控</td>
</tr>
<tr>
<td align="center">数据传输</td>
<td align="left">Read&#x2F;Write</td>
<td align="left">需要最高性能</td>
</tr>
<tr>
<td align="center">完成通知</td>
<td align="left">Send&#x2F;Recv</td>
<td align="left">需要确认</td>
</tr>
</tbody></table>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><table>
<thead>
<tr>
<th align="center">优化策略</th>
<th align="left">Send&#x2F;Recv</th>
<th align="left">Read&#x2F;Write</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>批量操作</strong></td>
<td align="left">批量提交 Receive WR</td>
<td align="left">批量提交 Read&#x2F;Write WR</td>
</tr>
<tr>
<td align="center"><strong>Signaling 策略</strong></td>
<td align="left">周期性 Signaling（每 N 个请求）</td>
<td align="left">避免频繁 Signaling</td>
</tr>
<tr>
<td align="center"><strong>内存对齐</strong></td>
<td align="left">建议对齐</td>
<td align="left">强烈建议对齐（64 字节）</td>
</tr>
<tr>
<td align="center"><strong>队列大小</strong></td>
<td align="left">合理设置 max_recv_wr</td>
<td align="left">合理设置 max_send_wr</td>
</tr>
<tr>
<td align="center"><strong>RNR 参数</strong></td>
<td align="left">合理设置 rnr_retry 和 min_rnr_timer</td>
<td align="left">不适用</td>
</tr>
</tbody></table>
<p><strong>Send&#x2F;Recv 性能优化代码</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 批量提交 Receive WR</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; BATCH_SIZE; i++) &#123;</span><br><span class="line">    post_recv_wr();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 周期性 Signaling</span></span><br><span class="line"><span class="keyword">if</span> (count % <span class="number">64</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    send_wr.send_flags |= IBV_SEND_SIGNALED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Read&#x2F;Write 性能优化代码</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 批量操作</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_send_wr</span> *<span class="title">wr_list</span> =</span> build_wr_list();</span><br><span class="line">ibv_post_send(qp, wr_list, &amp;bad_wr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 避免频繁 Signaling</span></span><br><span class="line">write_wr.send_flags = <span class="number">0</span>;  <span class="comment">// 不请求完成通知</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 内存对齐</span></span><br><span class="line">posix_memalign((<span class="type">void</span>**)&amp;buffer, <span class="number">64</span>, size);  <span class="comment">// 64 字节对齐</span></span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><table>
<thead>
<tr>
<th align="center">注意事项</th>
<th align="left">Send&#x2F;Recv</th>
<th align="left">Read&#x2F;Write</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>必须预先 post recv</strong></td>
<td align="left">✅ 必须</td>
<td align="left">❌ 不需要</td>
</tr>
<tr>
<td align="center"><strong>及时处理 CQ 事件</strong></td>
<td align="left">✅ 必须（避免 CQ 溢出）</td>
<td align="left">✅ 必须（仅发起端）</td>
</tr>
<tr>
<td align="center"><strong>合理设置队列大小</strong></td>
<td align="left">✅ 重要</td>
<td align="left">✅ 重要</td>
</tr>
<tr>
<td align="center"><strong>内存访问权限</strong></td>
<td align="left">✅ 需要</td>
<td align="left">✅ 需要（对端需设置 REMOTE 权限）</td>
</tr>
<tr>
<td align="center"><strong>R_Key 安全</strong></td>
<td align="left">❌ 不需要</td>
<td align="left">✅ 重要（需要安全传递）</td>
</tr>
<tr>
<td align="center"><strong>同步机制</strong></td>
<td align="left">✅ 通过 CQ 事件</td>
<td align="left">✅ 需要额外机制</td>
</tr>
<tr>
<td align="center"><strong>内存边界检查</strong></td>
<td align="left">✅ 需要</td>
<td align="left">✅ 需要（避免越界访问）</td>
</tr>
<tr>
<td align="center"><strong>并发安全</strong></td>
<td align="left">✅ 需要应用层同步</td>
<td align="left">✅ 需要应用层同步</td>
</tr>
</tbody></table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Send&#x2F;Recv 和 Read&#x2F;Write 代表了 InfiniBand&#x2F;RDMA 的两种不同设计哲学：</p>
<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="left">设计哲学</th>
<th align="left">核心特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Send&#x2F;Recv</strong></td>
<td align="left">协作和流控</td>
<td align="left">接收端参与，有流控机制，适合需要确认的场景</td>
</tr>
<tr>
<td align="center"><strong>Read&#x2F;Write</strong></td>
<td align="left">极致性能和 CPU 卸载</td>
<td align="left">对端 CPU 不参与，无流控，适合高性能场景</td>
</tr>
</tbody></table>
<p>在实际应用中，应根据具体场景的需求，灵活选择或组合使用这两种模式，充分发挥 InfiniBand&#x2F;RDMA 的性能优势。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/12/23/rdma/InfiniBand%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/12/23/rdma/InfiniBand%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">InfiniBand关键概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-12-23 15:36:17 / Modified: 11:34:45" itemprop="dateCreated datePublished" datetime="2025-12-23T15:36:17+00:00">2025-12-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/RDMA/" itemprop="url" rel="index"><span itemprop="name">RDMA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>InfiniBand 是一种高性能计算机网络通信标准，具有极高的吞吐量和极低的延迟。本文介绍 InfiniBand&#x2F;RDMA 编程中的关键概念及其相互关系。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="1-CA-Channel-Adapter-通道适配器"><a href="#1-CA-Channel-Adapter-通道适配器" class="headerlink" title="1. CA (Channel Adapter) - 通道适配器"></a>1. CA (Channel Adapter) - 通道适配器</h3><p>CA 是 InfiniBand 网络接口卡（NIC），是硬件层面的概念。每个 CA 都有一个或多个端口（Port），用于连接到 InfiniBand 网络。</p>
<h3 id="2-PD-Protection-Domain-保护域"><a href="#2-PD-Protection-Domain-保护域" class="headerlink" title="2. PD (Protection Domain) - 保护域"></a>2. PD (Protection Domain) - 保护域</h3><p>保护域是一个安全边界，用于将 QP（队列对）和 MR（内存区域）组织在一起。只有属于同一个 PD 的 QP 和 MR 才能相互操作，这提供了内存保护机制。</p>
<h3 id="3-MR-Memory-Region-内存区域"><a href="#3-MR-Memory-Region-内存区域" class="headerlink" title="3. MR (Memory Region) - 内存区域"></a>3. MR (Memory Region) - 内存区域</h3><p>内存区域是一块经过注册的内存，网卡可以直接访问。每个 MR 包含：</p>
<ul>
<li><strong>L_Key (Local Key)</strong>: 本地访问密钥，用于本地 QP 访问本地 MR</li>
<li><strong>R_Key (Remote Key)</strong>: 远程访问密钥，用于远程 QP 访问此 MR（通过 RDMA 操作）</li>
</ul>
<h3 id="4-QP-Queue-Pair-队列对"><a href="#4-QP-Queue-Pair-队列对" class="headerlink" title="4. QP (Queue Pair) - 队列对"></a>4. QP (Queue Pair) - 队列对</h3><p>队列对是 InfiniBand 通信的基本单位，由两个队列组成：</p>
<ul>
<li><strong>SQ (Send Queue)</strong>: 发送队列，用于发送数据</li>
<li><strong>RQ (Receive Queue)</strong>: 接收队列，用于接收数据</li>
</ul>
<p>每个 QP 必须属于一个 PD，并且可以关联多个 CQ。</p>
<h3 id="5-CQ-Completion-Queue-完成队列"><a href="#5-CQ-Completion-Queue-完成队列" class="headerlink" title="5. CQ (Completion Queue) - 完成队列"></a>5. CQ (Completion Queue) - 完成队列</h3><p>完成队列用于接收工作请求（WR）的完成通知。当 WR 执行完成后，会在对应的 CQ 中生成一个完成事件（Completion Event）。</p>
<h3 id="6-WR-Work-Request-工作请求"><a href="#6-WR-Work-Request-工作请求" class="headerlink" title="6. WR (Work Request) - 工作请求"></a>6. WR (Work Request) - 工作请求</h3><p>工作请求是提交到 QP 的操作指令，包括：</p>
<ul>
<li>Send WR: 发送请求</li>
<li>Receive WR: 接收请求</li>
<li>RDMA Write WR: RDMA 写请求</li>
<li>RDMA Read WR: RDMA 读请求</li>
</ul>
<h3 id="7-SGE-Scatter-Gather-Elements-分散-聚集元素"><a href="#7-SGE-Scatter-Gather-Elements-分散-聚集元素" class="headerlink" title="7. SGE (Scatter&#x2F;Gather Elements) - 分散&#x2F;聚集元素"></a>7. SGE (Scatter&#x2F;Gather Elements) - 分散&#x2F;聚集元素</h3><p>SGE 描述了一个内存缓冲区的位置和大小，包含：</p>
<ul>
<li>地址（Address）</li>
<li>长度（Length）</li>
<li>L_Key（用于验证访问权限）</li>
</ul>
<p>一个 WR 可以包含多个 SGE，实现分散&#x2F;聚集 I&#x2F;O。</p>
<h3 id="8-LID-Local-Identifier-本地标识符"><a href="#8-LID-Local-Identifier-本地标识符" class="headerlink" title="8. LID (Local Identifier) - 本地标识符"></a>8. LID (Local Identifier) - 本地标识符</h3><p>LID 是 InfiniBand 网络中每个端口的唯一标识符，用于路由数据包。</p>
<h3 id="9-AH-Address-Handle-地址句柄"><a href="#9-AH-Address-Handle-地址句柄" class="headerlink" title="9. AH (Address Handle) - 地址句柄"></a>9. AH (Address Handle) - 地址句柄</h3><p>地址句柄用于 UD (Unreliable Datagram) 传输类型，包含目标地址信息。每个 AH 属于一个 PD，用于在 UD QP 发送数据时指定目标地址。AH 包含：</p>
<ul>
<li>目标 LID (Local Identifier)</li>
<li>服务级别 (Service Level)</li>
<li>路径位 (Path Bits)</li>
<li>全局路由头 (GRH) 信息（如果使用）</li>
</ul>
<h3 id="10-CM-Connection-Manager-连接管理器"><a href="#10-CM-Connection-Manager-连接管理器" class="headerlink" title="10. CM (Connection Manager) - 连接管理器"></a>10. CM (Connection Manager) - 连接管理器</h3><p>连接管理器负责建立和管理 QP 之间的连接，处理连接建立、断开等事件。</p>
<h2 id="保护域（PD）资源组织结构图"><a href="#保护域（PD）资源组织结构图" class="headerlink" title="保护域（PD）资源组织结构图"></a>保护域（PD）资源组织结构图</h2><p>以下 ASCII 图详细说明了 PD（保护域）内资源的结构和关系：</p>
<p><strong>重要说明</strong>：图中 CQ 显示在 PD 内是为了展示逻辑关联关系。实际上：</p>
<ul>
<li>CQ 通过 Context 创建（<code>ibv_create_cq()</code>），不属于任何 PD</li>
<li>CQ 是 Context 级别的资源，可以被不同 PD 的 QP 共享</li>
<li>多个 QP（即使属于不同的 PD）可以关联到同一个 CQ</li>
<li>例如：PD 1 的 QP 1、QP 2 和 PD 2 的 QP 3、QP 4 可以共享同一个 CQ</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                      Application Process                           │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────┘</span><br><span class="line">                              │</span><br><span class="line">                              │ ibv_open_device()</span><br><span class="line">                              ▼</span><br><span class="line">┌─────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                         Context                                     │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────┘</span><br><span class="line">                              │</span><br><span class="line">                              │ ibv_alloc_pd()</span><br><span class="line">                              ▼</span><br><span class="line">        ┌─────────────────────────────────────────────────────────┐</span><br><span class="line">        │                                                         │</span><br><span class="line">        ▼                                                         ▼</span><br><span class="line">┌──────────────────────────────────────┐    ┌──────────────────────────────────────┐</span><br><span class="line">│         PD 1 (Protection Domain)     │    │         PD 2 (Protection Domain)     │</span><br><span class="line">│                                      │    │                                      │</span><br><span class="line">│  Resources in PD 1:                  │    │  Resources in PD 2:                 │</span><br><span class="line">│                                      │    │                                      │</span><br><span class="line">│  ┌────────────────────────────────┐  │    │  ┌────────────────────────────────┐  │</span><br><span class="line">│  │  MR 1                          │  │    │  │  MR 3                          │  │</span><br><span class="line">│  │  L_Key: 0x01  R_Key: 0x81      │  │    │  │  L_Key: 0x05  R_Key: 0x85     │  │</span><br><span class="line">│  └────────────────────────────────┘  │    │  └────────────────────────────────┘  │</span><br><span class="line">│                                      │    │                                      │</span><br><span class="line">│  ┌────────────────────────────────┐  │    │  ┌────────────────────────────────┐  │</span><br><span class="line">│  │  MR 2                          │  │    │  │  MR 4                          │  │</span><br><span class="line">│  │  L_Key: 0x02  R_Key: 0x82      │  │    │  │  L_Key: 0x06  R_Key: 0x86     │  │</span><br><span class="line">│  └────────────────────────────────┘  │    │  └────────────────────────────────┘  │</span><br><span class="line">│                                      │    │                                      │</span><br><span class="line">│  ┌────────────────────────────────┐  │    │  ┌────────────────────────────────┐  │</span><br><span class="line">│  │  AH 1                          │  │    │  │  AH 3                          │  │</span><br><span class="line">│  │  Target LID, Service Level     │  │    │  │  Target LID, Service Level     │  │</span><br><span class="line">│  └────────────────────────────────┘  │    │  └────────────────────────────────┘  │</span><br><span class="line">│                                      │    │                                      │</span><br><span class="line">│  ┌────────────────────────────────┐  │    │  ┌────────────────────────────────┐  │</span><br><span class="line">│  │  AH 2                          │  │    │  │  AH 4                          │  │</span><br><span class="line">│  │  Target LID, Service Level     │  │    │  │  Target LID, Service Level     │  │</span><br><span class="line">│  └────────────────────────────────┘  │    │  └────────────────────────────────┘  │</span><br><span class="line">│                                      │    │                                      │</span><br><span class="line">│  ┌────────────────────────────────┐  │    │  ┌────────────────────────────────┐  │</span><br><span class="line">│  │  QP 1                          │  │    │  │  QP 3                          │  │</span><br><span class="line">│  │  Uses: MR 1/2, AH 1/2, CQ 1    │  │    │  │  Uses: MR 3/4, AH 3/4, CQ 1/2  │  │</span><br><span class="line">│  └────────────────────────────────┘  │    │  └────────────────────────────────┘  │</span><br><span class="line">│                                      │    │                                      │</span><br><span class="line">│  ┌────────────────────────────────┐  │    │  ┌────────────────────────────────┐  │</span><br><span class="line">│  │  QP 2                          │  │    │  │  QP 4                          │  │</span><br><span class="line">│  │  Uses: MR 1/2, AH 1/2, CQ 1    │  │    │  │  Uses: MR 3/4, AH 3/4, CQ 1/2  │  │</span><br><span class="line">│  └────────────────────────────────┘  │    │  └────────────────────────────────┘  │</span><br><span class="line">│                                      │    │                                      │</span><br><span class="line">└──────────────────────────────────────┘    └──────────────────────────────────────┘</span><br><span class="line">        │                                                         │</span><br><span class="line">        │  Security Boundary                                      │  Security Boundary</span><br><span class="line">        └─────────────────────────────────────────────────────────┘</span><br><span class="line">                              │</span><br><span class="line">                              │</span><br><span class="line">                              ▼</span><br><span class="line">┌───────────────────────────────────────────────────────────────────┐</span><br><span class="line">│  CQ (Created via Context, NOT belonging to any PD)                │</span><br><span class="line">│  CQ can be shared by QP from different PDs!                       │</span><br><span class="line">│                                                                   │</span><br><span class="line">│  ┌──────────────────────────────────────────────────────────────┐ │</span><br><span class="line">│  │  CQ 1 (Shared across PDs)                                    │ │</span><br><span class="line">│  │  Receives completions from:                                  │ │</span><br><span class="line">│  │    - QP 1 (PD 1)                                             │ │</span><br><span class="line">│  │    - QP 2 (PD 1)                                             │ │</span><br><span class="line">│  │    - QP 3 (PD 2)  ← Cross-PD sharing                         │ │</span><br><span class="line">│  │    - QP 4 (PD 2)  ← Cross-PD sharing                         │ │</span><br><span class="line">│  └──────────────────────────────────────────────────────────────┘ │</span><br><span class="line">│                                                                   │</span><br><span class="line">│  ┌──────────────────────────────────────────────────────────────┐ │</span><br><span class="line">│  │  CQ 2 (Alternative: separate CQ for PD 2)                    │ │</span><br><span class="line">│  │  Receives completions from:                                  │ │</span><br><span class="line">│  │    - QP 3 (PD 2)                                             │ │</span><br><span class="line">│  │    - QP 4 (PD 2)                                             │ │</span><br><span class="line">│  └──────────────────────────────────────────────────────────────┘ │</span><br><span class="line">└───────────────────────────────────────────────────────────────────┘</span><br><span class="line">                              │</span><br><span class="line">                              │ Hardware Access</span><br><span class="line">                              ▼</span><br><span class="line">                    ┌──────────────────┐</span><br><span class="line">                    │  CA (NIC)        │</span><br><span class="line">                    └──────────────────┘</span><br><span class="line"></span><br><span class="line">资源使用关系：</span><br><span class="line">─────────────────────────────</span><br><span class="line">QP 1 (PD 1) ──使用──&gt; MR 1, MR 2, AH 1, AH 2</span><br><span class="line">QP 1 (PD 1) ──发送完成事件到──&gt; CQ 1</span><br><span class="line"></span><br><span class="line">QP 2 (PD 1) ──使用──&gt; MR 1, MR 2, AH 1, AH 2</span><br><span class="line">QP 2 (PD 1) ──发送完成事件到──&gt; CQ 1</span><br><span class="line"></span><br><span class="line">QP 3 (PD 2) ──使用──&gt; MR 3, MR 4, AH 3, AH 4</span><br><span class="line">QP 3 (PD 2) ──发送完成事件到──&gt; CQ 1 (共享) 或 CQ 2</span><br><span class="line"></span><br><span class="line">QP 4 (PD 2) ──使用──&gt; MR 3, MR 4, AH 3, AH 4</span><br><span class="line">QP 4 (PD 2) ──发送完成事件到──&gt; CQ 1 (共享) 或 CQ 2</span><br><span class="line"></span><br><span class="line">关键点：CQ 可以被不同 PD 的 QP 共享！</span><br><span class="line"></span><br><span class="line">关键关系说明：</span><br><span class="line">═══════════════════════════════════════════════════════════════════</span><br><span class="line"></span><br><span class="line">1. PD 作为安全边界</span><br><span class="line">   ─────────────────</span><br><span class="line">   • PD 1 和 PD 2 相互隔离，互不干扰</span><br><span class="line">   • PD 直接管理的资源：MR、QP、AH</span><br><span class="line">   • CQ 通过 Context 创建，通过 QP 间接关联到 PD（QP 创建时指定 CQ）</span><br><span class="line">   • 只有属于同一个 PD 的 QP 和 MR 才能相互操作</span><br><span class="line">   • PD 提供了内存和队列的访问控制机制</span><br><span class="line"></span><br><span class="line">2. MR (Memory Region) - 内存区域</span><br><span class="line">   ──────────────────────────────</span><br><span class="line">   • MR 1 和 MR 2 属于 PD 1</span><br><span class="line">   • MR 3 和 MR 4 属于 PD 2</span><br><span class="line">   • 每个 MR 都有唯一的 L_Key（本地密钥）和 R_Key（远程密钥）</span><br><span class="line">   • MR 是 QP 可以访问的内存区域</span><br><span class="line"></span><br><span class="line">3. QP (Queue Pair) - 队列对</span><br><span class="line">   ──────────────────────────</span><br><span class="line">   • QP 1 和 QP 2 属于 PD 1</span><br><span class="line">   • QP 3 和 QP 4 属于 PD 2</span><br><span class="line">   • 每个 QP 包含：</span><br><span class="line">     - SQ (Send Queue): 发送队列，用于发送数据</span><br><span class="line">     - RQ (Receive Queue): 接收队列，用于接收数据</span><br><span class="line">   • QP 只能访问同一 PD 内的 MR</span><br><span class="line"></span><br><span class="line">4. CQ (Completion Queue) - 完成队列</span><br><span class="line">   ──────────────────────────────────</span><br><span class="line">   • CQ 通过 Context 创建（`ibv_create_cq()`），不属于任何 PD</span><br><span class="line">   • CQ 是 Context 级别的资源，可以被不同 PD 的 QP 共享</span><br><span class="line">   • 多个 QP（即使属于不同的 PD）可以关联到同一个 CQ</span><br><span class="line">   • 示例：</span><br><span class="line">     - CQ 1 可以同时接收 PD 1 的 QP 1、QP 2 和 PD 2 的 QP 3、QP 4 的完成事件</span><br><span class="line">     - 这种设计提供了灵活性，允许跨 PD 共享完成队列</span><br><span class="line">   • 注意：虽然图中 CQ 显示在 PD 内，但这是逻辑关联，CQ 本身不属于 PD</span><br><span class="line"></span><br><span class="line">   QP 如何将完成事件发送到 CQ：</span><br><span class="line">   ────────────────────────────────</span><br><span class="line">   1. QP 创建时关联 CQ：</span><br><span class="line">      - 创建 QP 时，在 `ibv_qp_init_attr` 中指定 `send_cq` 和 `recv_cq`</span><br><span class="line">      - 每个 QP 可以有不同的 send_cq 和 recv_cq，也可以使用同一个 CQ</span><br><span class="line">   </span><br><span class="line">   2. WR 标志控制完成事件生成：</span><br><span class="line">      - Send WR：设置 `IBV_SEND_SIGNALED` 标志，完成后在 send_cq 中生成 CQE</span><br><span class="line">      - Receive WR：总是生成完成事件（在 recv_cq 中生成 CQE）</span><br><span class="line">      - 未设置 SIGNALED 的 Send WR 不会生成完成事件</span><br><span class="line">   </span><br><span class="line">   3. 硬件自动生成完成事件：</span><br><span class="line">      - 当 WR 执行完成后，硬件（CA）自动在对应的 CQ 中生成 CQE（Completion Queue Entry）</span><br><span class="line">      - CQE 包含：状态码、操作类型、WR ID、字节数等信息</span><br><span class="line">      - 应用程序通过 `ibv_poll_cq()` 轮询 CQ 获取完成事件</span><br><span class="line">   </span><br><span class="line">   4. 完成事件流程：</span><br><span class="line">      Application → ibv_post_send/recv() → QP (SQ/RQ)</span><br><span class="line">                                                      ↓</span><br><span class="line">                                              WR 执行完成</span><br><span class="line">                                                      ↓</span><br><span class="line">                                             硬件生成 CQE</span><br><span class="line">                                                      ↓</span><br><span class="line">                                             写入到 CQ</span><br><span class="line">                                                      ↓</span><br><span class="line">                                      Application ← ibv_poll_cq()</span><br><span class="line"></span><br><span class="line">5. AH (Address Handle) - 地址句柄</span><br><span class="line">   ────────────────────────────────</span><br><span class="line">   • AH 1 和 AH 2 属于 PD 1</span><br><span class="line">   • AH 3 和 AH 4 属于 PD 2</span><br><span class="line">   • AH 主要用于 UD (Unreliable Datagram) 传输类型</span><br><span class="line">   • UD QP 发送数据时，WR 必须包含 AH 来指定目标地址</span><br><span class="line">   • AH 包含目标 LID、服务级别等路由信息</span><br><span class="line"></span><br><span class="line">6. WR (Work Request) - 工作请求</span><br><span class="line">   ──────────────────────────────</span><br><span class="line">   • WR 提交到 QP 的 SQ 或 RQ</span><br><span class="line">   • WR 包含一个或多个 SGE（Scatter/Gather Elements）</span><br><span class="line">   • SGE 引用 MR，使用 L_Key 验证访问权限</span><br><span class="line">   • UD QP 的 Send WR 必须包含 AH 来指定目标地址</span><br><span class="line"></span><br><span class="line">7. 访问规则</span><br><span class="line">   ─────────</span><br><span class="line">   ✅ 允许：QP 1 → MR 1 (同一 PD)</span><br><span class="line">   ✅ 允许：QP 1 → MR 2 (同一 PD)</span><br><span class="line">   ✅ 允许：QP 2 → MR 1 (同一 PD)</span><br><span class="line">   ✅ 允许：QP 2 → MR 2 (同一 PD)</span><br><span class="line">   ✅ 允许：QP 3 → MR 3 (同一 PD)</span><br><span class="line">   ✅ 允许：QP 3 → MR 4 (同一 PD)</span><br><span class="line">   ✅ 允许：QP 4 → MR 3 (同一 PD)</span><br><span class="line">   ✅ 允许：QP 4 → MR 4 (同一 PD)</span><br><span class="line">   ✅ 允许：QP 1 → CQ 1 (CQ 可以被不同 PD 共享)</span><br><span class="line">   ✅ 允许：QP 2 → CQ 1 (CQ 可以被不同 PD 共享)</span><br><span class="line">   ✅ 允许：QP 3 → CQ 1 (CQ 可以被不同 PD 共享，跨 PD)</span><br><span class="line">   ✅ 允许：QP 3 → CQ 2 (CQ 可以被不同 PD 共享)</span><br><span class="line">   ✅ 允许：QP 4 → CQ 1 (CQ 可以被不同 PD 共享，跨 PD)</span><br><span class="line">   ✅ 允许：QP 4 → CQ 2 (CQ 可以被不同 PD 共享)</span><br><span class="line">   ✅ 允许：QP 1 → AH 1 (同一 PD，UD QP)</span><br><span class="line">   ✅ 允许：QP 1 → AH 2 (同一 PD，UD QP)</span><br><span class="line">   ✅ 允许：QP 2 → AH 1 (同一 PD，UD QP)</span><br><span class="line">   ✅ 允许：QP 2 → AH 2 (同一 PD，UD QP)</span><br><span class="line">   ✅ 允许：QP 3 → AH 3 (同一 PD，UD QP)</span><br><span class="line">   ✅ 允许：QP 3 → AH 4 (同一 PD，UD QP)</span><br><span class="line">   ✅ 允许：QP 4 → AH 3 (同一 PD，UD QP)</span><br><span class="line">   ✅ 允许：QP 4 → AH 4 (同一 PD，UD QP)</span><br><span class="line">   ❌ 禁止：QP 1 → MR 3 (不同 PD)</span><br><span class="line">   ❌ 禁止：QP 1 → MR 4 (不同 PD)</span><br><span class="line">   ❌ 禁止：QP 3 → MR 1 (不同 PD)</span><br><span class="line">   ❌ 禁止：QP 3 → MR 2 (不同 PD)</span><br><span class="line">   ❌ 禁止：QP 1 → AH 3 (不同 PD)</span><br><span class="line">   ❌ 禁止：QP 1 → AH 4 (不同 PD)</span><br><span class="line">   ❌ 禁止：QP 3 → AH 1 (不同 PD)</span><br><span class="line">   ❌ 禁止：QP 3 → AH 2 (不同 PD)</span><br><span class="line"></span><br><span class="line">8. 内存保护机制</span><br><span class="line">   ──────────────</span><br><span class="line">   • L_Key: 用于本地 QP 访问本地 MR</span><br><span class="line">     - QP 1 使用 L_Key 0x01 访问 MR 1</span><br><span class="line">     - QP 1 使用 L_Key 0x02 访问 MR 2</span><br><span class="line">     - SGE 中必须包含正确的 L_Key 才能访问 MR</span><br><span class="line">   </span><br><span class="line">   • R_Key: 用于远程 RDMA 操作</span><br><span class="line">     - 远程 QP 使用 R_Key 0x81 进行 RDMA Write/Read 到 MR 1</span><br><span class="line">     - 远程 QP 使用 R_Key 0x82 进行 RDMA Write/Read 到 MR 2</span><br><span class="line">     - RDMA 操作时，远程端必须提供正确的 R_Key</span><br><span class="line"></span><br><span class="line">9. 资源创建顺序</span><br><span class="line">   ──────────────</span><br><span class="line">   1. 创建 Context (ibv_open_device)</span><br><span class="line">   2. 创建 PD (ibv_alloc_pd)</span><br><span class="line">   3. 注册 MR (ibv_reg_mr) - 需要 PD</span><br><span class="line">   4. 创建 CQ (ibv_create_cq) - 需要 Context</span><br><span class="line">   5. 创建 AH (ibv_create_ah) - 需要 PD（仅 UD QP 需要）</span><br><span class="line">   6. 创建 QP (ibv_create_qp) - 需要 PD 和 CQ</span><br><span class="line">   7. 提交 WR (ibv_post_send/recv) - 需要 QP 和 MR（UD QP 还需要 AH）</span><br><span class="line"></span><br><span class="line">10. 实际应用场景</span><br><span class="line">   ──────────────</span><br><span class="line">   • 多租户隔离：不同应用使用不同 PD，确保安全隔离</span><br><span class="line">   • 资源管理：同一应用的不同模块可以使用不同 PD</span><br><span class="line">   • 权限控制：通过 PD 限制哪些 QP 可以访问哪些 MR</span><br><span class="line">   • 性能优化：合理组织 PD 内的资源，减少跨 PD 访问开销</span><br></pre></td></tr></table></figure>

<h2 id="概念关系图"><a href="#概念关系图" class="headerlink" title="概念关系图"></a>概念关系图</h2><p>以下 Mermaid 图表展示了 InfiniBand 关键概念之间的关系：</p>
<pre class="mermaid">graph TB
    subgraph Hardware["硬件层"]
        CA[CA<br/>Channel Adapter<br/>通道适配器]
        Port[Port<br/>端口]
    end
    
    subgraph Context["上下文层"]
        Context_Obj[Context<br/>上下文]
        PD[PD<br/>Protection Domain<br/>保护域]
    end
    
    subgraph Memory["内存管理"]
        MR[MR<br/>Memory Region<br/>内存区域]
        LKey[L_Key<br/>本地密钥]
        RKey[R_Key<br/>远程密钥]
        Buffer[Buffer<br/>缓冲区]
    end
    
    subgraph Queue["队列层"]
        QP[QP<br/>Queue Pair<br/>队列对]
        SQ[SQ<br/>Send Queue<br/>发送队列]
        RQ[RQ<br/>Receive Queue<br/>接收队列]
        CQ[CQ<br/>Completion Queue<br/>完成队列]
    end
    
    subgraph Operation["操作层"]
        WR[WR<br/>Work Request<br/>工作请求]
        SGE[SGE<br/>Scatter/Gather Elements<br/>分散/聚集元素]
        SendWR[Send WR]
        RecvWR[Receive WR]
        RDMAWriteWR[RDMA Write WR]
        RDMAReadWR[RDMA Read WR]
    end
    
    subgraph Network["网络层"]
        LID[LID<br/>Local Identifier<br/>本地标识符]
        CM[CM<br/>Connection Manager<br/>连接管理器]
    end
    
    %% Hardware relationships
    CA --> Port
    
    %% Context relationships
    CA --> Context_Obj
    Context_Obj --> PD
    
    %% Memory relationships
    PD --> MR
    MR --> LKey
    MR --> RKey
    MR --> Buffer
    
    %% Queue relationships
    PD --> QP
    QP --> SQ
    QP --> RQ
    QP --> CQ
    CQ --> QP
    
    %% Operation relationships
    SQ --> WR
    RQ --> WR
    WR --> SGE
    SGE --> MR
    SGE --> LKey
    WR --> SendWR
    WR --> RecvWR
    WR --> RDMAWriteWR
    WR --> RDMAReadWR
    RDMAWriteWR --> RKey
    RDMAReadWR --> RKey
    
    %% Network relationships
    Port --> LID
    CM --> QP
    
    %% Completion flow
    WR -->|完成通知| CQ
    
    style CA fill:#e1f5ff
    style PD fill:#fff4e1
    style MR fill:#e8f5e9
    style QP fill:#f3e5f5
    style CQ fill:#fce4ec
    style WR fill:#fff9c4</pre>

<h2 id="数据流关系图"><a href="#数据流关系图" class="headerlink" title="数据流关系图"></a>数据流关系图</h2><p>以下图表展示了数据在 InfiniBand 系统中的流动路径：</p>
<pre class="mermaid">sequenceDiagram
    participant App as 应用程序
    participant QP as Queue Pair
    participant SQ as Send Queue
    participant RQ as Receive Queue
    participant CQ as Completion Queue
    participant MR as Memory Region
    participant CA as Channel Adapter
    participant Network as InfiniBand网络
    
    Note over App,Network: 发送数据流程
    App->>MR: 注册内存区域
    App->>SQ: 提交 Send WR (包含 SGE)
    SQ->>CA: 处理工作请求
    CA->>Network: 发送数据包
    Network->>CA: 确认/完成
    CA->>CQ: 生成完成事件
    CQ->>App: 通知应用完成
    
    Note over App,Network: 接收数据流程
    App->>MR: 注册内存区域
    App->>RQ: 提交 Receive WR (包含 SGE)
    Network->>CA: 接收数据包
    CA->>RQ: 匹配 Receive WR
    CA->>MR: 写入数据到内存
    CA->>CQ: 生成完成事件
    CQ->>App: 通知应用完成
    
    Note over App,Network: RDMA Write 流程
    App->>MR: 注册内存区域(获取R_Key)
    App->>SQ: 提交 RDMA Write WR (包含R_Key)
    SQ->>CA: 处理 RDMA Write
    CA->>Network: 发送 RDMA Write 请求
    Network->>CA: 远程CA接收请求
    CA->>MR: 直接写入远程内存(无需CPU参与)
    CA->>CQ: 生成完成事件
    CQ->>App: 通知应用完成</pre>

<h2 id="层次结构图"><a href="#层次结构图" class="headerlink" title="层次结构图"></a>层次结构图</h2><p>以下图表展示了 InfiniBand 编程模型的层次结构：</p>
<pre class="mermaid">graph TD
    subgraph Level1["应用层"]
        App[应用程序]
    end
    
    subgraph Level2["Verbs API层"]
        Verbs[ibVerbs API]
    end
    
    subgraph Level3["资源管理层"]
        PD_Res[PD: 保护域]
        MR_Res[MR: 内存区域]
        QP_Res[QP: 队列对]
        CQ_Res[CQ: 完成队列]
    end
    
    subgraph Level4["操作层"]
        WR_Op[WR: 工作请求]
        SGE_Op[SGE: 分散/聚集元素]
    end
    
    subgraph Level5["硬件层"]
        CA_HW[CA: 通道适配器]
        Port_HW[Port: 端口]
    end
    
    App --> Verbs
    Verbs --> PD_Res
    Verbs --> MR_Res
    Verbs --> QP_Res
    Verbs --> CQ_Res
    QP_Res --> WR_Op
    WR_Op --> SGE_Op
    SGE_Op --> MR_Res
    WR_Op --> CQ_Res
    QP_Res --> CA_HW
    CA_HW --> Port_HW
    
    style Level1 fill:#e3f2fd
    style Level2 fill:#f1f8e9
    style Level3 fill:#fff3e0
    style Level4 fill:#fce4ec
    style Level5 fill:#e0f2f1</pre>

<h2 id="关键概念总结表"><a href="#关键概念总结表" class="headerlink" title="关键概念总结表"></a>关键概念总结表</h2><table>
<thead>
<tr>
<th>概念</th>
<th>英文全称</th>
<th>作用</th>
<th>关联对象</th>
</tr>
</thead>
<tbody><tr>
<td>CA</td>
<td>Channel Adapter</td>
<td>硬件网卡</td>
<td>Port</td>
</tr>
<tr>
<td>PD</td>
<td>Protection Domain</td>
<td>安全边界</td>
<td>QP, MR, AH (CQ通过QP间接关联)</td>
</tr>
<tr>
<td>MR</td>
<td>Memory Region</td>
<td>注册的内存区域</td>
<td>PD, L_Key, R_Key</td>
</tr>
<tr>
<td>QP</td>
<td>Queue Pair</td>
<td>通信端点</td>
<td>PD, SQ, RQ, CQ</td>
</tr>
<tr>
<td>SQ</td>
<td>Send Queue</td>
<td>发送队列</td>
<td>QP</td>
</tr>
<tr>
<td>RQ</td>
<td>Receive Queue</td>
<td>接收队列</td>
<td>QP</td>
</tr>
<tr>
<td>CQ</td>
<td>Completion Queue</td>
<td>完成队列</td>
<td>QP, WR</td>
</tr>
<tr>
<td>AH</td>
<td>Address Handle</td>
<td>地址句柄</td>
<td>PD, UD QP</td>
</tr>
<tr>
<td>WR</td>
<td>Work Request</td>
<td>工作请求</td>
<td>QP, SGE, AH</td>
</tr>
<tr>
<td>SGE</td>
<td>Scatter&#x2F;Gather Elements</td>
<td>内存描述符</td>
<td>MR, L_Key</td>
</tr>
<tr>
<td>L_Key</td>
<td>Local Key</td>
<td>本地访问密钥</td>
<td>MR</td>
</tr>
<tr>
<td>R_Key</td>
<td>Remote Key</td>
<td>远程访问密钥</td>
<td>MR</td>
</tr>
<tr>
<td>LID</td>
<td>Local Identifier</td>
<td>本地标识符</td>
<td>Port</td>
</tr>
<tr>
<td>CM</td>
<td>Connection Manager</td>
<td>连接管理器</td>
<td>QP</td>
</tr>
</tbody></table>
<h2 id="编程流程"><a href="#编程流程" class="headerlink" title="编程流程"></a>编程流程</h2><p>典型的 InfiniBand 编程流程：</p>
<ol>
<li><strong>打开设备</strong>: <code>ibv_open_device()</code> - 获取 Context</li>
<li><strong>分配保护域</strong>: <code>ibv_alloc_pd()</code> - 创建 PD</li>
<li><strong>注册内存</strong>: <code>ibv_reg_mr()</code> - 创建 MR，获得 L_Key 和 R_Key</li>
<li><strong>创建完成队列</strong>: <code>ibv_create_cq()</code> - 创建 CQ</li>
<li><strong>创建地址句柄</strong>: <code>ibv_create_ah()</code> - 创建 AH（仅 UD QP 需要）</li>
<li><strong>创建队列对</strong>: <code>ibv_create_qp()</code> - 创建 QP，关联 CQ</li>
<li><strong>建立连接</strong>: 使用 CM 或手动配置 QP 状态</li>
<li><strong>提交工作请求</strong>: <code>ibv_post_send()</code>, <code>ibv_post_recv()</code> - 提交 WR（UD QP 的 Send WR 需要包含 AH）</li>
<li><strong>轮询完成</strong>: <code>ibv_poll_cq()</code> - 检查完成事件</li>
<li><strong>清理资源</strong>: 销毁 QP, AH, CQ, MR, PD，关闭设备</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://docs.nvidia.com/networking/display/rdmaawareprogrammingv17">RDMA Aware Networks Programming User Manual</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.kernel.org/infiniband/index.html">Linux Kernel InfiniBand Documentation</a></li>
<li><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/ibv_post_send.3.html">ibVerbs Manual Pages</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/12/19/perf/%E5%8A%A8%E6%80%81%E6%8F%92%E6%A1%A9%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/12/19/perf/%E5%8A%A8%E6%80%81%E6%8F%92%E6%A1%A9%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">动态插桩工具</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-12-19 17:13:49" itemprop="dateCreated datePublished" datetime="2025-12-19T17:13:49+00:00">2025-12-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-23 11:34:45" itemprop="dateModified" datetime="2025-12-23T11:34:45+00:00">2025-12-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>动态插桩（Dynamic Instrumentation）是在程序运行时插入监控代码的技术，无需重新编译程序即可进行性能分析和调试。本文介绍 C&#x2F;C++ 程序中常用的动态插桩工具，重点关注函数调用次数和耗时统计（平均、最小、最大、总计），以及是否支持 attach 到正在运行的进程。</p>
<p><strong>重要说明：耗时统计的范围</strong></p>
<p>不同工具在统计函数耗时时的行为存在重要差异：</p>
<ul>
<li><strong>墙上时钟时间（Wall-clock Time）</strong>：包括函数执行期间的所有时间，包括 CPU 执行时间、IO 等待时间、sleep 时间等。这是函数从开始到结束的”真实”耗时。</li>
<li><strong>CPU 时间（CPU Time）</strong>：只包括函数在 CPU 上实际执行的时间，不包括 IO 等待和 sleep 时间。</li>
<li><strong>用户态 CPU 时间（User CPU Time）</strong>：只包括在用户态执行的时间，不包括内核态时间。</li>
</ul>
<p>大多数动态插桩工具默认统计的是<strong>墙上时钟时间</strong>，这意味着如果函数中包含 IO 操作（如文件读写、网络通信）或 sleep，这些时间也会被计入总耗时。这对于理解函数的”真实”执行时间很有帮助，但需要注意区分 CPU 密集型操作和 IO 密集型操作。</p>
<h2 id="动态插桩工具对比"><a href="#动态插桩工具对比" class="headerlink" title="动态插桩工具对比"></a>动态插桩工具对比</h2><table>
<thead>
<tr>
<th>工具</th>
<th>插桩方式</th>
<th>调用次数统计</th>
<th>耗时统计（avg&#x2F;min&#x2F;max&#x2F;total）</th>
<th>耗时范围</th>
<th>Attach 支持</th>
<th>权限要求</th>
<th>开销</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>eBPF&#x2F;BCC</strong></td>
<td>内核级动态插桩</td>
<td>✅</td>
<td>✅</td>
<td>墙上时钟时间</td>
<td>✅</td>
<td>root 或 CAP_BPF</td>
<td>极低</td>
<td>Linux 现代系统分析</td>
</tr>
<tr>
<td><strong>bptrace</strong></td>
<td>内核级动态插桩（eBPF）</td>
<td>✅</td>
<td>✅</td>
<td>墙上时钟时间</td>
<td>✅</td>
<td>root 或 CAP_BPF</td>
<td>极低</td>
<td>Linux 函数级性能分析</td>
</tr>
<tr>
<td><strong>SystemTap</strong></td>
<td>内核级动态插桩</td>
<td>✅</td>
<td>✅</td>
<td>墙上时钟时间</td>
<td>✅</td>
<td>root 或 stapdev&#x2F;stapusr 组</td>
<td>低-中</td>
<td>Linux 系统级分析</td>
</tr>
<tr>
<td><strong>perf + uprobes</strong></td>
<td>内核级动态插桩</td>
<td>✅</td>
<td>✅</td>
<td>墙上时钟时间（可配置）</td>
<td>✅</td>
<td>root 或 <code>perf_event_paranoid</code></td>
<td>低</td>
<td>Linux 系统级分析</td>
</tr>
<tr>
<td><strong>DTrace</strong></td>
<td>内核级动态插桩</td>
<td>✅</td>
<td>✅</td>
<td>墙上时钟时间</td>
<td>✅</td>
<td>root 或特殊权限</td>
<td>低</td>
<td>Solaris&#x2F;FreeBSD&#x2F;macOS</td>
</tr>
<tr>
<td><strong>Intel Pin</strong></td>
<td>二进制插桩</td>
<td>✅</td>
<td>✅</td>
<td>墙上时钟时间</td>
<td>❌</td>
<td>普通用户权限</td>
<td>高</td>
<td>详细分析，需要启动时插桩</td>
</tr>
<tr>
<td><strong>DynamoRIO</strong></td>
<td>二进制插桩</td>
<td>✅</td>
<td>✅</td>
<td>墙上时钟时间</td>
<td>❌</td>
<td>普通用户权限</td>
<td>高</td>
<td>跨平台分析，需要启动时插桩</td>
</tr>
<tr>
<td><strong>Valgrind Callgrind</strong></td>
<td>二进制插桩</td>
<td>✅</td>
<td>✅</td>
<td>CPU 时间（不包括IO&#x2F;sleep）</td>
<td>❌</td>
<td>普通用户权限</td>
<td>极高</td>
<td>详细调用图分析</td>
</tr>
<tr>
<td><strong>LD_PRELOAD</strong></td>
<td>库函数拦截</td>
<td>✅</td>
<td>✅</td>
<td>墙上时钟时间</td>
<td>❌</td>
<td>普通用户权限</td>
<td>低</td>
<td>简单场景，库函数级别</td>
</tr>
<tr>
<td><strong>ltrace</strong></td>
<td>库函数跟踪</td>
<td>✅</td>
<td>部分</td>
<td>墙上时钟时间</td>
<td>✅</td>
<td>普通用户权限（attach 需 ptrace）</td>
<td>低</td>
<td>库函数调用跟踪</td>
</tr>
</tbody></table>
<h2 id="详细工具介绍"><a href="#详细工具介绍" class="headerlink" title="详细工具介绍"></a>详细工具介绍</h2><h3 id="1-eBPF-BCC"><a href="#1-eBPF-BCC" class="headerlink" title="1. eBPF&#x2F;BCC"></a>1. eBPF&#x2F;BCC</h3><p><strong>简介</strong>：基于 eBPF（Extended Berkeley Packet Filter）的现代动态跟踪工具集，BCC 提供了高级封装。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>✅ 支持 attach 到正在运行的进程</li>
<li>✅ 极低开销，内核验证保证安全</li>
<li>✅ 可以统计函数调用次数和耗时（min&#x2F;max&#x2F;avg&#x2F;total）</li>
<li>✅ 丰富的工具集（funccount, funclatency, trace 等）</li>
<li>⏱️ <strong>耗时统计范围</strong>：统计墙上时钟时间（包括 IO、sleep 等所有时间）</li>
</ul>
<p><strong>权限要求</strong>：</p>
<ul>
<li><strong>root 权限</strong>：拥有所有 eBPF&#x2F;BCC 功能</li>
<li><strong>非 root 用户</strong>：需要 <code>CAP_BPF</code> 能力（Linux 5.8+）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 授予用户 CAP_BPF 能力</span></span><br><span class="line">sudo <span class="built_in">setcap</span> cap_bpf+ep /usr/bin/python3</span><br><span class="line"><span class="comment"># 或授予特定 BCC 工具</span></span><br><span class="line">sudo <span class="built_in">setcap</span> cap_bpf+ep /usr/share/bcc/tools/funccount</span><br></pre></td></tr></table></figure></li>
<li><strong>attach 到其他用户的进程</strong>：需要 root 权限或 <code>CAP_SYS_PTRACE</code> 能力</li>
<li><strong>加载 eBPF 程序</strong>：需要 root 权限或 <code>CAP_BPF</code> 能力（Linux 5.8+）</li>
<li><strong>读取内核符号</strong>：需要 root 权限或 <code>CAP_SYS_ADMIN</code> 能力</li>
</ul>
<p><strong>限制</strong>：</p>
<ul>
<li>需要 Linux 4.1+ 内核（eBPF 支持）</li>
</ul>
<p><strong>使用示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># funclatency - 统计函数耗时分布</span></span><br><span class="line">funclatency -p &lt;pid&gt; <span class="string">&#x27;target_function&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># funccount - 统计函数调用次数</span></span><br><span class="line">funccount -p &lt;pid&gt; <span class="string">&#x27;target_function&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义 BCC 脚本统计详细指标</span></span><br><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line">bpf_text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">BPF_HASH(start, u32);</span></span><br><span class="line"><span class="string">BPF_HASH(count, u32);</span></span><br><span class="line"><span class="string">BPF_HASH(total_time, u64);</span></span><br><span class="line"><span class="string">BPF_HASH(min_time, u64);</span></span><br><span class="line"><span class="string">BPF_HASH(max_time, u64);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int trace_entry(struct pt_regs *ctx) &#123;</span></span><br><span class="line"><span class="string">    u32 pid = bpf_get_current_pid_tgid();</span></span><br><span class="line"><span class="string">    u64 ts = bpf_ktime_get_ns();</span></span><br><span class="line"><span class="string">    start.update(&amp;pid, &amp;ts);</span></span><br><span class="line"><span class="string">    u64 zero = 0;</span></span><br><span class="line"><span class="string">    count.update(&amp;pid, &amp;zero);</span></span><br><span class="line"><span class="string">    u64 *val = count.lookup(&amp;pid);</span></span><br><span class="line"><span class="string">    if (val) &#123;</span></span><br><span class="line"><span class="string">        (*val)++;</span></span><br><span class="line"><span class="string">        count.update(&amp;pid, val);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int trace_return(struct pt_regs *ctx) &#123;</span></span><br><span class="line"><span class="string">    u32 pid = bpf_get_current_pid_tgid();</span></span><br><span class="line"><span class="string">    u64 *tsp = start.lookup(&amp;pid);</span></span><br><span class="line"><span class="string">    if (tsp == 0) &#123;</span></span><br><span class="line"><span class="string">        return 0;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    u64 delta = bpf_ktime_get_ns() - *tsp;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    // 更新统计信息</span></span><br><span class="line"><span class="string">    u64 *total = total_time.lookup(&amp;pid);</span></span><br><span class="line"><span class="string">    u64 *min = min_time.lookup(&amp;pid);</span></span><br><span class="line"><span class="string">    u64 *max = max_time.lookup(&amp;pid);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    if (total) &#123;</span></span><br><span class="line"><span class="string">        *total += delta;</span></span><br><span class="line"><span class="string">    &#125; else &#123;</span></span><br><span class="line"><span class="string">        total_time.update(&amp;pid, &amp;delta);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    if (!min || delta &lt; *min) &#123;</span></span><br><span class="line"><span class="string">        min_time.update(&amp;pid, &amp;delta);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    if (!max || delta &gt; *max) &#123;</span></span><br><span class="line"><span class="string">        max_time.update(&amp;pid, &amp;delta);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    start.delete(&amp;pid);</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># attach 到进程</span></span><br><span class="line">b = BPF(text=bpf_text)</span><br><span class="line">b.attach_uprobe(name=<span class="string">&quot;target_program&quot;</span>, sym=<span class="string">&quot;target_function&quot;</span>, fn_name=<span class="string">&quot;trace_entry&quot;</span>)</span><br><span class="line">b.attach_uretprobe(name=<span class="string">&quot;target_program&quot;</span>, sym=<span class="string">&quot;target_function&quot;</span>, fn_name=<span class="string">&quot;trace_return&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-bptrace"><a href="#2-bptrace" class="headerlink" title="2. bptrace"></a>2. bptrace</h3><p><strong>简介</strong>：基于 eBPF 的轻量级动态追踪工具，专门用于监控和分析正在运行的 C&#x2F;C++ 程序。bptrace 提供了简洁的命令行接口，可以方便地统计函数调用次数和执行时间。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>✅ 支持 attach 到正在运行的进程</li>
<li>✅ 可以统计函数调用次数和耗时（min&#x2F;max&#x2F;avg&#x2F;total）</li>
<li>✅ 极低开销，基于 eBPF 技术</li>
<li>✅ 简洁的命令行接口，易于使用</li>
<li>✅ 无需修改程序源码或重新编译</li>
<li>⏱️ <strong>耗时统计范围</strong>：统计墙上时钟时间（包括 IO、sleep 等所有时间）</li>
</ul>
<p><strong>权限要求</strong>：</p>
<ul>
<li><strong>root 权限</strong>：拥有所有 bptrace 功能</li>
<li><strong>非 root 用户</strong>：需要 <code>CAP_BPF</code> 能力（Linux 5.8+）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 授予用户 CAP_BPF 能力</span></span><br><span class="line">sudo <span class="built_in">setcap</span> cap_bpf+ep /usr/bin/bptrace</span><br></pre></td></tr></table></figure></li>
<li><strong>attach 到其他用户的进程</strong>：需要 root 权限或 <code>CAP_SYS_PTRACE</code> 能力</li>
<li><strong>加载 eBPF 程序</strong>：需要 root 权限或 <code>CAP_BPF</code> 能力（Linux 5.8+）</li>
</ul>
<p><strong>限制</strong>：</p>
<ul>
<li>需要 Linux 内核支持 eBPF（通常 4.1+）</li>
<li>Linux 5.8+ 才支持非 root 用户使用 CAP_BPF</li>
<li>主要适用于用户态函数追踪</li>
<li>需要目标程序包含调试符号信息（或使用地址）</li>
</ul>
<p><strong>使用示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计函数调用次数</span></span><br><span class="line">bptrace -p &lt;pid&gt; -f <span class="string">&#x27;target_function&#x27;</span> -c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计函数耗时（包括平均、最小、最大、总耗时）</span></span><br><span class="line">bptrace -p &lt;pid&gt; -f <span class="string">&#x27;target_function&#x27;</span> -t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时统计调用次数和耗时</span></span><br><span class="line">bptrace -p &lt;pid&gt; -f <span class="string">&#x27;target_function&#x27;</span> -c -t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计多个函数</span></span><br><span class="line">bptrace -p &lt;pid&gt; -f <span class="string">&#x27;function1,function2&#x27;</span> -c -t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定输出格式</span></span><br><span class="line">bptrace -p &lt;pid&gt; -f <span class="string">&#x27;target_function&#x27;</span> -t --format json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 持续监控并定期输出统计信息</span></span><br><span class="line">bptrace -p &lt;pid&gt; -f <span class="string">&#x27;target_function&#x27;</span> -t --interval 5</span><br></pre></td></tr></table></figure>

<p><strong>输出示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Function: target_function</span><br><span class="line">  Call Count: 1000</span><br><span class="line">  Total Time: 50000 us</span><br><span class="line">  Average Time: 50 us</span><br><span class="line">  Min Time: 10 us</span><br><span class="line">  Max Time: 200 us</span><br></pre></td></tr></table></figure>

<p><strong>与 eBPF&#x2F;BCC 的关系</strong>：</p>
<ul>
<li>bptrace 可以看作是 BCC 工具集的简化版本，专门针对函数级性能分析</li>
<li>相比 BCC，bptrace 提供了更简洁的命令行接口，适合快速分析</li>
<li>如果需要更复杂的自定义逻辑，仍需要使用 BCC 编写 Python&#x2F;C 脚本</li>
</ul>
<h3 id="3-SystemTap"><a href="#3-SystemTap" class="headerlink" title="3. SystemTap"></a>3. SystemTap</h3><p><strong>简介</strong>：Linux 系统级动态跟踪工具，功能强大，支持用户态和内核态插桩。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>✅ 支持 attach 到正在运行的进程</li>
<li>✅ 可以精确统计函数调用次数和耗时（包括 min&#x2F;max&#x2F;avg&#x2F;total）</li>
<li>✅ 灵活的脚本语言，可以自定义统计逻辑</li>
<li>✅ 低开销（取决于脚本复杂度）</li>
<li>⏱️ <strong>耗时统计范围</strong>：统计墙上时钟时间（包括 IO、sleep 等所有时间）</li>
</ul>
<p><strong>权限要求</strong>：</p>
<ul>
<li><strong>root 权限</strong>：拥有所有 SystemTap 功能</li>
<li><strong>非 root 用户</strong>：需要加入特定组：<ul>
<li><code>stapdev</code> 组：可以加载任意 SystemTap 模块（需要 root 权限添加）</li>
<li><code>stapusr</code> 组：只能使用预编译的 SystemTap 模块（更安全）</li>
</ul>
</li>
<li><strong>attach 到其他用户的进程</strong>：需要 root 权限或 <code>CAP_SYS_PTRACE</code> 能力</li>
<li><strong>内核模块加载</strong>：需要 root 权限或 <code>CAP_SYS_MODULE</code> 能力</li>
</ul>
<p><strong>限制</strong>：</p>
<ul>
<li>需要安装 kernel-devel 包（用于编译 SystemTap 模块）</li>
</ul>
<p><strong>使用示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 统计函数调用次数和耗时</span><br><span class="line">probe process(&quot;/path/to/program&quot;).function(&quot;target_function&quot;) &#123;</span><br><span class="line">    start_time = gettimeofday_us()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe process(&quot;/path/to/program&quot;).function(&quot;target_function&quot;).return &#123;</span><br><span class="line">    call_count++</span><br><span class="line">    elapsed = gettimeofday_us() - start_time</span><br><span class="line">    total_time += elapsed</span><br><span class="line">    if (elapsed &lt; min_time || min_time == 0) min_time = elapsed</span><br><span class="line">    if (elapsed &gt; max_time) max_time = elapsed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe end &#123;</span><br><span class="line">    printf(&quot;调用次数: %d\n&quot;, call_count)</span><br><span class="line">    printf(&quot;总耗时: %d us\n&quot;, total_time)</span><br><span class="line">    printf(&quot;平均耗时: %d us\n&quot;, total_time / call_count)</span><br><span class="line">    printf(&quot;最小耗时: %d us\n&quot;, min_time)</span><br><span class="line">    printf(&quot;最大耗时: %d us\n&quot;, max_time)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># attach 到运行中的进程</span><br><span class="line">stap -x &lt;pid&gt; script.stp</span><br></pre></td></tr></table></figure>

<h3 id="4-perf-uprobes"><a href="#4-perf-uprobes" class="headerlink" title="4. perf + uprobes"></a>4. perf + uprobes</h3><p><strong>简介</strong>：Linux 内核自带的性能分析工具，通过 uprobes 机制实现用户态动态插桩。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>✅ 支持 attach 到正在运行的进程</li>
<li>✅ 低开销，基于采样和事件计数</li>
<li>✅ 可以统计函数调用次数和耗时</li>
<li>✅ 无需修改程序源码或重新编译</li>
<li>⏱️ <strong>耗时统计范围</strong>：默认统计墙上时钟时间（包括 IO、sleep 等），也可配置为统计 CPU 时间</li>
</ul>
<p><strong>权限要求</strong>：</p>
<ul>
<li><strong>root 权限</strong>：最直接的方式，拥有所有 perf 功能</li>
<li><strong>非 root 用户</strong>：需要设置 <code>/proc/sys/kernel/perf_event_paranoid</code>：<ul>
<li><code>-1</code>：允许所有用户使用 perf（不推荐，安全风险）</li>
<li><code>0</code>：允许用户分析自己的进程</li>
<li><code>1</code>：允许用户分析自己的进程和内核（默认值）</li>
<li><code>2</code>：只允许 root 使用 perf</li>
</ul>
</li>
<li><strong>attach 到其他用户的进程</strong>：需要 root 权限或 <code>CAP_SYS_PTRACE</code> 能力</li>
<li><strong>查看内核符号</strong>：需要 root 权限或设置 <code>perf_event_paranoid &lt;= 1</code></li>
</ul>
<p><strong>限制</strong>：</p>
<ul>
<li>统计详细耗时需要额外脚本处理</li>
</ul>
<p><strong>使用示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计函数调用次数</span></span><br><span class="line">perf probe -x ./program function_name</span><br><span class="line">perf record -e probe_program:function_name ./program</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计函数耗时（需要自定义脚本或结合其他工具）</span></span><br><span class="line">perf record -g -p &lt;pid&gt;  <span class="comment"># attach 到运行中的进程</span></span><br><span class="line">perf report</span><br></pre></td></tr></table></figure>

<h3 id="5-DTrace"><a href="#5-DTrace" class="headerlink" title="5. DTrace"></a>5. DTrace</h3><p><strong>简介</strong>：Sun Microsystems 开发的动态跟踪框架，现支持 Solaris、FreeBSD、macOS。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>✅ 支持 attach 到正在运行的进程</li>
<li>✅ 可以统计函数调用次数和耗时（min&#x2F;max&#x2F;avg&#x2F;total）</li>
<li>✅ 低开销，功能强大</li>
<li>✅ 支持聚合统计（aggregations）</li>
<li>⏱️ <strong>耗时统计范围</strong>：统计墙上时钟时间（包括 IO、sleep 等所有时间）</li>
</ul>
<p><strong>权限要求</strong>：</p>
<ul>
<li><strong>macOS</strong>：<ul>
<li>需要关闭 SIP（System Integrity Protection）或使用特殊权限</li>
<li>或者使用 <code>sudo</code> 运行（需要管理员权限）</li>
</ul>
</li>
<li><strong>Solaris&#x2F;FreeBSD</strong>：<ul>
<li>需要 root 权限或 <code>dtrace_kernel</code> 权限</li>
</ul>
</li>
<li><strong>Linux</strong>：<ul>
<li>支持有限（需要 Oracle Linux 或通过 SystemTap）</li>
<li>通常需要 root 权限</li>
</ul>
</li>
</ul>
<p><strong>限制</strong>：</p>
<ul>
<li>Linux 上支持有限（需要 Oracle Linux 或通过 SystemTap）</li>
</ul>
<p><strong>使用示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/sbin/dtrace -s</span><br><span class="line"></span><br><span class="line">pid$target:target:function_name:entry</span><br><span class="line">&#123;</span><br><span class="line">    self-&gt;start = timestamp;</span><br><span class="line">    @count[probefunc] = count();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pid$target:target:function_name:return</span><br><span class="line">/self-&gt;start/</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;elapsed = timestamp - self-&gt;start;</span><br><span class="line">    @time[&quot;total&quot;] = sum(this-&gt;elapsed);</span><br><span class="line">    @time[&quot;avg&quot;] = avg(this-&gt;elapsed);</span><br><span class="line">    @time[&quot;min&quot;] = min(this-&gt;elapsed);</span><br><span class="line">    @time[&quot;max&quot;] = max(this-&gt;elapsed);</span><br><span class="line">    self-&gt;start = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">END</span><br><span class="line">&#123;</span><br><span class="line">    printa(&quot;调用次数: %@d\n&quot;, @count);</span><br><span class="line">    printa(&quot;总耗时: %@d ns\n&quot;, @time[&quot;total&quot;]);</span><br><span class="line">    printa(&quot;平均耗时: %@d ns\n&quot;, @time[&quot;avg&quot;]);</span><br><span class="line">    printa(&quot;最小耗时: %@d ns\n&quot;, @time[&quot;min&quot;]);</span><br><span class="line">    printa(&quot;最大耗时: %@d ns\n&quot;, @time[&quot;max&quot;]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 使用方式</span><br><span class="line">dtrace -s script.d -p &lt;pid&gt;</span><br></pre></td></tr></table></figure>


<p><strong>简介</strong>：基于 eBPF 的轻量级动态追踪工具，专门用于监控和分析正在运行的 C&#x2F;C++ 程序。bptrace 提供了简洁的命令行接口，可以方便地统计函数调用次数和执行时间。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>✅ 支持 attach 到正在运行的进程</li>
<li>✅ 可以统计函数调用次数和耗时（min&#x2F;max&#x2F;avg&#x2F;total）</li>
<li>✅ 极低开销，基于 eBPF 技术</li>
<li>✅ 简洁的命令行接口，易于使用</li>
<li>✅ 无需修改程序源码或重新编译</li>
<li>⏱️ <strong>耗时统计范围</strong>：统计墙上时钟时间（包括 IO、sleep 等所有时间）</li>
</ul>
<p><strong>权限要求</strong>：</p>
<ul>
<li><strong>root 权限</strong>：拥有所有 bptrace 功能</li>
<li><strong>非 root 用户</strong>：需要 <code>CAP_BPF</code> 能力（Linux 5.8+）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 授予用户 CAP_BPF 能力</span></span><br><span class="line">sudo <span class="built_in">setcap</span> cap_bpf+ep /usr/bin/bptrace</span><br></pre></td></tr></table></figure></li>
<li><strong>attach 到其他用户的进程</strong>：需要 root 权限或 <code>CAP_SYS_PTRACE</code> 能力</li>
<li><strong>加载 eBPF 程序</strong>：需要 root 权限或 <code>CAP_BPF</code> 能力（Linux 5.8+）</li>
</ul>
<p><strong>限制</strong>：</p>
<ul>
<li>需要 Linux 内核支持 eBPF（通常 4.1+）</li>
<li>Linux 5.8+ 才支持非 root 用户使用 CAP_BPF</li>
<li>主要适用于用户态函数追踪</li>
<li>需要目标程序包含调试符号信息（或使用地址）</li>
</ul>
<p><strong>使用示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计函数调用次数</span></span><br><span class="line">bptrace -p &lt;pid&gt; -f <span class="string">&#x27;target_function&#x27;</span> -c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计函数耗时（包括平均、最小、最大、总耗时）</span></span><br><span class="line">bptrace -p &lt;pid&gt; -f <span class="string">&#x27;target_function&#x27;</span> -t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时统计调用次数和耗时</span></span><br><span class="line">bptrace -p &lt;pid&gt; -f <span class="string">&#x27;target_function&#x27;</span> -c -t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计多个函数</span></span><br><span class="line">bptrace -p &lt;pid&gt; -f <span class="string">&#x27;function1,function2&#x27;</span> -c -t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定输出格式</span></span><br><span class="line">bptrace -p &lt;pid&gt; -f <span class="string">&#x27;target_function&#x27;</span> -t --format json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 持续监控并定期输出统计信息</span></span><br><span class="line">bptrace -p &lt;pid&gt; -f <span class="string">&#x27;target_function&#x27;</span> -t --interval 5</span><br></pre></td></tr></table></figure>

<p><strong>输出示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Function: target_function</span><br><span class="line">  Call Count: 1000</span><br><span class="line">  Total Time: 50000 us</span><br><span class="line">  Average Time: 50 us</span><br><span class="line">  Min Time: 10 us</span><br><span class="line">  Max Time: 200 us</span><br></pre></td></tr></table></figure>

<p><strong>与 eBPF&#x2F;BCC 的关系</strong>：</p>
<ul>
<li>bptrace 可以看作是 BCC 工具集的简化版本，专门针对函数级性能分析</li>
<li>相比 BCC，bptrace 提供了更简洁的命令行接口，适合快速分析</li>
<li>如果需要更复杂的自定义逻辑，仍需要使用 BCC 编写 Python&#x2F;C 脚本</li>
</ul>
<h3 id="6-Intel-Pin"><a href="#6-Intel-Pin" class="headerlink" title="6. Intel Pin"></a>6. Intel Pin</h3><p><strong>简介</strong>：Intel 开发的动态二进制插桩框架，功能强大但开销较高。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>❌ <strong>不支持 attach</strong>，必须在程序启动时插桩</li>
<li>✅ 可以统计函数调用次数和耗时（min&#x2F;max&#x2F;avg&#x2F;total）</li>
<li>✅ 支持细粒度插桩（指令级）</li>
<li>⚠️ 高开销（通常 10-100 倍）</li>
<li>⏱️ <strong>耗时统计范围</strong>：统计墙上时钟时间（包括 IO、sleep 等所有时间）</li>
</ul>
<p><strong>权限要求</strong>：</p>
<ul>
<li><strong>普通用户权限</strong>：Intel Pin 不需要特殊权限，普通用户即可使用</li>
<li><strong>读取目标程序</strong>：需要目标程序的读取权限</li>
<li><strong>写入输出文件</strong>：需要输出目录的写入权限</li>
</ul>
<p><strong>限制</strong>：</p>
<ul>
<li>不支持 attach 到运行中的进程</li>
<li>高开销，不适合生产环境</li>
<li>主要适用于详细分析和研究</li>
</ul>
<p><strong>使用示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 Pin 工具统计函数调用</span></span><br><span class="line">pin -t <span class="built_in">source</span>/tools/ManualExamples/obj-intel64/inscount0.so -- ./program</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义 Pin 工具统计函数耗时</span></span><br><span class="line"><span class="comment"># 需要编写 Pin 工具（C++）</span></span><br></pre></td></tr></table></figure>

<h3 id="7-DynamoRIO"><a href="#7-DynamoRIO" class="headerlink" title="7. DynamoRIO"></a>7. DynamoRIO</h3><p><strong>简介</strong>：跨平台的动态二进制插桩框架，支持 Windows、Linux、macOS。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>❌ <strong>不支持 attach</strong>，必须在程序启动时插桩</li>
<li>✅ 可以统计函数调用次数和耗时（min&#x2F;max&#x2F;avg&#x2F;total）</li>
<li>✅ 跨平台支持</li>
<li>⚠️ 高开销</li>
<li>⏱️ <strong>耗时统计范围</strong>：统计墙上时钟时间（包括 IO、sleep 等所有时间）</li>
</ul>
<p><strong>权限要求</strong>：</p>
<ul>
<li><strong>普通用户权限</strong>：DynamoRIO 不需要特殊权限，普通用户即可使用</li>
<li><strong>读取目标程序</strong>：需要目标程序的读取权限</li>
<li><strong>写入输出文件</strong>：需要输出目录的写入权限</li>
<li><strong>Windows</strong>：可能需要管理员权限（取决于目标程序）</li>
</ul>
<p><strong>限制</strong>：</p>
<ul>
<li>不支持 attach 到运行中的进程</li>
<li>高开销</li>
<li>需要编写客户端工具</li>
</ul>
<p><strong>使用示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 DynamoRIO 工具</span></span><br><span class="line">drrun -tool calltrace -- ./program</span><br><span class="line">drrun -tool memtrace -- ./program</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义工具统计函数耗时</span></span><br><span class="line"><span class="comment"># 需要编写 DynamoRIO 客户端（C++）</span></span><br></pre></td></tr></table></figure>

<h3 id="8-Valgrind-Callgrind"><a href="#8-Valgrind-Callgrind" class="headerlink" title="8. Valgrind Callgrind"></a>8. Valgrind Callgrind</h3><p><strong>简介</strong>：Valgrind 工具集中的调用图分析工具。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>❌ <strong>不支持 attach</strong>，必须在程序启动时插桩</li>
<li>✅ 可以统计函数调用次数和耗时</li>
<li>✅ 生成详细的调用图</li>
<li>⚠️ 极高开销（通常 20-100 倍）</li>
<li>⏱️ <strong>耗时统计范围</strong>：统计 CPU 时间（<strong>不包括</strong> IO 等待和 sleep 时间），只统计函数在 CPU 上实际执行的时间</li>
</ul>
<p><strong>权限要求</strong>：</p>
<ul>
<li><strong>普通用户权限</strong>：Valgrind 不需要特殊权限，普通用户即可使用</li>
<li><strong>读取目标程序</strong>：需要目标程序的读取权限</li>
<li><strong>写入输出文件</strong>：需要输出目录的写入权限</li>
<li><strong>内存访问</strong>：Valgrind 需要访问进程内存，但不需要 root 权限</li>
</ul>
<p><strong>限制</strong>：</p>
<ul>
<li>不支持 attach</li>
<li>极高开销，不适合生产环境</li>
<li>主要用于开发阶段的详细分析</li>
</ul>
<p><strong>使用示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 Callgrind 分析</span></span><br><span class="line">valgrind --tool=callgrind ./program</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看结果</span></span><br><span class="line">callgrind_annotate callgrind.out.&lt;pid&gt;</span><br><span class="line">kcachegrind callgrind.out.&lt;pid&gt;  <span class="comment"># GUI 工具</span></span><br></pre></td></tr></table></figure>

<h3 id="9-LD-PRELOAD-自定义库"><a href="#9-LD-PRELOAD-自定义库" class="headerlink" title="9. LD_PRELOAD + 自定义库"></a>9. LD_PRELOAD + 自定义库</h3><p><strong>简介</strong>：通过 LD_PRELOAD 机制拦截库函数调用，实现简单的动态插桩。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>❌ <strong>不支持 attach</strong>，需要在启动时设置环境变量</li>
<li>✅ 可以统计库函数调用次数和耗时</li>
<li>✅ 低开销</li>
<li>⚠️ 只能拦截库函数，不能拦截静态函数</li>
<li>⏱️ <strong>耗时统计范围</strong>：统计墙上时钟时间（包括 IO、sleep 等所有时间），取决于使用的计时函数（如 <code>gettimeofday()</code>）</li>
</ul>
<p><strong>权限要求</strong>：</p>
<ul>
<li><strong>普通用户权限</strong>：LD_PRELOAD 不需要特殊权限，普通用户即可使用</li>
<li><strong>读取目标程序</strong>：需要目标程序的读取权限</li>
<li><strong>加载共享库</strong>：需要共享库的读取权限</li>
<li><strong>设置环境变量</strong>：需要设置 <code>LD_PRELOAD</code> 环境变量的权限（通常都有）</li>
</ul>
<p><strong>限制</strong>：</p>
<ul>
<li>不支持 attach</li>
<li>只能拦截库函数，不能拦截静态函数或内联函数</li>
<li>需要手动编写包装代码</li>
</ul>
<p><strong>使用示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wrapper.c - 包装库函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> call_count = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> total_time = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> min_time = ULONG_MAX;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> max_time = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __attribute__((constructor)) init() &#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __attribute__((destructor)) fini() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用次数: %lu\n&quot;</span>, call_count);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;总耗时: %lu us\n&quot;</span>, total_time);</span><br><span class="line">    <span class="keyword">if</span> (call_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;平均耗时: %lu us\n&quot;</span>, total_time / call_count);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最小耗时: %lu us\n&quot;</span>, min_time);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最大耗时: %lu us\n&quot;</span>, max_time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装目标函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">target_function</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">    gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用原始函数</span></span><br><span class="line">    <span class="type">int</span> (*original_func)(<span class="type">int</span>) = dlsym(RTLD_NEXT, <span class="string">&quot;target_function&quot;</span>);</span><br><span class="line">    <span class="type">int</span> result = original_func(arg);</span><br><span class="line">    </span><br><span class="line">    gettimeofday(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> elapsed = (end.tv_sec - start.tv_sec) * <span class="number">1000000</span> + </span><br><span class="line">                           (end.tv_usec - start.tv_usec);</span><br><span class="line">    </span><br><span class="line">    call_count++;</span><br><span class="line">    total_time += elapsed;</span><br><span class="line">    <span class="keyword">if</span> (elapsed &lt; min_time) min_time = elapsed;</span><br><span class="line">    <span class="keyword">if</span> (elapsed &gt; max_time) max_time = elapsed;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译包装库</span></span><br><span class="line">gcc -shared -fPIC -o wrapper.so wrapper.c -ldl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">LD_PRELOAD=./wrapper.so ./program</span><br></pre></td></tr></table></figure>

<h3 id="10-ltrace"><a href="#10-ltrace" class="headerlink" title="10. ltrace"></a>10. ltrace</h3><p><strong>简介</strong>：Linux 库函数调用跟踪工具。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>✅ 支持 attach 到正在运行的进程</li>
<li>✅ 可以统计库函数调用次数</li>
<li>⚠️ 只能统计库函数，不能统计自定义函数</li>
<li>⚠️ 耗时统计功能有限</li>
<li>⏱️ <strong>耗时统计范围</strong>：统计墙上时钟时间（包括 IO、sleep 等所有时间），但功能有限</li>
</ul>
<p><strong>权限要求</strong>：</p>
<ul>
<li><strong>跟踪自己的进程</strong>：普通用户权限即可</li>
<li><strong>attach 到其他用户的进程</strong>：需要 root 权限或 <code>CAP_SYS_PTRACE</code> 能力</li>
<li><strong>读取目标程序</strong>：需要目标程序的读取权限</li>
<li><strong>ptrace 系统调用</strong>：attach 功能依赖 ptrace，受 <code>/proc/sys/kernel/yama/ptrace_scope</code> 限制：<ul>
<li><code>0</code>：允许同一用户调试其权限范围内的任意进程</li>
<li><code>1</code>：只允许调试直接子进程（默认值）</li>
<li><code>2</code>：只有 root 或具备 <code>CAP_SYS_PTRACE</code> 的进程可以使用 ptrace</li>
<li><code>3</code>：完全禁用 ptrace</li>
</ul>
</li>
</ul>
<p><strong>限制</strong>：</p>
<ul>
<li>只能跟踪库函数</li>
<li>耗时统计功能有限</li>
<li>不适合统计自定义函数</li>
</ul>
<p><strong>使用示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 跟踪库函数调用</span></span><br><span class="line">ltrace -p &lt;pid&gt; -c  <span class="comment"># 统计调用次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 跟踪特定函数</span></span><br><span class="line">ltrace -p &lt;pid&gt; -e <span class="string">&#x27;malloc+free&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="耗时统计范围详解"><a href="#耗时统计范围详解" class="headerlink" title="耗时统计范围详解"></a>耗时统计范围详解</h2><h3 id="墙上时钟时间-vs-CPU-时间"><a href="#墙上时钟时间-vs-CPU-时间" class="headerlink" title="墙上时钟时间 vs CPU 时间"></a>墙上时钟时间 vs CPU 时间</h3><p>理解不同工具统计的耗时范围对于正确解读性能数据至关重要：</p>
<h4 id="1-墙上时钟时间（Wall-clock-Time）"><a href="#1-墙上时钟时间（Wall-clock-Time）" class="headerlink" title="1. 墙上时钟时间（Wall-clock Time）"></a>1. 墙上时钟时间（Wall-clock Time）</h4><p><strong>包括的内容</strong>：</p>
<ul>
<li>✅ CPU 执行时间</li>
<li>✅ IO 等待时间（文件读写、网络通信等）</li>
<li>✅ sleep 时间（<code>sleep()</code>, <code>usleep()</code>, <code>nanosleep()</code> 等）</li>
<li>✅ 线程阻塞时间（等待锁、条件变量等）</li>
<li>✅ 上下文切换时间</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>了解函数的”真实”执行时间</li>
<li>分析 IO 密集型函数的性能</li>
<li>诊断包含阻塞操作的函数</li>
<li>评估用户体验相关的性能指标</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">slow_function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// CPU 执行：1ms</span></span><br><span class="line">    do_computation();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// IO 等待：100ms</span></span><br><span class="line">    read_from_disk();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sleep：50ms</span></span><br><span class="line">    sleep(<span class="number">0.05</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 总墙上时钟时间：~151ms</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用墙上时钟时间的工具</strong>：</p>
<ul>
<li>SystemTap、DTrace、eBPF&#x2F;BCC、bptrace</li>
<li>Intel Pin、DynamoRIO</li>
<li>LD_PRELOAD（使用 <code>gettimeofday()</code> 等）</li>
<li>perf（默认配置）</li>
</ul>
<h4 id="2-CPU-时间（CPU-Time）"><a href="#2-CPU-时间（CPU-Time）" class="headerlink" title="2. CPU 时间（CPU Time）"></a>2. CPU 时间（CPU Time）</h4><p><strong>包括的内容</strong>：</p>
<ul>
<li>✅ CPU 执行时间</li>
<li>❌ <strong>不包括</strong> IO 等待时间</li>
<li>❌ <strong>不包括</strong> sleep 时间</li>
<li>❌ <strong>不包括</strong> 线程阻塞时间</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>分析 CPU 密集型函数的性能</li>
<li>评估算法的计算复杂度</li>
<li>识别 CPU 热点</li>
<li>优化计算逻辑</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">slow_function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// CPU 执行：1ms（计入）</span></span><br><span class="line">    do_computation();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// IO 等待：100ms（不计入）</span></span><br><span class="line">    read_from_disk();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sleep：50ms（不计入）</span></span><br><span class="line">    sleep(<span class="number">0.05</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// CPU 时间：~1ms（只包括 CPU 执行时间）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用 CPU 时间的工具</strong>：</p>
<ul>
<li>Valgrind Callgrind（主要统计 CPU 时间）</li>
</ul>
<h4 id="3-实际应用建议"><a href="#3-实际应用建议" class="headerlink" title="3. 实际应用建议"></a>3. 实际应用建议</h4><p><strong>选择统计范围的原则</strong>：</p>
<ol>
<li><p><strong>IO 密集型函数</strong>：使用墙上时钟时间</p>
<ul>
<li>文件操作、网络通信、数据库查询</li>
<li>需要了解包括等待时间在内的总耗时</li>
</ul>
</li>
<li><p><strong>CPU 密集型函数</strong>：两种时间都关注</p>
<ul>
<li>算法计算、数据处理</li>
<li>CPU 时间用于评估算法效率</li>
<li>墙上时钟时间用于评估用户体验</li>
</ul>
</li>
<li><p><strong>混合型函数</strong>：优先使用墙上时钟时间</p>
<ul>
<li>大多数实际应用中的函数</li>
<li>墙上时钟时间更能反映真实性能</li>
</ul>
</li>
</ol>
<p><strong>注意事项</strong>：</p>
<ul>
<li>⚠️ <strong>多线程环境</strong>：墙上时钟时间可能小于 CPU 时间（并行执行）</li>
<li>⚠️ <strong>IO 操作</strong>：如果函数包含 IO，墙上时钟时间会显著大于 CPU 时间</li>
<li>⚠️ <strong>sleep 操作</strong>：如果函数包含 sleep，墙上时钟时间会包含 sleep 时间</li>
<li>⚠️ <strong>上下文切换</strong>：频繁的上下文切换会增加墙上时钟时间</li>
</ul>
<p><strong>如何区分 CPU 时间和 IO 时间</strong>：</p>
<p>如果使用统计墙上时钟时间的工具，可以通过以下方式区分：</p>
<ol>
<li><strong>结合系统调用跟踪</strong>：使用 <code>strace</code> 或 <code>perf trace</code> 查看 IO 系统调用</li>
<li><strong>分析函数内部</strong>：如果函数耗时很长但 CPU 使用率低，可能是 IO 等待</li>
<li><strong>使用 perf 的 CPU 时间模式</strong>：<code>perf record -e cpu-clock</code> 可以统计 CPU 时间</li>
</ol>
<h2 id="权限要求总结"><a href="#权限要求总结" class="headerlink" title="权限要求总结"></a>权限要求总结</h2><h3 id="权限类型说明"><a href="#权限类型说明" class="headerlink" title="权限类型说明"></a>权限类型说明</h3><h4 id="1-root-权限"><a href="#1-root-权限" class="headerlink" title="1. root 权限"></a>1. root 权限</h4><ul>
<li><strong>含义</strong>：拥有系统最高权限</li>
<li><strong>获取方式</strong>：使用 <code>sudo</code> 或切换到 root 用户</li>
<li><strong>适用工具</strong>：perf、SystemTap、DTrace、eBPF&#x2F;BCC、bptrace（默认需要）</li>
</ul>
<h4 id="2-Linux-Capabilities（能力）"><a href="#2-Linux-Capabilities（能力）" class="headerlink" title="2. Linux Capabilities（能力）"></a>2. Linux Capabilities（能力）</h4><p>现代 Linux 系统使用 capabilities 机制，允许非 root 用户执行特定操作：</p>
<ul>
<li><strong>CAP_BPF</strong>：加载 eBPF 程序（Linux 5.8+）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">setcap</span> cap_bpf+ep /path/to/tool</span><br></pre></td></tr></table></figure></li>
<li><strong>CAP_SYS_PTRACE</strong>：使用 ptrace attach 到其他进程<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">setcap</span> cap_sys_ptrace+ep /path/to/tool</span><br></pre></td></tr></table></figure></li>
<li><strong>CAP_SYS_ADMIN</strong>：访问内核符号和系统管理功能</li>
<li><strong>CAP_SYS_MODULE</strong>：加载内核模块</li>
</ul>
<h4 id="3-普通用户权限"><a href="#3-普通用户权限" class="headerlink" title="3. 普通用户权限"></a>3. 普通用户权限</h4><ul>
<li><strong>含义</strong>：不需要特殊权限，普通用户即可使用</li>
<li><strong>适用工具</strong>：Intel Pin、DynamoRIO、Valgrind Callgrind、LD_PRELOAD</li>
</ul>
<h4 id="4-组权限"><a href="#4-组权限" class="headerlink" title="4. 组权限"></a>4. 组权限</h4><ul>
<li><strong>stapdev 组</strong>：SystemTap 开发组，可以加载任意模块</li>
<li><strong>stapusr 组</strong>：SystemTap 用户组，只能使用预编译模块</li>
</ul>
<h3 id="权限配置示例"><a href="#权限配置示例" class="headerlink" title="权限配置示例"></a>权限配置示例</h3><h4 id="配置-perf-非-root-使用"><a href="#配置-perf-非-root-使用" class="headerlink" title="配置 perf 非 root 使用"></a>配置 perf 非 root 使用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许用户分析自己的进程</span></span><br><span class="line"><span class="built_in">echo</span> 0 | sudo <span class="built_in">tee</span> /proc/sys/kernel/perf_event_paranoid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或永久配置</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;kernel.perf_event_paranoid = 0&quot;</span> | sudo <span class="built_in">tee</span> -a /etc/sysctl.conf</span><br><span class="line">sudo sysctl -p</span><br></pre></td></tr></table></figure>

<h4 id="配置-eBPF-BCC-非-root-使用（Linux-5-8-）"><a href="#配置-eBPF-BCC-非-root-使用（Linux-5-8-）" class="headerlink" title="配置 eBPF&#x2F;BCC 非 root 使用（Linux 5.8+）"></a>配置 eBPF&#x2F;BCC 非 root 使用（Linux 5.8+）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 授予 Python 解释器 CAP_BPF 能力</span></span><br><span class="line">sudo <span class="built_in">setcap</span> cap_bpf+ep /usr/bin/python3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或授予特定 BCC 工具</span></span><br><span class="line">sudo <span class="built_in">setcap</span> cap_bpf+ep /usr/share/bcc/tools/funccount</span><br><span class="line">sudo <span class="built_in">setcap</span> cap_bpf+ep /usr/share/bcc/tools/funclatency</span><br></pre></td></tr></table></figure>

<h4 id="配置-SystemTap-非-root-使用"><a href="#配置-SystemTap-非-root-使用" class="headerlink" title="配置 SystemTap 非 root 使用"></a>配置 SystemTap 非 root 使用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将用户添加到 stapusr 组</span></span><br><span class="line">sudo usermod -a -G stapusr <span class="variable">$USER</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要重新登录使组权限生效</span></span><br></pre></td></tr></table></figure>

<h4 id="配置-ptrace（用于-attach-功能）"><a href="#配置-ptrace（用于-attach-功能）" class="headerlink" title="配置 ptrace（用于 attach 功能）"></a>配置 ptrace（用于 attach 功能）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前 ptrace_scope 设置</span></span><br><span class="line"><span class="built_in">cat</span> /proc/sys/kernel/yama/ptrace_scope</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许同一用户调试其权限范围内的进程（开发环境）</span></span><br><span class="line"><span class="built_in">echo</span> 0 | sudo <span class="built_in">tee</span> /proc/sys/kernel/yama/ptrace_scope</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或永久配置</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;kernel.yama.ptrace_scope = 0&quot;</span> | sudo <span class="built_in">tee</span> -a /etc/sysctl.conf</span><br></pre></td></tr></table></figure>

<h3 id="权限要求快速参考"><a href="#权限要求快速参考" class="headerlink" title="权限要求快速参考"></a>权限要求快速参考</h3><table>
<thead>
<tr>
<th>工具</th>
<th>跟踪自己的进程</th>
<th>attach 到其他用户的进程</th>
<th>内核级插桩</th>
</tr>
</thead>
<tbody><tr>
<td><strong>eBPF&#x2F;BCC</strong></td>
<td>CAP_BPF（Linux 5.8+）</td>
<td>root</td>
<td>root</td>
</tr>
<tr>
<td><strong>bptrace</strong></td>
<td>CAP_BPF（Linux 5.8+）</td>
<td>root</td>
<td>root</td>
</tr>
<tr>
<td><strong>SystemTap</strong></td>
<td>stapusr 组</td>
<td>root</td>
<td>root</td>
</tr>
<tr>
<td><strong>perf</strong></td>
<td>普通用户（需配置）</td>
<td>root</td>
<td>root</td>
</tr>
<tr>
<td><strong>DTrace</strong></td>
<td>root</td>
<td>root</td>
<td>root</td>
</tr>
<tr>
<td><strong>Intel Pin</strong></td>
<td>普通用户</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td><strong>DynamoRIO</strong></td>
<td>普通用户</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td><strong>Valgrind</strong></td>
<td>普通用户</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td><strong>LD_PRELOAD</strong></td>
<td>普通用户</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td><strong>ltrace</strong></td>
<td>普通用户</td>
<td>root 或 CAP_SYS_PTRACE</td>
<td>N&#x2F;A</td>
</tr>
</tbody></table>
<h3 id="安全注意事项"><a href="#安全注意事项" class="headerlink" title="安全注意事项"></a>安全注意事项</h3><p>⚠️ <strong>生产环境建议</strong>：</p>
<ul>
<li>避免使用 <code>perf_event_paranoid = -1</code>（允许所有用户）</li>
<li>避免将用户添加到 <code>stapdev</code> 组（安全风险）</li>
<li>谨慎配置 <code>ptrace_scope = 0</code>（允许任意进程调试）</li>
<li>使用 capabilities 而非 root 权限（最小权限原则）</li>
<li>定期审查已授予的 capabilities</li>
</ul>
<h2 id="工具选择建议"><a href="#工具选择建议" class="headerlink" title="工具选择建议"></a>工具选择建议</h2><h3 id="需要-attach-到运行中进程"><a href="#需要-attach-到运行中进程" class="headerlink" title="需要 attach 到运行中进程"></a>需要 attach 到运行中进程</h3><ol>
<li><strong>eBPF&#x2F;BCC</strong>（推荐）：现代、低开销、功能强大</li>
<li><strong>bptrace</strong>（推荐）：简洁易用，专门针对函数级性能分析</li>
<li><strong>SystemTap</strong>：功能强大，脚本灵活</li>
<li><strong>perf + uprobes</strong>：系统自带，简单易用</li>
<li><strong>DTrace</strong>：如果使用 Solaris&#x2F;FreeBSD&#x2F;macOS</li>
</ol>
<h3 id="不需要-attach（可以重新启动程序）"><a href="#不需要-attach（可以重新启动程序）" class="headerlink" title="不需要 attach（可以重新启动程序）"></a>不需要 attach（可以重新启动程序）</h3><ol>
<li><strong>Intel Pin &#x2F; DynamoRIO</strong>：需要详细分析时使用</li>
<li><strong>Valgrind Callgrind</strong>：需要调用图分析时使用</li>
<li><strong>LD_PRELOAD</strong>：简单场景，只统计库函数</li>
</ol>
<h3 id="统计指标对比"><a href="#统计指标对比" class="headerlink" title="统计指标对比"></a>统计指标对比</h3><table>
<thead>
<tr>
<th>工具</th>
<th>调用次数</th>
<th>平均耗时</th>
<th>最小耗时</th>
<th>最大耗时</th>
<th>总耗时</th>
</tr>
</thead>
<tbody><tr>
<td>eBPF&#x2F;BCC</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>bptrace</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>SystemTap</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>perf + uprobes</td>
<td>✅</td>
<td>⚠️ 需脚本</td>
<td>⚠️ 需脚本</td>
<td>⚠️ 需脚本</td>
<td>⚠️ 需脚本</td>
</tr>
<tr>
<td>DTrace</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Intel Pin</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>DynamoRIO</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Valgrind Callgrind</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>LD_PRELOAD</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>ltrace</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
</tbody></table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于 C&#x2F;C++ 程序的动态插桩，推荐使用以下工具：</p>
<ol>
<li><strong>生产环境 + 需要 attach</strong>：<strong>bptrace</strong>、<strong>eBPF&#x2F;BCC</strong> 或 <strong>SystemTap</strong></li>
<li><strong>开发调试 + 详细分析</strong>：<strong>Intel Pin</strong> 或 <strong>DynamoRIO</strong></li>
<li><strong>简单场景 + 库函数统计</strong>：<strong>LD_PRELOAD</strong></li>
<li><strong>系统级分析</strong>：<strong>perf + uprobes</strong></li>
</ol>
<p>选择工具时需要考虑：</p>
<ul>
<li>是否需要 attach 到运行中的进程</li>
<li>对性能开销的容忍度</li>
<li>需要统计的详细程度</li>
<li>系统平台和权限限制</li>
<li><strong>耗时统计范围</strong>：大多数工具统计墙上时钟时间（包括 IO、sleep），只有 Valgrind Callgrind 统计 CPU 时间（不包括 IO、sleep）</li>
<li><strong>权限要求</strong>：<ul>
<li>内核级插桩工具（perf、SystemTap、eBPF&#x2F;BCC、bptrace）通常需要 root 权限或特殊 capabilities</li>
<li>二进制插桩工具（Intel Pin、DynamoRIO、Valgrind）通常只需要普通用户权限</li>
<li>attach 到其他用户的进程需要 root 权限或 <code>CAP_SYS_PTRACE</code> 能力</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/12/03/perf/%E8%87%AA%E6%97%8B%E9%94%81%E9%80%80%E9%81%BF%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/12/03/perf/%E8%87%AA%E6%97%8B%E9%94%81%E9%80%80%E9%81%BF%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">自旋锁退避算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-12-03 17:37:48" itemprop="dateCreated datePublished" datetime="2025-12-03T17:37:48+00:00">2025-12-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-23 11:34:45" itemprop="dateModified" datetime="2025-12-23T11:34:45+00:00">2025-12-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Predicate&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpinWaitWhile</span><span class="params">(Predicate pred)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">pred</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            tbb::detail::<span class="built_in">machine_pause</span>(<span class="number">10</span>);</span><br><span class="line">            ++count;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &lt; <span class="number">200</span>) &#123;</span><br><span class="line">            utils::<span class="built_in">yield</span>();</span><br><span class="line">            ++count;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(count/<span class="number">100</span>));</span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">                count += <span class="number">100</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">machine_pause</span><span class="params">(<span class="type">int32_t</span> delay)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __TBB_x86_64 || __TBB_x86_32</span></span><br><span class="line">    <span class="keyword">while</span> (delay-- &gt; <span class="number">0</span>) &#123; _mm_pause(); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __ARM_ARCH_7A__ || __aarch64__</span></span><br><span class="line">    <span class="keyword">while</span> (delay-- &gt; <span class="number">0</span>) &#123; __asm__ __volatile__(<span class="string">&quot;isb sy&quot;</span> ::: <span class="string">&quot;memory&quot;</span>); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* Generic */</span></span></span><br><span class="line">    (<span class="type">void</span>)delay; <span class="comment">// suppress without including _template_helpers.h</span></span><br><span class="line">    <span class="built_in">yield</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数说明与CPU周期分析"><a href="#函数说明与CPU周期分析" class="headerlink" title="函数说明与CPU周期分析"></a>函数说明与CPU周期分析</h2><p>该自旋锁退避算法采用三级退避策略，逐步降低CPU占用：</p>
<h3 id="1-第一阶段：machine-pause-count-100"><a href="#1-第一阶段：machine-pause-count-100" class="headerlink" title="1. 第一阶段：machine_pause() (count &lt; 100)"></a>1. 第一阶段：<code>machine_pause()</code> (count &lt; 100)</h3><p><strong>x86架构 (<code>_mm_pause()</code>)</strong></p>
<ul>
<li><strong>功能</strong>：执行 <code>PAUSE</code> 指令，提示CPU当前处于自旋等待状态</li>
<li><strong>系统调用</strong>：❌ <strong>否</strong> - 纯用户态CPU指令</li>
<li><strong>进入内核态</strong>：❌ <strong>否</strong> - 完全在用户态执行</li>
<li><strong>调用调度器</strong>：❌ <strong>否</strong> - 不涉及操作系统调度</li>
<li><strong>CPU周期</strong>：<ul>
<li>Intel处理器：约 <strong>140个周期</strong>（Skylake及以后架构）</li>
<li>AMD处理器：约 <strong>10-40个周期</strong></li>
<li>代码中调用 <code>machine_pause(10)</code>，实际执行10次 <code>PAUSE</code> 指令</li>
</ul>
</li>
<li><strong>开销来源</strong>：<ul>
<li>CPU指令执行延迟（主要开销）</li>
<li>流水线停顿（Pipeline Stall）</li>
<li>无系统调用开销、无上下文切换开销</li>
</ul>
</li>
<li><strong>作用</strong>：<ul>
<li>降低CPU功耗（避免超线程的忙等待）</li>
<li>减少内存顺序违规（Memory Order Violation）</li>
<li>在超线程环境下，让出执行资源给同核心的另一个线程</li>
</ul>
</li>
<li><strong>总开销</strong>：每次循环约 <strong>1400-4000个周期</strong>（Intel）或 <strong>100-400个周期</strong>（AMD）</li>
</ul>
<p><strong>ARM架构 (<code>isb sy</code>)</strong></p>
<ul>
<li><strong>功能</strong>：指令同步屏障（Instruction Synchronization Barrier），确保所有指令完成</li>
<li><strong>系统调用</strong>：❌ <strong>否</strong> - 纯用户态CPU指令</li>
<li><strong>进入内核态</strong>：❌ <strong>否</strong> - 完全在用户态执行</li>
<li><strong>调用调度器</strong>：❌ <strong>否</strong> - 不涉及操作系统调度</li>
<li><strong>CPU周期</strong>：约 <strong>10-50个周期</strong>（取决于具体ARM核心）</li>
<li><strong>开销来源</strong>：<ul>
<li>CPU指令执行延迟（主要开销）</li>
<li>指令流水线同步等待</li>
<li>无系统调用开销、无上下文切换开销</li>
</ul>
</li>
<li><strong>作用</strong>：确保内存访问顺序，避免乱序执行导致的问题</li>
<li><strong>总开销</strong>：每次循环约 <strong>100-500个周期</strong></li>
</ul>
<h3 id="2-第二阶段：utils-yield-100-≤-count-200"><a href="#2-第二阶段：utils-yield-100-≤-count-200" class="headerlink" title="2. 第二阶段：utils::yield() (100 ≤ count &lt; 200)"></a>2. 第二阶段：<code>utils::yield()</code> (100 ≤ count &lt; 200)</h3><ul>
<li><strong>功能</strong>：主动让出CPU时间片，通常对应 <code>sched_yield()</code> 系统调用</li>
<li><strong>系统调用</strong>：✅ <strong>是</strong> - 调用 <code>sched_yield()</code> 系统调用（Linux）或 <code>SwitchToThread()</code>（Windows）</li>
<li><strong>进入内核态</strong>：✅ <strong>是</strong> - 必须进入内核态执行系统调用</li>
<li><strong>调用调度器</strong>：✅ <strong>是</strong> - 主动调用内核调度器，将当前线程移出运行队列</li>
<li><strong>CPU周期</strong>：<ul>
<li>系统调用开销：约 <strong>1000-3000个周期</strong><ul>
<li>用户态到内核态切换：~200-500周期</li>
<li>系统调用处理：~300-1000周期</li>
<li>内核态到用户态切换：~200-500周期</li>
</ul>
</li>
<li>调度器开销：约 <strong>2000-5000个周期</strong><ul>
<li>调度器决策：~500-1500周期</li>
<li>运行队列操作：~300-800周期</li>
</ul>
</li>
<li>上下文切换开销：约 <strong>3000-15000个周期</strong>（如果发生线程切换）<ul>
<li>寄存器保存&#x2F;恢复：~1000-3000周期</li>
<li>TLB刷新：~500-2000周期</li>
<li>缓存失效：~1500-10000周期</li>
</ul>
</li>
<li>总计：<strong>6000-23000个周期</strong></li>
</ul>
</li>
<li><strong>开销来源</strong>：<ul>
<li><strong>系统调用开销</strong>：用户态&#x2F;内核态切换（主要开销之一）</li>
<li><strong>调度器开销</strong>：调度决策和运行队列操作</li>
<li><strong>上下文切换开销</strong>：如果调度器选择运行其他线程（主要开销）</li>
<li><strong>缓存失效</strong>：线程切换导致L1&#x2F;L2缓存失效</li>
</ul>
</li>
<li><strong>作用</strong>：<ul>
<li>让调度器有机会运行其他线程</li>
<li>避免长时间占用CPU核心</li>
<li>在锁竞争激烈时，给持有锁的线程更多执行机会</li>
</ul>
</li>
</ul>
<h3 id="3-第三阶段：sleep-for-count-≥-200"><a href="#3-第三阶段：sleep-for-count-≥-200" class="headerlink" title="3. 第三阶段：sleep_for() (count ≥ 200)"></a>3. 第三阶段：<code>sleep_for()</code> (count ≥ 200)</h3><ul>
<li><strong>功能</strong>：线程主动睡眠指定时间</li>
<li><strong>系统调用</strong>：✅ <strong>是</strong> - 调用 <code>nanosleep()</code> 或 <code>futex()</code> 系统调用（Linux）</li>
<li><strong>进入内核态</strong>：✅ <strong>是</strong> - 必须进入内核态执行系统调用</li>
<li><strong>调用调度器</strong>：✅ <strong>是</strong> - 将当前线程移出运行队列，放入等待队列</li>
<li><strong>CPU周期</strong>：<ul>
<li>系统调用开销：约 <strong>1000-3000个周期</strong><ul>
<li>用户态到内核态切换：~200-500周期</li>
<li>系统调用处理（设置定时器）：~500-1500周期</li>
<li>内核态到用户态切换：~200-500周期</li>
</ul>
</li>
<li>调度器开销：约 <strong>3000-8000个周期</strong><ul>
<li>调度器决策：~500-1500周期</li>
<li>运行队列操作：~500-1000周期</li>
<li>等待队列操作：~500-1000周期</li>
<li>定时器设置：~1500-4500周期</li>
</ul>
</li>
<li>上下文切换开销：约 <strong>7000-42000个周期</strong>（必然发生）<ul>
<li>寄存器保存&#x2F;恢复：~1000-3000周期</li>
<li>TLB刷新：~500-2000周期</li>
<li>缓存失效：~5500-37000周期（L1&#x2F;L2&#x2F;L3缓存）</li>
</ul>
</li>
<li>睡眠时间：<code>count/100</code> 微秒（例如 count&#x3D;200 时睡眠2微秒）</li>
<li>总计：<strong>11000-53000个周期</strong> + 睡眠时间</li>
</ul>
</li>
<li><strong>开销来源</strong>：<ul>
<li><strong>系统调用开销</strong>：用户态&#x2F;内核态切换（主要开销之一）</li>
<li><strong>调度器开销</strong>：调度决策、队列操作、定时器管理（主要开销之一）</li>
<li><strong>上下文切换开销</strong>：线程必然被切换，寄存器、TLB、缓存全部失效（主要开销）</li>
<li><strong>定时器开销</strong>：内核定时器设置和管理</li>
<li><strong>唤醒开销</strong>：定时器到期后唤醒线程的开销（未计入上述周期）</li>
</ul>
</li>
<li><strong>作用</strong>：<ul>
<li>大幅降低CPU占用</li>
<li>睡眠时间随 <code>count</code> 增长而增加（最大100微秒）</li>
<li>适用于锁竞争非常激烈或持锁时间较长的情况</li>
</ul>
</li>
</ul>
<h3 id="退避策略总结"><a href="#退避策略总结" class="headerlink" title="退避策略总结"></a>退避策略总结</h3><table>
<thead>
<tr>
<th>阶段</th>
<th>循环次数</th>
<th>主要操作</th>
<th>系统调用</th>
<th>内核态</th>
<th>调度器</th>
<th>CPU周期&#x2F;次</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>阶段1</td>
<td>0-99</td>
<td><code>machine_pause(10)</code></td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>100-4000</td>
<td>锁很快释放，短时间等待</td>
</tr>
<tr>
<td>阶段2</td>
<td>100-199</td>
<td><code>yield()</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>6000-23000</td>
<td>中等竞争，需要让出CPU</td>
</tr>
<tr>
<td>阶段3</td>
<td>200+</td>
<td><code>sleep_for()</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>11000-53000+</td>
<td>高竞争或长持锁时间</td>
</tr>
</tbody></table>
<h3 id="开销来源对比"><a href="#开销来源对比" class="headerlink" title="开销来源对比"></a>开销来源对比</h3><table>
<thead>
<tr>
<th>开销类型</th>
<th>阶段1 (<code>machine_pause</code>)</th>
<th>阶段2 (<code>yield</code>)</th>
<th>阶段3 (<code>sleep_for</code>)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CPU指令执行</strong></td>
<td>✅ 主要开销</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td><strong>系统调用</strong></td>
<td>❌</td>
<td>✅ 主要开销之一</td>
<td>✅ 主要开销之一</td>
</tr>
<tr>
<td><strong>用户态&#x2F;内核态切换</strong></td>
<td>❌</td>
<td>✅ 主要开销之一</td>
<td>✅ 主要开销之一</td>
</tr>
<tr>
<td><strong>调度器调用</strong></td>
<td>❌</td>
<td>✅ 主要开销之一</td>
<td>✅ 主要开销之一</td>
</tr>
<tr>
<td><strong>上下文切换</strong></td>
<td>❌</td>
<td>⚠️ 可能发生</td>
<td>✅ 必然发生</td>
</tr>
<tr>
<td><strong>缓存失效</strong></td>
<td>❌</td>
<td>⚠️ 可能发生</td>
<td>✅ 必然发生</td>
</tr>
<tr>
<td><strong>定时器管理</strong></td>
<td>❌</td>
<td>❌</td>
<td>✅ 额外开销</td>
</tr>
</tbody></table>
<p>这种分级退避策略能够在锁快速释放时保持低延迟（阶段1，纯用户态，无系统调用开销），同时在竞争激烈时避免浪费CPU资源（阶段2和3，通过系统调用和调度器协作降低CPU占用）。</p>
<h2 id="PAUSE指令与普通指令的区别"><a href="#PAUSE指令与普通指令的区别" class="headerlink" title="PAUSE指令与普通指令的区别"></a>PAUSE指令与普通指令的区别</h2><p>在自旋锁实现中，为什么使用 <code>PAUSE</code> 指令而不是普通的空操作指令（如 <code>NOP</code>）？两者在硬件层面的行为有显著差异：</p>
<h3 id="1-执行延迟差异"><a href="#1-执行延迟差异" class="headerlink" title="1. 执行延迟差异"></a>1. 执行延迟差异</h3><table>
<thead>
<tr>
<th>特性</th>
<th>PAUSE指令</th>
<th>普通指令（如NOP）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>执行周期</strong></td>
<td>约140个周期（Intel）</td>
<td>1个周期</td>
</tr>
<tr>
<td><strong>流水线行为</strong></td>
<td>主动暂停流水线</td>
<td>正常流水线执行</td>
</tr>
<tr>
<td><strong>功耗</strong></td>
<td>降低功耗</td>
<td>正常功耗</td>
</tr>
</tbody></table>
<p><strong>为什么PAUSE需要更多周期？</strong></p>
<ul>
<li><code>PAUSE</code> 指令被设计为<strong>延迟执行</strong>，而不是快速完成</li>
<li>CPU会主动等待一段时间，让内存子系统有机会完成待处理的操作</li>
<li>这140个周期是<strong>有意为之的延迟</strong>，而非性能缺陷</li>
</ul>
<h3 id="2-内存顺序违规（Memory-Order-Violation）处理"><a href="#2-内存顺序违规（Memory-Order-Violation）处理" class="headerlink" title="2. 内存顺序违规（Memory Order Violation）处理"></a>2. 内存顺序违规（Memory Order Violation）处理</h3><p><strong>普通指令的问题</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用普通循环的自旋锁</span></span><br><span class="line"><span class="keyword">while</span> (lock.<span class="built_in">load</span>() == LOCKED) &#123;</span><br><span class="line">    <span class="comment">// 空循环或NOP - 可能导致内存顺序违规</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在超线程（Hyper-Threading）环境下，两个逻辑核心共享执行单元</li>
<li>如果线程A在自旋等待，线程B在修改锁变量，CPU的乱序执行可能导致：<ul>
<li>线程A<strong>持续读取锁的旧值</strong>（缓存未更新）</li>
<li>即使线程B已经释放锁，线程A仍无法感知</li>
<li>造成<strong>虚假的自旋等待</strong></li>
</ul>
</li>
</ul>
<p><strong>PAUSE指令的解决方案</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用PAUSE的自旋锁</span></span><br><span class="line"><span class="keyword">while</span> (lock.<span class="built_in">load</span>() == LOCKED) &#123;</span><br><span class="line">    _mm_pause(); <span class="comment">// 提示CPU这是自旋等待</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>PAUSE</code> 指令向CPU发出<strong>信号</strong>：当前处于自旋等待状态</li>
<li>CPU会：<ul>
<li><strong>暂停内存推测执行</strong>（Memory Speculation）</li>
<li><strong>刷新内存访问队列</strong></li>
<li><strong>等待内存子系统完成待处理操作</strong></li>
</ul>
</li>
<li>减少内存顺序违规，确保能及时看到锁状态变化</li>
</ul>
<h3 id="3-超线程资源分配"><a href="#3-超线程资源分配" class="headerlink" title="3. 超线程资源分配"></a>3. 超线程资源分配</h3><p><strong>普通指令</strong>：</p>
<ul>
<li>两个超线程<strong>竞争相同的执行资源</strong></li>
<li>自旋线程占用大量执行单元，影响同核心另一个线程的性能</li>
<li>CPU无法区分”有用工作”和”忙等待”</li>
</ul>
<p><strong>PAUSE指令</strong>：</p>
<ul>
<li>CPU识别出这是<strong>自旋等待</strong>，而非实际工作</li>
<li>在超线程环境下，<strong>优先将执行资源分配给同核心的另一个线程</strong></li>
<li>提高整体CPU利用率</li>
</ul>
<h3 id="4-功耗管理"><a href="#4-功耗管理" class="headerlink" title="4. 功耗管理"></a>4. 功耗管理</h3><p><strong>普通指令</strong>：</p>
<ul>
<li>CPU持续高速执行，功耗较高</li>
<li>在自旋等待期间浪费能源</li>
</ul>
<p><strong>PAUSE指令</strong>：</p>
<ul>
<li>CPU可以降低执行单元的频率或暂停部分单元</li>
<li>显著降低功耗（特别是在移动设备和服务器上）</li>
</ul>
<h3 id="5-实际性能对比"><a href="#5-实际性能对比" class="headerlink" title="5. 实际性能对比"></a>5. 实际性能对比</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方案A：普通空循环（不推荐）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spin_with_nop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (lock.<span class="built_in">load</span>() == LOCKED) &#123;</span><br><span class="line">        <span class="comment">// 空循环或NOP</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案B：使用PAUSE（推荐）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spin_with_pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (lock.<span class="built_in">load</span>() == LOCKED) &#123;</span><br><span class="line">        _mm_pause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性能差异</strong>：</p>
<ul>
<li><strong>延迟感知</strong>：方案B能更快感知到锁释放（减少内存顺序违规）</li>
<li><strong>吞吐量</strong>：在超线程环境下，方案B的整体吞吐量更高</li>
<li><strong>功耗</strong>：方案B功耗显著更低</li>
<li><strong>单线程延迟</strong>：方案A可能略快（1周期 vs 140周期），但实际应用中差异可忽略</li>
</ul>
<h3 id="6-为什么不能简单用空循环？"><a href="#6-为什么不能简单用空循环？" class="headerlink" title="6. 为什么不能简单用空循环？"></a>6. 为什么不能简单用空循环？</h3><p>如果只是简单的空循环：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">volatile</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i); <span class="comment">// 不推荐</span></span><br></pre></td></tr></table></figure>

<p>问题：</p>
<ul>
<li>❌ 无法解决内存顺序违规</li>
<li>❌ 无法优化超线程资源分配</li>
<li>❌ 功耗较高</li>
<li>❌ CPU无法识别这是自旋等待</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>对比项</th>
<th>PAUSE指令</th>
<th>普通指令&#x2F;NOP</th>
</tr>
</thead>
<tbody><tr>
<td><strong>执行周期</strong></td>
<td>~140周期（有意延迟）</td>
<td>1周期</td>
</tr>
<tr>
<td><strong>内存顺序</strong></td>
<td>✅ 减少违规</td>
<td>❌ 可能违规</td>
</tr>
<tr>
<td><strong>超线程优化</strong></td>
<td>✅ 资源优先分配</td>
<td>❌ 无优化</td>
</tr>
<tr>
<td><strong>功耗</strong></td>
<td>✅ 降低</td>
<td>❌ 正常</td>
</tr>
<tr>
<td><strong>锁感知速度</strong></td>
<td>✅ 更快</td>
<td>❌ 可能延迟</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>✅ 自旋等待</td>
<td>❌ 不适合</td>
</tr>
</tbody></table>
<p><strong>结论</strong>：<code>PAUSE</code> 指令虽然执行周期更长，但这是<strong>有意设计</strong>的延迟，用于优化自旋等待的整体性能。在自旋锁场景中，<code>PAUSE</code> 指令带来的收益（减少内存违规、优化资源分配、降低功耗）远大于其执行延迟的成本。</p>
<h2 id="逻辑核心与执行单元"><a href="#逻辑核心与执行单元" class="headerlink" title="逻辑核心与执行单元"></a>逻辑核心与执行单元</h2><p>在理解超线程（Hyper-Threading）和PAUSE指令的作用时，需要明确<strong>逻辑核心</strong>和<strong>执行单元</strong>的概念：</p>
<h3 id="1-物理核心（Physical-Core）"><a href="#1-物理核心（Physical-Core）" class="headerlink" title="1. 物理核心（Physical Core）"></a>1. 物理核心（Physical Core）</h3><p><strong>物理核心</strong>是CPU中实际存在的、独立的处理单元，包含：</p>
<ul>
<li><strong>执行单元</strong>（Execution Units）：ALU（算术逻辑单元）、FPU（浮点单元）、加载&#x2F;存储单元等</li>
<li><strong>寄存器文件</strong>（Register File）：通用寄存器、浮点寄存器</li>
<li><strong>一级缓存</strong>（L1 Cache）：指令缓存（L1I）和数据缓存（L1D）</li>
<li><strong>分支预测器</strong>（Branch Predictor）</li>
<li><strong>指令解码器</strong>（Instruction Decoder）</li>
<li><strong>重排序缓冲区</strong>（Reorder Buffer, ROB）</li>
</ul>
<h3 id="2-逻辑核心（Logical-Core）"><a href="#2-逻辑核心（Logical-Core）" class="headerlink" title="2. 逻辑核心（Logical Core）"></a>2. 逻辑核心（Logical Core）</h3><p><strong>逻辑核心</strong>是操作系统看到的”CPU核心”，在超线程技术中：</p>
<ul>
<li><strong>一个物理核心</strong>可以对应<strong>两个逻辑核心</strong></li>
<li>每个逻辑核心有<strong>独立的寄存器文件</strong>和<strong>程序计数器（PC）</strong></li>
<li>但<strong>共享执行单元</strong>和其他硬件资源</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">物理核心1</span><br><span class="line">├── 逻辑核心0（线程0）</span><br><span class="line">│   ├── 寄存器文件（独立）</span><br><span class="line">│   └── 程序计数器（独立）</span><br><span class="line">├── 逻辑核心1（线程1）</span><br><span class="line">│   ├── 寄存器文件（独立）</span><br><span class="line">│   └── 程序计数器（独立）</span><br><span class="line">└── 共享资源</span><br><span class="line">    ├── 执行单元（ALU、FPU等）</span><br><span class="line">    ├── L1缓存</span><br><span class="line">    ├── 分支预测器</span><br><span class="line">    └── 指令解码器</span><br></pre></td></tr></table></figure>

<h3 id="3-执行单元（Execution-Units）"><a href="#3-执行单元（Execution-Units）" class="headerlink" title="3. 执行单元（Execution Units）"></a>3. 执行单元（Execution Units）</h3><p><strong>执行单元</strong>是CPU中实际执行指令的硬件单元，包括：</p>
<table>
<thead>
<tr>
<th>执行单元类型</th>
<th>功能</th>
<th>示例指令</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ALU</strong>（算术逻辑单元）</td>
<td>整数运算</td>
<td><code>ADD</code>, <code>SUB</code>, <code>AND</code>, <code>OR</code></td>
</tr>
<tr>
<td><strong>FPU</strong>（浮点单元）</td>
<td>浮点运算</td>
<td><code>FADD</code>, <code>FMUL</code>, <code>FDIV</code></td>
</tr>
<tr>
<td><strong>加载单元</strong>（Load Unit）</td>
<td>从内存&#x2F;缓存加载数据</td>
<td><code>MOV</code>, <code>LOAD</code></td>
</tr>
<tr>
<td><strong>存储单元</strong>（Store Unit）</td>
<td>将数据写入内存&#x2F;缓存</td>
<td><code>STORE</code>, <code>MOV [mem]</code></td>
</tr>
<tr>
<td><strong>分支单元</strong>（Branch Unit）</td>
<td>处理分支指令</td>
<td><code>JMP</code>, <code>CALL</code>, <code>RET</code></td>
</tr>
<tr>
<td><strong>SIMD单元</strong></td>
<td>向量运算</td>
<td><code>SSE</code>, <code>AVX</code> 指令</td>
</tr>
</tbody></table>
<h3 id="4-超线程的工作原理"><a href="#4-超线程的工作原理" class="headerlink" title="4. 超线程的工作原理"></a>4. 超线程的工作原理</h3><p><strong>超线程（Hyper-Threading）</strong>允许一个物理核心同时运行两个线程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">时间线示例（单物理核心，双逻辑核心）：</span><br><span class="line"></span><br><span class="line">时钟周期 | 逻辑核心0（线程A）        | 逻辑核心1（线程B）        | 执行单元使用情况</span><br><span class="line">---------|------------------------|------------------------|------------------</span><br><span class="line">1        | ADD指令（使用ALU）      | 等待                    | ALU: 线程A</span><br><span class="line">2        | FPU指令（使用FPU）      | LOAD指令（使用Load）    | FPU: 线程A, Load: 线程B</span><br><span class="line">3        | 等待（指令解码）        | ADD指令（使用ALU）      | ALU: 线程B</span><br><span class="line">4        | STORE指令（使用Store）  | FPU指令（使用FPU）      | Store: 线程A, FPU: 线程B</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>：</p>
<ul>
<li>两个逻辑核心<strong>共享执行单元</strong></li>
<li>当一个线程的指令在等待（如等待内存访问）时，另一个线程可以使用空闲的执行单元</li>
<li>这提高了<strong>硬件利用率</strong>，但两个线程会<strong>竞争相同的执行资源</strong></li>
</ul>
<h3 id="5-为什么PAUSE指令能优化超线程？"><a href="#5-为什么PAUSE指令能优化超线程？" class="headerlink" title="5. 为什么PAUSE指令能优化超线程？"></a>5. 为什么PAUSE指令能优化超线程？</h3><p><strong>问题场景</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程A在逻辑核心0上自旋等待</span></span><br><span class="line"><span class="keyword">while</span> (lock.<span class="built_in">load</span>() == LOCKED) &#123;</span><br><span class="line">    <span class="comment">// 空循环 - 持续占用执行单元</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程B在逻辑核心1上（同一物理核心）执行实际工作</span></span><br><span class="line"><span class="built_in">do_real_work</span>();</span><br></pre></td></tr></table></figure>

<p><strong>没有PAUSE的问题</strong>：</p>
<ul>
<li>线程A的空循环<strong>持续占用ALU等执行单元</strong></li>
<li>线程B的指令<strong>无法使用这些执行单元</strong></li>
<li>两个逻辑核心<strong>竞争执行资源</strong>，整体性能下降</li>
</ul>
<p><strong>使用PAUSE的优化</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程A在逻辑核心0上自旋等待</span></span><br><span class="line"><span class="keyword">while</span> (lock.<span class="built_in">load</span>() == LOCKED) &#123;</span><br><span class="line">    _mm_pause(); <span class="comment">// 提示CPU这是自旋等待</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程B在逻辑核心1上执行实际工作</span></span><br><span class="line"><span class="built_in">do_real_work</span>();</span><br></pre></td></tr></table></figure>

<p><strong>PAUSE的作用</strong>：</p>
<ul>
<li>CPU识别出这是<strong>自旋等待</strong>，而非实际工作</li>
<li><strong>优先将执行单元分配给线程B</strong>（执行实际工作）</li>
<li>线程A的PAUSE指令执行时，<strong>让出执行资源</strong></li>
<li>提高整体CPU利用率</li>
</ul>
<h3 id="6-执行单元的竞争与调度"><a href="#6-执行单元的竞争与调度" class="headerlink" title="6. 执行单元的竞争与调度"></a>6. 执行单元的竞争与调度</h3><p><strong>执行单元调度策略</strong>（简化模型）：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>线程A状态</th>
<th>线程B状态</th>
<th>执行单元分配</th>
</tr>
</thead>
<tbody><tr>
<td><strong>无PAUSE</strong></td>
<td>自旋（空循环）</td>
<td>执行工作</td>
<td>竞争激烈，性能下降</td>
</tr>
<tr>
<td><strong>有PAUSE</strong></td>
<td>自旋（PAUSE）</td>
<td>执行工作</td>
<td>优先分配给线程B</td>
</tr>
<tr>
<td><strong>双工作线程</strong></td>
<td>执行工作</td>
<td>执行工作</td>
<td>公平分配，交替使用</td>
</tr>
</tbody></table>
<p><strong>实际效果</strong>：</p>
<ul>
<li>使用PAUSE时，<strong>自旋线程对执行单元的占用减少</strong></li>
<li>同核心的另一个线程获得<strong>更多执行资源</strong></li>
<li>整体<strong>吞吐量提升</strong>（特别是在超线程环境下）</li>
</ul>
<h3 id="7-物理核心-vs-逻辑核心-vs-执行单元"><a href="#7-物理核心-vs-逻辑核心-vs-执行单元" class="headerlink" title="7. 物理核心 vs 逻辑核心 vs 执行单元"></a>7. 物理核心 vs 逻辑核心 vs 执行单元</h3><p><strong>层级关系</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CPU芯片</span><br><span class="line">└── 物理核心1</span><br><span class="line">    ├── 逻辑核心0（操作系统看到的CPU 0）</span><br><span class="line">    │   └── 线程A运行在此</span><br><span class="line">    ├── 逻辑核心1（操作系统看到的CPU 1）</span><br><span class="line">    │   └── 线程B运行在此</span><br><span class="line">    └── 共享执行单元</span><br><span class="line">        ├── ALU（算术逻辑单元）</span><br><span class="line">        ├── FPU（浮点单元）</span><br><span class="line">        ├── Load/Store单元</span><br><span class="line">        └── 其他执行单元</span><br><span class="line"></span><br><span class="line">物理核心2</span><br><span class="line">├── 逻辑核心2（操作系统看到的CPU 2）</span><br><span class="line">├── 逻辑核心3（操作系统看到的CPU 3）</span><br><span class="line">└── 共享执行单元（独立于物理核心1）</span><br></pre></td></tr></table></figure>

<p><strong>关键区别</strong>：</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>数量关系</th>
<th>独立性</th>
<th>共享资源</th>
</tr>
</thead>
<tbody><tr>
<td><strong>物理核心</strong></td>
<td>1个</td>
<td>完全独立</td>
<td>不共享</td>
</tr>
<tr>
<td><strong>逻辑核心</strong></td>
<td>1-2个&#x2F;物理核心</td>
<td>部分独立（寄存器独立）</td>
<td>共享执行单元</td>
</tr>
<tr>
<td><strong>执行单元</strong></td>
<td>多个&#x2F;物理核心</td>
<td>硬件资源</td>
<td>被逻辑核心共享</td>
</tr>
</tbody></table>
<h3 id="8-实际应用示例"><a href="#8-实际应用示例" class="headerlink" title="8. 实际应用示例"></a>8. 实际应用示例</h3><p><strong>查看系统核心信息</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Linux系统</span></span><br><span class="line">lscpu</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line"><span class="comment"># CPU(s):                8          # 逻辑核心数</span></span><br><span class="line"><span class="comment"># Thread(s) per core:    2          # 每个物理核心的逻辑核心数</span></span><br><span class="line"><span class="comment"># Core(s) per socket:    4          # 每个CPU插槽的物理核心数</span></span><br><span class="line"><span class="comment"># Socket(s):             1          # CPU插槽数</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 含义：1个物理插槽 × 4个物理核心 × 2个逻辑核心 = 8个逻辑核心</span></span><br></pre></td></tr></table></figure>

<p><strong>在代码中的体现</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 操作系统看到8个逻辑核心（CPU 0-7）</span></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">([]() &#123; <span class="comment">/* 运行在CPU 0或1 */</span> &#125;)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">([]() &#123; <span class="comment">/* 运行在CPU 2或3 */</span> &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果t1和t2运行在同一物理核心的不同逻辑核心上</span></span><br><span class="line"><span class="comment">// 它们会共享执行单元，PAUSE指令能优化资源分配</span></span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>逻辑核心</strong>：操作系统看到的CPU核心，每个逻辑核心可以运行一个线程</li>
<li><strong>执行单元</strong>：实际执行指令的硬件单元（ALU、FPU等），被逻辑核心共享</li>
<li><strong>超线程</strong>：一个物理核心提供两个逻辑核心，共享执行单元</li>
<li><strong>PAUSE指令</strong>：让CPU识别自旋等待，优先将执行单元分配给执行实际工作的线程</li>
</ul>
<p>理解这些概念有助于理解为什么PAUSE指令在超线程环境下能提高整体性能。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/uxlfoundation/oneTBB/blob/master/test/common/spin_barrier.h">TBB spin_barrier.h</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/12/02/perf/numa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/12/02/perf/numa/" class="post-title-link" itemprop="url">NUMA节点详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-12-02 13:44:25" itemprop="dateCreated datePublished" datetime="2025-12-02T13:44:25+00:00">2025-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-23 11:34:45" itemprop="dateModified" datetime="2025-12-23T11:34:45+00:00">2025-12-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-NUMA概念"><a href="#1-NUMA概念" class="headerlink" title="1. NUMA概念"></a>1. NUMA概念</h2><p>NUMA（Non-Uniform Memory Access，非统一内存访问）是一种计算机内存设计架构，主要用于多处理器系统中。</p>
<p>在NUMA架构中：</p>
<ul>
<li>每个CPU处理器都有本地内存（Local Memory），访问速度较快</li>
<li>每个CPU也可以访问其他CPU的内存（Remote Memory），但访问速度较慢</li>
<li>多个CPU和其本地内存组成一个NUMA节点（NUMA Node）</li>
<li>系统通过NUMA拓扑来管理内存和CPU的分配</li>
</ul>
<p><strong>NUMA架构的优势：</strong></p>
<ul>
<li>减少内存访问延迟（本地内存访问更快）</li>
<li>提高系统整体性能</li>
<li>支持更大规模的多处理器系统</li>
</ul>
<p><strong>NUMA架构的挑战：</strong></p>
<ul>
<li>需要合理分配进程和内存到对应的NUMA节点</li>
<li>跨节点访问内存会带来性能损失</li>
<li>需要应用程序或系统管理员进行优化</li>
</ul>
<h2 id="2-CPU亲和性概念"><a href="#2-CPU亲和性概念" class="headerlink" title="2. CPU亲和性概念"></a>2. CPU亲和性概念</h2><p><strong>CPU亲和性（CPU Affinity）</strong>是指将进程或线程绑定到特定的CPU核心上运行的机制。通过设置CPU亲和性，可以：</p>
<ol>
<li><strong>提高缓存命中率</strong>：进程始终运行在同一个CPU核心上，可以更好地利用CPU的L1&#x2F;L2&#x2F;L3缓存</li>
<li><strong>减少进程迁移开销</strong>：避免进程在不同CPU核心间频繁迁移带来的性能损失</li>
<li><strong>资源隔离</strong>：将不同进程绑定到不同CPU核心，实现资源隔离和负载均衡</li>
</ol>
<p><strong>CPU亲和性的类型：</strong></p>
<ul>
<li><strong>硬亲和性（Hard Affinity）</strong>：强制绑定，进程&#x2F;线程<strong>只能</strong>运行在指定的CPU核心上，调度器会严格遵循这个限制<ul>
<li>例如：如果绑定到CPU 0，进程&#x2F;线程就<strong>只能</strong>调度到CPU 0上运行，<strong>不能</strong>调度到CPU 1或其他CPU核心上</li>
<li>通过 <code>sched_setaffinity()</code>、<code>taskset</code>、<code>numactl --cpunodebind</code>、<code>cgroup cpuset.cpus</code> 等方法设置</li>
</ul>
</li>
<li><strong>软亲和性（Soft Affinity）</strong>：偏好设置，系统会尽量将进程调度到指定的CPU核心，但不强制<ul>
<li>这是调度器的默认行为，在没有显式设置CPU亲和性时，调度器会尽量保持进程在同一个CPU核心上运行</li>
<li><strong>设置方法</strong>：<ol>
<li><strong>默认方法</strong>：不设置任何CPU亲和性，直接运行程序，调度器自动实现软亲和性</li>
<li><strong>numactl</strong>：使用 <code>numactl --preferred=&lt;node&gt;</code> 只设置内存偏好，不设置CPU绑定（CPU使用默认软亲和性）</li>
<li><strong>nice值</strong>：通过 <code>nice -n &lt;value&gt;</code> 或 <code>renice &lt;value&gt; &lt;pid&gt;</code> 调整进程优先级，间接影响调度器行为</li>
<li><strong>cgroup</strong>：使用 <code>cpu.shares</code>（v1）或 <code>cpu.weight</code>（v2）设置CPU时间权重，影响调度器分配</li>
<li>**set_mempolicy()**：使用 <code>MPOL_PREFERRED</code> 策略设置内存分配偏好，CPU使用默认软亲和性</li>
<li><strong>SCHED_NORMAL策略</strong>：使用默认的CFS调度器（<code>SCHED_NORMAL</code>），自动实现软亲和性</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li>CPU亲和性设置会影响操作系统的调度器行为</li>
<li>过度绑定可能导致CPU负载不均衡</li>
<li>即使通过硬亲和性强制绑定到单个CPU核心，进程仍可能创建多个线程，这些线程会在该CPU核心上通过时间片轮转的方式轮流调度执行</li>
</ul>
<p><strong>验证硬亲和性：</strong></p>
<p>以下示例演示如何验证硬亲和性的效果。创建一个多线程程序：</p>
<figure class="highlight c"><figcaption><span>affinity_test.c</span><a href="/blog/downloads/code/perf/numa/affinity_test.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// affinity_test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREADS 200</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">worker_thread</span><span class="params">(<span class="type">void</span>* arg)</span> {</span><br><span class="line">    <span class="type">int</span> thread_id = *(<span class="type">int</span>*)arg;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行一些计算工作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) {</span><br><span class="line">        count += i;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %d completed, count = %llu\n&quot;</span>, thread_id, count);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">    <span class="type">int</span> thread_ids[NUM_THREADS];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Creating %d threads...\n&quot;</span>, NUM_THREADS);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) {</span><br><span class="line">        thread_ids[i] = i;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, worker_thread, &amp;thread_ids[i]);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) {</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;All threads completed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>编译程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o affinity_test affinity_test.c -lpthread</span><br></pre></td></tr></table></figure>

<p><strong>测试1：绑定到单个CPU核心</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskset -c 0 ./affinity_test</span><br></pre></td></tr></table></figure>

<p>使用Oracle Developer Studio Performance Analyzer观察：</p>
<p><strong>Threads View示例输出：</strong></p>
<figure class="highlight txt"><figcaption><span>affinity_test_threads_view_cpu0.txt</span><a href="/blog/downloads/code/perf/numa/affinity_test_threads_view_cpu0.txt">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line">Threads sorted by metric: Exclusive Total CPU Time</span><br><span class="line"></span><br><span class="line">Exclusive        </span><br><span class="line"></span><br><span class="line">| Total CPU Time (sec.) | Name                    |</span><br><span class="line">|-----------------------|-------------------------|</span><br><span class="line">| 2.001                 | &lt;Total&gt;                 |</span><br><span class="line">| 0.010                 | Process 1, Thread 1     |</span><br><span class="line">| 0.010                 | Process 1, Thread 2     |</span><br><span class="line">| 0.010                 | Process 1, Thread 3     |</span><br><span class="line">| 0.010                 | Process 1, Thread 4     |</span><br><span class="line">| 0.010                 | Process 1, Thread 5     |</span><br><span class="line">| 0.010                 | Process 1, Thread 6     |</span><br><span class="line">| 0.010                 | Process 1, Thread 7     |</span><br><span class="line">| 0.010                 | Process 1, Thread 8     |</span><br><span class="line">| 0.010                 | Process 1, Thread 9     |</span><br><span class="line">| 0.010                 | Process 1, Thread 10    |</span><br><span class="line">| 0.010                 | Process 1, Thread 11    |</span><br><span class="line">| 0.010                 | Process 1, Thread 12    |</span><br><span class="line">| 0.010                 | Process 1, Thread 13    |</span><br><span class="line">| 0.010                 | Process 1, Thread 14    |</span><br><span class="line">| 0.010                 | Process 1, Thread 15    |</span><br><span class="line">| 0.010                 | Process 1, Thread 16    |</span><br><span class="line">| 0.010                 | Process 1, Thread 17    |</span><br><span class="line">| 0.010                 | Process 1, Thread 18    |</span><br><span class="line">| 0.010                 | Process 1, Thread 19    |</span><br><span class="line">| 0.010                 | Process 1, Thread 20    |</span><br><span class="line">| 0.010                 | Process 1, Thread 21    |</span><br><span class="line">| 0.010                 | Process 1, Thread 22    |</span><br><span class="line">| 0.010                 | Process 1, Thread 23    |</span><br><span class="line">| 0.010                 | Process 1, Thread 24    |</span><br><span class="line">| 0.010                 | Process 1, Thread 25    |</span><br><span class="line">| 0.010                 | Process 1, Thread 26    |</span><br><span class="line">| 0.010                 | Process 1, Thread 27    |</span><br><span class="line">| 0.010                 | Process 1, Thread 28    |</span><br><span class="line">| 0.010                 | Process 1, Thread 29    |</span><br><span class="line">| 0.010                 | Process 1, Thread 30    |</span><br><span class="line">| 0.010                 | Process 1, Thread 31    |</span><br><span class="line">| 0.010                 | Process 1, Thread 32    |</span><br><span class="line">| 0.010                 | Process 1, Thread 33    |</span><br><span class="line">| 0.010                 | Process 1, Thread 34    |</span><br><span class="line">| 0.010                 | Process 1, Thread 35    |</span><br><span class="line">| 0.010                 | Process 1, Thread 36    |</span><br><span class="line">| 0.010                 | Process 1, Thread 37    |</span><br><span class="line">| 0.010                 | Process 1, Thread 38    |</span><br><span class="line">| 0.010                 | Process 1, Thread 39    |</span><br><span class="line">| 0.010                 | Process 1, Thread 40    |</span><br><span class="line">| 0.010                 | Process 1, Thread 41    |</span><br><span class="line">| 0.010                 | Process 1, Thread 42    |</span><br><span class="line">| 0.010                 | Process 1, Thread 43    |</span><br><span class="line">| 0.010                 | Process 1, Thread 44    |</span><br><span class="line">| 0.010                 | Process 1, Thread 45    |</span><br><span class="line">| 0.010                 | Process 1, Thread 46    |</span><br><span class="line">| 0.010                 | Process 1, Thread 47    |</span><br><span class="line">| 0.010                 | Process 1, Thread 48    |</span><br><span class="line">| 0.010                 | Process 1, Thread 49    |</span><br><span class="line">| 0.010                 | Process 1, Thread 50    |</span><br><span class="line">| 0.010                 | Process 1, Thread 51    |</span><br><span class="line">| 0.010                 | Process 1, Thread 52    |</span><br><span class="line">| 0.010                 | Process 1, Thread 53    |</span><br><span class="line">| 0.010                 | Process 1, Thread 54    |</span><br><span class="line">| 0.010                 | Process 1, Thread 55    |</span><br><span class="line">| 0.010                 | Process 1, Thread 56    |</span><br><span class="line">| 0.010                 | Process 1, Thread 57    |</span><br><span class="line">| 0.010                 | Process 1, Thread 58    |</span><br><span class="line">| 0.010                 | Process 1, Thread 59    |</span><br><span class="line">| 0.010                 | Process 1, Thread 60    |</span><br><span class="line">| 0.010                 | Process 1, Thread 61    |</span><br><span class="line">| 0.010                 | Process 1, Thread 62    |</span><br><span class="line">| 0.010                 | Process 1, Thread 63    |</span><br><span class="line">| 0.010                 | Process 1, Thread 64    |</span><br><span class="line">| 0.010                 | Process 1, Thread 65    |</span><br><span class="line">| 0.010                 | Process 1, Thread 66    |</span><br><span class="line">| 0.010                 | Process 1, Thread 67    |</span><br><span class="line">| 0.010                 | Process 1, Thread 68    |</span><br><span class="line">| 0.010                 | Process 1, Thread 69    |</span><br><span class="line">| 0.010                 | Process 1, Thread 70    |</span><br><span class="line">| 0.010                 | Process 1, Thread 71    |</span><br><span class="line">| 0.010                 | Process 1, Thread 72    |</span><br><span class="line">| 0.010                 | Process 1, Thread 73    |</span><br><span class="line">| 0.010                 | Process 1, Thread 74    |</span><br><span class="line">| 0.010                 | Process 1, Thread 75    |</span><br><span class="line">| 0.010                 | Process 1, Thread 76    |</span><br><span class="line">| 0.010                 | Process 1, Thread 77    |</span><br><span class="line">| 0.010                 | Process 1, Thread 78    |</span><br><span class="line">| 0.010                 | Process 1, Thread 79    |</span><br><span class="line">| 0.010                 | Process 1, Thread 80    |</span><br><span class="line">| 0.010                 | Process 1, Thread 81    |</span><br><span class="line">| 0.010                 | Process 1, Thread 82    |</span><br><span class="line">| 0.010                 | Process 1, Thread 83    |</span><br><span class="line">| 0.010                 | Process 1, Thread 84    |</span><br><span class="line">| 0.010                 | Process 1, Thread 85    |</span><br><span class="line">| 0.010                 | Process 1, Thread 86    |</span><br><span class="line">| 0.010                 | Process 1, Thread 87    |</span><br><span class="line">| 0.010                 | Process 1, Thread 88    |</span><br><span class="line">| 0.010                 | Process 1, Thread 89    |</span><br><span class="line">| 0.010                 | Process 1, Thread 90    |</span><br><span class="line">| 0.010                 | Process 1, Thread 91    |</span><br><span class="line">| 0.010                 | Process 1, Thread 92    |</span><br><span class="line">| 0.010                 | Process 1, Thread 93    |</span><br><span class="line">| 0.010                 | Process 1, Thread 94    |</span><br><span class="line">| 0.010                 | Process 1, Thread 95    |</span><br><span class="line">| 0.010                 | Process 1, Thread 96    |</span><br><span class="line">| 0.010                 | Process 1, Thread 97    |</span><br><span class="line">| 0.010                 | Process 1, Thread 98    |</span><br><span class="line">| 0.010                 | Process 1, Thread 99    |</span><br><span class="line">| 0.010                 | Process 1, Thread 100    |</span><br><span class="line">| 0.010                 | Process 1, Thread 101    |</span><br><span class="line">| 0.010                 | Process 1, Thread 102    |</span><br><span class="line">| 0.010                 | Process 1, Thread 103    |</span><br><span class="line">| 0.010                 | Process 1, Thread 104    |</span><br><span class="line">| 0.010                 | Process 1, Thread 105    |</span><br><span class="line">| 0.010                 | Process 1, Thread 106    |</span><br><span class="line">| 0.010                 | Process 1, Thread 107    |</span><br><span class="line">| 0.010                 | Process 1, Thread 108    |</span><br><span class="line">| 0.010                 | Process 1, Thread 109    |</span><br><span class="line">| 0.010                 | Process 1, Thread 110    |</span><br><span class="line">| 0.010                 | Process 1, Thread 111    |</span><br><span class="line">| 0.010                 | Process 1, Thread 112    |</span><br><span class="line">| 0.010                 | Process 1, Thread 113    |</span><br><span class="line">| 0.010                 | Process 1, Thread 114    |</span><br><span class="line">| 0.010                 | Process 1, Thread 115    |</span><br><span class="line">| 0.010                 | Process 1, Thread 116    |</span><br><span class="line">| 0.010                 | Process 1, Thread 117    |</span><br><span class="line">| 0.010                 | Process 1, Thread 118    |</span><br><span class="line">| 0.010                 | Process 1, Thread 119    |</span><br><span class="line">| 0.010                 | Process 1, Thread 120    |</span><br><span class="line">| 0.010                 | Process 1, Thread 121    |</span><br><span class="line">| 0.010                 | Process 1, Thread 122    |</span><br><span class="line">| 0.010                 | Process 1, Thread 123    |</span><br><span class="line">| 0.010                 | Process 1, Thread 124    |</span><br><span class="line">| 0.010                 | Process 1, Thread 125    |</span><br><span class="line">| 0.010                 | Process 1, Thread 126    |</span><br><span class="line">| 0.010                 | Process 1, Thread 127    |</span><br><span class="line">| 0.010                 | Process 1, Thread 128    |</span><br><span class="line">| 0.010                 | Process 1, Thread 129    |</span><br><span class="line">| 0.010                 | Process 1, Thread 130    |</span><br><span class="line">| 0.010                 | Process 1, Thread 131    |</span><br><span class="line">| 0.010                 | Process 1, Thread 132    |</span><br><span class="line">| 0.010                 | Process 1, Thread 133    |</span><br><span class="line">| 0.010                 | Process 1, Thread 134    |</span><br><span class="line">| 0.010                 | Process 1, Thread 135    |</span><br><span class="line">| 0.010                 | Process 1, Thread 136    |</span><br><span class="line">| 0.010                 | Process 1, Thread 137    |</span><br><span class="line">| 0.010                 | Process 1, Thread 138    |</span><br><span class="line">| 0.010                 | Process 1, Thread 139    |</span><br><span class="line">| 0.010                 | Process 1, Thread 140    |</span><br><span class="line">| 0.010                 | Process 1, Thread 141    |</span><br><span class="line">| 0.010                 | Process 1, Thread 142    |</span><br><span class="line">| 0.010                 | Process 1, Thread 143    |</span><br><span class="line">| 0.010                 | Process 1, Thread 144    |</span><br><span class="line">| 0.010                 | Process 1, Thread 145    |</span><br><span class="line">| 0.010                 | Process 1, Thread 146    |</span><br><span class="line">| 0.010                 | Process 1, Thread 147    |</span><br><span class="line">| 0.010                 | Process 1, Thread 148    |</span><br><span class="line">| 0.010                 | Process 1, Thread 149    |</span><br><span class="line">| 0.010                 | Process 1, Thread 150    |</span><br><span class="line">| 0.010                 | Process 1, Thread 151    |</span><br><span class="line">| 0.010                 | Process 1, Thread 152    |</span><br><span class="line">| 0.010                 | Process 1, Thread 153    |</span><br><span class="line">| 0.010                 | Process 1, Thread 154    |</span><br><span class="line">| 0.010                 | Process 1, Thread 155    |</span><br><span class="line">| 0.010                 | Process 1, Thread 156    |</span><br><span class="line">| 0.010                 | Process 1, Thread 157    |</span><br><span class="line">| 0.010                 | Process 1, Thread 158    |</span><br><span class="line">| 0.010                 | Process 1, Thread 159    |</span><br><span class="line">| 0.010                 | Process 1, Thread 160    |</span><br><span class="line">| 0.010                 | Process 1, Thread 161    |</span><br><span class="line">| 0.010                 | Process 1, Thread 162    |</span><br><span class="line">| 0.010                 | Process 1, Thread 163    |</span><br><span class="line">| 0.010                 | Process 1, Thread 164    |</span><br><span class="line">| 0.010                 | Process 1, Thread 165    |</span><br><span class="line">| 0.010                 | Process 1, Thread 166    |</span><br><span class="line">| 0.010                 | Process 1, Thread 167    |</span><br><span class="line">| 0.010                 | Process 1, Thread 168    |</span><br><span class="line">| 0.010                 | Process 1, Thread 169    |</span><br><span class="line">| 0.010                 | Process 1, Thread 170    |</span><br><span class="line">| 0.010                 | Process 1, Thread 171    |</span><br><span class="line">| 0.010                 | Process 1, Thread 172    |</span><br><span class="line">| 0.010                 | Process 1, Thread 173    |</span><br><span class="line">| 0.010                 | Process 1, Thread 174    |</span><br><span class="line">| 0.010                 | Process 1, Thread 175    |</span><br><span class="line">| 0.010                 | Process 1, Thread 176    |</span><br><span class="line">| 0.010                 | Process 1, Thread 177    |</span><br><span class="line">| 0.010                 | Process 1, Thread 178    |</span><br><span class="line">| 0.010                 | Process 1, Thread 179    |</span><br><span class="line">| 0.010                 | Process 1, Thread 180    |</span><br><span class="line">| 0.010                 | Process 1, Thread 181    |</span><br><span class="line">| 0.010                 | Process 1, Thread 182    |</span><br><span class="line">| 0.010                 | Process 1, Thread 183    |</span><br><span class="line">| 0.010                 | Process 1, Thread 184    |</span><br><span class="line">| 0.010                 | Process 1, Thread 185    |</span><br><span class="line">| 0.010                 | Process 1, Thread 186    |</span><br><span class="line">| 0.010                 | Process 1, Thread 187    |</span><br><span class="line">| 0.010                 | Process 1, Thread 188    |</span><br><span class="line">| 0.010                 | Process 1, Thread 189    |</span><br><span class="line">| 0.010                 | Process 1, Thread 190    |</span><br><span class="line">| 0.010                 | Process 1, Thread 191    |</span><br><span class="line">| 0.010                 | Process 1, Thread 192    |</span><br><span class="line">| 0.010                 | Process 1, Thread 193    |</span><br><span class="line">| 0.010                 | Process 1, Thread 194    |</span><br><span class="line">| 0.010                 | Process 1, Thread 195    |</span><br><span class="line">| 0.010                 | Process 1, Thread 196    |</span><br><span class="line">| 0.010                 | Process 1, Thread 197    |</span><br><span class="line">| 0.010                 | Process 1, Thread 198    |</span><br><span class="line">| 0.010                 | Process 1, Thread 199    |</span><br><span class="line">| 0.010                 | Process 1, Thread 200    |</span><br></pre></td></tr></table></figure>

<p><strong>CPU View示例输出：</strong></p>
<figure class="highlight txt"><figcaption><span>affinity_test_cpu_view_cpu0.txt</span><a href="/blog/downloads/code/perf/numa/affinity_test_cpu_view_cpu0.txt">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CPUs sorted by metric: Exclusive Total CPU Time</span><br><span class="line"></span><br><span class="line">Exclusive</span><br><span class="line"></span><br><span class="line">| Total CPU Time (sec.) | Name     |</span><br><span class="line">|-----------------------|----------|</span><br><span class="line">| 2.001                 | &lt;Total&gt;  |</span><br><span class="line">| 2.001                 | CPU 0    |</span><br></pre></td></tr></table></figure>

<p><strong>观察结果：</strong> 所有200个线程都运行在CPU 0上，CPU 0的利用率为100%，其他CPU未被使用。这证明了硬亲和性：即使创建了多个线程，它们也只能在绑定的CPU核心上运行。</p>
<p><strong>测试2：绑定到两个CPU核心</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskset -c 0-1 ./affinity_test</span><br></pre></td></tr></table></figure>

<p><strong>Threads View示例输出：</strong></p>
<figure class="highlight txt"><figcaption><span>affinity_test_threads_view_cpu01.txt</span><a href="/blog/downloads/code/perf/numa/affinity_test_threads_view_cpu01.txt">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line">Threads sorted by metric: Exclusive Total CPU Time</span><br><span class="line"></span><br><span class="line">Exclusive        </span><br><span class="line"></span><br><span class="line">| Total CPU Time (sec.) | Name                    |</span><br><span class="line">|-----------------------|-------------------------|</span><br><span class="line">| 2.152                 | &lt;Total&gt;                 |</span><br><span class="line">| 0.020                 | Process 1, Thread 18    |</span><br><span class="line">| 0.020                 | Process 1, Thread 22    |</span><br><span class="line">| 0.020                 | Process 1, Thread 24    |</span><br><span class="line">| 0.020                 | Process 1, Thread 50     |</span><br><span class="line">| 0.020                 | Process 1, Thread 64    |</span><br><span class="line">| 0.020                 | Process 1, Thread 66    |</span><br><span class="line">| 0.020                 | Process 1, Thread 68    |</span><br><span class="line">| 0.020                 | Process 1, Thread 97    |</span><br><span class="line">| 0.020                 | Process 1, Thread 100    |</span><br><span class="line">| 0.020                 | Process 1, Thread 104    |</span><br><span class="line">| 0.020                 | Process 1, Thread 117    |</span><br><span class="line">| 0.020                 | Process 1, Thread 123    |</span><br><span class="line">| 0.020                 | Process 1, Thread 128    |</span><br><span class="line">| 0.020                 | Process 1, Thread 130    |</span><br><span class="line">| 0.020                 | Process 1, Thread 135    |</span><br><span class="line">| 0.010                 | Process 1, Thread 1      |</span><br><span class="line">| 0.010                 | Process 1, Thread 2      |</span><br><span class="line">| 0.010                 | Process 1, Thread 3      |</span><br><span class="line">| 0.010                 | Process 1, Thread 4      |</span><br><span class="line">| 0.010                 | Process 1, Thread 5      |</span><br><span class="line">| 0.010                 | Process 1, Thread 6      |</span><br><span class="line">| 0.010                 | Process 1, Thread 7      |</span><br><span class="line">| 0.010                 | Process 1, Thread 8      |</span><br><span class="line">| 0.010                 | Process 1, Thread 9      |</span><br><span class="line">| 0.010                 | Process 1, Thread 10     |</span><br><span class="line">| 0.010                 | Process 1, Thread 11     |</span><br><span class="line">| 0.010                 | Process 1, Thread 12     |</span><br><span class="line">| 0.010                 | Process 1, Thread 13     |</span><br><span class="line">| 0.010                 | Process 1, Thread 14    |</span><br><span class="line">| 0.010                 | Process 1, Thread 15     |</span><br><span class="line">| 0.010                 | Process 1, Thread 16     |</span><br><span class="line">| 0.010                 | Process 1, Thread 17     |</span><br><span class="line">| 0.010                 | Process 1, Thread 19     |</span><br><span class="line">| 0.010                 | Process 1, Thread 20     |</span><br><span class="line">| 0.010                 | Process 1, Thread 21     |</span><br><span class="line">| 0.010                 | Process 1, Thread 23     |</span><br><span class="line">| 0.010                 | Process 1, Thread 25     |</span><br><span class="line">| 0.010                 | Process 1, Thread 26     |</span><br><span class="line">| 0.010                 | Process 1, Thread 27     |</span><br><span class="line">| 0.010                 | Process 1, Thread 28     |</span><br><span class="line">| 0.010                 | Process 1, Thread 29     |</span><br><span class="line">| 0.010                 | Process 1, Thread 30     |</span><br><span class="line">| 0.010                 | Process 1, Thread 31     |</span><br><span class="line">| 0.010                 | Process 1, Thread 32     |</span><br><span class="line">| 0.010                 | Process 1, Thread 33     |</span><br><span class="line">| 0.010                 | Process 1, Thread 34     |</span><br><span class="line">| 0.010                 | Process 1, Thread 35     |</span><br><span class="line">| 0.010                 | Process 1, Thread 36     |</span><br><span class="line">| 0.010                 | Process 1, Thread 37     |</span><br><span class="line">| 0.010                 | Process 1, Thread 38     |</span><br><span class="line">| 0.010                 | Process 1, Thread 39     |</span><br><span class="line">| 0.010                 | Process 1, Thread 40     |</span><br><span class="line">| 0.010                 | Process 1, Thread 41     |</span><br><span class="line">| 0.010                 | Process 1, Thread 42     |</span><br><span class="line">| 0.010                 | Process 1, Thread 43     |</span><br><span class="line">| 0.010                 | Process 1, Thread 44     |</span><br><span class="line">| 0.010                 | Process 1, Thread 45     |</span><br><span class="line">| 0.010                 | Process 1, Thread 46     |</span><br><span class="line">| 0.010                 | Process 1, Thread 47     |</span><br><span class="line">| 0.010                 | Process 1, Thread 48     |</span><br><span class="line">| 0.010                 | Process 1, Thread 49     |</span><br><span class="line">| 0.010                 | Process 1, Thread 51     |</span><br><span class="line">| 0.010                 | Process 1, Thread 52     |</span><br><span class="line">| 0.010                 | Process 1, Thread 53     |</span><br><span class="line">| 0.010                 | Process 1, Thread 54     |</span><br><span class="line">| 0.010                 | Process 1, Thread 55     |</span><br><span class="line">| 0.010                 | Process 1, Thread 56     |</span><br><span class="line">| 0.010                 | Process 1, Thread 57     |</span><br><span class="line">| 0.010                 | Process 1, Thread 58     |</span><br><span class="line">| 0.010                 | Process 1, Thread 59     |</span><br><span class="line">| 0.010                 | Process 1, Thread 60     |</span><br><span class="line">| 0.010                 | Process 1, Thread 61     |</span><br><span class="line">| 0.010                 | Process 1, Thread 62     |</span><br><span class="line">| 0.010                 | Process 1, Thread 63     |</span><br><span class="line">| 0.010                 | Process 1, Thread 65     |</span><br><span class="line">| 0.010                 | Process 1, Thread 67     |</span><br><span class="line">| 0.010                 | Process 1, Thread 69     |</span><br><span class="line">| 0.010                 | Process 1, Thread 70     |</span><br><span class="line">| 0.010                 | Process 1, Thread 71     |</span><br><span class="line">| 0.010                 | Process 1, Thread 72     |</span><br><span class="line">| 0.010                 | Process 1, Thread 73     |</span><br><span class="line">| 0.010                 | Process 1, Thread 74     |</span><br><span class="line">| 0.010                 | Process 1, Thread 75     |</span><br><span class="line">| 0.010                 | Process 1, Thread 76     |</span><br><span class="line">| 0.010                 | Process 1, Thread 77     |</span><br><span class="line">| 0.010                 | Process 1, Thread 78     |</span><br><span class="line">| 0.010                 | Process 1, Thread 79     |</span><br><span class="line">| 0.010                 | Process 1, Thread 80     |</span><br><span class="line">| 0.010                 | Process 1, Thread 81     |</span><br><span class="line">| 0.010                 | Process 1, Thread 82     |</span><br><span class="line">| 0.010                 | Process 1, Thread 83     |</span><br><span class="line">| 0.010                 | Process 1, Thread 84     |</span><br><span class="line">| 0.010                 | Process 1, Thread 85     |</span><br><span class="line">| 0.010                 | Process 1, Thread 86     |</span><br><span class="line">| 0.010                 | Process 1, Thread 87     |</span><br><span class="line">| 0.010                 | Process 1, Thread 88     |</span><br><span class="line">| 0.010                 | Process 1, Thread 89     |</span><br><span class="line">| 0.010                 | Process 1, Thread 90     |</span><br><span class="line">| 0.010                 | Process 1, Thread 91     |</span><br><span class="line">| 0.010                 | Process 1, Thread 92     |</span><br><span class="line">| 0.010                 | Process 1, Thread 93     |</span><br><span class="line">| 0.010                 | Process 1, Thread 94     |</span><br><span class="line">| 0.010                 | Process 1, Thread 95     |</span><br><span class="line">| 0.010                 | Process 1, Thread 96     |</span><br><span class="line">| 0.010                 | Process 1, Thread 98     |</span><br><span class="line">| 0.010                 | Process 1, Thread 99     |</span><br><span class="line">| 0.010                 | Process 1, Thread 101     |</span><br><span class="line">| 0.010                 | Process 1, Thread 102     |</span><br><span class="line">| 0.010                 | Process 1, Thread 103     |</span><br><span class="line">| 0.010                 | Process 1, Thread 105     |</span><br><span class="line">| 0.010                 | Process 1, Thread 106     |</span><br><span class="line">| 0.010                 | Process 1, Thread 107     |</span><br><span class="line">| 0.010                 | Process 1, Thread 108     |</span><br><span class="line">| 0.010                 | Process 1, Thread 109     |</span><br><span class="line">| 0.010                 | Process 1, Thread 110     |</span><br><span class="line">| 0.010                 | Process 1, Thread 111     |</span><br><span class="line">| 0.010                 | Process 1, Thread 112     |</span><br><span class="line">| 0.010                 | Process 1, Thread 113     |</span><br><span class="line">| 0.010                 | Process 1, Thread 114     |</span><br><span class="line">| 0.010                 | Process 1, Thread 115     |</span><br><span class="line">| 0.010                 | Process 1, Thread 116     |</span><br><span class="line">| 0.010                 | Process 1, Thread 118     |</span><br><span class="line">| 0.010                 | Process 1, Thread 119     |</span><br><span class="line">| 0.010                 | Process 1, Thread 120     |</span><br><span class="line">| 0.010                 | Process 1, Thread 121     |</span><br><span class="line">| 0.010                 | Process 1, Thread 122     |</span><br><span class="line">| 0.010                 | Process 1, Thread 124     |</span><br><span class="line">| 0.010                 | Process 1, Thread 125     |</span><br><span class="line">| 0.010                 | Process 1, Thread 126     |</span><br><span class="line">| 0.010                 | Process 1, Thread 127     |</span><br><span class="line">| 0.010                 | Process 1, Thread 129     |</span><br><span class="line">| 0.010                 | Process 1, Thread 131     |</span><br><span class="line">| 0.010                 | Process 1, Thread 132     |</span><br><span class="line">| 0.010                 | Process 1, Thread 133     |</span><br><span class="line">| 0.010                 | Process 1, Thread 134     |</span><br><span class="line">| 0.010                 | Process 1, Thread 136     |</span><br><span class="line">| 0.010                 | Process 1, Thread 137     |</span><br><span class="line">| 0.010                 | Process 1, Thread 138     |</span><br><span class="line">| 0.010                 | Process 1, Thread 139     |</span><br><span class="line">| 0.010                 | Process 1, Thread 140     |</span><br><span class="line">| 0.010                 | Process 1, Thread 141     |</span><br><span class="line">| 0.010                 | Process 1, Thread 142     |</span><br><span class="line">| 0.010                 | Process 1, Thread 143     |</span><br><span class="line">| 0.010                 | Process 1, Thread 144     |</span><br><span class="line">| 0.010                 | Process 1, Thread 145     |</span><br><span class="line">| 0.010                 | Process 1, Thread 146     |</span><br><span class="line">| 0.010                 | Process 1, Thread 147     |</span><br><span class="line">| 0.010                 | Process 1, Thread 148     |</span><br><span class="line">| 0.010                 | Process 1, Thread 149     |</span><br><span class="line">| 0.010                 | Process 1, Thread 150     |</span><br><span class="line">| 0.010                 | Process 1, Thread 151     |</span><br><span class="line">| 0.010                 | Process 1, Thread 152     |</span><br><span class="line">| 0.010                 | Process 1, Thread 153     |</span><br><span class="line">| 0.010                 | Process 1, Thread 154     |</span><br><span class="line">| 0.010                 | Process 1, Thread 155     |</span><br><span class="line">| 0.010                 | Process 1, Thread 156     |</span><br><span class="line">| 0.010                 | Process 1, Thread 157     |</span><br><span class="line">| 0.010                 | Process 1, Thread 158     |</span><br><span class="line">| 0.010                 | Process 1, Thread 159     |</span><br><span class="line">| 0.010                 | Process 1, Thread 160     |</span><br><span class="line">| 0.010                 | Process 1, Thread 161     |</span><br><span class="line">| 0.010                 | Process 1, Thread 162     |</span><br><span class="line">| 0.010                 | Process 1, Thread 163     |</span><br><span class="line">| 0.010                 | Process 1, Thread 164     |</span><br><span class="line">| 0.010                 | Process 1, Thread 165     |</span><br><span class="line">| 0.010                 | Process 1, Thread 166     |</span><br><span class="line">| 0.010                 | Process 1, Thread 167     |</span><br><span class="line">| 0.010                 | Process 1, Thread 168     |</span><br><span class="line">| 0.010                 | Process 1, Thread 169     |</span><br><span class="line">| 0.010                 | Process 1, Thread 170     |</span><br><span class="line">| 0.010                 | Process 1, Thread 171     |</span><br><span class="line">| 0.010                 | Process 1, Thread 172     |</span><br><span class="line">| 0.010                 | Process 1, Thread 173     |</span><br><span class="line">| 0.010                 | Process 1, Thread 174     |</span><br><span class="line">| 0.010                 | Process 1, Thread 175     |</span><br><span class="line">| 0.010                 | Process 1, Thread 176     |</span><br><span class="line">| 0.010                 | Process 1, Thread 177     |</span><br><span class="line">| 0.010                 | Process 1, Thread 178     |</span><br><span class="line">| 0.010                 | Process 1, Thread 179     |</span><br><span class="line">| 0.010                 | Process 1, Thread 180     |</span><br><span class="line">| 0.010                 | Process 1, Thread 181     |</span><br><span class="line">| 0.010                 | Process 1, Thread 182     |</span><br><span class="line">| 0.010                 | Process 1, Thread 183     |</span><br><span class="line">| 0.010                 | Process 1, Thread 184     |</span><br><span class="line">| 0.010                 | Process 1, Thread 185     |</span><br><span class="line">| 0.010                 | Process 1, Thread 186     |</span><br><span class="line">| 0.010                 | Process 1, Thread 187     |</span><br><span class="line">| 0.010                 | Process 1, Thread 188     |</span><br><span class="line">| 0.010                 | Process 1, Thread 189     |</span><br><span class="line">| 0.010                 | Process 1, Thread 190     |</span><br><span class="line">| 0.010                 | Process 1, Thread 191     |</span><br><span class="line">| 0.010                 | Process 1, Thread 192     |</span><br><span class="line">| 0.010                 | Process 1, Thread 193     |</span><br><span class="line">| 0.010                 | Process 1, Thread 194     |</span><br><span class="line">| 0.010                 | Process 1, Thread 195     |</span><br><span class="line">| 0.010                 | Process 1, Thread 196     |</span><br><span class="line">| 0.010                 | Process 1, Thread 197     |</span><br><span class="line">| 0.010                 | Process 1, Thread 198     |</span><br><span class="line">| 0.010                 | Process 1, Thread 199     |</span><br><span class="line">| 0.010                 | Process 1, Thread 200     |</span><br></pre></td></tr></table></figure>

<p><strong>CPU View示例输出：</strong></p>
<figure class="highlight txt"><figcaption><span>affinity_test_cpu_view_cpu01.txt</span><a href="/blog/downloads/code/perf/numa/affinity_test_cpu_view_cpu01.txt">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CPUs sorted by metric: Exclusive Total CPU Time</span><br><span class="line"></span><br><span class="line">Exclusive        </span><br><span class="line"></span><br><span class="line">| Total CPU Time (sec.) | Name     |</span><br><span class="line">|-----------------------|----------|</span><br><span class="line">| 2.152                 | &lt;Total&gt;  |</span><br><span class="line">| 1.591                 | CPU 0    |</span><br><span class="line">| 0.560                 | CPU 1    |</span><br></pre></td></tr></table></figure>

<p><strong>观察结果：</strong> 200个线程被分配到CPU 0和CPU 1上，两个CPU的利用率都是100%，其他CPU未被使用。这证明了硬亲和性限制了线程只能在指定的CPU核心范围内运行。</p>
<p><strong>结论：</strong> 硬亲和性确实强制限制了线程只能在绑定的CPU核心上运行，即使创建了多个线程，它们也无法使用绑定范围之外的CPU核心。</p>
<p><strong>并行库适配说明：</strong></p>
<p>CPU绑定（如 <code>taskset</code>、<code>sched_setaffinity</code>、<code>numactl --cpunodebind</code>）是<strong>硬亲和性</strong>（强制性的），能有效限制并行库的线程数。例如，TBB（Threading Building Blocks）在初始化时会根据操作系统报告的硬件资源（通过 <code>sysconf(_SC_NPROCESSORS_ONLN)</code> 等API）来决定线程池大小和调度策略。如果使用 <code>taskset</code> 或 <code>numactl</code> 将进程绑定到部分CPU核心，TBB只会看到这些CPU核心，从而自动调整线程池大小。这意味着通过限制可见的CPU资源，可以间接控制并行库的行为。</p>
<p><strong>NUMA架构下CPU亲和性的特殊性：</strong></p>
<p>在NUMA架构系统中，CPU亲和性具有特殊的重要性：</p>
<ol>
<li><p><strong>内存访问性能依赖CPU位置</strong>：</p>
<ul>
<li>进程运行在节点A的CPU上，如果内存分配在节点B，会产生远程内存访问，性能显著下降</li>
<li>因此，NUMA架构下的CPU亲和性设置必须配合内存分配策略，才能获得最佳性能</li>
</ul>
</li>
<li><p><strong>节点级别的CPU绑定</strong>：</p>
<ul>
<li>在NUMA系统中，通常以NUMA节点为单位进行CPU绑定，而不是单个CPU核心</li>
<li>绑定到某个NUMA节点的CPU意味着可以使用该节点的所有CPU核心，同时配合该节点的本地内存</li>
</ul>
</li>
<li><p><strong>CPU亲和性与内存策略的协同</strong>：</p>
<ul>
<li>仅设置CPU亲和性而不设置内存策略可能导致远程内存访问</li>
<li>NUMA优化需要同时考虑CPU绑定和内存分配策略</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：NUMA架构是CPU亲和性在多处理器系统中的特殊应用场景。在NUMA系统中，CPU亲和性不仅影响CPU调度，还直接影响内存访问性能，因此需要与内存分配策略协同使用。</p>
<h2 id="3-CPU亲和性的设置"><a href="#3-CPU亲和性的设置" class="headerlink" title="3. CPU亲和性的设置"></a>3. CPU亲和性的设置</h2><h3 id="方法对比总览"><a href="#方法对比总览" class="headerlink" title="方法对比总览"></a>方法对比总览</h3><table>
<thead>
<tr>
<th>方法</th>
<th>易用性</th>
<th>NUMA感知</th>
<th>内存控制</th>
<th>CPU绑定类型</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>taskset</strong></td>
<td>⭐⭐⭐⭐⭐</td>
<td>❌</td>
<td>❌</td>
<td>✅ 硬亲和性</td>
<td>简单CPU绑定</td>
</tr>
<tr>
<td><strong>sched_setaffinity</strong></td>
<td>⭐⭐⭐</td>
<td>❌</td>
<td>❌</td>
<td>✅ 硬亲和性</td>
<td>程序内部控制</td>
</tr>
<tr>
<td><strong>cgroup</strong></td>
<td>⭐⭐</td>
<td>✅</td>
<td>✅</td>
<td>✅ 硬亲和性</td>
<td>系统级资源管理</td>
</tr>
<tr>
<td><strong>numactl</strong></td>
<td>⭐⭐⭐⭐</td>
<td>✅</td>
<td>✅</td>
<td>✅ 硬亲和性</td>
<td>NUMA优化（详见NUMA章节）</td>
</tr>
</tbody></table>
<h3 id="方法一：taskset（通用CPU绑定）"><a href="#方法一：taskset（通用CPU绑定）" class="headerlink" title="方法一：taskset（通用CPU绑定）"></a>方法一：taskset（通用CPU绑定）</h3><p><code>taskset</code> 是一个用于设置或查看进程CPU亲和性的命令行工具，适用于所有系统（包括非NUMA系统）。</p>
<p><strong>基本用法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看进程的CPU亲和性</span></span><br><span class="line">taskset -p &lt;pid&gt;</span><br><span class="line">taskset -<span class="built_in">cp</span> &lt;pid&gt;  <span class="comment"># 更易读的格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置进程的CPU亲和性（使用CPU掩码）</span></span><br><span class="line">taskset -p 0x3 &lt;pid&gt;  <span class="comment"># 绑定到CPU 0和1（二进制：11）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用CPU列表格式</span></span><br><span class="line">taskset -<span class="built_in">cp</span> 0,1,2,3 &lt;pid&gt;  <span class="comment"># 绑定到CPU 0,1,2,3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动新进程并设置CPU亲和性</span></span><br><span class="line">taskset -c 0-3 ./your_program  <span class="comment"># 绑定到CPU 0-3</span></span><br><span class="line">taskset -c 0,2,4,6 ./your_program  <span class="comment"># 绑定到CPU 0,2,4,6</span></span><br></pre></td></tr></table></figure>

<p><strong>taskset的特点：</strong></p>
<ul>
<li>✅ 简单易用，命令行工具</li>
<li>✅ 直接指定CPU编号，精确控制</li>
<li>✅ CPU绑定是<strong>硬亲和性</strong>（强制绑定）</li>
<li>❌ 不感知NUMA拓扑结构</li>
<li>❌ 无法控制内存分配策略</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>非NUMA系统（单节点系统）</li>
<li>只需要简单的CPU绑定，不关心内存位置</li>
<li>系统没有NUMA架构</li>
</ul>
<h3 id="方法二：sched-setaffinity系统调用"><a href="#方法二：sched-setaffinity系统调用" class="headerlink" title="方法二：sched_setaffinity系统调用"></a>方法二：sched_setaffinity系统调用</h3><p><code>sched_setaffinity()</code> 是Linux系统提供的系统调用，用于设置进程或线程的CPU亲和性。这是 <code>taskset</code> 命令的底层实现。</p>
<p><strong>C语言示例：</strong></p>
<figure class="highlight c"><figcaption><span>sched_setaffinity.c</span><a href="/blog/downloads/code/perf/numa/sched_setaffinity.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">cpu_set_t</span> cpuset;</span><br><span class="line">    CPU_ZERO(&amp;cpuset);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置CPU亲和性：绑定到CPU 0和1</span></span><br><span class="line">    CPU_SET(<span class="number">0</span>, &amp;cpuset);</span><br><span class="line">    CPU_SET(<span class="number">1</span>, &amp;cpuset);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置当前进程的CPU亲和性</span></span><br><span class="line">    <span class="keyword">if</span> (sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(cpuset), &amp;cpuset) != <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">&quot;sched_setaffinity failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 验证设置结果</span></span><br><span class="line">    CPU_ZERO(&amp;cpuset);</span><br><span class="line">    <span class="keyword">if</span> (sched_getaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(cpuset), &amp;cpuset) != <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">&quot;sched_getaffinity failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程绑定到CPU: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CPU_SETSIZE; i++) {</span><br><span class="line">        <span class="keyword">if</span> (CPU_ISSET(i, &amp;cpuset)) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p><strong>多线程示例：</strong></p>
<figure class="highlight c"><figcaption><span>sched_setaffinity_threads.c</span><a href="/blog/downloads/code/perf/numa/sched_setaffinity_threads.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREADS 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">worker_thread</span><span class="params">(<span class="type">void</span> *arg)</span> {</span><br><span class="line">    <span class="type">int</span> thread_id = *(<span class="type">int</span> *)arg;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpuset;</span><br><span class="line">    CPU_ZERO(&amp;cpuset);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每个线程绑定到不同的CPU</span></span><br><span class="line">    CPU_SET(thread_id, &amp;cpuset);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置线程的CPU亲和性</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_setaffinity_np(pthread_self(), <span class="keyword">sizeof</span>(cpuset), &amp;cpuset) != <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">&quot;pthread_setaffinity_np failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前运行的CPU</span></span><br><span class="line">    <span class="type">int</span> cpu = sched_getcpu();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程 %d 运行在CPU %d\n&quot;</span>, thread_id, cpu);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">    <span class="type">int</span> thread_ids[NUM_THREADS];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) {</span><br><span class="line">        thread_ids[i] = i;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, worker_thread, &amp;thread_ids[i]);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) {</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>编译命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o sched_affinity sched_affinity.c -lpthread</span><br></pre></td></tr></table></figure>

<p><strong>API说明：</strong></p>
<ul>
<li><code>sched_setaffinity(pid_t pid, size_t cpusetsize, const cpu_set_t *mask)</code>：设置进程的CPU亲和性<ul>
<li><code>pid = 0</code>：设置当前进程</li>
<li><code>pid &gt; 0</code>：设置指定进程</li>
</ul>
</li>
<li><code>sched_getaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask)</code>：获取进程的CPU亲和性</li>
<li><code>pthread_setaffinity_np(pthread_t thread, size_t cpusetsize, const cpu_set_t *mask)</code>：设置线程的CPU亲和性</li>
<li><code>pthread_getaffinity_np(pthread_t thread, size_t cpusetsize, cpu_set_t *mask)</code>：获取线程的CPU亲和性</li>
</ul>
<p><strong>sched_setaffinity的特点：</strong></p>
<ul>
<li>✅ 系统级API，功能强大</li>
<li>✅ 可以在程序内部精确控制CPU绑定</li>
<li>✅ 支持进程和线程级别的绑定</li>
<li>✅ CPU绑定是<strong>硬亲和性</strong>（强制绑定）</li>
<li>❌ 需要编写代码，不如命令行工具方便</li>
<li>❌ 不感知NUMA拓扑</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>需要在程序运行时动态调整CPU绑定</li>
<li>需要为不同线程设置不同的CPU亲和性</li>
<li>需要精确控制CPU绑定的应用程序</li>
</ul>
<h3 id="方法三：cgroup（系统级资源管理）"><a href="#方法三：cgroup（系统级资源管理）" class="headerlink" title="方法三：cgroup（系统级资源管理）"></a>方法三：cgroup（系统级资源管理）</h3><p>cgroup是Linux内核提供的资源管理机制，可以通过cgroup v1或cgroup v2来限制进程组的CPU使用。</p>
<p><strong>cgroup v1方法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建cgroup</span></span><br><span class="line">sudo <span class="built_in">mkdir</span> -p /sys/fs/cgroup/cpuset/mygroup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置可用的CPU核心（例如CPU 0-3）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0-3&quot;</span> | sudo <span class="built_in">tee</span> /sys/fs/cgroup/cpuset/mygroup/cpuset.cpus</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置内存节点（NUMA节点，如果系统支持）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0&quot;</span> | sudo <span class="built_in">tee</span> /sys/fs/cgroup/cpuset/mygroup/cpuset.mems</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将进程添加到cgroup</span></span><br><span class="line"><span class="built_in">echo</span> &lt;pid&gt; | sudo <span class="built_in">tee</span> /sys/fs/cgroup/cpuset/mygroup/cgroup.procs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者启动新进程</span></span><br><span class="line">sudo cgexec -g cpuset:mygroup ./your_program</span><br></pre></td></tr></table></figure>

<p><strong>cgroup v2方法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 挂载cgroup v2（如果未挂载）</span></span><br><span class="line">sudo mount -t cgroup2 none /sys/fs/cgroup2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建cgroup</span></span><br><span class="line">sudo <span class="built_in">mkdir</span> -p /sys/fs/cgroup2/mygroup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置CPU范围（例如CPU 0-3）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0-3&quot;</span> | sudo <span class="built_in">tee</span> /sys/fs/cgroup2/mygroup/cpuset.cpus</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置内存节点（如果系统支持）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0&quot;</span> | sudo <span class="built_in">tee</span> /sys/fs/cgroup2/mygroup/cpuset.mems</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将进程添加到cgroup</span></span><br><span class="line"><span class="built_in">echo</span> &lt;pid&gt; | sudo <span class="built_in">tee</span> /sys/fs/cgroup2/mygroup/cgroup.procs</span><br></pre></td></tr></table></figure>

<p><strong>systemd使用cgroup：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建systemd服务单元文件</span></span><br><span class="line">sudo systemd-run --unit=myapp --scope \</span><br><span class="line">    --property=CPUSetCPUs=0-3 \</span><br><span class="line">    --property=CPUSetMems=0 \</span><br><span class="line">    ./your_program</span><br></pre></td></tr></table></figure>

<p><strong>cgroup的特点：</strong></p>
<ul>
<li>✅ 系统级资源管理，功能强大</li>
<li>✅ 支持NUMA感知（可以设置内存节点）</li>
<li>✅ 可以同时管理CPU和内存</li>
<li>✅ 支持进程组管理</li>
<li>✅ <strong>硬亲和性</strong>（强制绑定），保证进程组只在指定CPU上运行</li>
<li>⚠️ 需要root权限</li>
<li>⚠️ 配置相对复杂</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>容器化环境（Docker、Kubernetes等）</li>
<li>需要同时管理多个进程的资源分配</li>
<li>需要持久化的资源限制配置</li>
<li>系统级资源管理需求</li>
</ul>
<h2 id="4-NUMA的设置"><a href="#4-NUMA的设置" class="headerlink" title="4. NUMA的设置"></a>4. NUMA的设置</h2><h3 id="查询和监控NUMA信息"><a href="#查询和监控NUMA信息" class="headerlink" title="查询和监控NUMA信息"></a>查询和监控NUMA信息</h3><h4 id="1-查看NUMA节点拓扑"><a href="#1-查看NUMA节点拓扑" class="headerlink" title="1. 查看NUMA节点拓扑"></a>1. 查看NUMA节点拓扑</h4><p>使用 <code>numactl --hardware</code> 命令查看NUMA硬件信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ numactl --hardware</span><br><span class="line">available: 2 nodes (0-1)</span><br><span class="line">node 0 cpus: 0 1 2 3 8 9 10 11</span><br><span class="line">node 0 size: 16384 MB</span><br><span class="line">node 0 free: 1024 MB</span><br><span class="line">node 1 cpus: 4 5 6 7 12 13 14 15</span><br><span class="line">node 1 size: 16384 MB</span><br><span class="line">node 1 free: 2048 MB</span><br><span class="line">node distances:</span><br><span class="line">node   0   1</span><br><span class="line">  0:  10  21</span><br><span class="line">  1:  21  10</span><br></pre></td></tr></table></figure>

<p><strong>结果说明：</strong></p>
<ul>
<li><code>available: 2 nodes (0-1)</code>: 系统有2个NUMA节点，编号为0和1</li>
<li><code>node 0 cpus: 0 1 2 3 8 9 10 11</code>: 节点0包含的CPU核心编号</li>
<li><code>node 0 size: 16384 MB</code>: 节点0的内存大小（16GB）</li>
<li><code>node 0 free: 1024 MB</code>: 节点0的可用内存</li>
<li><code>node distances</code>: 节点间访问距离矩阵<ul>
<li>节点0到节点0的距离是10（本地访问）</li>
<li>节点0到节点1的距离是21（远程访问，距离越大性能越差）</li>
</ul>
</li>
</ul>
<h4 id="2-查看CPU和NUMA节点的映射关系"><a href="#2-查看CPU和NUMA节点的映射关系" class="headerlink" title="2. 查看CPU和NUMA节点的映射关系"></a>2. 查看CPU和NUMA节点的映射关系</h4><p>使用 <code>lscpu</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ lscpu | grep -i numa</span><br><span class="line">NUMA node(s):          2</span><br><span class="line">NUMA node0 CPU(s):     0-3,8-11</span><br><span class="line">NUMA node1 CPU(s):     4-7,12-15</span><br></pre></td></tr></table></figure>

<h4 id="3-查看NUMA统计信息"><a href="#3-查看NUMA统计信息" class="headerlink" title="3. 查看NUMA统计信息"></a>3. 查看NUMA统计信息</h4><p>使用 <code>numastat</code> 查看NUMA统计信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ numastat</span><br><span class="line">                           node0           node1</span><br><span class="line">numa_hit             12345678901     23456789012</span><br><span class="line">numa_miss              123456789       234567890</span><br><span class="line">numa_foreign           234567890       123456789</span><br><span class="line">interleave_hit             12345           12345</span><br><span class="line">local_node           12345678901     23456789012</span><br><span class="line">other_node              123456789       234567890</span><br></pre></td></tr></table></figure>

<h4 id="4-查看进程的NUMA策略"><a href="#4-查看进程的NUMA策略" class="headerlink" title="4. 查看进程的NUMA策略"></a>4. 查看进程的NUMA策略</h4><p>使用 <code>numactl --show</code> 查看当前进程的NUMA策略：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ numactl --show</span><br><span class="line">policy: default</span><br><span class="line">preferred node: current</span><br><span class="line">physcpubind: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15</span><br><span class="line">cpubind: 0 1</span><br><span class="line">nodebind: 0 1</span><br><span class="line">membind: 0 1</span><br></pre></td></tr></table></figure>

<h4 id="5-查看系统NUMA节点详细信息"><a href="#5-查看系统NUMA节点详细信息" class="headerlink" title="5. 查看系统NUMA节点详细信息"></a>5. 查看系统NUMA节点详细信息</h4><p>查看 <code>/sys/devices/system/node/</code> 目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> /sys/devices/system/node/</span><br><span class="line">node0  node1</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> /sys/devices/system/node/node0/cpulist</span><br><span class="line">0-3,8-11</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> /sys/devices/system/node/node0/meminfo</span><br><span class="line">Node 0 MemTotal:       16777216 kB</span><br><span class="line">Node 0 MemFree:         1048576 kB</span><br><span class="line">Node 0 MemUsed:       15728640 kB</span><br></pre></td></tr></table></figure>

<h3 id="numactl：NUMA架构下的CPU亲和性和内存策略工具"><a href="#numactl：NUMA架构下的CPU亲和性和内存策略工具" class="headerlink" title="numactl：NUMA架构下的CPU亲和性和内存策略工具"></a>numactl：NUMA架构下的CPU亲和性和内存策略工具</h3><p><code>numactl</code> 是NUMA架构优化的首选工具，可以同时控制CPU和内存分配策略。</p>
<p><strong>基本用法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将进程绑定到节点0的CPU和内存（CPU是硬亲和性，内存是强制绑定）</span></span><br><span class="line">numactl --cpunodebind=0 --membind=0 ./your_program</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用节点0的CPU（硬亲和性），但允许使用所有节点的内存</span></span><br><span class="line">numactl --cpunodebind=0 ./your_program</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用节点0和1的CPU（硬亲和性），优先使用节点0的内存（偏好设置）</span></span><br><span class="line">numactl --cpunodebind=0,1 --preferred=0 ./your_program</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只绑定内存到节点0（强制绑定），CPU可以使用所有节点</span></span><br><span class="line">numactl --membind=0 ./your_program</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交错分配内存到多个节点</span></span><br><span class="line">numactl --interleave=all ./your_program</span><br></pre></td></tr></table></figure>

<p><strong>numactl选项说明：</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>CPU绑定类型</th>
<th>内存绑定类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>--cpunodebind=&lt;nodes&gt;</code></td>
<td>✅ <strong>硬亲和性（强制绑定）</strong></td>
<td>-</td>
<td>进程只能运行在指定节点的CPU上</td>
</tr>
<tr>
<td><code>--membind=&lt;nodes&gt;</code></td>
<td>-</td>
<td>✅ <strong>强制绑定</strong></td>
<td>内存只能从指定节点分配</td>
</tr>
<tr>
<td><code>--preferred=&lt;node&gt;</code></td>
<td>-</td>
<td>⚠️ <strong>偏好设置</strong></td>
<td>优先从指定节点分配内存，但允许从其他节点分配</td>
</tr>
<tr>
<td><code>--interleave=&lt;nodes&gt;</code></td>
<td>-</td>
<td>⚠️ <strong>交错分配</strong></td>
<td>在指定节点间轮询分配内存</td>
</tr>
<tr>
<td><code>--localalloc</code></td>
<td>-</td>
<td>⚠️ <strong>本地优先</strong></td>
<td>优先在本地节点分配内存</td>
</tr>
</tbody></table>
<p><strong>详细说明：</strong></p>
<ul>
<li><code>--cpunodebind=&lt;nodes&gt;</code>：将进程绑定到指定NUMA节点的CPU（硬亲和性，强制绑定）<ul>
<li>示例：<code>--cpunodebind=0</code> 绑定到节点0的所有CPU</li>
<li>示例：<code>--cpunodebind=0,1</code> 绑定到节点0和1的所有CPU</li>
</ul>
</li>
<li><code>--membind=&lt;nodes&gt;</code>：设置内存分配策略为强制绑定到指定节点（强制）<ul>
<li>示例：<code>--membind=0</code> 内存只能从节点0分配</li>
<li>如果节点0内存不足，进程可能无法运行</li>
</ul>
</li>
<li><code>--preferred=&lt;node&gt;</code>：设置内存分配偏好节点（偏好设置）<ul>
<li>示例：<code>--preferred=0</code> 优先从节点0分配内存</li>
<li>如果节点0内存不足，允许从其他节点分配</li>
</ul>
</li>
<li><code>--interleave=&lt;nodes&gt;</code>：在多个节点间交错分配内存<ul>
<li>示例：<code>--interleave=0,1</code> 在节点0和1间轮询分配</li>
<li>适用于需要均匀使用多个节点内存的场景</li>
</ul>
</li>
</ul>
<p><strong>taskset与numactl的区别：</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>taskset</th>
<th>numactl</th>
</tr>
</thead>
<tbody><tr>
<td><strong>主要功能</strong></td>
<td>CPU亲和性设置</td>
<td>NUMA节点和内存策略管理</td>
</tr>
<tr>
<td><strong>CPU绑定</strong></td>
<td>✅ 支持（基于CPU编号）</td>
<td>✅ 支持（基于NUMA节点）</td>
</tr>
<tr>
<td><strong>内存管理</strong></td>
<td>❌ 不支持</td>
<td>✅ 支持（内存节点绑定）</td>
</tr>
<tr>
<td><strong>NUMA感知</strong></td>
<td>❌ 不感知NUMA拓扑</td>
<td>✅ 完全NUMA感知</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>简单的CPU绑定需求</td>
<td>NUMA架构优化</td>
</tr>
</tbody></table>
<p><strong>关键区别：</strong></p>
<ol>
<li><p><strong>CPU绑定方式不同</strong>：</p>
<ul>
<li><code>taskset</code>：直接指定CPU编号（如CPU 0, 1, 2, 3）</li>
<li><code>numactl</code>：基于NUMA节点指定（如节点0，自动包含该节点的所有CPU）</li>
</ul>
</li>
<li><p><strong>内存管理能力</strong>：</p>
<ul>
<li><code>taskset</code>：<strong>无法控制内存分配</strong>，进程可能从任意NUMA节点分配内存</li>
<li><code>numactl</code>：可以控制内存分配策略，确保内存分配在特定NUMA节点</li>
</ul>
</li>
<li><p><strong>NUMA架构优化</strong>：</p>
<ul>
<li><code>taskset</code>：在NUMA系统中，即使绑定了CPU，内存仍可能从远程节点分配，导致性能问题</li>
<li><code>numactl</code>：可以同时绑定CPU和内存，确保本地内存访问，获得最佳性能</li>
</ul>
</li>
</ol>
<p><strong>实际示例对比：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用taskset：只绑定CPU，不控制内存</span></span><br><span class="line">taskset -c 0-3 ./program</span><br><span class="line"><span class="comment"># 问题：CPU在节点0，但内存可能从节点1分配（远程访问，性能差）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用numactl：同时绑定CPU和内存</span></span><br><span class="line">numactl --cpunodebind=0 --membind=0 ./program</span><br><span class="line"><span class="comment"># 优势：CPU和内存都在节点0（本地访问，性能好）</span></span><br></pre></td></tr></table></figure>

<h3 id="NUMA函数和命令对比"><a href="#NUMA函数和命令对比" class="headerlink" title="NUMA函数和命令对比"></a>NUMA函数和命令对比</h3><p>下表列出了常用的NUMA相关函数和命令，以及它们的作用和绑定类型：</p>
<table>
<thead>
<tr>
<th>函数&#x2F;命令</th>
<th>作用</th>
<th>绑定类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>numa_alloc_onnode()</code></td>
<td>在指定NUMA节点分配内存</td>
<td>✅ <strong>强制保证</strong></td>
<td>内存一定分配在指定节点上，失败返回NULL</td>
</tr>
<tr>
<td><code>numa_sched_setaffinity()</code></td>
<td>设置进程&#x2F;线程的CPU亲和性</td>
<td>✅ <strong>硬亲和性</strong></td>
<td>进程&#x2F;线程只能运行在指定的CPU核心上</td>
</tr>
<tr>
<td><code>numactl --cpunodebind</code></td>
<td>绑定进程到指定节点的CPU</td>
<td>✅ <strong>硬亲和性</strong></td>
<td>进程只能运行在指定节点的CPU上</td>
</tr>
<tr>
<td><code>numactl --membind</code></td>
<td>绑定进程的内存分配策略</td>
<td>✅ <strong>强制绑定</strong></td>
<td>内存只能从指定节点分配，失败则进程无法运行</td>
</tr>
<tr>
<td><code>numa_run_on_node()</code></td>
<td>绑定进程到指定节点（CPU+内存）</td>
<td>⚠️ <strong>混合</strong></td>
<td>CPU绑定是硬亲和性，内存分配是偏好设置</td>
</tr>
<tr>
<td><code>numactl --preferred</code></td>
<td>设置内存分配偏好节点</td>
<td>⚠️ <strong>偏好设置</strong></td>
<td>优先从指定节点分配，但允许从其他节点分配</td>
</tr>
<tr>
<td><code>malloc()</code> &#x2F; <code>calloc()</code></td>
<td>普通内存分配</td>
<td>⚠️ <strong>受策略影响</strong></td>
<td>在<code>numa_run_on_node()</code>后，会优先在绑定节点分配，但不保证</td>
</tr>
<tr>
<td><code>set_mempolicy()</code></td>
<td>设置内存分配策略</td>
<td>取决于策略类型</td>
<td><code>MPOL_BIND</code>强制，<code>MPOL_PREFERRED</code>偏好，<code>MPOL_INTERLEAVE</code>交错</td>
</tr>
<tr>
<td><code>numa_node_to_cpus()</code></td>
<td>获取节点的CPU列表</td>
<td>✅ <strong>查询函数</strong></td>
<td>仅查询，不设置任何策略</td>
</tr>
<tr>
<td><code>get_mempolicy()</code></td>
<td>获取内存策略</td>
<td>✅ <strong>查询函数</strong></td>
<td>仅查询，不设置任何策略</td>
</tr>
</tbody></table>
<p><strong>关键区别说明：</strong></p>
<ol>
<li><p><strong>强制保证 vs 偏好设置</strong>：</p>
<ul>
<li><strong>强制保证（硬亲和性）</strong>：系统会严格遵循设置，如果无法满足（如内存不足），操作会失败</li>
<li><strong>偏好设置（软亲和性）</strong>：系统会尽量满足设置，但在资源不足时允许从其他节点分配，不会失败</li>
</ul>
</li>
<li><p><strong><code>numa_run_on_node()</code>的特殊性</strong>：</p>
<ul>
<li>CPU绑定是<strong>强制的（硬亲和性）</strong>：进程只能运行在指定节点的CPU上</li>
<li>内存分配是<strong>偏好的</strong>：优先在指定节点分配，但允许从其他节点分配</li>
<li>这是为了平衡性能和可用性：如果绑定节点内存不足，进程仍能正常运行</li>
</ul>
</li>
<li><p><strong>内存分配策略类型</strong>：</p>
<ul>
<li><code>MPOL_BIND</code>（对应<code>--membind</code>）：强制绑定，内存必须从指定节点分配</li>
<li><code>MPOL_PREFERRED</code>（对应<code>--preferred</code>）：偏好设置，优先从指定节点分配</li>
<li><code>MPOL_INTERLEAVE</code>：交错分配，在多个节点间轮询分配</li>
<li><code>MPOL_DEFAULT</code>：默认策略，由系统决定</li>
</ul>
</li>
</ol>
<p><strong>使用建议：</strong></p>
<ul>
<li>需要<strong>严格保证</strong>内存位置：使用 <code>numa_alloc_onnode()</code> 或 <code>numactl --membind</code></li>
<li>需要<strong>高性能但允许灵活性</strong>：使用 <code>numa_run_on_node()</code> 或 <code>numactl --preferred</code></li>
<li>需要<strong>精确控制CPU（硬亲和性）</strong>：使用 <code>numactl --cpunodebind</code>、<code>numa_sched_setaffinity()</code> 或 <code>taskset</code></li>
<li>需要<strong>系统级强制CPU绑定（硬亲和性）</strong>：使用 <code>cgroup</code> 的 <code>cpuset.cpus</code></li>
</ul>
<h3 id="编程示例"><a href="#编程示例" class="headerlink" title="编程示例"></a>编程示例</h3><h4 id="示例1：C语言中使用libnuma库"><a href="#示例1：C语言中使用libnuma库" class="headerlink" title="示例1：C语言中使用libnuma库"></a>示例1：C语言中使用libnuma库</h4><figure class="highlight c"><figcaption><span>numa_basic.c</span><a href="/blog/downloads/code/perf/numa/numa_basic.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numa.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numaif.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 检查NUMA是否可用</span></span><br><span class="line">    <span class="keyword">if</span> (numa_available() &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NUMA不可用\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取NUMA节点数量</span></span><br><span class="line">    <span class="type">int</span> max_node = numa_max_node();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;系统有 %d 个NUMA节点\n&quot;</span>, max_node + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前进程运行的节点</span></span><br><span class="line">    <span class="type">int</span> current_node = numa_node_of_cpu(sched_getcpu());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前CPU属于节点: %d\n&quot;</span>, current_node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存到指定NUMA节点</span></span><br><span class="line">    <span class="type">size_t</span> size = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>; <span class="comment">// 100MB</span></span><br><span class="line">    <span class="type">void</span> *mem = numa_alloc_onnode(size, <span class="number">0</span>); <span class="comment">// 在节点0上分配内存</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="literal">NULL</span>) {</span><br><span class="line">        perror(<span class="string">&quot;内存分配失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取内存所在的节点</span></span><br><span class="line">    <span class="type">int</span> mem_node;</span><br><span class="line">    <span class="keyword">if</span> (get_mempolicy(&amp;mem_node, <span class="literal">NULL</span>, <span class="number">0</span>, mem, MPOL_F_NODE | MPOL_F_ADDR) == <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;分配的内存位于节点: %d\n&quot;</span>, mem_node);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用内存...</span></span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    numa_free(mem, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>编译命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o numa_example numa_basic.c -lnuma</span><br></pre></td></tr></table></figure>

<h4 id="示例2：Python中使用numa库"><a href="#示例2：Python中使用numa库" class="headerlink" title="示例2：Python中使用numa库"></a>示例2：Python中使用numa库</h4><figure class="highlight py"><figcaption><span>numa_python.py</span><a href="/blog/downloads/code/perf/numa/numa_python.py">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_numa_nodes</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取NUMA节点信息&quot;&quot;&quot;</span></span><br><span class="line">    result = subprocess.run([<span class="string">&#x27;numactl&#x27;</span>, <span class="string">&#x27;--hardware&#x27;</span>], </span><br><span class="line">                          capture_output=<span class="literal">True</span>, text=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> result.stdout</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bind_to_numa_node</span>(<span class="params">node_id, command</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将命令绑定到指定的NUMA节点执行&quot;&quot;&quot;</span></span><br><span class="line">    cmd = [<span class="string">&#x27;numactl&#x27;</span>, <span class="string">&#x27;--cpunodebind={}&#x27;</span>.<span class="built_in">format</span>(node_id),</span><br><span class="line">           <span class="string">&#x27;--membind={}&#x27;</span>.<span class="built_in">format</span>(node_id)] + command</span><br><span class="line">    <span class="keyword">return</span> subprocess.run(cmd)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：获取NUMA信息</span></span><br><span class="line"><span class="built_in">print</span>(get_numa_nodes())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：在节点0上运行Python脚本</span></span><br><span class="line">bind_to_numa_node(<span class="number">0</span>, [<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;your_script.py&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h4 id="示例3：多线程程序中的NUMA优化"><a href="#示例3：多线程程序中的NUMA优化" class="headerlink" title="示例3：多线程程序中的NUMA优化"></a>示例3：多线程程序中的NUMA优化</h4><p><strong>方法一：不同线程绑定到不同NUMA节点</strong></p>
<p>当不同线程需要绑定到不同NUMA节点时，需要在线程内部手动设置CPU亲和性和内存分配：</p>
<figure class="highlight c"><figcaption><span>numa_threads_different_nodes.c</span><a href="/blog/downloads/code/perf/numa/numa_threads_different_nodes.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numa.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREADS 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_SIZE 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">int</span> thread_id;</span><br><span class="line">    <span class="type">int</span> numa_node;</span><br><span class="line">    <span class="type">double</span> *<span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">} <span class="type">thread_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">worker_thread</span><span class="params">(<span class="type">void</span> *arg)</span> {</span><br><span class="line">    <span class="type">thread_data_t</span> *data = (<span class="type">thread_data_t</span> *)arg;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法1：手动设置CPU亲和性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmask</span> *<span class="title">cpuset</span> =</span> numa_allocate_cpumask();</span><br><span class="line">    numa_node_to_cpus(data-&gt;numa_node, cpuset);</span><br><span class="line">    numa_sched_setaffinity(<span class="number">0</span>, cpuset);</span><br><span class="line">    numa_free_cpumask(cpuset);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在指定节点上分配内存</span></span><br><span class="line">    data-&gt;<span class="built_in">array</span> = (<span class="type">double</span> *)numa_alloc_onnode(</span><br><span class="line">        data-&gt;size * <span class="keyword">sizeof</span>(<span class="type">double</span>), data-&gt;numa_node);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (data-&gt;<span class="built_in">array</span> == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;线程 %d: 内存分配失败\n&quot;</span>, data-&gt;thread_id);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行计算（使用本地内存）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; data-&gt;size; i++) {</span><br><span class="line">        data-&gt;<span class="built_in">array</span>[i] = i * <span class="number">1.0</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cpu = sched_getcpu();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程 %d 在CPU %d (节点 %d) 上完成计算\n&quot;</span>, </span><br><span class="line">           data-&gt;thread_id, cpu, data-&gt;numa_node);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (numa_available() &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;NUMA不可用\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> max_node = numa_max_node();</span><br><span class="line">    <span class="type">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">    <span class="type">thread_data_t</span> thread_data[NUM_THREADS];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建线程，每个线程分配到不同的NUMA节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) {</span><br><span class="line">        thread_data[i].thread_id = i;</span><br><span class="line">        thread_data[i].numa_node = i % (max_node + <span class="number">1</span>);</span><br><span class="line">        thread_data[i].size = ARRAY_SIZE;</span><br><span class="line">        </span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, worker_thread, &amp;thread_data[i]);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) {</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (thread_data[i].<span class="built_in">array</span>) {</span><br><span class="line">            numa_free(thread_data[i].<span class="built_in">array</span>, </span><br><span class="line">                     thread_data[i].size * <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p><strong>方法二：所有线程绑定到同一NUMA节点</strong></p>
<p><code>numa_run_on_node()</code> 是一个便捷函数，它会将当前进程绑定到指定NUMA节点的所有CPU上，并设置内存分配偏好策略为该节点。<strong>注意</strong>：CPU绑定是<strong>硬亲和性</strong>（强制的），但内存分配只是偏好设置（不强制保证）。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>需要将整个进程（包括所有线程）绑定到特定NUMA节点</li>
<li>希望简化代码，避免手动管理CPU掩码和内存策略</li>
<li>在进程启动时进行NUMA绑定</li>
</ul>
<p>如果所有线程都需要绑定到同一个NUMA节点，可以在主线程中使用 <code>numa_run_on_node()</code> 统一绑定：</p>
<figure class="highlight c"><figcaption><span>numa_threads_same_node.c</span><a href="/blog/downloads/code/perf/numa/numa_threads_same_node.c">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numa.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREADS 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_SIZE 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">int</span> thread_id;</span><br><span class="line">    <span class="type">double</span> *<span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">} <span class="type">thread_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">worker_thread</span><span class="params">(<span class="type">void</span> *arg)</span> {</span><br><span class="line">    <span class="type">thread_data_t</span> *data = (<span class="type">thread_data_t</span> *)arg;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意：numa_run_on_node在主线程中调用后，</span></span><br><span class="line">    <span class="comment">// 所有线程都会继承这个绑定，但每个线程仍可能运行在不同CPU上</span></span><br><span class="line">    <span class="comment">// 内存分配会优先在绑定的节点上进行（偏好设置，不强制保证）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分配内存（会优先在绑定的节点上分配，但不保证）</span></span><br><span class="line">    data-&gt;<span class="built_in">array</span> = (<span class="type">double</span> *)<span class="built_in">malloc</span>(data-&gt;size * <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (data-&gt;<span class="built_in">array</span> == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;线程 %d: 内存分配失败\n&quot;</span>, data-&gt;thread_id);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行计算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; data-&gt;size; i++) {</span><br><span class="line">        data-&gt;<span class="built_in">array</span>[i] = i * <span class="number">1.0</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cpu = sched_getcpu();</span><br><span class="line">    <span class="type">int</span> node = numa_node_of_cpu(cpu);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程 %d 在CPU %d (节点 %d) 上完成计算\n&quot;</span>, </span><br><span class="line">           data-&gt;thread_id, cpu, node);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (numa_available() &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;NUMA不可用\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> target_node = <span class="number">0</span>; <span class="comment">// 所有线程绑定到节点0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在主线程中绑定到目标节点</span></span><br><span class="line">    <span class="comment">// 这会影响到所有后续创建的线程</span></span><br><span class="line">    <span class="keyword">if</span> (numa_run_on_node(target_node) != <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">&quot;绑定到NUMA节点失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主进程绑定到节点 %d，创建 %d 个工作线程\n&quot;</span>, target_node, NUM_THREADS);</span><br><span class="line">    </span><br><span class="line">    <span class="type">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">    <span class="type">thread_data_t</span> thread_data[NUM_THREADS];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建线程（会自动继承NUMA绑定）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) {</span><br><span class="line">        thread_data[i].thread_id = i;</span><br><span class="line">        thread_data[i].size = ARRAY_SIZE;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, worker_thread, &amp;thread_data[i]);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) {</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (thread_data[i].<span class="built_in">array</span>) {</span><br><span class="line">            <span class="built_in">free</span>(thread_data[i].<span class="built_in">array</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p><strong>numa_run_on_node的特点：</strong></p>
<ul>
<li>✅ <strong>优点</strong>：代码简单，一个函数调用完成绑定</li>
<li>✅ <strong>优点</strong>：CPU绑定是<strong>硬亲和性</strong>（强制的），进程只能运行在指定节点的CPU上</li>
<li>⚠️ <strong>注意</strong>：内存分配是<strong>偏好设置</strong>，会优先在绑定的节点上分配，但不强制保证</li>
<li>⚠️ <strong>限制</strong>：所有线程都绑定到同一个节点，无法为不同线程分配不同节点</li>
<li>⚠️ <strong>注意</strong>：<code>numa_run_on_node()</code> 会影响整个进程及其所有线程</li>
</ul>
<p><strong>选择建议：</strong></p>
<ul>
<li>如果所有线程需要绑定到<strong>同一个NUMA节点</strong>：使用 <code>numa_run_on_node()</code>（方法二）</li>
<li>如果不同线程需要绑定到<strong>不同的NUMA节点</strong>：使用手动设置CPU亲和性（方法一）</li>
</ul>
<p>编译命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o numa_threads_different_nodes numa_threads_different_nodes.c -lnuma -lpthread</span><br><span class="line">gcc -o numa_threads_same_node numa_threads_same_node.c -lnuma -lpthread</span><br></pre></td></tr></table></figure>

<h3 id="NUMA优化建议"><a href="#NUMA优化建议" class="headerlink" title="NUMA优化建议"></a>NUMA优化建议</h3><ol>
<li><strong>进程绑定</strong>：将进程绑定到特定的NUMA节点，减少跨节点访问</li>
<li><strong>内存本地化</strong>：在进程运行的节点上分配内存</li>
<li><strong>数据局部性</strong>：确保数据访问模式与NUMA拓扑匹配</li>
<li><strong>监控工具</strong>：使用 <code>numastat</code> 和 <code>numactl</code> 监控和调整NUMA策略</li>
<li><strong>应用程序设计</strong>：在应用程序设计时考虑NUMA架构，合理分配线程和内存</li>
<li><strong>并行库适配</strong>：注意并行库（如TBB、OpenMP）在初始化时会根据操作系统报告的硬件资源来决定线程池大小，通过限制可见的CPU资源可以间接控制并行库的线程数</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><code>man numactl</code> - numactl命令手册</li>
<li><code>man numa</code> - NUMA库函数手册</li>
<li><code>/proc/sys/kernel/numa_balancing</code> - NUMA平衡配置</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/11/26/concurrency/%E5%B9%B6%E5%8F%91%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/11/26/concurrency/%E5%B9%B6%E5%8F%91%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">并发调试工具</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-11-26 10:32:15" itemprop="dateCreated datePublished" datetime="2025-11-26T10:32:15+00:00">2025-11-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-23 11:34:45" itemprop="dateModified" datetime="2025-12-23T11:34:45+00:00">2025-12-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="常用-C-并发调试工具-ThreadSanitizer-TSan"><a href="#常用-C-并发调试工具-ThreadSanitizer-TSan" class="headerlink" title="常用 C++ 并发调试工具 ThreadSanitizer (TSan)"></a>常用 C++ 并发调试工具 ThreadSanitizer (TSan)</h2><ul>
<li>LLVM&#x2F;Clang 提供的运行时检测工具<ul>
<li>能精准捕获 数据竞争，输出冲突内存地址、访问栈回溯和涉及线程</li>
</ul>
</li>
<li>Helgrind (Valgrind 工具集)<ul>
<li>专门用于检测 死锁 和 锁误用</li>
<li>通过监视线程对共享内存的访问来发现潜在冲突</li>
</ul>
</li>
<li>rr (Record and Replay Debugger)<ul>
<li>可以记录程序执行过程并重放</li>
<li>适合调试 难以复现的并发 bug，如竞态条件和原子性问题</li>
</ul>
</li>
<li>Clang Static Analyzer<ul>
<li>静态分析工具，在编译阶段发现潜在的并发问题</li>
<li>可检测未加锁访问共享变量、内存序错误等</li>
</ul>
</li>
<li>PVS-Studio<ul>
<li>商业静态分析工具</li>
<li>能在 CI 流程中提前发现并发安全隐患</li>
</ul>
</li>
</ul>
<p>适用场景</p>
<ul>
<li>数据竞争 (Data Race) → 使用 ThreadSanitizer</li>
<li>死锁 (Deadlock) → 使用 Helgrind</li>
<li>难复现的竞态条件 → 使用 rr</li>
</ul>
<p>编译阶段预防 → 使用 Clang Static Analyzer &#x2F; PVS-Studio</p>
<p>这些工具往往需要结合使用：例如 TSan + Helgrind + rr 的组合拳，可以覆盖运行时检测、死锁分析和重放调试<br>，从而大幅提升并发问题定位效率</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>语言&#x2F;平台</th>
<th>主要功能</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>ThreadSanitizer</td>
<td>C&#x2F;C++ (Clang&#x2F;LLVM)</td>
<td>数据竞争检测</td>
<td>运行时发现共享变量冲突</td>
</tr>
<tr>
<td>Helgrind</td>
<td>C&#x2F;C++ (Valgrind)</td>
<td>死锁检测、锁误用</td>
<td>多线程同步问题</td>
</tr>
<tr>
<td>rr</td>
<td>C&#x2F;C++ (Linux)</td>
<td>执行记录与重放</td>
<td>难复现的竞态条件</td>
</tr>
<tr>
<td>Clang Static Analyzer</td>
<td>C&#x2F;C++</td>
<td>静态分析并发隐患</td>
<td>编译阶段预防</td>
</tr>
<tr>
<td>PVS-Studio</td>
<td>C&#x2F;C++</td>
<td>商业静态分析</td>
<td>CI 流程集成</td>
</tr>
<tr>
<td><strong>Oracle Thread Analyzer</strong></td>
<td>Java (Oracle 工具链)</td>
<td>线程可视化、死锁检测</td>
<td>Java 并发调试</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/11/26/perf/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/11/26/perf/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">性能分析工具</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-11-26 10:12:33" itemprop="dateCreated datePublished" datetime="2025-11-26T10:12:33+00:00">2025-11-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-23 11:34:45" itemprop="dateModified" datetime="2025-12-23T11:34:45+00:00">2025-12-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="性能分析工具"><a href="#性能分析工具" class="headerlink" title="性能分析工具"></a>性能分析工具</h2><table>
<thead>
<tr>
<th>工具</th>
<th align="center">类型&#x2F;定位</th>
<th align="center">attach 支持</th>
<th align="center">分析范围</th>
<th align="center">特点</th>
<th align="center">与 perf 的关系</th>
<th align="center">开源&#x2F;商业授权</th>
<th align="center">适用人群</th>
</tr>
</thead>
<tbody><tr>
<td>Oracle Performance Analyzer (PA)</td>
<td align="center">企业级性能分析器，Oracle Developer Studio 套件</td>
<td align="center">✅</td>
<td align="center">用户态程序 (C&#x2F;C++&#x2F;Java&#x2F;Fortran&#x2F;Scala)，并行应用</td>
<td align="center">GUI 丰富，低开销采样，函数&#x2F;源代码&#x2F;指令级分析</td>
<td align="center">独立工具</td>
<td align="center">商业软件 (Oracle Developer Studio)</td>
<td align="center">企业&#x2F;科研环境下的应用开发者</td>
</tr>
<tr>
<td>perf</td>
<td align="center">Linux 内核自带性能分析框架</td>
<td align="center">✅</td>
<td align="center">用户态 + 内核态 + 硬件事件</td>
<td align="center">功能全面，支持调用链、硬件计数器，生态丰富 (eBPF, flamegraph)</td>
<td align="center">基础框架</td>
<td align="center">开源 (GPL，Linux 内核自带)</td>
<td align="center">系统工程师，底层性能调优</td>
</tr>
<tr>
<td>gprofng</td>
<td align="center">GNU 新一代应用性能分析器</td>
<td align="center">✅</td>
<td align="center">用户态程序 (C&#x2F;C++&#x2F;Java&#x2F;Scala)，跨平台</td>
<td align="center">基于实验目录，支持 GUI，跨语言，继承 Oracle PA 思路</td>
<td align="center">独立工具</td>
<td align="center">开源 (GNU 工具链)</td>
<td align="center">应用开发者，跨平台性能优化</td>
</tr>
<tr>
<td>gprof</td>
<td align="center">经典 GNU 性能分析器 (1980s)</td>
<td align="center">❌</td>
<td align="center">用户态程序 (C&#x2F;C++)</td>
<td align="center">需编译时 -pg，生成 gmon.out，功能有限，不支持多线程&#x2F;attach</td>
<td align="center">独立工具</td>
<td align="center">开源 (GNU 工具链)</td>
<td align="center">学术&#x2F;教学场景，简单函数级分析</td>
</tr>
<tr>
<td>Intel PMU Tools</td>
<td align="center">Intel 提供的硬件性能计数器工具集</td>
<td align="center">✅</td>
<td align="center">硬件事件 (CPU pipeline、cache、branch、memory)</td>
<td align="center">基于 PMU，提供 top-down 分析，解释微架构瓶颈</td>
<td align="center">依赖 perf 收集数据，属于 perf 的增强解释层</td>
<td align="center">开源 (MIT&#x2F;Apache 许可，Intel GitHub 提供)</td>
<td align="center">系统&#x2F;性能工程师，硬件级调优</td>
</tr>
<tr>
<td>Intel Advisor</td>
<td align="center">高级性能优化工具 (Intel oneAPI 套件)</td>
<td align="center">✅</td>
<td align="center">用户态程序，尤其是 HPC 应用</td>
<td align="center">提供矢量化分析、内存访问优化、并行化建议，GUI 支持</td>
<td align="center">独立工具</td>
<td align="center">商业软件 (Intel oneAPI 套件，部分免费版)</td>
<td align="center">HPC 开发者，科学计算优化</td>
</tr>
<tr>
<td>Intel VTune Profiler</td>
<td align="center">深度性能分析器</td>
<td align="center">✅</td>
<td align="center">CPU&#x2F;GPU&#x2F;FPGA、内存、线程、I&#x2F;O、微架构</td>
<td align="center">微架构级剖析，支持 cache、pipeline、分支预测，功能全面</td>
<td align="center">独立工具，但可结合 perf 数据</td>
<td align="center">商业软件 (Intel oneAPI 套件，提供免费社区版)</td>
<td align="center">系统&#x2F;性能工程师，硬件与应用优化</td>
</tr>
<tr>
<td>Linaro MAP (Arm Forge MAP)</td>
<td align="center">HPC 并行应用性能分析器</td>
<td align="center">✅</td>
<td align="center">MPI、OpenMP、UPC 等大规模并行应用</td>
<td align="center">低开销采样，跨节点整体分析，源代码行级耗时展示，GUI 可视化</td>
<td align="center">独立工具</td>
<td align="center">商业软件 (Arm Forge 套件，需许可证)</td>
<td align="center">HPC 开发者，超级计算机环境</td>
</tr>
</tbody></table>
<p><strong>差异总结</strong></p>
<ul>
<li>Oracle PA &#x2F; gprofng：应用层性能分析，强调 GUI 和跨语言支持。</li>
<li>perf：系统级通用工具，是底层框架。</li>
<li>gprof：老工具，功能有限，不支持 attach。</li>
<li>Intel PMU Tools：基于 perf，提供 Intel CPU 微架构解释，是 perf 的增强解释层。</li>
<li>Intel Advisor：智能优化建议工具，适合 HPC 和科学计算。</li>
<li>Intel VTune Profiler：深度剖析工具，能揭示硬件微架构瓶颈，适合单节点和复杂应用。</li>
<li>Linaro MAP：专为 HPC 并行应用设计，低开销，跨节点整体性能分析。</li>
</ul>
<p><strong>结论</strong></p>
<ul>
<li>应用层性能分析：Oracle PA、gprofng</li>
<li>系统&#x2F;内核级调优：perf</li>
<li>硬件级微架构分析：Intel PMU Tools、Intel VTune Profiler</li>
<li>智能优化建议 (HPC)：Intel Advisor</li>
<li>大规模并行应用分析 (HPC)：Linaro MAP</li>
</ul>
<p>👉 可以把它们看作一个层次结构：</p>
<ul>
<li>gprof → gprofng&#x2F;Oracle PA → perf → Intel PMU Tools&#x2F;VTune → Advisor&#x2F;MAP</li>
<li>逐步从函数级分析 → 应用性能 → 系统级 → 硬件级 → HPC 并行整体优化。</li>
</ul>
<h3 id="Performance-Analyzer"><a href="#Performance-Analyzer" class="headerlink" title="Performance Analyzer"></a>Performance Analyzer</h3><p>Oracle Developer Studio 提供了多种工具：Performance Analyzer、Thread Analyzer。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E77782_01/html/E77798/afagg.html#OSSPAgrkam">Performance Analyzer 官方文档</a></p>
</blockquote>
<h4 id="收集数据"><a href="#收集数据" class="headerlink" title="收集数据"></a>收集数据</h4><p>使用 <code>collect</code> 命令收集数据<br>（<a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E77782_01/html/E77798/afadn.html#scrolltoc">官方文档</a>）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collect collect-options program program-arguments</span><br></pre></td></tr></table></figure>

<h4 id="开始性能分析"><a href="#开始性能分析" class="headerlink" title="开始性能分析"></a>开始性能分析</h4><p>使用 <code>analyzer</code> 命令进行性能分析<br>（<a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E77782_01/html/E77798/afafs.html#scrolltoc">官方文档</a>）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyzer [control-options] [experiment | experiment-list]</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyzer -c test.1.er test.4.er</span><br></pre></td></tr></table></figure>

<h3 id="Thread-Analyzer"><a href="#Thread-Analyzer" class="headerlink" title="Thread Analyzer"></a>Thread Analyzer</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.oracle.com/application-development/technologies/developerstudio-features.html#thread-analyzer-tab">Thread Analyzer 官方文档</a></p>
</blockquote>
<h2 id="计时"><a href="#计时" class="headerlink" title="计时"></a>计时</h2><h3 id="计时工具-time"><a href="#计时工具-time" class="headerlink" title="计时工具 time"></a>计时工具 <code>time</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/bin/time -p <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p>Or,</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ time <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p>其中（参<br>考<a target="_blank" rel="noopener" href="https://ostechnix.com/how-to-find-the-execution-time-of-a-command-or-process-in-linux/">链接</a>），</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">type</span> -a time</span><br><span class="line">time is a shell keyword</span><br><span class="line">time is /usr/bin/time</span><br></pre></td></tr></table></figure>

<h3 id="软件和硬件定时器"><a href="#软件和硬件定时器" class="headerlink" title="软件和硬件定时器"></a>软件和硬件定时器</h3><p><a target="_blank" rel="noopener" href="https://weedge.github.io/perf-book-cn/zh/chapters/2-Measuring-Performance/2-5_SW_and_HW_Timers_cn.html">https://weedge.github.io/perf-book-cn/zh/chapters/2-Measuring-Performance/2-5_SW_and_HW_Timers_cn.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/11/21/perf/Bad-Speculation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/11/21/perf/Bad-Speculation/" class="post-title-link" itemprop="url">Bad Speculation</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-11-21 15:29:24" itemprop="dateCreated datePublished" datetime="2025-11-21T15:29:24+00:00">2025-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-23 11:34:45" itemprop="dateModified" datetime="2025-12-23T11:34:45+00:00">2025-12-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Bad Speculation 指不好的预测，尤其是分支预测。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/11/21/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/11/21/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/" class="post-title-link" itemprop="url">分支预测</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-11-21 15:29:02" itemprop="dateCreated datePublished" datetime="2025-11-21T15:29:02+00:00">2025-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-23 11:34:45" itemprop="dateModified" datetime="2025-12-23T11:34:45+00:00">2025-12-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/11/21/perf/core-bound/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/11/21/perf/core-bound/" class="post-title-link" itemprop="url">Core Bound</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-11-21 14:05:58" itemprop="dateCreated datePublished" datetime="2025-11-21T14:05:58+00:00">2025-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-12-23 11:34:45" itemprop="dateModified" datetime="2025-12-23T11:34:45+00:00">2025-12-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Core Bound 指 CPU 核心计算能力受限。包括两种：</p>
<ol>
<li>硬件的计算资源不足（吞吐量受限）</li>
</ol>
<ul>
<li>port 冲突：例如 Intel Skylake 架构上，除法和平方根运算都会被分配到 port 0 上，如果大量的类似耗时操<br>作排队，那么就会体现为硬件算力的限制。</li>
</ul>
<p><strong>Port 指的是 CPU 内部的 执行端口（execution ports）。</strong></p>
<blockquote>
<p>现代 CPU（尤其是 Intel、AMD 的 x86-64 架构）采用 超标量、乱序执行，有多个功能单元可以并行执行不同<br>类型的指令。</p>
<p>每个功能单元挂在一个 端口 (port) 上，负责特定类型的操作，比如：</p>
<ul>
<li>整数运算端口（加减、逻辑运算）</li>
<li>浮点运算端口（乘法、除法、加法）</li>
<li>加载端口（从内存读取数据）</li>
<li>存储端口（写数据到内存）</li>
</ul>
<p>CPU 的调度器会把指令分配到合适的端口执行。</p>
<p>如果某类端口资源不足，就会出现 port bound（端口受限），性能瓶颈来自于某个端口的拥塞。</p>
<p>👉 举例： Intel Skylake 架构有 8 个端口：</p>
<ul>
<li>Port 0&#x2F;1：整数和浮点运算</li>
<li>Port 2&#x2F;3：加载（Load）</li>
<li>Port 4：存储地址计算</li>
<li>Port 5：存储数据</li>
<li>Port 6：分支预测</li>
<li>Port 7：整数运算</li>
</ul>
</blockquote>
<ol start="2">
<li>指令间的依赖（增加延迟）</li>
</ol>
<p>例如链表的遍历，CPU 无法对其并行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (n) &#123;</span><br><span class="line">    n = n-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>第 1 种计算能力受限的问题，最好的办法是升级 CPU，换成具有更多除数的型号，或者将计算任务卸载到加速器<br>上。</p>
<p>第 2 种数据依赖链的问题，可能需要重写算法。下面介绍一些有名的优化方法：</p>
<ol>
<li>向量化</li>
<li>函数 inline 化</li>
<li>循环转换</li>
<li>编译器内建函数</li>
<li>其他</li>
</ol>
<p>目的是减少执行的指令或用更好的汇编指令替代。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/12/">12</a><a class="extend next" rel="next" href="/blog/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="bi-an"
      src="/blog/images/avatar.gif">
  <p class="site-author-name" itemprop="name">bi-an</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">119</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/bi-an" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;bi-an" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ah_zzg@126.com" title="E-Mail → mailto:ah_zzg@126.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://cuda-doc.readthedocs.io/" title="https:&#x2F;&#x2F;cuda-doc.readthedocs.io" rel="noopener" target="_blank">CUDA中文手册</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://infiniband-doc.readthedocs.io/" title="https:&#x2F;&#x2F;infiniband-doc.readthedocs.io&#x2F;" rel="noopener" target="_blank">InfiniBand中文手册</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bi-an</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>




  




  
<script src="/blog/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

</body>
</html>
