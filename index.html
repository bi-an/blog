<!DOCTYPE html>
<html lang="en, zh_CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"bi-an.github.io","root":"/blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="江南人物的博客">
<meta property="og:url" content="https://bi-an.github.io/blog/index.html">
<meta property="og:site_name" content="江南人物的博客">
<meta property="og:locale">
<meta property="article:author" content="bi-an">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://bi-an.github.io/blog/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en, zh_CN'
  };
</script>

  <title>江南人物的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">江南人物的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-resource">

    <a href="/blog/resources/" rel="section"><i class="fa fa-paperclip fa-fw"></i>Resource</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/09/15/concurrency/ABA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/09/15/concurrency/ABA/" class="post-title-link" itemprop="url">CAS 的 ABA问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-09-15 19:48:58 / Modified: 11:59:20" itemprop="dateCreated datePublished" datetime="2025-09-15T19:48:58+00:00">2025-09-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="Hazard-Pointer（危险指针）"><a href="#Hazard-Pointer（危险指针）" class="headerlink" title="Hazard Pointer（危险指针）"></a>Hazard Pointer（危险指针）</h3><p>思路：每个线程在访问共享指针之前，把自己正在访问的指针写到一个全局可见的“hazard pointer”里。</p>
<p>作用：其他线程在想要回收这个节点内存时，必须检查所有线程的 hazard pointers，如果发现有人还在用这个节<br>点，就不能释放。</p>
<p>优点：简单直接，内存可以安全回收。</p>
<p>缺点：维护 hazard pointers 有一定开销，每次回收都要检查所有线程。</p>
<h3 id="Epoch-Based-Reclamation（基于世代的回收，简称-Epoch-GC）"><a href="#Epoch-Based-Reclamation（基于世代的回收，简称-Epoch-GC）" class="headerlink" title="Epoch-Based Reclamation（基于世代的回收，简称 Epoch GC）"></a>Epoch-Based Reclamation（基于世代的回收，简称 Epoch GC）</h3><p>思路：把时间切分成 epoch（世代）。线程进入临界区时声明自己在某个 epoch。当一个节点被删除后，先放到一<br>个“延迟回收队列”，等到所有线程都离开这个 epoch 之后，才能真正释放这些节点。</p>
<p>作用：保证没有线程会在旧 epoch 中访问到已经释放的节点。</p>
<p>优点：比 hazard pointer 更高效（不用逐个检查指针）。</p>
<p>缺点：需要所有线程都周期性地报告自己活跃的 epoch，否则内存可能迟迟回收不了。</p>
<p>🚩 为什么会和 ABA 有关？</p>
<p>像 Michael-Scott 队列这种链表结构，节点被 pop 出队后地址可能被重用。如果没有安全的内存回收，另一个线<br>程可能 CAS 成功指向了一个“已经被释放并重用的地址”，这就是 ABA 的根源。所以 hazard pointer 或 epoch<br>GC 是在链表队列里用来避免这种 悬空引用 + ABA 的。</p>
<p>而 moodycamel::ConcurrentQueue 因为用的是 环形 buffer + sequence number，节点不会反复 malloc&#x2F;free，<br>所以根本就不需要 hazard pointer 或 epoch GC。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/09/13/concurrency/SPSC-lock-free-queue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/09/13/concurrency/SPSC-lock-free-queue/" class="post-title-link" itemprop="url">单生产者 - 单消费者 无锁队列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-09-13 17:09:37" itemprop="dateCreated datePublished" datetime="2025-09-13T17:09:37+00:00">2025-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-15 11:59:20" itemprop="dateModified" datetime="2025-09-15T11:59:20+00:00">2025-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/concurrency/" itemprop="url" rel="index"><span itemprop="name">concurrency</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是阅读 Cameron Desrochers 的 <a target="_blank" rel="noopener" href="https://moodycamel.com/blog/2013/a-fast-lock-free-queue-for-c++">A Fast Lock-Free Queue for C++</a> 源码的笔记。</p>
<p>仓库地址：<a target="_blank" rel="noopener" href="https://github.com/cameron314/readerwriterqueue">https://github.com/cameron314/readerwriterqueue</a></p>
<p>其他参考文献：</p>
<p><a target="_blank" rel="noopener" href="https://preshing.com/20120612/an-introduction-to-lock-free-programming/">An Introduction to Lock-Free Programming</a><br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=A8eCGOqgvH4&list=PLjwoip0ltHwHCe0Nw7PDPtzlJP7rUouRL">C++ and Beyond 2012: Herb Sutter - atomic Weapons 1 of 2</a><br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=KeLBd2EJLOU">C++ and Beyond 2012: Herb Sutter - atomic Weapons 2 of 2</a></p>
<h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>约束 memory loads&#x2F;stores 的顺序。</p>
<ul>
<li>releaase 内存屏障：告诉 CPU，如果屏障之后的任何写入变得可见，那么屏障之前的任何写入都应该在其他核心中可见，前提是其他核心在读取 写屏障之后写入的数据 后执行读屏障。<br>换句话说，如果线程 B 可以看到在另一个线程 A 上的写屏障之后写入的新值，那么在执行读屏障（在线程 B 上）之后，可以保证在线程 A 上的写屏障之前发生的所有写入在线程 B 上可见。</li>
</ul>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><ol>
<li>block: 一个连续的环形缓冲区，用来存储元素。这样可以预分配内存。</li>
<li>块过小（这不利于无锁）时，无需将所有现有元素复制到新的块中；多个块（大小独立）以循环链表的形式链接在一起。</li>
<li>当前插入的块称为 “尾块”，当前消费的块称为 “头块”。</li>
<li>头索引指向下一个要读取的满槽；尾索引指向下一个要插入的空槽。如果两个索引相等，则块为空（确切地说，当队列已满时，恰好有一个插槽为空，以避免在具有相同头和尾索引的满块和空块之间产生歧义）。</li>
<li>为了允许队列对任意线程创建 &#x2F; 析构（独立于生产 &#x2F; 消费线程），全内存屏障（memory_order_acq_cst）被用在析构函数地最后、析构函数的开头（这会强制所有的 CPU cores 同步 outstanding changes）。显然，在析构函数可以被安全地调用之前，生产者和消费者必须已经停止使用该队列。</li>
</ol>
<h2 id="Give-me-the-codes"><a href="#Give-me-the-codes" class="headerlink" title="Give me the codes"></a>Give me the codes</h2><ol>
<li>用户不需要管理内存。</li>
<li>预分配内存，在连续的块中。</li>
<li><code>try_enqueue</code>: 保证不会分配内存（队列有初始容量）；</li>
<li><code>enqueue</code>: 会根据需要动态扩容。</li>
<li>没有使用 CAS loop；这意味者 enqueue 和 dequeue 是 O(1) 的（没有计入内存分配的时间）。</li>
<li>因为在 x86 平台，内存屏障是空操作，所以 enqueue 和 dequeue 是一系列简单的 loads 和 stores (and branches) 。</li>
</ol>
<p>此代码仅仅适用于以原子方式处理 自然对齐的整型（aligned integer） 和 原生指针大小（native-pointer-size） 的 loads&#x2F;stores 的 CPU 上；<br>幸运的是，这包括了所有的现代处理器（包括 ARM, x86&#x2F;x86_64 和 PowerPC）。<br>它不是为在 DEC Alpha 上运行而设计的（DEC Alpha 似乎具有有史以来最弱的内存排序保证）。</p>
<p>注：在 x86 上，memory_order_acquire&#x2F;release 通常不需要额外指令就能实现语义，但仍然能限制编译器的重排。<br>fetch_add 不是一个原子操作，而是三个：load, add, store. 所以不适用上述说的 “自然对齐的整型” 或“原生指针大小”的 load&#x2F;store.</p>
<h2 id="性能优化点"><a href="#性能优化点" class="headerlink" title="性能优化点"></a>性能优化点</h2><ol>
<li>平凡析构：跳过析构，直接释放内存。</li>
<li><a target="_blank" rel="noopener" href="http://www.cse.cuhk.edu.hk/~pclee/www/pubs/ancs09poster.pdf">MCRingBuffer paper</a><ol>
<li>cache line padding</li>
<li>local control variables<ol>
<li>减少对全局 read&#x2F;write 指针的读取</li>
</ol>
</li>
<li>local block</li>
</ol>
</li>
</ol>
<h2 id="正确性测试"><a href="#正确性测试" class="headerlink" title="正确性测试"></a>正确性测试</h2><ol>
<li>定义不可预测性延时函数，用于模拟线程调度。</li>
<li>写线程塞入 32 M 个数据；读线程读取 32 M 次。读写线程中使用 unpredDelay() 模拟调度延迟。</li>
<li>测试能否顺序读取，失败则打印日志，不退出。</li>
<li>测试程序无限运行，每次使用一个写线程和读线程。直至手动 Ctrl C 关闭。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/09/08/%E6%B5%8B%E8%AF%95%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/09/08/%E6%B5%8B%E8%AF%95%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD/" class="post-title-link" itemprop="url">测试磁盘性能</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-09-08 11:27:57" itemprop="dateCreated datePublished" datetime="2025-09-08T11:27:57+00:00">2025-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-15 11:59:20" itemprop="dateModified" datetime="2025-09-15T11:59:20+00:00">2025-09-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="查看磁盘类型"><a href="#查看磁盘类型" class="headerlink" title="查看磁盘类型"></a>查看磁盘类型</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lsblk -d -o name,rota,<span class="built_in">type</span>,size,model</span><br><span class="line">NAME ROTA TYPE  SIZE MODEL</span><br><span class="line">sda     1 disk  1.8T PERC H740P Mini</span><br></pre></td></tr></table></figure>

<p><code>ROTA=1</code>：这是旋转磁盘。</p>
<h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><p>顺序写吞吐测试（逼近最大写入速度）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=seqwrite --rw=write --bs=1M --size=5G --numjobs=4 --iodepth=32 --direct=1 --runtime=60 --group_reporting</span><br></pre></td></tr></table></figure>

<p>随机读 IOPS 测试（逼近最大并发处理能力）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=randread --rw=randread --bs=4k --size=5G --numjobs=4 --iodepth=64 --direct=1 --runtime=60 --group_reporting</span><br></pre></td></tr></table></figure>

<p>混合读写测试（模拟数据库负载）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=mixrw --rw=randrw --rwmixread=70 --bs=4k --size=5G --numjobs=4 --iodepth=32 --direct=1 --runtime=60 --group_reporting</span><br></pre></td></tr></table></figure>


<h2 id="磁盘的测试结果"><a href="#磁盘的测试结果" class="headerlink" title="磁盘的测试结果"></a>磁盘的测试结果</h2><p>由于是旋转磁盘，iodepth 总是 1（设成其他值不会生效）</p>
<p><strong>单线程读写文件：</strong></p>
<details>
  <summary>点击展开代码</summary>
  <pre>
    <figure class="highlight bash"><figcaption><span>fio_bs_test.sh</span><a href="/blog/downloads/code/fio_bs_test.sh">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试参数</span></span><br><span class="line">DEVICE=<span class="string">&quot;./testfile&quot;</span>   <span class="comment"># 修改为你要测试的文件或设备路径</span></span><br><span class="line">RUNTIME=30                       <span class="comment"># 每个测试运行时间（秒）</span></span><br><span class="line"><span class="comment"># BLOCK_SIZES=(&quot;4k&quot; &quot;16k&quot; &quot;64k&quot; &quot;256k&quot; &quot;1M&quot; &quot;4M&quot; &quot;16M&quot; &quot;32M&quot; &quot;64M&quot; &quot;128M&quot;)  # 测试块大小列表</span></span><br><span class="line">BLOCK_SIZES=(<span class="string">&quot;128M&quot;</span> <span class="string">&quot;64M&quot;</span> <span class="string">&quot;32M&quot;</span> <span class="string">&quot;16M&quot;</span> <span class="string">&quot;4M&quot;</span> <span class="string">&quot;1M&quot;</span> <span class="string">&quot;256k&quot;</span> <span class="string">&quot;64k&quot;</span> <span class="string">&quot;16k&quot;</span> <span class="string">&quot;4k&quot;</span>)  <span class="comment"># 测试块大小列表</span></span><br><span class="line">LOG_FILE=<span class="string">&quot;fio_bs_output.log&quot;</span>        <span class="comment"># 原始输出日志文件</span></span><br><span class="line">PERFORMANCE_LOG=<span class="string">&quot;fio_bs_performance.log&quot;</span>  <span class="comment"># 性能结果日志文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出表头</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%-8s | %-10s | %-8s | %-10s | %-10s\n&quot;</span> <span class="string">&quot;RW&quot;</span> <span class="string">&quot;BlockSize&quot;</span> <span class="string">&quot;IOPS&quot;</span> <span class="string">&quot;BW(MiB/s)&quot;</span> <span class="string">&quot;AvgLat(ms)&quot;</span> | <span class="built_in">tee</span> <span class="string">&quot;<span class="variable">$PERFORMANCE_LOG</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;-------------------------------------------------------------&quot;</span> | <span class="built_in">tee</span> -a <span class="string">&quot;<span class="variable">$PERFORMANCE_LOG</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt; <span class="string">&quot;<span class="variable">$LOG_FILE</span>&quot;</span>  <span class="comment"># 清空日志文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环测试不同块大小</span></span><br><span class="line"><span class="keyword">for</span> RW <span class="keyword">in</span> <span class="built_in">read</span> write; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">for</span> BS <span class="keyword">in</span> <span class="string">&quot;<span class="variable">${BLOCK_SIZES[@]}</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    OUTPUT=$(fio --name=bs_test \</span><br><span class="line">                 --filename=<span class="string">&quot;<span class="variable">$DEVICE</span>&quot;</span> \</span><br><span class="line">                 --rw=<span class="variable">$RW</span> \</span><br><span class="line">                 --bs=<span class="variable">$BS</span> \</span><br><span class="line">                 --size=1G \</span><br><span class="line">                 --time_based \</span><br><span class="line">                 --runtime=<span class="variable">$RUNTIME</span> \</span><br><span class="line">                 --numjobs=1 \</span><br><span class="line">                 --direct=1 \</span><br><span class="line">                 --ioengine=psync \</span><br><span class="line">                 --group_reporting)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;----------------------------------------------&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$LOG_FILE</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$OUTPUT</span>&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$LOG_FILE</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$LOG_FILE</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提取关键指标</span></span><br><span class="line">    <span class="built_in">read</span> IOPS BW BWUNIT LAT LAT_UNIT &lt;&lt;&lt; $(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$OUTPUT</span>&quot;</span> | awk <span class="string">&#x27;</span></span><br><span class="line"><span class="string">        /IOPS=/ {match($0, /IOPS= *([0-9.]+)/, iops)}</span></span><br><span class="line"><span class="string">        /BW=/ {</span></span><br><span class="line"><span class="string">            match($0, /BW= *([0-9.]+)([KMG]iB)\/s/, bwinfo)</span></span><br><span class="line"><span class="string">            bwval=bwinfo[1]; bwunit=bwinfo[2]</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">        /clat \(/ {match($0, /avg= *([0-9.]+),/, lat); match($0, /\(([^)]+)\)/, lat_unit)}</span></span><br><span class="line"><span class="string">        END {print iops[1], bwval, bwunit, lat[1], lat_unit[1]}</span></span><br><span class="line"><span class="string">    &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 延迟单位换算</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$LAT_UNIT</span>&quot;</span> = <span class="string">&quot;usec&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        LAT_MS=$(awk <span class="string">&quot;BEGIN {printf \&quot;%.2f\&quot;, <span class="variable">$LAT</span>/1000}&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$LAT_UNIT</span>&quot;</span> = <span class="string">&quot;msec&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        LAT_MS=<span class="variable">$LAT</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        LAT_MS=<span class="string">&quot;Unknown&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 带宽单位换算为 MiB/s</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$BWUNIT</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        <span class="string">&quot;KiB&quot;</span>) BW_MIB=$(awk <span class="string">&quot;BEGIN {printf \&quot;%.2f\&quot;, <span class="variable">$BW</span>/1024}&quot;</span>) ;;</span><br><span class="line">        <span class="string">&quot;MiB&quot;</span>) BW_MIB=<span class="variable">$BW</span> ;;</span><br><span class="line">        <span class="string">&quot;GiB&quot;</span>) BW_MIB=$(awk <span class="string">&quot;BEGIN {printf \&quot;%.2f\&quot;, <span class="variable">$BW</span>*1024}&quot;</span>) ;;</span><br><span class="line">        *) BW_MIB=<span class="string">&quot;Unknown&quot;</span> ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出结果行</span></span><br><span class="line">    <span class="built_in">printf</span> <span class="string">&quot;%-8s | %-10s | %-8s | %-10s | %-10s\n&quot;</span> <span class="string">&quot;<span class="variable">$RW</span>&quot;</span> <span class="string">&quot;<span class="variable">$BS</span>&quot;</span> <span class="string">&quot;<span class="variable">$IOPS</span>&quot;</span> <span class="string">&quot;<span class="variable">$BW_MIB</span>&quot;</span> <span class="string">&quot;<span class="variable">$LAT_MS</span>&quot;</span> | <span class="built_in">tee</span> -a <span class="string">&quot;<span class="variable">$PERFORMANCE_LOG</span>&quot;</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 fio 创建的测试文件</span></span><br><span class="line"><span class="built_in">rm</span> -f <span class="string">&quot;<span class="variable">$DEVICE</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;测试完成，结果已保存到 <span class="variable">$LOG_FILE</span> 和 <span class="variable">$PERFORMANCE_LOG</span>&quot;</span></span><br></pre></td></tr></table></figure>
  </pre>
</details>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RW       | BlockSize  | IOPS     | BW(MiB/s)  | AvgLat(ms)</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">read     | 4k         | 194      | 0.76       | 5.14</span><br><span class="line">read     | 16k        | 239      | 3.74       | 4.17</span><br><span class="line">read     | 64k        | 347      | 21.7       | 2.88</span><br><span class="line">read     | 256k       | 271      | 67.9       | 3.68</span><br><span class="line">read     | 1M         | 94       | 94.9       | 10.53</span><br><span class="line">read     | 4M         | 14       | 57.2       | 69.74</span><br><span class="line">read     | 16M        | 6        | 97.6       | 163.96</span><br><span class="line">read     | 32M        | 3        | 111        | 288.99</span><br><span class="line">read     | 64M        | 1        | 112        | 573.70</span><br><span class="line">read     | 128M       | 0        | 112        | 1147.00</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RW       | BlockSize  | IOPS     | BW(MiB/s)  | AvgLat(ms)</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">write    | 4k         | 1884     | 7.36       | 0.53</span><br><span class="line">write    | 16k        | 1452     | 22.7       | 0.69</span><br><span class="line">write    | 64k        | 793      | 49.6       | 1.26</span><br><span class="line">write    | 256k       | 307      | 76.8       | 3.24</span><br><span class="line">write    | 1M         | 100      | 100        | 9.96</span><br><span class="line">write    | 4M         | 18       | 73.7       | 53.99</span><br><span class="line">write    | 16M        | 5        | 93.8       | 169.43</span><br><span class="line">write    | 32M        | 3        | 101        | 313.24</span><br><span class="line">write    | 64M        | 1        | 107        | 594.46</span><br><span class="line">write    | 128M       | 0        | 102        | 1249.35</span><br></pre></td></tr></table></figure>


<p>当 BlockSize&#x3D;32M 以后，写入性能基本达到顶峰（110 MiB&#x2F;s），和旋转磁盘的参数基本一致。</p>
<p><strong>多线程读写同一个文件，BS&#x3D;64KiB：</strong></p>
<details>
  <summary>点击展开代码</summary>
  <pre>
    <figure class="highlight bash"><figcaption><span>fio_mt_test.sh</span><a href="/blog/downloads/code/fio_mt_test.sh">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">DEVICE=<span class="string">&quot;./mt_testfile&quot;</span>   <span class="comment"># 测试文件路径</span></span><br><span class="line">RUNTIME=30            <span class="comment"># 每个测试运行时间（秒）</span></span><br><span class="line">THREADS=(1 2 4 8 16 32 64 72 120)  <span class="comment"># 测试线程数列表</span></span><br><span class="line">BLOCK_SIZE=<span class="string">&quot;64k&quot;</span>      <span class="comment"># 块大小，可根据需要修改</span></span><br><span class="line">LOG_FILE=<span class="string">&quot;fio_thread_output.log&quot;</span></span><br><span class="line">PERFORMANCE_LOG=<span class="string">&quot;fio_thread_performance.log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出表头</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%-8s | %-8s | %-10s | %-10s | %-10s\n&quot;</span> <span class="string">&quot;RW&quot;</span> <span class="string">&quot;Threads&quot;</span> <span class="string">&quot;IOPS&quot;</span> <span class="string">&quot;BW(MiB/s)&quot;</span> <span class="string">&quot;AvgLat(ms)&quot;</span> | <span class="built_in">tee</span> <span class="string">&quot;<span class="variable">$PERFORMANCE_LOG</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;---------------------------------------------------------------&quot;</span> | <span class="built_in">tee</span> -a <span class="string">&quot;<span class="variable">$PERFORMANCE_LOG</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt; <span class="string">&quot;<span class="variable">$LOG_FILE</span>&quot;</span>  <span class="comment"># 清空日志文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> RW <span class="keyword">in</span> <span class="built_in">read</span> write; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">for</span> THREAD <span class="keyword">in</span> <span class="string">&quot;<span class="variable">${THREADS[@]}</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    OUTPUT=$(fio --name=thread_test \</span><br><span class="line">                 --filename=<span class="string">&quot;<span class="variable">$DEVICE</span>&quot;</span> \</span><br><span class="line">                 --rw=<span class="variable">$RW</span> \</span><br><span class="line">                 --bs=<span class="variable">$BLOCK_SIZE</span> \</span><br><span class="line">                 --size=5G \</span><br><span class="line">                 --time_based \</span><br><span class="line">                 --runtime=<span class="variable">$RUNTIME</span> \</span><br><span class="line">                 --numjobs=<span class="variable">$THREAD</span> \</span><br><span class="line">                 --direct=1 \</span><br><span class="line">                 --ioengine=psync \</span><br><span class="line">                 --group_reporting)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;---------------------------------------------------------------&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$LOG_FILE</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$OUTPUT</span>&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$LOG_FILE</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$LOG_FILE</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提取关键指标</span></span><br><span class="line">    <span class="built_in">read</span> IOPS BW BWUNIT LAT LAT_UNIT &lt;&lt;&lt; $(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$OUTPUT</span>&quot;</span> | awk <span class="string">&#x27;</span></span><br><span class="line"><span class="string">        /IOPS=/ {match($0, /IOPS= *([0-9.]+)/, iops)}</span></span><br><span class="line"><span class="string">        /BW=/ {</span></span><br><span class="line"><span class="string">            match($0, /BW= *([0-9.]+)([KMG]iB)\/s/, bwinfo)</span></span><br><span class="line"><span class="string">            bwval=bwinfo[1]; bwunit=bwinfo[2]</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">        /clat \(/ {match($0, /avg= *([0-9.]+),/, lat); match($0, /\(([^)]+)\)/, lat_unit)}</span></span><br><span class="line"><span class="string">        END {print iops[1], bwval, bwunit, lat[1], lat_unit[1]}</span></span><br><span class="line"><span class="string">    &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 延迟单位换算</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$LAT_UNIT</span>&quot;</span> = <span class="string">&quot;usec&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        LAT_MS=$(awk <span class="string">&quot;BEGIN {printf \&quot;%.2f\&quot;, <span class="variable">$LAT</span>/1000}&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$LAT_UNIT</span>&quot;</span> = <span class="string">&quot;msec&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        LAT_MS=<span class="variable">$LAT</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        LAT_MS=<span class="string">&quot;Unknown&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 带宽单位换算为 MiB/s</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$BWUNIT</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">        <span class="string">&quot;KiB&quot;</span>) BW_MIB=$(awk <span class="string">&quot;BEGIN {printf \&quot;%.2f\&quot;, <span class="variable">$BW</span>/1024}&quot;</span>) ;;</span><br><span class="line">        <span class="string">&quot;MiB&quot;</span>) BW_MIB=<span class="variable">$BW</span> ;;</span><br><span class="line">        <span class="string">&quot;GiB&quot;</span>) BW_MIB=$(awk <span class="string">&quot;BEGIN {printf \&quot;%.2f\&quot;, <span class="variable">$BW</span>*1024}&quot;</span>) ;;</span><br><span class="line">        *) BW_MIB=<span class="string">&quot;Unknown&quot;</span> ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出结果行</span></span><br><span class="line">  <span class="built_in">printf</span> <span class="string">&quot;%-8s | %-8s | %-10s | %-10s | %-10s\n&quot;</span> <span class="string">&quot;<span class="variable">$RW</span>&quot;</span> <span class="string">&quot;<span class="variable">$THREAD</span>&quot;</span> <span class="string">&quot;<span class="variable">$IOPS</span>&quot;</span> <span class="string">&quot;<span class="variable">$BW_MIB</span>&quot;</span> <span class="string">&quot;<span class="variable">$LAT_MS</span>&quot;</span> | <span class="built_in">tee</span> -a <span class="string">&quot;<span class="variable">$PERFORMANCE_LOG</span>&quot;</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -f <span class="string">&quot;<span class="variable">$DEVICE</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;测试完成，结果已保存到 <span class="variable">$LOG_FILE</span> 和 <span class="variable">$PERFORMANCE_LOG</span>&quot;</span></span><br></pre></td></tr></table></figure>
  </pre>
</details>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RW       | Threads  | IOPS       | BW(MiB/s)  | AvgLat(ms)</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">read     | 1        | 826        | 51.6       | 1.21</span><br><span class="line">read     | 2        | 1300       | 81.3       | 1.54</span><br><span class="line">read     | 4        | 1681       | 105        | 2.38</span><br><span class="line">read     | 8        | 1778       | 111        | 4.49</span><br><span class="line">read     | 16       | 1789       | 112        | 8.93</span><br><span class="line">read     | 32       | 1790       | 112        | 17.86</span><br><span class="line">read     | 64       | 1789       | 112        | 35.73</span><br><span class="line">read     | 72       | 1790       | 112        | 40.18</span><br><span class="line">read     | 120      | 1789       | 112        | 66.98</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RW       | Threads  | IOPS       | BW(MiB/s)  | AvgLat(ms)</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">write    | 1        | 847        | 52.9       | 1.18</span><br><span class="line">write    | 2        | 1367       | 85.5       | 1.46</span><br><span class="line">write    | 4        | 1757       | 110        | 2.27</span><br><span class="line">write    | 8        | 1786       | 112        | 4.47</span><br><span class="line">write    | 16       | 1788       | 112        | 8.92</span><br><span class="line">write    | 32       | 1788       | 112        | 17.79</span><br><span class="line">write    | 64       | 1788       | 112        | 35.09</span><br><span class="line">write    | 72       | 1788       | 112        | 39.54</span><br><span class="line">write    | 120      | 1784       | 112        | 64.50</span><br></pre></td></tr></table></figure>

<p>当线程数增加，IO 性能随之提高，可能原因是 64KiB 小块数据大量提交到 I&#x2F;O 队列，操作系统能更好地完成读写路径优化。<br>但达到8线程的时候，就基本到达性能顶峰了。</p>
<p>注意：fio 多线程写入同一个文件是没有加锁的，如果超过 page cache (一般是 4 KB)，那么可能乱序写入。</p>
<h2 id="概念（以-fio-为例）"><a href="#概念（以-fio-为例）" class="headerlink" title="概念（以 fio 为例）"></a>概念（以 fio 为例）</h2><h3 id="ioengine"><a href="#ioengine" class="headerlink" title="ioengine"></a>ioengine</h3><p>ioengine（I&#x2F;O 引擎）是 fio 提供以执行读写任务的底层接口。不同的引擎代表不同的 I&#x2F;O 模型，比如同步、异步、内存映射、零拷贝等。</p>
<table>
<thead>
<tr>
<th align="center">引擎名称</th>
<th align="center">类型</th>
<th align="center">特点与用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sync</td>
<td align="center">同步</td>
<td align="center">默认方式，每次 I&#x2F;O 都等待完成，适合简单测试</td>
</tr>
<tr>
<td align="center">psync</td>
<td align="center">同步</td>
<td align="center">使用 pread&#x2F;pwrite，可指定偏移，略快</td>
</tr>
<tr>
<td align="center">libaio</td>
<td align="center">异步</td>
<td align="center">Linux 异步 I&#x2F;O，适合高性能 SSD&#x2F;NVMe</td>
</tr>
<tr>
<td align="center">io_uring</td>
<td align="center">异步</td>
<td align="center">新一代 Linux 异步接口，低延迟、高并发</td>
</tr>
<tr>
<td align="center">mmap</td>
<td align="center">内存映射</td>
<td align="center">将文件映射到内存，适合大文件顺序访问</td>
</tr>
<tr>
<td align="center">splice</td>
<td align="center">零拷贝</td>
<td align="center">用于高效数据传输，减少 CPU 和内存开销</td>
</tr>
<tr>
<td align="center">windowsaio</td>
<td align="center">异步</td>
<td align="center">Windows 原生异步 I&#x2F;O，适合多线程写入</td>
</tr>
<tr>
<td align="center">net</td>
<td align="center">网络</td>
<td align="center">用于网络 I&#x2F;O 测试，如 socket 传输</td>
</tr>
<tr>
<td align="center">sg</td>
<td align="center">SCSI</td>
<td align="center">用于直接访问 SCSI 设备</td>
</tr>
</tbody></table>
<p>每种 ioengine 都依赖操作系统提供的底层 I&#x2F;O 接口。例如：</p>
<table>
<thead>
<tr>
<th align="center">ioengine 类型</th>
<th align="center">操作系统要求</th>
<th align="center">是否异步</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sync &#x2F; psync</td>
<td align="center">所有系统</td>
<td align="center">❌</td>
<td align="center">使用标准阻塞 I&#x2F;O，几乎总是可用</td>
</tr>
<tr>
<td align="center">libaio</td>
<td align="center">Linux，需安装 libaio 库</td>
<td align="center">✅</td>
<td align="center">依赖 Linux 的异步 I&#x2F;O 接口</td>
</tr>
<tr>
<td align="center">io_uring</td>
<td align="center">Linux ≥ 5.1，推荐 ≥ 5.4</td>
<td align="center">✅</td>
<td align="center">依赖新内核特性和 liburing 库</td>
</tr>
<tr>
<td align="center">windowsaio</td>
<td align="center">Windows</td>
<td align="center">✅</td>
<td align="center">使用 Windows 原生异步 I&#x2F;O</td>
</tr>
<tr>
<td align="center">mmap</td>
<td align="center">所有主流系统</td>
<td align="center">❌</td>
<td align="center">使用内存映射，适合顺序读写</td>
</tr>
<tr>
<td align="center">posixaio</td>
<td align="center">POSIX 兼容系统</td>
<td align="center">✅</td>
<td align="center">使用 aio_read &#x2F; aio_write 接口</td>
</tr>
</tbody></table>
<p>你可以指定任意 ioengine （默认值是 sync &#x2F; psync），但它是否能运行，必须得到操作系统的支持。这包括内核版本、系统接口、库文件等。如果系统不支持，fio 会报错或自动回退。</p>
<p>查看支持列表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --enghelp</span><br></pre></td></tr></table></figure>

<p>这会列出当前系统上可用的 ioengine，但注意：列出来 ≠ 能用，还要看运行时是否报错。</p>
<p>实际测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=<span class="built_in">test</span> --ioengine=io_uring --rw=write --size=1G --bs=1M</span><br></pre></td></tr></table></figure>

<p>如果不支持，会报错，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio: pid=132756, err=38/file:engines/io_uring.c:1351, func=io_queue_init, error=Function not implemented</span><br></pre></td></tr></table></figure>

<h3 id="iodepth"><a href="#iodepth" class="headerlink" title="iodepth"></a>iodepth</h3><p><code>--iodepth</code> 是传递给内核的参数。</p>
<p>如果你不显式设置 <code>--iodepth</code>，那么 fio 会根据所选的 I&#x2F;O 引擎（<code>--ioengine</code>） 来决定默认值</p>
<table>
<thead>
<tr>
<th align="center">I&#x2F;O 引擎</th>
<th align="center">默认 iodepth</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sync &#x2F; psync &#x2F; vsync</td>
<td align="center">1（同步 I&#x2F;O，只能一个一个处理）</td>
</tr>
<tr>
<td align="center">libaio &#x2F; io_uring</td>
<td align="center">1，但可以设置更高以启用异步并发</td>
</tr>
<tr>
<td align="center">mmap &#x2F; pread &#x2F; pwrite</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">windowsaio（Windows）</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">sg（SCSI generic）</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>fio 并不会主动维护队列，队列是内核的特性。</p>
<table>
<thead>
<tr>
<th align="center">I&#x2F;O 引擎</th>
<th align="center">队列位置</th>
<th align="center">是否异步</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">psync &#x2F; sync</td>
<td align="center">无队列（直接调用）</td>
<td align="center">否</td>
<td align="center">每次写入调用 write()，无排队机制</td>
</tr>
<tr>
<td align="center">libaio</td>
<td align="center">内核空间</td>
<td align="center">✅ 是</td>
<td align="center">使用 Linux AIO，队列在内核中，由 io_submit() 提交</td>
</tr>
<tr>
<td align="center">io_uring</td>
<td align="center">用户 + 内核共享</td>
<td align="center">✅ 是</td>
<td align="center">使用环形缓冲区，用户空间提交，内核空间处理</td>
</tr>
<tr>
<td align="center">mmap &#x2F; null</td>
<td align="center">用户空间</td>
<td align="center">❌ 否</td>
<td align="center">模拟或跳过实际 I&#x2F;O，不涉及内核队列</td>
</tr>
</tbody></table>
<ul>
<li>对于支持异步 I&#x2F;O 的引擎（如 libaio 或 io_uring），你可以设置更高的 iodepth（如 32、64、128）来模拟高并发负载；</li>
<li>对 SSD 或 NVMe 设备，高 iodepth 能显著提升 IOPS 和吞吐量；</li>
<li>对机械硬盘，提升有限，但仍可用于测试调度策略和队列行为。</li>
</ul>
<p>但如果你的 ioengine 是 sync 或 psync，这些是同步阻塞 I&#x2F;O，根本不支持高并发，所以 iodepth 实际上不会生效。</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">–name&#x3D;seqwrite</td>
<td align="center">定义测试任务的名称为 seqwrite，用于标识输出结果</td>
</tr>
<tr>
<td align="center">–rw&#x3D;write</td>
<td align="center">设置为顺序写入模式（sequential write），数据按顺序写入磁盘</td>
</tr>
<tr>
<td align="center">–bs&#x3D;1M</td>
<td align="center">每次 I&#x2F;O 操作的块大小为 1MB，适合测试吞吐量</td>
</tr>
<tr>
<td align="center">–size&#x3D;5G</td>
<td align="center">每个线程写入的总数据量为 5GB（不是总共，是每个 job）</td>
</tr>
<tr>
<td align="center">–numjobs&#x3D;4</td>
<td align="center">启动 4 个并发线程（job），模拟多线程写入场景</td>
</tr>
<tr>
<td align="center">–iodepth&#x3D;32</td>
<td align="center">每个线程的 I&#x2F;O 队列深度为 32，表示最多可同时挂起 32 个 I&#x2F;O 请求 <br> 本例中每个线程会发起 5G&#x2F;1M&#x3D;5120 个 I&#x2F;O 请求</td>
</tr>
<tr>
<td align="center">–direct&#x3D;1</td>
<td align="center">绕过系统缓存，直接对磁盘进行读写，更真实地反映设备性能</td>
</tr>
<tr>
<td align="center">–runtime&#x3D;60</td>
<td align="center">测试持续时间为 60 秒，优先于 –size，<br>1. 即使数据写完也继续写更多数据直到时间结束 &lt; br&gt;2. 如果没有写完，则时间到就结束</td>
</tr>
<tr>
<td align="center">–group_reporting</td>
<td align="center">汇总所有线程的测试结果，输出整体性能指标而不是每个线程单独显示</td>
</tr>
</tbody></table>
<p>可能的代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libaio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_PATH <span class="string">&quot;testfile.bin&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCK_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IODEPTH 4  <span class="comment">// 控制并发请求数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(FILE_PATH, O_CREAT | O_WRONLY | O_DIRECT, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// io_setup 是 libaio 的函数</span></span><br><span class="line">    <span class="type">io_context_t</span> ctx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (io_setup(IODEPTH, &amp;ctx) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;io_setup&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iocb</span> *<span class="title">iocbs</span>[<span class="title">IODEPTH</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iocb</span> <span class="title">iocb_array</span>[<span class="title">IODEPTH</span>];</span></span><br><span class="line">    <span class="type">char</span> *buffers[IODEPTH];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; IODEPTH; i++) &#123;</span><br><span class="line">        <span class="comment">// 分配对齐内存</span></span><br><span class="line">        posix_memalign((<span class="type">void</span>**)&amp;buffers[i], BLOCK_SIZE, BLOCK_SIZE);</span><br><span class="line">        <span class="built_in">memset</span>(buffers[i], <span class="string">&#x27;A&#x27;</span> + i, BLOCK_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 iocb</span></span><br><span class="line">        io_prep_pwrite(&amp;iocb_array[i], fd, buffers[i], BLOCK_SIZE, i * BLOCK_SIZE);</span><br><span class="line">        iocbs[i] = &amp;iocb_array[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交所有请求</span></span><br><span class="line">    <span class="type">int</span> ret = io_submit(ctx, IODEPTH, iocbs);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;io_submit&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有请求完成</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_event</span> <span class="title">events</span>[<span class="title">IODEPTH</span>];</span></span><br><span class="line">    io_getevents(ctx, IODEPTH, IODEPTH, events, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; IODEPTH; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(buffers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    io_destroy(ctx);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;All %d I/O requests completed.\n&quot;</span>, IODEPTH);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h3><table>
<thead>
<tr>
<th>指标</th>
<th>含义</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>slat</td>
<td>Submission Latency</td>
<td>从 fio 发起 I&#x2F;O 请求到内核接收该请求的时间。通常很短，单位是微秒（usec）。</td>
</tr>
<tr>
<td>clat</td>
<td>Completion Latency</td>
<td>从内核接收请求到 I&#x2F;O 操作完成的时间。这个是最能反映存储设备性能的部分。</td>
</tr>
<tr>
<td>lat</td>
<td>Total Latency</td>
<td>总延迟，即 slat + clat，表示从 fio 发起请求到 I&#x2F;O 完成的整个过程。</td>
</tr>
</tbody></table>
<h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ fio --name=seqwrite --rw=write --bs=1M --size=5G --numjobs=2 --direct=1 --runtime=60 --group_reporting</span><br><span class="line">seqwrite: (g=0): rw=write, bs=(R) 1024KiB-1024KiB, (W) 1024KiB-1024KiB, (T) 1024KiB-1024KiB, ioengine=psync, iodepth=1</span><br><span class="line">...</span><br><span class="line">fio-3.41</span><br><span class="line">Starting 2 processes</span><br><span class="line">seqwrite: Laying out IO file (1 file / 5120MiB)</span><br><span class="line">seqwrite: Laying out IO file (1 file / 5120MiB)</span><br><span class="line">Jobs: 2 (f=2): [W(2)][100.0%][w=112MiB/s][w=112 IOPS][eta 00m:00s]</span><br><span class="line">seqwrite: (groupid=0, <span class="built_in">jobs</span>=2): err= 0: pid=70688: Sun Sep  7 22:37:47 2025</span><br><span class="line">  write: IOPS=111, BW=111MiB/s (117MB/s)(6685MiB/60016msec); 0 zone resets</span><br><span class="line">    clat (usec): min=9606, max=74763, avg=17922.82, stdev=1446.89</span><br><span class="line">     lat (usec): min=9628, max=74791, avg=17951.49, stdev=1446.80</span><br><span class="line">    clat percentiles (usec):</span><br><span class="line">     |  1.00th=[15008],  5.00th=[16319], 10.00th=[16909], 20.00th=[17433],</span><br><span class="line">     | 30.00th=[17695], 40.00th=[17695], 50.00th=[17957], 60.00th=[17957],</span><br><span class="line">     | 70.00th=[18220], 80.00th=[18482], 90.00th=[19006], 95.00th=[19268],</span><br><span class="line">     | 99.00th=[21365], 99.50th=[22414], 99.90th=[32375], 99.95th=[40109],</span><br><span class="line">     | 99.99th=[74974]</span><br><span class="line">   bw (KiB/s): min=96062, max=116736, per=100.00%, avg=114150.20, stdev=1061.35, samples=238</span><br><span class="line">   iops        : min=   92, max=  114, avg=110.77, stdev= 1.18, samples=238</span><br><span class="line">  lat (msec)   : 10=0.03%, 20=97.43%, 50=2.53%, 100=0.01%</span><br><span class="line">  cpu          : usr=0.22%, sys=0.75%, ctx=6717, majf=0, minf=67</span><br><span class="line">  IO depths    : 1=100.0%, 2=0.0%, 4=0.0%, 8=0.0%, 16=0.0%, 32=0.0%, &gt;=64=0.0%</span><br><span class="line">     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &gt;=64=0.0%</span><br><span class="line">     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &gt;=64=0.0%</span><br><span class="line">     issued rwts: total=0,6685,0,0 short=0,0,0,0 dropped=0,0,0,0</span><br><span class="line">     latency   : target=0, window=0, percentile=100.00%, depth=1</span><br><span class="line"></span><br><span class="line">Run status group 0 (all <span class="built_in">jobs</span>):</span><br><span class="line">  WRITE: bw=111MiB/s (117MB/s), 111MiB/s-111MiB/s (117MB/s-117MB/s), io=6685MiB (7010MB), run=60016-60016mse</span><br></pre></td></tr></table></figure>

<p>🧾 测试配置解析<br>bash<br>fio –name&#x3D;seqwrite –rw&#x3D;write –bs&#x3D;1M –size&#x3D;10G –numjobs&#x3D;1 –direct&#x3D;1 –runtime&#x3D;60 –group_reporting<br>参数	含义<br>rw&#x3D;write	顺序写入<br>bs&#x3D;1M	每次写入块大小为 1MiB<br>numjobs&#x3D;1	单线程写入<br>direct&#x3D;1	使用 Direct I&#x2F;O，绕过页缓存<br>ioengine&#x3D;psync	使用同步 I&#x2F;O（每次 pwrite()）<br>iodepth&#x3D;1	每次只挂起一个 I&#x2F;O 请求（同步模式下默认如此）<br>📊 性能结果概览<br>指标	数值	说明<br>IOPS	96	每秒执行 96 次写入操作<br>带宽	96.2 MiB&#x2F;s（101 MB&#x2F;s）	每秒写入约 96 MiB 数据<br>总写入量	5772 MiB	在 60 秒内完成的写入总量<br>延迟（avg clat）	10.36 ms	每次写入的平均完成时间<br>CPU 使用率	usr&#x3D;0.46%, sys&#x3D;1.23%	CPU 负载极低，瓶颈不在 CPU<br>⏱ 延迟分布分析<br>50% 的写入延迟低于 9.9 ms</p>
<p>95% 的写入低于 12.5 ms</p>
<p>99.95% 的写入延迟达到了 22.9 ms</p>
<p>最慢的写入高达 28.2 ms</p>
<p>尾部延迟略高，说明偶尔会有磁盘响应变慢的情况，可能是设备内部缓存刷新或寻址造成。</p>
<p>📈 带宽波动情况<br>平均带宽：约 96 MiB&#x2F;s</p>
<p>最小带宽：60 MiB&#x2F;s</p>
<p>最大带宽：104 MiB&#x2F;s</p>
<p>标准差：6.2 MiB&#x2F;s → 表明带宽相对稳定，但仍有轻微波动</p>
<p>🧠 深层解读<br>✅ 为什么 IOPS ≈ 带宽（MiB&#x2F;s）？<br>因为你设置了 bs&#x3D;1M，每次写入 1MiB 数据，所以：</p>
<p>Code<br>IOPS × Block Size &#x3D; Bandwidth<br>96 IOPS × 1 MiB &#x3D; 96 MiB&#x2F;s<br>✅ 为什么 Direct I&#x2F;O？<br>绕过页缓存，测试的是磁盘的真实物理性能，避免被内存加速 “欺骗”。</p>
<p>✅ 为什么使用 psync？<br>psync 是同步写入，每次调用 pwrite()，适合模拟数据库或日志系统的写入行为。但它无法并发挂起多个请求，限制了吞吐。</p>
<p>📌 性能瓶颈分析<br>磁盘类型：如果是 HDD，这个结果（96 MiB&#x2F;s）非常合理；如果是 SSD，则偏低，可能受限于同步 I&#x2F;O 或单线程。</p>
<p>IO 引擎限制：psync 是阻塞式，无法发挥磁盘的并发能力。</p>
<p>线程数限制：只有一个线程，磁盘可能未被充分利用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/09/03/cuda/CUDA%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/09/03/cuda/CUDA%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/" class="post-title-link" itemprop="url">CUDA矩阵乘法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-09-03 09:23:17" itemprop="dateCreated datePublished" datetime="2025-09-03T09:23:17+00:00">2025-09-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-15 11:59:20" itemprop="dateModified" datetime="2025-09-15T11:59:20+00:00">2025-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/CUDA/" itemprop="url" rel="index"><span itemprop="name">CUDA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="使用共享内存优化"><a href="#使用共享内存优化" class="headerlink" title="使用共享内存优化"></a>使用共享内存优化</h2><p><a href='https://postimg.cc/BjfXcPQ9' target='_blank'><img src='https://i.postimg.cc/dVLrFGb1/matrix-Mul.png' border='0' alt='matrix-Mul'/></a></p>
<figure class="highlight cpp"><figcaption><span>matrixMul.cpp</span><a href="/blog/downloads/code/cuda/matrixMul.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Matrix multiplication (CUDA Kernel) on the device: C = A * B</span></span><br><span class="line"><span class="comment"> * wA is A&#x27;s width and wB is B&#x27;s width</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> BLOCK_SIZE&gt; <span class="function">__global__ <span class="type">void</span> <span class="title">MatrixMulCUDA</span><span class="params">(<span class="type">float</span> *C, <span class="type">float</span> *A, <span class="type">float</span> *B, <span class="type">int</span> wA, <span class="type">int</span> wB)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Block index</span></span><br><span class="line">    <span class="type">int</span> bx = blockIdx.x;</span><br><span class="line">    <span class="type">int</span> by = blockIdx.y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Thread index</span></span><br><span class="line">    <span class="type">int</span> tx = threadIdx.x;</span><br><span class="line">    <span class="type">int</span> ty = threadIdx.y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Index of the first sub-matrix of A processed by the block</span></span><br><span class="line">    <span class="type">int</span> aBegin = wA * BLOCK_SIZE * by;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Index of the last sub-matrix of A processed by the block</span></span><br><span class="line">    <span class="type">int</span> aEnd = aBegin + wA - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step size used to iterate through the sub-matrices of A</span></span><br><span class="line">    <span class="type">int</span> aStep = BLOCK_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Index of the first sub-matrix of B processed by the block</span></span><br><span class="line">    <span class="type">int</span> bBegin = BLOCK_SIZE * bx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step size used to iterate through the sub-matrices of B</span></span><br><span class="line">    <span class="type">int</span> bStep = BLOCK_SIZE * wB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Csub is used to store the element of the block sub-matrix</span></span><br><span class="line">    <span class="comment">// that is computed by the thread</span></span><br><span class="line">    <span class="type">float</span> Csub = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loop over all the sub-matrices of A and B</span></span><br><span class="line">    <span class="comment">// required to compute the block sub-matrix</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = aBegin, b = bBegin; a &lt;= aEnd; a += aStep, b += bStep) {</span><br><span class="line">        <span class="comment">// Declaration of the shared memory array As used to</span></span><br><span class="line">        <span class="comment">// store the sub-matrix of A</span></span><br><span class="line">        __shared__ <span class="type">float</span> As[BLOCK_SIZE][BLOCK_SIZE];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Declaration of the shared memory array Bs used to</span></span><br><span class="line">        <span class="comment">// store the sub-matrix of B</span></span><br><span class="line">        __shared__ <span class="type">float</span> Bs[BLOCK_SIZE][BLOCK_SIZE];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Load the matrices from device memory</span></span><br><span class="line">        <span class="comment">// to shared memory; each thread loads</span></span><br><span class="line">        <span class="comment">// one element of each matrix</span></span><br><span class="line">        As[ty][tx] = A[a + wA * ty + tx];</span><br><span class="line">        Bs[ty][tx] = B[b + wB * ty + tx];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Synchronize to make sure the matrices are loaded</span></span><br><span class="line">        __syncthreads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Multiply the two matrices together;</span></span><br><span class="line">        <span class="comment">// each thread computes one element</span></span><br><span class="line">        <span class="comment">// of the block sub-matrix</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> unroll</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; BLOCK_SIZE; ++k) {</span><br><span class="line">            Csub += As[ty][k] * Bs[k][tx];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Synchronize to make sure that the preceding</span></span><br><span class="line">        <span class="comment">// computation is done before loading two new</span></span><br><span class="line">        <span class="comment">// sub-matrices of A and B in the next iteration</span></span><br><span class="line">        __syncthreads();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write the block sub-matrix to device memory;</span></span><br><span class="line">    <span class="comment">// each thread writes one element</span></span><br><span class="line">    <span class="type">int</span> c               = wB * BLOCK_SIZE * by + BLOCK_SIZE * bx;</span><br><span class="line">    C[c + wB * ty + tx] = Csub;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/09/02/concurrency/%E4%BA%BA%E4%BA%BA%E9%83%BD%E7%9C%8B%E5%BE%97%E6%87%82%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/09/02/concurrency/%E4%BA%BA%E4%BA%BA%E9%83%BD%E7%9C%8B%E5%BE%97%E6%87%82%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">人人都看得懂的内存模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-09-02 11:10:13" itemprop="dateCreated datePublished" datetime="2025-09-02T11:10:13+00:00">2025-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-15 11:59:20" itemprop="dateModified" datetime="2025-09-15T11:59:20+00:00">2025-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/c-cpp/" itemprop="url" rel="index"><span itemprop="name">c/cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>内存模型（Memory Model）是定义<strong>数据一致性</strong>与<strong>执行顺序</strong>规则的一组规范。</p>
<p>关键概念：</p>
<ol>
<li>原子性：操作不可打断；如果同时修改，硬件会串行排队。</li>
<li>可见性：对其他核心（即<strong>其他线程</strong>）可见，也就是 load 指令可以读到最新值。</li>
<li>顺序性：禁止<strong>本线程</strong>内的指令重排序。所以可以用作同步点。</li>
</ol>
<p>所有原子变量都满足原子性。但是其他两者不一定满足，由内存序定义。</p>
<p>比如原子自增 fetch_add(relaxed) 是线程安全的，但是无法使用 load 指令读到最新的结果。</p>
<h2 id="缓存一致性协议-MESI"><a href="#缓存一致性协议-MESI" class="headerlink" title="缓存一致性协议 (MESI)"></a>缓存一致性协议 (MESI)</h2><table>
<thead>
<tr>
<th align="center">状态</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">M (Modified)</td>
<td align="center">缓存行已被修改，只有当前 CPU 拥有，主内存未更新</td>
</tr>
<tr>
<td align="center">E (Exclusive)</td>
<td align="center">缓存行未被修改，只有当前 CPU 拥有，与主内存一致</td>
</tr>
<tr>
<td align="center">S (Shared)</td>
<td align="center">缓存行未被修改，多个 CPU 拥有，与主内存一致</td>
</tr>
<tr>
<td align="center">I (Invalid)</td>
<td align="center">缓存行无效，必须重新从主内存加载</td>
</tr>
</tbody></table>
<h2 id="relaxed-内存序"><a href="#relaxed-内存序" class="headerlink" title="relaxed 内存序"></a>relaxed 内存序</h2><p>术语：</p>
<ol>
<li>保证原子性：整个操作不可被打断；不一定立即回写主内存，可能暂时把结果放在 Store Buffer 中。</li>
<li>不保证顺序：编译器和CPU可能对指令重排序。</li>
<li>不保证可见性：其他核心不一定立即可见。</li>
</ol>
<p>说人话：</p>
<ol>
<li>原子性：原子操作是串行的（由硬件排队）</li>
<li>不保证可见性：<ul>
<li>load 操作是并行的，并且不保证看到最新值。</li>
<li>“可见性”是针对程序员的，因为对于 relaxed ，没有任何指令可以保证 load 拿到最新值。它可能直接从自己的缓存行中把旧值返回给你。</li>
<li>硬件本身是知道最新值的，它会根据 MESI 来保证自己当时拿到的是最新值（但是无法通过指令告知你）。</li>
</ul>
</li>
<li>不保证顺序：不是同步点，无法保证前后指令与程序员的编写顺序一致。</li>
</ol>
<table>
<thead>
<tr>
<th align="center">层级</th>
<th align="center">机制</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">指令级</td>
<td align="center">原子指令（如 LOCK XADD）</td>
<td align="center">保证操作不可打断</td>
</tr>
<tr>
<td align="center">缓存级</td>
<td align="center">MESI 协议</td>
<td align="center">控制缓存行访问，避免冲突</td>
</tr>
<tr>
<td align="center">编译器级</td>
<td align="center">编译器屏障</td>
<td align="center">防止指令重排</td>
</tr>
<tr>
<td align="center">CPU级</td>
<td align="center">内存屏障</td>
<td align="center">保证执行顺序</td>
</tr>
<tr>
<td align="center">高级机制</td>
<td align="center">事务性内存</td>
<td align="center">实现复杂原子逻辑（可选）</td>
</tr>
</tbody></table>
<h2 id="release-acquire-语义"><a href="#release-acquire-语义" class="headerlink" title="release-acquire 语义"></a>release-acquire 语义</h2><h2 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h2><ol>
<li>编译器指令重排：编译器屏障防止指令重排</li>
<li>CPU 乱序执行：内存屏障保证执行顺序。</li>
</ol>
<h2 id="原子指令"><a href="#原子指令" class="headerlink" title="原子指令"></a>原子指令</h2><p>原子指令（如 LOCK XADD）：保证操作不可打断</p>
<h2 id="Load-Store-Buffer"><a href="#Load-Store-Buffer" class="headerlink" title="Load &#x2F; Store Buffer"></a>Load &#x2F; Store Buffer</h2><h2 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h2><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/26/cpp/%E4%BD%8D%E7%BD%AE%E6%97%A0%E5%85%B3%E4%BB%A3%E7%A0%81PIC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/26/cpp/%E4%BD%8D%E7%BD%AE%E6%97%A0%E5%85%B3%E4%BB%A3%E7%A0%81PIC/" class="post-title-link" itemprop="url">位置无关代码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-26 13:54:18" itemprop="dateCreated datePublished" datetime="2025-08-26T13:54:18+00:00">2025-08-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-15 11:59:20" itemprop="dateModified" datetime="2025-09-15T11:59:20+00:00">2025-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/c-cpp/" itemprop="url" rel="index"><span itemprop="name">c/cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="位置无关代码（PIC）"><a href="#位置无关代码（PIC）" class="headerlink" title="位置无关代码（PIC）"></a>位置无关代码（PIC）</h2><ul>
<li>位置无关代码（<code>PIC</code>）：程序可以在内存中的任意位置运行，不需要修改代码中的绝对地址。</li>
<li>节省空间：相比使用 64 位绝对地址，RIP 相对寻址只需要一个 32 位偏移量。</li>
<li>更安全：支持地址随机化（ASLR），提高程序的安全性。</li>
</ul>
<p>在 x86-64 架构中，传统的绝对地址寻址方式不再适用于位置无关代码。于是引入了 RIP（指令指针）相对寻址：</p>
<p>假设你有一个全局变量 int x &#x3D; 42;，在汇编中访问它可能会变成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asm</span><br><span class="line">mov eax, DWORD PTR [rip + offset_to_x]</span><br></pre></td></tr></table></figure>

<p>这里的 offset_to_x 是编译器计算出来的 x 相对于当前指令的偏移量。</p>
<table>
<thead>
<tr>
<th align="center">寻址方式</th>
<th align="center">描述</th>
<th align="center">是否位置无关</th>
</tr>
</thead>
<tbody><tr>
<td align="center">绝对地址寻址</td>
<td align="center">使用固定地址，如 [0x400123]</td>
<td align="center">❌ 否</td>
</tr>
<tr>
<td align="center">寄存器间接寻址</td>
<td align="center">如 [rax]，地址由寄存器决定</td>
<td align="center">✅ 是</td>
</tr>
<tr>
<td align="center">RIP 相对寻址</td>
<td align="center">如 [rip + offset]，相对当前指令位置</td>
<td align="center">✅ 是</td>
</tr>
</tbody></table>
<p>但并不是所有 PIC 都用 RIP 相对寻址，PIC 的实现方式取决于：</p>
<ul>
<li>架构：在 x86（32 位）中没有 RIP 寄存器，PIC 通常通过 call 指令获取当前地址，再加偏移量。</li>
<li>编译器策略：有些编译器会使用全局偏移表（GOT）或过程链接表（PLT）来实现位置无关性。</li>
<li>访问目标：访问函数地址时可能通过 PLT；访问外部变量时可能通过 GOT；访问静态数据时可能用 RIP 相对寻址。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">架构</th>
<th align="center">是否使用 RIP 相对寻址</th>
<th align="center">是否支持位置无关代码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">x86-64</td>
<td align="center">✅ 常用，尤其访问数据段</td>
<td align="center">✅ 强力支持（默认启用）</td>
</tr>
<tr>
<td align="center">x86 (32位)</td>
<td align="center">❌ 无 RIP，用其他方式实现</td>
<td align="center">✅ 但需要特殊技巧</td>
</tr>
</tbody></table>
<p>举个 gdb 调试的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/i <span class="variable">$rip</span></span><br><span class="line">=&gt; 0x2ac084b5ec10 &lt;poll&gt;:       cmpl   <span class="variable">$0x0</span>,0x2d939d(%rip)        <span class="comment"># 0x2ac084e37fb4 &lt;__libc_multiple_threads&gt;</span></span><br><span class="line">(gdb) p (bool)<span class="variable">$__libc_multiple_threads</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>cmpl $0x0, 0x2d939d(%rip)</code> 是一条比较指令（<code>cmp</code>），用于将某个内存地址中的值与立即数 <code>0</code> 进行比较。</li>
<li><code>(%rip)</code> 表示使用 RIP 相对寻址，这是 x86-64 架构中常见的一种寻址方式。</li>
<li>实际比较的是地址 <code>0x2ac084e37fb4</code> 处的值，也就是 <code>__libc_multiple_threads</code> 这个变量。</li>
</ul>
<p><code>__libc_multiple_threads</code> 是什么？</p>
<ul>
<li>这是 GNU C 库（glibc）中的一个内部变量，用来标记当前进程是否启用了多线程。</li>
<li>如果这个值是 0，说明当前进程是单线程。</li>
<li>如果是非零，说明进程中有多个线程。</li>
</ul>
<p>所以这条指令的作用是：判断当前进程是否是多线程环境，可能用于决定是否启用线程安全的行为。</p>
<h3 id="为什么使用-RIP-相对寻址？"><a href="#为什么使用-RIP-相对寻址？" class="headerlink" title="为什么使用 RIP 相对寻址？"></a>为什么使用 RIP 相对寻址？</h3><ol>
<li>RIP 是唯一始终已知的寄存器</li>
</ol>
<ul>
<li>在执行指令时，CPU总是知道当前指令的地址（即 RIP）。</li>
<li>所以可以在编译时计算出目标数据与当前指令之间的偏移量，而不需要知道数据的绝对地址。</li>
</ul>
<p>这就允许编译器生成位置无关代码，即使程序被加载到不同的内存地址，偏移量仍然有效。</p>
<ol start="2">
<li>其他寄存器值是动态的，不可预测</li>
</ol>
<ul>
<li>比如 RBX、RAX、RDI 等寄存器，它们的值在运行时可能被程序修改。</li>
<li>如果用这些寄存器做基址寻址，编译器就无法提前知道它们的值，也就无法生成稳定的偏移量。</li>
</ul>
<ol start="3">
<li>支持共享库和地址空间布局随机化（ASLR）</li>
</ol>
<ul>
<li>RIP 相对寻址让代码段不依赖固定地址，可以被多个进程共享。</li>
<li>也支持操作系统在运行时随机加载地址，提高安全性（ASLR）。</li>
</ul>
<ol start="4">
<li>节省指令空间</li>
</ol>
<ul>
<li>使用 RIP 相对寻址只需要一个 32 位偏移量。</li>
<li>如果使用绝对地址，需要嵌入完整的 64 位地址，指令长度更长，效率更低。</li>
</ul>
<h3 id="为什么使用-RIP-相对寻址只需要一个-32-位偏移量"><a href="#为什么使用-RIP-相对寻址只需要一个-32-位偏移量" class="headerlink" title="为什么使用 RIP 相对寻址只需要一个 32 位偏移量"></a>为什么使用 RIP 相对寻址只需要一个 32 位偏移量</h3><p>在 x86-64 架构中，RIP 相对寻址的偏移量被设计为一个有符号的 32 位整数，也就是一个 displacement（位移）字段，它在机器码中只占用 4 个字节。</p>
<ul>
<li><p>RIP 是 64 位的指令指针，表示当前指令的地址。</p>
</li>
<li><p>RIP 相对寻址的目标地址是通过：</p>
<p><code>目标地址 = 下一条指令地址（RIP） + 32 位偏移量</code></p>
</li>
<li><p>这个偏移量是一个 有符号整数，所以它的范围是：</p>
<p>从 −2³¹ 到 +2³¹−1，即 <strong>±2GB</strong> 的寻址范围。</p>
</li>
</ul>
<p>这意味着，当前指令附近 ±2GB 范围内的任何数据都可以通过 RIP 相对寻址访问。</p>
<table>
<thead>
<tr>
<th align="center">优点</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">✅ 节省空间</td>
<td align="center">只用 4 字节表示偏移，比使用完整 64 位地址节省指令长度</td>
</tr>
<tr>
<td align="center">✅ 支持位置无关代码</td>
<td align="center">编译器只需计算偏移，不依赖绝对地址</td>
</tr>
<tr>
<td align="center">✅ 高效</td>
<td align="center">CPU 执行时只需加法运算，无需查表或重定位</td>
</tr>
<tr>
<td align="center">✅ 安全</td>
<td align="center">支持地址空间布局随机化（ASLR），提高安全性</td>
</tr>
</tbody></table>
<h3 id="为什么可以被多个进程共享？"><a href="#为什么可以被多个进程共享？" class="headerlink" title="为什么可以被多个进程共享？"></a>为什么可以被多个进程共享？</h3><p>因为代码中不再硬编码具体地址，多个进程可以：</p>
<ul>
<li>使用同一份物理内存中的代码段。</li>
<li>每个进程有自己的数据段，但共享同一份只读代码。</li>
</ul>
<p>这大大节省了内存，提高了系统效率。</p>
<p>举个例子：</p>
<table>
<thead>
<tr>
<th align="center">进程</th>
<th align="center">加载地址</th>
<th align="center">使用的代码段</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">0x400000</td>
<td align="center">使用共享代码段</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">0x500000</td>
<td align="center">使用共享代码段</td>
</tr>
</tbody></table>
<p>两者的代码段内容完全一样，因为里面的寻址是相对 RIP 的，不依赖于加载地址。</p>
<p>为什么绝对寻址不可以被多进程共享？</p>
<ul>
<li>每个进程的虚拟地址空间是独立的<ul>
<li>操作系统为每个进程分配独立的虚拟地址空间。</li>
<li>即使两个进程都加载了同一个程序，它们的地址空间可能完全不同。</li>
<li>如果代码中使用绝对地址，加载到不同地址空间后，这些地址就不再有效。</li>
</ul>
</li>
</ul>
<p>所以，绝对地址在一个进程中是有效的，在另一个进程中可能就指向错误的地方或根本不存在。</p>
<ul>
<li><p>需要重定位，无法直接共享物理页</p>
<ul>
<li>如果使用绝对地址，操作系统必须在每个进程加载时对代码进行“重定位”，修改指令中的地址。</li>
<li>一旦修改，代码段就变成了进程私有，不能共享同一份物理内存。</li>
<li>而位置无关代码（如使用 RIP 相对寻址）不需要修改，可以直接映射到多个进程的地址空间。</li>
</ul>
</li>
<li><p>违反共享库的设计原则</p>
<ul>
<li>动态链接库（如 <code>.so</code> 或 <code>.dll</code>）的核心优势就是可以被多个进程共享。</li>
<li>如果库中使用绝对地址，每个进程都要有自己的副本，失去了共享的意义。</li>
<li>正确做法是使用位置无关代码（PIC），让库在任意地址都能运行。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">区域</th>
<th align="center">是否可共享</th>
<th align="center">原因说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">代码段</td>
<td align="center">✅ 是</td>
<td align="center">只读 + 位置无关，多个进程可映射同一物理页</td>
</tr>
<tr>
<td align="center">数据段</td>
<td align="center">❌ 否</td>
<td align="center">每个进程的数据不同，需独立副本</td>
</tr>
<tr>
<td align="center">堆</td>
<td align="center">❌ 否</td>
<td align="center">动态分配，地址空间不同</td>
</tr>
<tr>
<td align="center">栈</td>
<td align="center">❌ 否</td>
<td align="center">私有调用栈，不能混用</td>
</tr>
<tr>
<td align="center">共享内存段</td>
<td align="center">✅ 是</td>
<td align="center">显式创建，专门用于共享</td>
</tr>
</tbody></table>
<p>如果你想深入了解某个进程的内存布局，可以分析 <code>/proc/[pid]/maps</code> 或用工具如 <code>pmap</code>、<code>vmmap</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/22/cpp/%E6%B1%87%E7%BC%96%E4%B8%8Egdb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/22/cpp/%E6%B1%87%E7%BC%96%E4%B8%8Egdb/" class="post-title-link" itemprop="url">汇编与 gdb</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-22 15:42:27" itemprop="dateCreated datePublished" datetime="2025-08-22T15:42:27+00:00">2025-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-15 11:59:20" itemprop="dateModified" datetime="2025-09-15T11:59:20+00:00">2025-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/c-cpp/" itemprop="url" rel="index"><span itemprop="name">c/cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>我们在调试 release 版本的程序时，由于缺乏符号信息，所以需要通过寄存器来查看函数的参数、返回值等。</p>
<h2 id="2-寄存器"><a href="#2-寄存器" class="headerlink" title="2. 寄存器"></a>2. 寄存器</h2><h3 id="2-1-通用寄存器-General-Purpose-Registers"><a href="#2-1-通用寄存器-General-Purpose-Registers" class="headerlink" title="2.1. 通用寄存器 (General Purpose Registers)"></a>2.1. 通用寄存器 (General Purpose Registers)</h3><table>
<thead>
<tr>
<th>寄存器名</th>
<th>英文名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>rax</td>
<td>Accumulator</td>
<td>累加器，通常用于算术运算和函数返回值存储。</td>
</tr>
<tr>
<td>rbx</td>
<td>Base</td>
<td>基址寄存器，常用于存储数据或指针。</td>
</tr>
<tr>
<td>rsi</td>
<td>Source Index</td>
<td>源索引寄存器，常用于字符串操作中的源地址指针（函数第一个参数）。</td>
</tr>
<tr>
<td>rdi</td>
<td>Destination Index</td>
<td>目标索引寄存器，常用于字符串操作中的目标地址指针或结构体指针（函数第二个参数）。</td>
</tr>
<tr>
<td>rdx</td>
<td>Data</td>
<td>数据寄存器，常用于 I&#x2F;O 操作或乘除法运算中的扩展数据存储（函数第三个参数）。</td>
</tr>
<tr>
<td>rcx</td>
<td>Counter</td>
<td>计数器寄存器，常用于循环计数或字符串操作中的计数（函数第四个参数）。</td>
</tr>
<tr>
<td>rsp</td>
<td>Stack Pointer</td>
<td>栈指针寄存器，指向当前栈顶。</td>
</tr>
<tr>
<td>rbp</td>
<td>Base Pointer</td>
<td>基址指针寄存器，指向当前栈帧的基址。</td>
</tr>
<tr>
<td>r8~r15</td>
<td>General Purpose</td>
<td>通用寄存器，扩展的 64 位寄存器之一，用于存储数据或指针（<code>r8</code><del><code>r9</code> 常用于保存函数第五</del>六个参数）。</td>
</tr>
</tbody></table>
<h3 id="2-2-特殊用途寄存器-Special-Purpose-Registers"><a href="#2-2-特殊用途寄存器-Special-Purpose-Registers" class="headerlink" title="2.2. 特殊用途寄存器 (Special Purpose Registers)"></a>2.2. 特殊用途寄存器 (Special Purpose Registers)</h3><table>
<thead>
<tr>
<th>寄存器名</th>
<th>英文名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>rip</td>
<td>Instruction Pointer</td>
<td>指令指针寄存器，存储当前执行指令的地址。</td>
</tr>
<tr>
<td>rflags</td>
<td>Flags</td>
<td>标志寄存器，存储状态标志位（如进位、溢出、零标志等）。</td>
</tr>
</tbody></table>
<h3 id="2-3-段寄存器-Segment-Registers"><a href="#2-3-段寄存器-Segment-Registers" class="headerlink" title="2.3. 段寄存器 (Segment Registers)"></a>2.3. 段寄存器 (Segment Registers)</h3><table>
<thead>
<tr>
<th>寄存器名</th>
<th>英文名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>cs</td>
<td>Code Segment</td>
<td>代码段寄存器，指向当前代码段的基址。</td>
</tr>
<tr>
<td>ds</td>
<td>Data Segment</td>
<td>数据段寄存器，指向当前数据段的基址。</td>
</tr>
<tr>
<td>es</td>
<td>Extra Segment</td>
<td>额外段寄存器，指向额外数据段的基址。</td>
</tr>
<tr>
<td>fs</td>
<td>FS Segment</td>
<td>特殊用途段寄存器，常用于线程本地存储等。</td>
</tr>
<tr>
<td>gs</td>
<td>GS Segment</td>
<td>特殊用途段寄存器，常用于线程本地存储等。</td>
</tr>
<tr>
<td>ss</td>
<td>Stack Segment</td>
<td>栈段寄存器，指向当前栈段的基址。</td>
</tr>
</tbody></table>
<h3 id="2-4-浮点与向量寄存器-Floating-Point-and-Vector-Registers"><a href="#2-4-浮点与向量寄存器-Floating-Point-and-Vector-Registers" class="headerlink" title="2.4. 浮点与向量寄存器 (Floating Point and Vector Registers)"></a>2.4. 浮点与向量寄存器 (Floating Point and Vector Registers)</h3><table>
<thead>
<tr>
<th>寄存器名</th>
<th>英文名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>xmm0-xmm15</td>
<td>SIMD Registers</td>
<td>用于 SSE 指令集的 128 位向量运算。</td>
</tr>
<tr>
<td>ymm0-ymm15</td>
<td>AVX Registers</td>
<td>用于 AVX 指令集的 256 位向量运算。</td>
</tr>
<tr>
<td>zmm0-zmm31</td>
<td>AVX-512 Registers</td>
<td>用于 AVX-512 指令集的 512 位向量运算。</td>
</tr>
</tbody></table>
<h3 id="2-5-函数调用时的参数传递"><a href="#2-5-函数调用时的参数传递" class="headerlink" title="2.5. 函数调用时的参数传递"></a>2.5. 函数调用时的参数传递</h3><p>在 x86_64 架构中，函数调用时的参数传递遵循 System V AMD64 ABI（Linux&#x2F;Unix 系统的标准调用约定）。</p>
<p>前六个整数或指针类型的参数依次存储在以下寄存器中：</p>
<ol>
<li><strong>rdi</strong> - 第一个参数</li>
<li><strong>rsi</strong> - 第二个参数</li>
<li><strong>rdx</strong> - 第三个参数</li>
<li><strong>rcx</strong> - 第四个参数</li>
<li><strong>r8</strong>  - 第五个参数</li>
<li><strong>r9</strong>  - 第六个参数</li>
</ol>
<p>对于浮点类型的参数（如 <code>float</code> 或 <code>double</code>），前八个参数存储在以下 <strong>SSE 寄存器</strong> 中：</p>
<ol>
<li><strong>xmm0</strong> - 第一个浮点参数</li>
<li><strong>xmm1</strong> - 第二个浮点参数</li>
<li><strong>xmm2</strong> - 第三个浮点参数</li>
<li><strong>xmm3</strong> - 第四个浮点参数</li>
<li><strong>xmm4</strong> - 第五个浮点参数</li>
<li><strong>xmm5</strong> - 第六个浮点参数</li>
<li><strong>xmm6</strong> - 第七个浮点参数</li>
<li><strong>xmm7</strong> - 第八个浮点参数</li>
</ol>
<p>溢出参数（超过寄存器数量）会依次存储在 <strong>栈</strong> 中：</p>
<ul>
<li>超过寄存器数量（整数参数超过 6 个，浮点参数超过 8 个）的参数会依次压入栈中。</li>
<li>栈需要保持 16 字节对齐，可能会插入填充字节。</li>
<li>可以通过访问栈指针（rsp）或基址指针（rbp）来找到栈上的参数。<ul>
<li>使用 rsp（栈指针）<ul>
<li>在函数入口时，rsp 指向栈顶（即返回地址的下一个位置）。</li>
<li>栈上的第一个参数位于 [rsp + 8]（跳过返回地址）。</li>
<li>第二个参数位于 [rsp + 16]，依此类推。</li>
</ul>
</li>
<li>使用 rbp（基址指针）<ul>
<li>如果函数使用了帧指针（rbp），rbp 通常指向调用者的栈帧基址。</li>
<li>栈上的第一个参数位于 [rbp + 16]（跳过返回地址和保存的 rbp）。</li>
<li>第二个参数位于 [rbp + 24]，依此类推。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-栈"><a href="#3-栈" class="headerlink" title="3. 栈"></a>3. 栈</h2><h3 id="3-1-理解栈布局"><a href="#3-1-理解栈布局" class="headerlink" title="3.1. 理解栈布局"></a>3.1. 理解栈布局</h3><p>在函数调用时，栈的布局通常如下（从高地址到低地址）：</p>
<ol>
<li>返回地址：调用函数时，call 指令会将返回地址（下一条指令的地址）压入栈中。</li>
<li>溢出参数：如果参数超过寄存器数量，多余的参数会依次压入栈中。</li>
<li>栈对齐填充：为了满足 16 字节对齐要求，可能会有额外的填充字节。</li>
<li>局部变量和保存的寄存器：函数内部可能会在栈上分配空间用于局部变量或保存调用者的寄存器。</li>
</ol>
<h3 id="3-2-函数调用时的压栈过程"><a href="#3-2-函数调用时的压栈过程" class="headerlink" title="3.2. 函数调用时的压栈过程"></a>3.2. 函数调用时的压栈过程</h3><p>在x86_64架构中，函数调用时会涉及到栈的操作，包括压栈和出栈。这些操作主要用于保存调用者的上下文（如返回地址、寄存器值）以及为被调用函数分配栈帧。</p>
<h4 id="3-2-1-调用者（Caller）的操作"><a href="#3-2-1-调用者（Caller）的操作" class="headerlink" title="3.2.1. 调用者（Caller）的操作"></a>3.2.1. 调用者（Caller）的操作</h4><ol>
<li><p><strong>压入返回地址</strong><br>当调用者使用 <code>call</code> 指令调用函数时，CPU会自动将返回地址（下一条指令的地址）压入栈中。此时，<code>rsp</code>（栈指针）会减少8字节（64位系统）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call function</span><br><span class="line"># 等价于：</span><br><span class="line">push rip  ; 将返回地址压入栈</span><br><span class="line">jmp function</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>压入溢出参数（如果有）</strong><br>如果函数的参数超过了寄存器数量（整数参数超过6个，浮点参数超过8个），多余的参数会从右到左依次压入栈中。<code>rsp</code> 会随着每个参数的压入减少。</p>
</li>
<li><p><strong>对齐栈</strong><br>为了满足 <strong>16字节对齐</strong> 的要求，调用者可能会插入额外的填充字节，使得 <code>rsp</code> 在调用函数前保持16字节对齐。</p>
</li>
</ol>
<h4 id="3-2-2-被调用者（Callee）的操作"><a href="#3-2-2-被调用者（Callee）的操作" class="headerlink" title="3.2.2. 被调用者（Callee）的操作"></a>3.2.2. <strong>被调用者（Callee）的操作</strong></h4><ol>
<li><p><strong>保存调用者的栈帧基址</strong><br>被调用者通常会保存调用者的栈帧基址（<code>rbp</code>），以便在函数返回时恢复调用者的栈帧。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push rbp       ; 保存调用者的 rbp</span><br><span class="line">mov rbp, rsp   ; 设置当前函数的栈帧基址</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>分配栈空间</strong><br>被调用者会根据函数内部局部变量的需求，在栈上分配空间。<code>rsp</code> 会减少相应的字节数。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub rsp, &lt;size&gt;  ; 为局部变量分配栈空间</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-3-2-函数返回时的出栈过程"><a href="#3-3-2-函数返回时的出栈过程" class="headerlink" title="3.3. 2. 函数返回时的出栈过程"></a>3.3. <strong>2. 函数返回时的出栈过程</strong></h3><h4 id="3-3-1-被调用者（Callee）的操作"><a href="#3-3-1-被调用者（Callee）的操作" class="headerlink" title="3.3.1. 被调用者（Callee）的操作"></a>3.3.1. <strong>被调用者（Callee）的操作</strong></h4><ol>
<li><p><strong>释放局部变量的栈空间</strong><br>被调用者在返回前会释放为局部变量分配的栈空间。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add rsp, &lt;size&gt;  ; 恢复 rsp</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>恢复调用者的栈帧基址</strong><br>被调用者会恢复调用者的 <code>rbp</code>，以确保调用者的栈帧完整。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop rbp  ; 恢复调用者的 rbp</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>返回到调用者</strong><br>被调用者使用 <code>ret</code> 指令从栈中弹出返回地址，并跳转到该地址。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret  ; 等价于：pop rip</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="3-3-2-调用者（Caller）的操作"><a href="#3-3-2-调用者（Caller）的操作" class="headerlink" title="3.3.2. 调用者（Caller）的操作"></a>3.3.2. <strong>调用者（Caller）的操作</strong></h4><ol>
<li><strong>清理栈上的参数（如果需要）</strong><br>如果调用约定要求调用者清理栈上的参数（如 <code>cdecl</code> 调用约定），调用者会调整 <code>rsp</code>。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add rsp, &lt;size&gt;  ; 清理栈上的参数</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-4-3-栈指针（rsp）和基址指针（rbp）的变化"><a href="#3-4-3-栈指针（rsp）和基址指针（rbp）的变化" class="headerlink" title="3.4. 3. 栈指针（rsp）和基址指针（rbp）的变化"></a>3.4. <strong>3. 栈指针（<code>rsp</code>）和基址指针（<code>rbp</code>）的变化</strong></h3><p>以下是一个函数调用的栈布局示例：</p>
<p> <strong>C代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">example</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    example(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>汇编代码（简化版）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># main 函数</span><br><span class="line">main:</span><br><span class="line">    sub rsp, 16         ; 对齐栈</span><br><span class="line">    mov edi, 1          ; 第一个参数 -&gt; rdi</span><br><span class="line">    mov esi, 2          ; 第二个参数 -&gt; rsi</span><br><span class="line">    call example        ; 调用 example 函数</span><br><span class="line">    add rsp, 16         ; 恢复栈</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line"># example 函数</span><br><span class="line">example:</span><br><span class="line">    push rbp            ; 保存调用者的 rbp</span><br><span class="line">    mov rbp, rsp        ; 设置当前栈帧基址</span><br><span class="line">    sub rsp, 16         ; 为局部变量分配栈空间</span><br><span class="line">    mov eax, edi        ; a -&gt; eax</span><br><span class="line">    add eax, esi        ; a + b</span><br><span class="line">    leave               ; 恢复栈帧（等价于：mov rsp, rbp; pop rbp）</span><br><span class="line">    ret                 ; 返回调用者</span><br></pre></td></tr></table></figure>

<p> <strong>栈布局变化</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th><code>rsp</code> 变化</th>
<th>栈内容（从高地址到低地址）</th>
</tr>
</thead>
<tbody><tr>
<td><code>call example</code></td>
<td><code>rsp -= 8</code></td>
<td>返回地址</td>
</tr>
<tr>
<td><code>push rbp</code></td>
<td><code>rsp -= 8</code></td>
<td>保存调用者的 <code>rbp</code></td>
</tr>
<tr>
<td><code>sub rsp, 16</code></td>
<td><code>rsp -= 16</code></td>
<td>为局部变量分配空间</td>
</tr>
<tr>
<td><code>leave</code></td>
<td><code>rsp += 16</code></td>
<td>释放局部变量空间</td>
</tr>
<tr>
<td><code>ret</code></td>
<td><code>rsp += 8</code></td>
<td>弹出返回地址</td>
</tr>
</tbody></table>
<h3 id="3-5-总结"><a href="#3-5-总结" class="headerlink" title="3.5. 总结"></a>3.5. <strong>总结</strong></h3><ol>
<li><strong>函数调用的栈操作</strong>：<ul>
<li>调用者负责压入返回地址和溢出参数。</li>
<li>被调用者负责保存 <code>rbp</code> 和分配局部变量空间。</li>
<li>函数返回时，释放局部变量空间并恢复调用者的栈帧。</li>
</ul>
</li>
<li><strong><code>rsp</code> 和 <code>rbp</code> 的变化</strong>：<ul>
<li><code>rsp</code> 指向栈顶，动态变化。</li>
<li><code>rbp</code> 指向栈帧基址，通常固定不变。</li>
</ul>
</li>
</ol>
<h2 id="4-使用-gdb-查看寄存器"><a href="#4-使用-gdb-查看寄存器" class="headerlink" title="4. 使用 gdb 查看寄存器"></a>4. 使用 gdb 查看寄存器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有寄存器</span></span><br><span class="line">info registers</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定寄存器</span></span><br><span class="line">info registers rdi</span><br><span class="line"><span class="comment"># 或简写</span></span><br><span class="line">i r rdi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看十六进制</span></span><br><span class="line">p/x <span class="variable">$rdx</span>    <span class="comment"># 十六进制</span></span><br><span class="line">p/d <span class="variable">$rdx</span>    <span class="comment"># 十进制</span></span><br><span class="line"><span class="comment"># 或简写</span></span><br><span class="line">p <span class="variable">$rdx</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>info registers</code> 会打印三列：</p>
<ul>
<li>第一列：寄存器名称</li>
<li>第二列：寄存器的值（十六进制）</li>
<li>第三列：寄存器的值（十进制；也可能是十六进制，用 <code>0x</code> 开头）</li>
</ul>
<p><code>info registers rdi</code> 与 <code>p $rdi</code> 效果相同。</p>
<p>从寄存器查到的内存地址，可以用 <code>x</code> （examinze）命令来查看内存的值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看指令</span></span><br><span class="line">x/i <span class="variable">$rip</span></span><br><span class="line"><span class="comment"># 查看栈顶</span></span><br><span class="line">x/16x <span class="variable">$rsp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内存</span></span><br><span class="line">p <span class="variable">$rdi</span></span><br><span class="line">x/2gx <span class="variable">$rdi</span></span><br><span class="line"><span class="comment"># 或先用 $rdi 查出内存地址，直接用地址访问</span></span><br><span class="line">x/2gx 47926411878160</span><br></pre></td></tr></table></figure>

<p><code>x</code> 命令的说明：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/FMT ADDRESS</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>x</code>：表示“examine memory”（查看内存）</li>
<li><code>2</code>：数字，表示要查看的单元数</li>
<li><code>g</code>：表示每个单元的 size，有 b(byte), h(halfword), w(word), g(giant, 8 bytes)</li>
<li><code>x</code>：表示值的格式，有 o(octal), x(hex), d(decimal), u(unsigned decimal), t(binary), f(float), a(address), i(instruction), c(char), s(string)<br>and z(hex, zero padded on the left).</li>
</ul>
<p>在 gdb 命令行中使用 <code>help</code> 命令，可以查看命令的说明。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">help</span> x</span><br><span class="line">Examine memory: x/FMT ADDRESS.</span><br><span class="line">ADDRESS is an expression <span class="keyword">for</span> the memory address to examine.</span><br><span class="line">FMT is a repeat count followed by a format letter and a size letter.</span><br><span class="line">Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal),</span><br><span class="line">  t(binary), f(<span class="built_in">float</span>), a(address), i(instruction), c(char), s(string)</span><br><span class="line">  and z(hex, zero padded on the left).</span><br><span class="line">Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).</span><br><span class="line">The specified number of objects of the specified size are printed</span><br><span class="line">according to the format.  If a negative number is specified, memory is</span><br><span class="line">examined backward from the address.</span><br><span class="line"></span><br><span class="line">Defaults <span class="keyword">for</span> format and size letters are those previously used.</span><br><span class="line">Default count is 1.  Default address is following last thing printed</span><br><span class="line">with this <span class="built_in">command</span> or <span class="string">&quot;print&quot;</span>.</span><br></pre></td></tr></table></figure>

<h2 id="5-使用-gdb-查看栈"><a href="#5-使用-gdb-查看栈" class="headerlink" title="5. 使用 gdb 查看栈"></a>5. 使用 gdb 查看栈</h2><ul>
<li>bt</li>
<li>frame</li>
<li>args</li>
<li>locals</li>
<li>x</li>
</ul>
<p>TDODO</p>
<h3 id="5-1-frame-与寄存器的值"><a href="#5-1-frame-与寄存器的值" class="headerlink" title="5.1. frame 与寄存器的值"></a>5.1. <code>frame</code> 与寄存器的值</h3><ul>
<li>GDB 中的寄存器值（如 <code>$rax</code>, <code>$rdi</code>, <code>$rsp</code> 等）是当前 CPU 执行上下文的快照。</li>
<li>当你切换到 <code>frame 0</code>（最内层栈帧）时，寄存器值是最真实的，因为这是程序当前正在执行的地方。</li>
<li>当你切换到 外层栈帧（frame 1, 2, …）时，GDB 会尝试还原当时的寄存器状态，但这依赖于：<ul>
<li>编译器是否保存了寄存器值（如 callee-saved）</li>
<li>是否有调试符号或 unwind 信息</li>
<li>GDB 是否能推断出寄存器的保存位置</li>
</ul>
</li>
</ul>
<p>寄存器值可能出现的情况</p>
<table>
<thead>
<tr>
<th align="center">情况</th>
<th align="center">表现</th>
</tr>
</thead>
<tbody><tr>
<td align="center">寄存器是 caller-saved（如 rdi, rsi, rax）</td>
<td align="center">可能显示 <not saved> 或错误值</td>
</tr>
<tr>
<td align="center">寄存器是 callee-saved（如 rbx, rbp, r12~r15）</td>
<td align="center">通常能正确还原</td>
</tr>
<tr>
<td align="center">没有调试信息或优化严重</td>
<td align="center">GDB 无法还原，显示当前值或 <not saved></td>
</tr>
</tbody></table>
<p>建议</p>
<ul>
<li>如果你要分析寄存器状态，最好在 frame 0 或断点处进行。</li>
<li>如果你在分析 core dump 或栈破坏问题，寄存器值只能作为参考，不要完全依赖外层 frame 的寄存器快照。</li>
<li>使用 info args 和 info locals 更可靠地查看参数和局部变量（如果有符号信息）。</li>
</ul>
<h2 id="6-在特定线程中设置断点"><a href="#6-在特定线程中设置断点" class="headerlink" title="6. 在特定线程中设置断点"></a>6. 在特定线程中设置断点</h2><h3 id="6-1-断点只作用于某线程"><a href="#6-1-断点只作用于某线程" class="headerlink" title="6.1. 断点只作用于某线程"></a>6.1. 断点只作用于某线程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有线程 ID 和当前线程 ID（gdb 中会使用 * 标注当前线程）</span></span><br><span class="line">(gdb) info threads</span><br><span class="line"><span class="comment"># 切换当前上下文到指定线程</span></span><br><span class="line">(gdb) thread &lt;THREAD_ID&gt;</span><br><span class="line"><span class="comment"># 通过查看当前堆栈是不是自己要断点的线程</span></span><br><span class="line">(gdb) bt</span><br><span class="line">(gdb) <span class="built_in">break</span> LOCATION thread THREADNUM</span><br><span class="line"><span class="comment"># 条件断点</span></span><br><span class="line">(gdb) <span class="built_in">break</span> source.c:123 thread 5 <span class="keyword">if</span> fds[0].fd == 7</span><br><span class="line"><span class="comment"># 如果没有 debug 符号，可以利用函数返回值寄存器断点</span></span><br><span class="line">(gdb) <span class="built_in">break</span> poll thread 2 <span class="keyword">if</span> <span class="variable">$rdx</span> &gt; 0</span><br><span class="line"><span class="comment"># 完整格式</span></span><br><span class="line"><span class="built_in">break</span> [PROBE_MODIFIER] [LOCATION] [thread THREADNUM] [<span class="keyword">if</span> CONDITION]</span><br></pre></td></tr></table></figure>

<h3 id="6-2-锁定调度器，只让当前线程运行"><a href="#6-2-锁定调度器，只让当前线程运行" class="headerlink" title="6.2. 锁定调度器，只让当前线程运行"></a>6.2. 锁定调度器，只让当前线程运行</h3><p>默认情况下，GDB 会让所有线程一起运行（比如你执行 continue 时）。如果你只想让当前线程运行，其它线程保持暂停，可以使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> scheduler-locking on</span><br></pre></td></tr></table></figure>

<p>这表示：只有当前线程会执行，其他线程全部暂停。</p>
<p>其中模式还有：</p>
<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">off</td>
<td align="center">默认值，所有线程都可以运行</td>
</tr>
<tr>
<td align="center">on</td>
<td align="center">只有当前线程运行，其他线程暂停</td>
</tr>
<tr>
<td align="center">step</td>
<td align="center">单步调试时只运行当前线程，continue 时其他线程也会运行</td>
</tr>
</tbody></table>
<p>你可以随时切换：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> scheduler-locking step</span><br></pre></td></tr></table></figure>

<ul>
<li>如果你在调试死锁、竞态或线程间通信问题，锁定调度器是非常有效的方式。</li>
<li>如果你在调试某个 poll() 或 epoll_wait() 调用，只想观察某个线程的行为，可以结合 catch syscall 和 thread 命令一起使用。</li>
</ul>
<h2 id="7-查看汇编代码"><a href="#7-查看汇编代码" class="headerlink" title="7. 查看汇编代码"></a>7. 查看汇编代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看汇编代码，其中 &quot;=&gt;&quot; 标记的是当前执行位置</span></span><br><span class="line">(gdb) disassemble</span><br><span class="line"><span class="comment"># 反汇编指定地址范围</span></span><br><span class="line"><span class="comment"># 这会显示从当前指令开始的 32 字节范围内的汇编代码。</span></span><br><span class="line">(gdb) disassemble <span class="variable">$rip</span>, <span class="variable">$rip</span>+32</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前指令（x86）</span></span><br><span class="line">(gdb) x/i <span class="variable">$pc</span></span><br><span class="line"><span class="comment"># 或在 x86-64 架构下：</span></span><br><span class="line">(gdb) x/i <span class="variable">$rip</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bonus: 默认 GDB 使用 AT&amp;T 风格（如 %rax），你可以切换为 Intel 风格</span></span><br><span class="line"><span class="comment"># 这样输出会更接近你在汇编教材或 IDA Pro 中看到的格式</span></span><br><span class="line">(gdb) <span class="built_in">set</span> disassembly-flavor intel</span><br></pre></td></tr></table></figure>

<h2 id="8-位置无关代码（PIC）"><a href="#8-位置无关代码（PIC）" class="headerlink" title="8. 位置无关代码（PIC）"></a>8. 位置无关代码（PIC）</h2><h3 id="8-1-什么是-PIC"><a href="#8-1-什么是-PIC" class="headerlink" title="8.1. 什么是 PIC"></a>8.1. <strong>什么是 PIC</strong></h3><ul>
<li><strong>PIC</strong>（Position Independent Code，位置无关代码）是一种编译方式，使得生成的代码可以在内存中的任意位置运行，而无需硬编码绝对地址。</li>
<li>在动态链接库（<code>shared libraries</code>）中，通常需要使用 PIC，以便库可以被加载到任意内存地址。</li>
<li>节省空间：相比使用 64 位绝对地址，RIP 相对寻址只需要一个 32 位偏移量。</li>
<li>更安全：支持地址随机化（ASLR），提高程序的安全性。</li>
</ul>
<h3 id="8-2-PIC-的实现"><a href="#8-2-PIC-的实现" class="headerlink" title="8.2. PIC 的实现"></a>8.2. <strong>PIC 的实现</strong></h3><ol>
<li><p><strong>访问全局变量</strong><br>在 PIC 模式下，代码通过 <strong>全局偏移表（GOT, Global Offset Table）</strong> 和 <strong>过程链接表（PLT, Procedure Linkage Table）</strong> 访问全局变量和函数地址。</p>
</li>
<li><p><strong>寄存器 <code>rip</code> 的使用</strong><br>x86_64 支持基于 <code>rip</code>（指令指针）的寻址方式，PIC 会利用 <code>rip</code> 相对寻址来访问全局变量或函数地址，而不是使用绝对地址。</p>
</li>
</ol>
<p>在 x86-64 架构中，传统的绝对地址寻址方式不再适用于位置无关代码。于是引入了 RIP（指令指针）相对寻址：</p>
<p>假设你有一个全局变量 int x &#x3D; 42;，在汇编中访问它可能会变成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asm</span><br><span class="line">mov eax, DWORD PTR [rip + offset_to_x]</span><br></pre></td></tr></table></figure>

<p>这里的 offset_to_x 是编译器计算出来的 x 相对于当前指令的偏移量。</p>
<table>
<thead>
<tr>
<th align="center">寻址方式</th>
<th align="center">描述</th>
<th align="center">是否位置无关</th>
</tr>
</thead>
<tbody><tr>
<td align="center">绝对地址寻址</td>
<td align="center">使用固定地址，如 [0x400123]</td>
<td align="center">❌ 否</td>
</tr>
<tr>
<td align="center">寄存器间接寻址</td>
<td align="center">如 [rax]，地址由寄存器决定</td>
<td align="center">✅ 是</td>
</tr>
<tr>
<td align="center">RIP 相对寻址</td>
<td align="center">如 [rip + offset]，相对当前指令位置</td>
<td align="center">✅ 是</td>
</tr>
</tbody></table>
<h3 id="8-3-PIC-的优化"><a href="#8-3-PIC-的优化" class="headerlink" title="8.3. PIC 的优化"></a>8.3. <strong>PIC 的优化</strong></h3><ul>
<li><strong>减少重定位</strong>：通过 <code>rip</code> 相对寻址，避免了加载时的重定位操作，提高了加载速度。</li>
<li><strong>共享内存</strong>：多个进程可以共享同一段动态库代码，而无需为每个进程生成独立的副本。</li>
</ul>
<h3 id="8-4-示例"><a href="#8-4-示例" class="headerlink" title="8.4. 示例"></a>8.4. <strong>示例</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [rip + global_var@GOTPCREL]  ; 通过 GOT 表访问全局变量</span><br><span class="line">call [rip + func@PLT]                ; 通过 PLT 表调用函数</span><br></pre></td></tr></table></figure>

<p>举个 gdb 调试的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/i <span class="variable">$rip</span></span><br><span class="line">=&gt; 0x2ac084b5ec10 &lt;poll&gt;:       cmpl   <span class="variable">$0x0</span>,0x2d939d(%rip)        <span class="comment"># 0x2ac084e37fb4 &lt;__libc_multiple_threads&gt;</span></span><br><span class="line">(gdb) p (bool)<span class="variable">$__libc_multiple_threads</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>cmpl $0x0, 0x2d939d(%rip)</code> 是一条比较指令（<code>cmp</code>），用于将某个内存地址中的值与立即数 <code>0</code> 进行比较。</li>
<li><code>(%rip)</code> 表示使用 RIP 相对寻址，这是 x86-64 架构中常见的一种寻址方式。</li>
<li>实际比较的是地址 <code>0x2ac084e37fb4</code> 处的值，也就是 <code>__libc_multiple_threads</code> 这个变量。</li>
</ul>
<p><code>__libc_multiple_threads</code> 是什么？</p>
<ul>
<li>这是 GNU C 库（glibc）中的一个内部变量，用来标记当前进程是否启用了多线程。</li>
<li>如果这个值是 0，说明当前进程是单线程。</li>
<li>如果是非零，说明进程中有多个线程。</li>
</ul>
<p>所以这条指令的作用是：判断当前进程是否是多线程环境，可能用于决定是否启用线程安全的行为。</p>
<h3 id="8-5-为什么使用-RIP-相对寻址？"><a href="#8-5-为什么使用-RIP-相对寻址？" class="headerlink" title="8.5. 为什么使用 RIP 相对寻址？"></a>8.5. 为什么使用 RIP 相对寻址？</h3><ol>
<li>RIP 是唯一始终已知的寄存器</li>
</ol>
<ul>
<li>在执行指令时，CPU 总是知道当前指令的地址（即 RIP）。</li>
<li>所以可以在编译时计算出目标数据与当前指令之间的偏移量，而不需要知道数据的绝对地址。</li>
</ul>
<p>这就允许编译器生成位置无关代码，即使程序被加载到不同的内存地址，偏移量仍然有效。</p>
<ol start="2">
<li>其他寄存器值是动态的，不可预测</li>
</ol>
<ul>
<li>比如 RBX、RAX、RDI 等寄存器，它们的值在运行时可能被程序修改。</li>
<li>如果用这些寄存器做基址寻址，编译器就无法提前知道它们的值，也就无法生成稳定的偏移量。</li>
</ul>
<ol start="3">
<li>支持共享库和地址空间布局随机化（ASLR）</li>
</ol>
<ul>
<li>RIP 相对寻址让代码段不依赖固定地址，可以被多个进程共享。</li>
<li>也支持操作系统在运行时随机加载地址，提高安全性（ASLR）。</li>
</ul>
<ol start="4">
<li>节省指令空间</li>
</ol>
<ul>
<li>使用 RIP 相对寻址只需要一个 32 位偏移量。</li>
<li>如果使用绝对地址，需要嵌入完整的 64 位地址，指令长度更长，效率更低。</li>
</ul>
<h3 id="8-6-为什么使用-RIP-相对寻址只需要一个-32-位偏移量"><a href="#8-6-为什么使用-RIP-相对寻址只需要一个-32-位偏移量" class="headerlink" title="8.6. 为什么使用 RIP 相对寻址只需要一个 32 位偏移量"></a>8.6. 为什么使用 RIP 相对寻址只需要一个 32 位偏移量</h3><p>在 x86-64 架构中，RIP 相对寻址的偏移量被设计为一个有符号的 32 位整数，也就是一个 displacement（位移）字段，它在机器码中只占用 4 个字节。</p>
<ul>
<li><p>RIP 是 64 位的指令指针，表示当前指令的地址。</p>
</li>
<li><p>RIP 相对寻址的目标地址是通过：</p>
<p><code>目标地址 = 下一条指令地址（RIP） + 32 位偏移量</code></p>
</li>
<li><p>这个偏移量是一个 有符号整数，所以它的范围是：</p>
<p>从 −2³¹ 到 +2³¹−1，即 <strong>±2GB</strong> 的寻址范围。</p>
</li>
</ul>
<p>这意味着，当前指令附近 ±2GB 范围内的任何数据都可以通过 RIP 相对寻址访问。</p>
<table>
<thead>
<tr>
<th align="center">优点</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">✅ 节省空间</td>
<td align="center">只用 4 字节表示偏移，比使用完整 64 位地址节省指令长度</td>
</tr>
<tr>
<td align="center">✅ 支持位置无关代码</td>
<td align="center">编译器只需计算偏移，不依赖绝对地址</td>
</tr>
<tr>
<td align="center">✅ 高效</td>
<td align="center">CPU 执行时只需加法运算，无需查表或重定位</td>
</tr>
<tr>
<td align="center">✅ 安全</td>
<td align="center">支持地址空间布局随机化（ASLR），提高安全性</td>
</tr>
</tbody></table>
<h3 id="8-7-为什么可以被多个进程共享？"><a href="#8-7-为什么可以被多个进程共享？" class="headerlink" title="8.7. 为什么可以被多个进程共享？"></a>8.7. 为什么可以被多个进程共享？</h3><p>因为代码中不再硬编码具体地址，多个进程可以：</p>
<ul>
<li>使用同一份物理内存中的代码段。</li>
<li>每个进程有自己的数据段，但共享同一份只读代码。</li>
</ul>
<p>这大大节省了内存，提高了系统效率。</p>
<p>举个例子：</p>
<table>
<thead>
<tr>
<th align="center">进程</th>
<th align="center">加载地址</th>
<th align="center">使用的代码段</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">0x400000</td>
<td align="center">使用共享代码段</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">0x500000</td>
<td align="center">使用共享代码段</td>
</tr>
</tbody></table>
<p>两者的代码段内容完全一样，因为里面的寻址是相对 RIP 的，不依赖于加载地址。</p>
<p>为什么绝对寻址不可以被多进程共享？</p>
<ul>
<li>每个进程的虚拟地址空间是独立的<ul>
<li>操作系统为每个进程分配独立的虚拟地址空间。</li>
<li>即使两个进程都加载了同一个程序，它们的地址空间可能完全不同。</li>
<li>如果代码中使用绝对地址，加载到不同地址空间后，这些地址就不再有效。</li>
</ul>
</li>
</ul>
<p>所以，绝对地址在一个进程中是有效的，在另一个进程中可能就指向错误的地方或根本不存在。</p>
<ul>
<li><p>需要重定位，无法直接共享物理页</p>
<ul>
<li>如果使用绝对地址，操作系统必须在每个进程加载时对代码进行“重定位”，修改指令中的地址。</li>
<li>一旦修改，代码段就变成了进程私有，不能共享同一份物理内存。</li>
<li>而位置无关代码（如使用 RIP 相对寻址）不需要修改，可以直接映射到多个进程的地址空间。</li>
</ul>
</li>
<li><p>违反共享库的设计原则</p>
<ul>
<li>动态链接库（如 <code>.so</code> 或 <code>.dll</code>）的核心优势就是可以被多个进程共享。</li>
<li>如果库中使用绝对地址，每个进程都要有自己的副本，失去了共享的意义。</li>
<li>正确做法是使用位置无关代码（PIC），让库在任意地址都能运行。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">区域</th>
<th align="center">是否可共享</th>
<th align="center">原因说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">代码段</td>
<td align="center">✅ 是</td>
<td align="center">只读 + 位置无关，多个进程可映射同一物理页</td>
</tr>
<tr>
<td align="center">数据段</td>
<td align="center">❌ 否</td>
<td align="center">每个进程的数据不同，需独立副本</td>
</tr>
<tr>
<td align="center">堆</td>
<td align="center">❌ 否</td>
<td align="center">动态分配，地址空间不同</td>
</tr>
<tr>
<td align="center">栈</td>
<td align="center">❌ 否</td>
<td align="center">私有调用栈，不能混用</td>
</tr>
<tr>
<td align="center">共享内存段</td>
<td align="center">✅ 是</td>
<td align="center">显式创建，专门用于共享</td>
</tr>
</tbody></table>
<p>如果你想深入了解某个进程的内存布局，可以分析 <code>/proc/[pid]/maps</code> 或用工具如 <code>pmap</code>、<code>vmmap</code>。</p>
<h2 id="9-实际-debug-例子：在多线程中查看-poll-的事件"><a href="#9-实际-debug-例子：在多线程中查看-poll-的事件" class="headerlink" title="9. 实际 debug 例子：在多线程中查看 poll 的事件"></a>9. 实际 debug 例子：在多线程中查看 poll 的事件</h2><p>先复习下 <code>poll</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数 fds 的类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="type">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">    <span class="type">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>FIXME：这种在汇编代码 ret 前断点，并依据 <code>rax</code> 、<code>rdi</code> 设置条件断点的方式不可靠，因为可能进入了 libc 层。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 polll 的汇编代码</span></span><br><span class="line">(gdb) disass poll</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> poll:</span><br><span class="line">   0x00002ac084b5ec10 &lt;+0&gt;:     cmpl   <span class="variable">$0x0</span>,0x2d939d(%rip)        <span class="comment"># 0x2ac084e37fb4 &lt;__libc_multiple_threads&gt;</span></span><br><span class="line">   0x00002ac084b5ec17 &lt;+7&gt;:     jne    0x2ac084b5ec29 &lt;poll+25&gt;</span><br><span class="line">   0x00002ac084b5ec19 &lt;+0&gt;:     mov    <span class="variable">$0x7</span>,%eax</span><br><span class="line">   0x00002ac084b5ec1e &lt;+5&gt;:     syscall </span><br><span class="line">   0x00002ac084b5ec20 &lt;+7&gt;:     cmp    <span class="variable">$0xfffffffffffff001</span>,%rax</span><br><span class="line">   0x00002ac084b5ec26 &lt;+13&gt;:    jae    0x2ac084b5ec59 &lt;poll+73&gt;</span><br><span class="line">   0x00002ac084b5ec28 &lt;+15&gt;:    ret    </span><br><span class="line">   0x00002ac084b5ec29 &lt;+25&gt;:    sub    <span class="variable">$0x8</span>,%rsp</span><br><span class="line">   0x00002ac084b5ec2d &lt;+29&gt;:    call   0x2ac084b77600 &lt;__libc_enable_asynccancel&gt;</span><br><span class="line">   0x00002ac084b5ec32 &lt;+34&gt;:    mov    %rax,(%rsp)</span><br><span class="line">   0x00002ac084b5ec36 &lt;+38&gt;:    mov    <span class="variable">$0x7</span>,%eax</span><br><span class="line">   0x00002ac084b5ec3b &lt;+43&gt;:    syscall </span><br><span class="line">   0x00002ac084b5ec3d &lt;+45&gt;:    mov    (%rsp),%rdi</span><br><span class="line">   0x00002ac084b5ec41 &lt;+49&gt;:    mov    %rax,%rdx</span><br><span class="line">   0x00002ac084b5ec44 &lt;+52&gt;:    call   0x2ac084b77660 &lt;__libc_disable_asynccancel&gt;</span><br><span class="line">   0x00002ac084b5ec49 &lt;+57&gt;:    mov    %rdx,%rax</span><br><span class="line">   0x00002ac084b5ec4c &lt;+60&gt;:    add    <span class="variable">$0x8</span>,%rsp</span><br><span class="line">   0x00002ac084b5ec50 &lt;+64&gt;:    cmp    <span class="variable">$0xfffffffffffff001</span>,%rax</span><br><span class="line">   0x00002ac084b5ec56 &lt;+70&gt;:    jae    0x2ac084b5ec59 &lt;poll+73&gt;</span><br><span class="line">=&gt; 0x00002ac084b5ec58 &lt;+72&gt;:    ret    </span><br><span class="line">   0x00002ac084b5ec59 &lt;+73&gt;:    mov    0x2d31f0(%rip),%rcx        <span class="comment"># 0x2ac084e31e50</span></span><br><span class="line">   0x00002ac084b5ec60 &lt;+80&gt;:    neg    %eax</span><br><span class="line">   0x00002ac084b5ec62 &lt;+82&gt;:    mov    %eax,%fs:(%rcx)</span><br><span class="line">   0x00002ac084b5ec65 &lt;+85&gt;:    or     <span class="variable">$0xffffffffffffffff</span>,%rax</span><br><span class="line">   0x00002ac084b5ec69 &lt;+89&gt;:    ret</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到所有的 ret 指令，设置条件断点</span></span><br><span class="line"><span class="comment"># 注意：最好是在 ret 指令之前的指令上也加上断点，</span></span><br><span class="line"><span class="comment"># 因为 ret 的时候，可能已经把当前栈（除 rsp / rbp 外）都弹出了，寄存器中将看不到当前栈的信息</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># $rax 是返回值寄存器，也就是返回大于 0 时，让进程暂停</span></span><br><span class="line"><span class="comment"># 这里的 * 表示取内存的值（存放的是指令），* 断不可少，不然会被认为是 Function name</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">(gdb) b *0x00002ac084b5ec26 thread 4 <span class="keyword">if</span> <span class="variable">$rax</span> &gt; 0</span><br><span class="line">(gdb) b *0x00002ac084b5ec28 thread 4 <span class="keyword">if</span> <span class="variable">$rax</span> &gt; 0</span><br><span class="line">(gdb) b *0x00002ac084b5ec56 thread 4 <span class="keyword">if</span> <span class="variable">$rax</span> &gt; 0</span><br><span class="line">(gdb) b *0x00002ac084b5ec58 thread 4 <span class="keyword">if</span> <span class="variable">$rax</span> &gt; 0</span><br><span class="line">(gdb) b *0x00002ac084b5ec65 thread 4 <span class="keyword">if</span> <span class="variable">$rax</span> &gt; 0</span><br><span class="line">(gdb) b *0x00002ac084b5ec69 thread 4 <span class="keyword">if</span> <span class="variable">$rax</span> &gt; 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继续运行</span></span><br><span class="line">(gdb) c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 IO 事件发生，程序会被暂停</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/21/dmtcp/DMTCP%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86jalib/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/21/dmtcp/DMTCP%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86jalib/" class="post-title-link" itemprop="url">DMTCP 之内存管理 (jalib)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-21 09:59:55" itemprop="dateCreated datePublished" datetime="2025-08-21T09:59:55+00:00">2025-08-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-15 11:59:20" itemprop="dateModified" datetime="2025-09-15T11:59:20+00:00">2025-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/DMTCP/" itemprop="url" rel="index"><span itemprop="name">DMTCP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a target="_blank" rel="noopener" href="https://github.com/dmtcp/dmtcp/tree/main/jalib">https://github.com/dmtcp/dmtcp/tree/main/jalib</a></p>
<h2 id="malloc-的特性和局限"><a href="#malloc-的特性和局限" class="headerlink" title="malloc 的特性和局限"></a>malloc 的特性和局限</h2><p><code>malloc</code>&#x2F;<code>free</code> 是操作系统（或 C 库）提供的通用堆分配器。</p>
<ul>
<li>它通常会采用 “内存池 + 分块 + 空闲链表” 等技术，但它为了通用性和线程安全，设计得很复杂，开销较大。</li>
<li>在高并发 &#x2F; 频繁小块分配释放的场景下，<code>malloc</code> 的性能和碎片控制未必理想。</li>
</ul>
<p><code>malloc</code> 很难让你：</p>
<ul>
<li>控制分配内存的位置（如 DMTCP 需要特殊内存区域）</li>
<li>统计 &#x2F; 追踪所有分配的内存块</li>
<li>实现定制的分配策略（如无锁、分层小块池、预扩展等）</li>
<li>轻松调试和隔离内存问题</li>
</ul>
<h3 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h3><p>malloc 的确在其实现内部也维护着自己的 “内存池”，并且会对小块内存（small bins&#x2F;tcache&#x2F;fast bins 等）做优化和分组管理。比如在 glibc 的 malloc（ptmalloc）中，就有针对小块内存的快速分配机制。</p>
<ol>
<li><p>malloc 是 “通用分配器”<br>malloc 需要支持所有应用场景，包括大 &#x2F; 小 &#x2F; 奇异尺寸的分配、跨多线程、兼容各种系统调用和 ABI。<br>为了兼容性和健壮性，malloc 实现复杂，包含很多额外的元数据和检查，导致分配 &#x2F; 释放开销更大。</p>
</li>
<li><p>malloc 的小块管理是 “全局的”<br>malloc 管理的小块是全进程共享的，所有线程 &#x2F; 模块都会竞争同一套管理结构（如 fastbin、tcache、small bin）。<br>在高并发、频繁小块分配 &#x2F; 释放的场景下，锁竞争和同步成本变高，可能成为性能瓶颈。</p>
</li>
<li><p>自定义分配器（如 jalib）“更窄、更专用”<br>jalib 只服务 DMTCP 内部的特殊内存分配需求，只关注固定几种典型的小块尺寸（如 64&#x2F;256&#x2F;1024…）。<br>可以用更简单、更高效的 “无锁链表 + 内存对齐块” 来管理池，分配和释放几乎都是 O(1)的原子操作。<br>不需要兼容所有 malloc 的场景（如 realloc、跨模块释放等），所以能极致优化。</p>
</li>
<li><p>控制权和可观测性<br>jalib 可以完全掌控池的生命周期、分配区域、分配策略（如预扩展、定制回收），还可以追踪统计、调试。<br>malloc 的内部状态你无法直接控制或感知，也无法方便地和 DMTCP 的 checkpoint、回滚等功能集成。</p>
</li>
<li><p>内存碎片和确定性<br>专用分配器能保证分配块 “定长、对齐”，几乎无碎片，分配和回收都是确定性的。<br>malloc 需要兼容各种尺寸，碎片和内存抖动不可避免。</p>
</li>
</ol>
<h2 id="jalib（自定义分配器）的设计动机"><a href="#jalib（自定义分配器）的设计动机" class="headerlink" title="jalib（自定义分配器）的设计动机"></a>jalib（自定义分配器）的设计动机</h2><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul>
<li>DMTCP 频繁地分配和释放小块内存（如元数据、临时缓存等），如果每次都用 malloc，性能损耗大。</li>
<li>jalib 采用分级固定块池，每次分配 &#x2F; 释放只需操作链表和原子变量，比 malloc 更快、更少碎片。</li>
</ul>
<h3 id="线程安全的高效实现"><a href="#线程安全的高效实现" class="headerlink" title="线程安全的高效实现"></a>线程安全的高效实现</h3><ul>
<li>jalib 用无锁（128 位 CAS）或轻量级互斥方案，适合高并发分配 &#x2F; 释放。</li>
<li>malloc 虽然线程安全，但实现方式更重，适用范围更广，未必最优。</li>
</ul>
<h3 id="可控性和可追踪性"><a href="#可控性和可追踪性" class="headerlink" title="可控性和可追踪性"></a>可控性和可追踪性</h3><ul>
<li>jalib 可以统计分配次数、追踪所有内存池区，方便调试、分析和 checkpoint 恢复。</li>
<li>可根据实际需求预分配或批量扩展，避免运行时大规模内存抖动。</li>
</ul>
<h3 id="适应-DMTCP-的特殊需求"><a href="#适应-DMTCP-的特殊需求" class="headerlink" title="适应 DMTCP 的特殊需求"></a>适应 DMTCP 的特殊需求</h3><ul>
<li>DMTCP 需要在 checkpoint&#x2F;restore 时管理所有内存区域，jalib 可以定制分配区域、分配方式，malloc 无法满足。</li>
<li>可实现特定平台的优化，如 mmap 固定地址分配等。</li>
</ul>
<h3 id="故障隔离和调试"><a href="#故障隔离和调试" class="headerlink" title="故障隔离和调试"></a>故障隔离和调试</h3><ul>
<li>jalib 可以在有 bug 或内存泄漏时，帮助定位具体的分配 &#x2F; 释放流程。</li>
<li>可以方便地记录所有 arena 信息，甚至实现特殊的调试模式。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虽然 malloc 也是内存池管理，但它是为通用用途设计的，不能满足 DMTCP 这类高性能、高可控性、特殊内存管理需求场景。自定义 jalib 分配器可以更高效地管理小块内存，优化多线程性能，便于调试和适配特定需求。</p>
<p>可以归纳为三点：</p>
<ul>
<li>性能更高，碎片更少</li>
<li>更好地适应 DMTCP 的需求</li>
<li>更易于调试和控制</li>
</ul>
<h2 id="jalloc-设计思路"><a href="#jalloc-设计思路" class="headerlink" title="jalloc 设计思路"></a>jalloc 设计思路</h2><h3 id="多层级固定大小块分配（层级分配器）"><a href="#多层级固定大小块分配（层级分配器）" class="headerlink" title="多层级固定大小块分配（层级分配器）"></a>多层级固定大小块分配（层级分配器）</h3><ul>
<li>设计了 5 个分配层级（lvl1~lvl5），每层负责不同大小的定长内存块（如 64、256、1024、4096、16384 字节）。</li>
<li>小于等于这 5 个等级的分配请求，会被分配到各自的层级。</li>
<li>超过最大层级的请求，则直接调用 <code>_alloc_raw</code>（通常是 <code>mmap</code>）。</li>
</ul>
<p>优点：</p>
<ul>
<li>小块内存可以复用，减少系统调用和碎片。</li>
<li>大块内存仍可直接用系统接口，兼顾通用性。</li>
</ul>
<h3 id="固定块分配器-JFixedAllocStack"><a href="#固定块分配器-JFixedAllocStack" class="headerlink" title="固定块分配器 JFixedAllocStack"></a>固定块分配器 JFixedAllocStack</h3><p>每个层级对应一个 <code>JFixedAllocStack&lt;N&gt;</code>，其核心是无锁栈式管理：</p>
<ul>
<li>内部维护一个空闲块栈（LIFO 链表）。</li>
<li>allocate 时从栈取出一个空闲块，栈空时调用 expand 申请一批新块。</li>
<li>deallocate 时将块归还到栈顶。</li>
</ul>
<p>核心技术点</p>
<ul>
<li><p>原子双字比较交换（128 位 CAS）</p>
<p>为了线程安全，栈顶指针 _top 需要原子更新。这里用到了 128 位 CAS（Compare-And-Swap），保证 node 指针和计数器同时更新，避免 ABA 问题。</p>
</li>
<li><p>CAS 不可用时的降级方案</p>
<p>对于不支持 128 位原子操作的平台，采用 futex+memcpy 的方式手动实现互斥和原子性。</p>
</li>
</ul>
<h3 id="线程安全设计"><a href="#线程安全设计" class="headerlink" title="线程安全设计"></a>线程安全设计</h3><p>分配和释放都用原子操作保护，无需锁，性能高。<br>多线程环境下不会出现竞争条件或内存破坏。</p>
<h3 id="Arena-记录和调试"><a href="#Arena-记录和调试" class="headerlink" title="Arena 记录和调试"></a>Arena 记录和调试</h3><p>分配的内存区域（arena）可以记录到全局数组中，方便调试和统计。<br>通过 <code>JAlloc::getAllocArenas()</code> 可获得分配区域列表。</p>
<h3 id="全局-new-delete-重载（可选）"><a href="#全局-new-delete-重载（可选）" class="headerlink" title="全局 new&#x2F;delete 重载（可选）"></a>全局 new&#x2F;delete 重载（可选）</h3><p>如果定义了 <code>OVERRIDE_GLOBAL_ALLOCATOR</code>，会重载 <code>operator new</code> 和 <code>operator delete</code>，让全局 <code>new</code>&#x2F;<code>delete</code> 也用这个分配器。</p>
<h3 id="灵活切换"><a href="#灵活切换" class="headerlink" title="灵活切换"></a>灵活切换</h3><p>可以通过宏 <code>JALIB_ALLOCATOR</code> 切换：</p>
<ul>
<li>启用时用自定义分配器</li>
<li>否则回退为标准 malloc&#x2F;free</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>本内存分配器的设计核心在于：</p>
<ul>
<li>采用多级固定块内存池 + 无锁算法，高效服务于小块高频分配 &#x2F; 释放；</li>
<li>通过 128 位原子操作或 futex 确保并发安全，适用多平台；</li>
<li>提供 arena 管理和统计，方便调试与维护；</li>
<li>兼容传统分配方式，易于集成和切换。</li>
</ul>
<p>这种设计非常适合像 DMTCP 这样对性能和内存管理有特殊要求的系统级软件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/20/EDA/EAD%E4%BB%BF%E7%9C%9F%E4%B9%8BMemory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/20/EDA/EAD%E4%BB%BF%E7%9C%9F%E4%B9%8BMemory/" class="post-title-link" itemprop="url">EDA 仿真之 Memory</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-20 22:25:49" itemprop="dateCreated datePublished" datetime="2025-08-20T22:25:49+00:00">2025-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-15 11:59:20" itemprop="dateModified" datetime="2025-09-15T11:59:20+00:00">2025-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/EDA/" itemprop="url" rel="index"><span itemprop="name">EDA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>Memory &#x3D; 存储 + 访问逻辑</p>
<p>存储</p>
<ul>
<li>在仿真里，memory 本质上就是一个数组（Array）或者向量（Vector），每个元素对应一个存储单元（bit&#x2F;byte&#x2F;word）。</li>
<li>例：一个 8 位 × 1024 深度的 RAM，可以在仿真里用 <code>uint8_t mem[1024];</code> 表示。</li>
</ul>
<p>访问逻辑</p>
<ul>
<li>读（Read）：根据地址返回对应的数据。</li>
<li>写（Write）：根据地址和写使能信号，将数据写入存储单元。</li>
<li>可能涉及 时序：同步（clock 边沿写入）或异步（立即生效）。</li>
</ul>
<p>时序和延迟</p>
<ul>
<li>在硬件里，memory 访问不是瞬间的：存在 读延迟、写延迟。</li>
<li>仿真时，可以用 延时事件 或 clock 边沿触发 来模拟。</li>
</ul>
<h2 id="仿真代码"><a href="#仿真代码" class="headerlink" title="仿真代码"></a>仿真代码</h2><p>功能说明</p>
<ul>
<li>多端口读写：支持同时多个端口访问 memory</li>
<li>写冲突仲裁：写优先策略或延迟写，可扩展读优先 &#x2F; 轮询</li>
<li>读延迟 pipeline：延迟由 read_delay 控制</li>
<li>Burst &#x2F; wrap-around：访问超出末尾自动回绕</li>
<li>简单 Cache&#x2F;Tag：模拟命中 &#x2F; 未命中</li>
<li>异步端口：不同端口调用 read&#x2F;write 可在不同 tick，模拟异步时钟</li>
<li>随机 bit flip &#x2F; SEU：1% 概率错误注入</li>
<li>统计与功耗估算基础：记录读写次数、命中数、平均延迟</li>
</ul>
<figure class="highlight cpp"><figcaption><span>EdaMemoryFull.cpp</span><a href="/blog/downloads/code/eda/memory/EdaMemoryFull.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Event</span> {</span><br><span class="line">    <span class="type">int</span> time;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; action;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Event&amp; other) <span class="type">const</span> { <span class="keyword">return</span> time &gt; other.time; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EdaMemoryFull</span> {</span><br><span class="line">    std::vector&lt;<span class="type">uint8_t</span>&gt; mem;</span><br><span class="line">    std::priority_queue&lt;Event&gt; event_queue;</span><br><span class="line">    <span class="type">int</span> sim_time = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> read_delay;</span><br><span class="line">    std::mt19937 gen;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cache_size;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CacheLine</span> { <span class="type">bool</span> valid=<span class="literal">false</span>; <span class="type">int</span> tag=<span class="number">-1</span>; };</span><br><span class="line">    std::vector&lt;CacheLine&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max_bus_access_per_cycle = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> current_cycle_access = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计信息</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; read_count, write_count, read_hits, write_hits;</span><br><span class="line">    std::map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; read_delay_total;</span><br><span class="line">    <span class="type">int</span> dynamic_power = <span class="number">0</span>; <span class="comment">// 动态功耗</span></span><br><span class="line">    <span class="type">int</span> static_power; <span class="comment">// 静态功耗</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; dynamic_power_per_cycle; <span class="comment">// 每周期动态功耗</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态功耗公式（单位：动态功耗单位 = 每bit切换一次算1）</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// P_dyn = α * C * V^2 * f</span></span><br><span class="line">    <span class="comment">// 其中，α 开关活动因子（switching activity）</span></span><br><span class="line">    <span class="comment">//      C 负载电容</span></span><br><span class="line">    <span class="comment">//      V 电源电压</span></span><br><span class="line">    <span class="comment">//      f 时钟频率</span></span><br><span class="line">    <span class="comment">// 简化为每次 bit 改变增加一个单位动态功耗</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 静态功耗公式（单位：静态功耗单位 = 每8bit存储单元算1）</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// P_static = I_leak * V * N</span></span><br><span class="line">    <span class="comment">// 简化为每8bit存储单元增加1单位静态功耗</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 总功耗</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// P_total = P_dyn + P_static</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">WritePriority</span> { WRITE_FIRST, READ_FIRST, ROUND_ROBIN } write_prio;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EdaMemoryFull</span>(<span class="type">size_t</span> size, <span class="type">int</span> delay, <span class="type">int</span> c_size, WritePriority prio=WRITE_FIRST)</span><br><span class="line">        : <span class="built_in">mem</span>(size,<span class="number">0</span>), <span class="built_in">read_delay</span>(delay), <span class="built_in">gen</span>(std::random_device{}()), </span><br><span class="line">          <span class="built_in">cache_size</span>(c_size), <span class="built_in">cache</span>(c_size), <span class="built_in">static_power</span>(size/<span class="number">8</span>), <span class="built_in">write_prio</span>(prio)</span><br><span class="line">    {</span><br><span class="line">        std::uniform_int_distribution&lt;&gt; <span class="built_in">dis</span>(<span class="number">0</span>,<span class="number">255</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v: mem) v = <span class="built_in">dis</span>(gen);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> port,<span class="type">int</span> addr,<span class="type">const</span> std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; data)</span></span>{</span><br><span class="line">        write_count[port]++;</span><br><span class="line">        <span class="keyword">if</span>(current_cycle_access&gt;=max_bus_access_per_cycle){</span><br><span class="line">            event_queue.<span class="built_in">push</span>({sim_time+<span class="number">1</span>,[<span class="keyword">this</span>,port,addr,data](){ <span class="built_in">write</span>(port,addr,data); }});</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        current_cycle_access++;</span><br><span class="line">        <span class="keyword">if</span>(write_prio==WRITE_FIRST){</span><br><span class="line">            <span class="built_in">apply_write</span>(addr,data);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            event_queue.<span class="built_in">push</span>({sim_time+<span class="number">1</span>,[<span class="keyword">this</span>,addr,data](){ <span class="built_in">apply_write</span>(addr,data); }});</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">update_cache</span>(port, addr,data,<span class="literal">true</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> port,<span class="type">int</span> addr,<span class="type">size_t</span> length,std::function&lt;<span class="type">void</span>(std::vector&lt;<span class="type">uint8_t</span>&gt;)&gt; callback)</span></span>{</span><br><span class="line">        read_count[port]++;</span><br><span class="line">        <span class="keyword">if</span>(current_cycle_access&gt;=max_bus_access_per_cycle){</span><br><span class="line">            event_queue.<span class="built_in">push</span>({sim_time+<span class="number">1</span>,[<span class="keyword">this</span>,port,addr,length,callback](){ <span class="built_in">read</span>(port,addr,length,callback); }});</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        current_cycle_access++;</span><br><span class="line">        <span class="type">int</span> trigger_time = sim_time+read_delay;</span><br><span class="line">        <span class="type">bool</span> hit = <span class="built_in">check_cache</span>(port, addr,length);</span><br><span class="line">        <span class="keyword">if</span>(hit) read_hits[port]++;</span><br><span class="line">        event_queue.<span class="built_in">push</span>({trigger_time,[<span class="keyword">this</span>,addr,length,callback,port,trigger_time]() {</span><br><span class="line">            std::vector&lt;<span class="type">uint8_t</span>&gt; data;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;length;i++){</span><br><span class="line">                <span class="type">uint8_t</span> val = mem[(addr+i)%mem.<span class="built_in">size</span>()];</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">random_bit_flip</span>()) val ^= (<span class="number">1</span>&lt;&lt;(<span class="built_in">gen</span>()%<span class="number">8</span>));</span><br><span class="line">                dynamic_power += <span class="built_in">count_bit_changes</span>(val, mem[(addr+i)%mem.<span class="built_in">size</span>()]);</span><br><span class="line">                data.<span class="built_in">push_back</span>(val);</span><br><span class="line">            }</span><br><span class="line">            read_delay_total[port] += (trigger_time - sim_time);</span><br><span class="line">            <span class="built_in">callback</span>(data);</span><br><span class="line">        }});</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">()</span></span>{</span><br><span class="line">        sim_time++;</span><br><span class="line">        current_cycle_access = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cycle_dyn_power = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!event_queue.<span class="built_in">empty</span>() &amp;&amp; event_queue.<span class="built_in">top</span>().time &lt;= sim_time){</span><br><span class="line">            <span class="keyword">auto</span> e = event_queue.<span class="built_in">top</span>(); event_queue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> before = dynamic_power;</span><br><span class="line">            e.<span class="built_in">action</span>();</span><br><span class="line">            cycle_dyn_power += (dynamic_power - before);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        dynamic_power_per_cycle.<span class="built_in">push_back</span>(cycle_dyn_power);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ASCII 可视化每周期动态功耗</span></span><br><span class="line">        <span class="type">int</span> scale = <span class="number">50</span>;</span><br><span class="line">        <span class="type">int</span> bar_len = *std::<span class="built_in">max_element</span>(dynamic_power_per_cycle.<span class="built_in">begin</span>(), dynamic_power_per_cycle.<span class="built_in">end</span>())&gt;<span class="number">0</span> ?</span><br><span class="line">                      cycle_dyn_power*scale/(*std::<span class="built_in">max_element</span>(dynamic_power_per_cycle.<span class="built_in">begin</span>(), dynamic_power_per_cycle.<span class="built_in">end</span>())) : <span class="number">0</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Cycle &quot;</span> &lt;&lt; sim_time &lt;&lt; <span class="string">&quot; dyn power: &quot;</span> &lt;&lt; cycle_dyn_power</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; total power: &quot;</span> &lt;&lt; dynamic_power + static_power &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;bar_len;i++) std::cout&lt;&lt;<span class="string">&quot;#&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_stats</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Simulation stats:\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [port,cnt]: read_count)</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;Port &quot;</span>&lt;&lt;port&lt;&lt;<span class="string">&quot; read count: &quot;</span>&lt;&lt;cnt</span><br><span class="line">                     &lt;&lt;<span class="string">&quot;, hits: &quot;</span>&lt;&lt;read_hits.<span class="built_in">at</span>(port)</span><br><span class="line">                     &lt;&lt;<span class="string">&quot;, avg delay: &quot;</span>&lt;&lt;(cnt?read_delay_total.<span class="built_in">at</span>(port)/cnt:<span class="number">0</span>)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [port,cnt]: write_count)</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;Port &quot;</span>&lt;&lt;port&lt;&lt;<span class="string">&quot; write count: &quot;</span>&lt;&lt;cnt</span><br><span class="line">                     &lt;&lt;<span class="string">&quot;, hits: &quot;</span>&lt;&lt;write_hits.<span class="built_in">at</span>(port)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Dynamic power units: &quot;</span>&lt;&lt;dynamic_power&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Static power units: &quot;</span>&lt;&lt;static_power&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Total power units: &quot;</span>&lt;&lt;dynamic_power + static_power&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">export_power_csv</span><span class="params">(<span class="type">const</span> std::string &amp;filename)</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="function">std::ofstream <span class="title">ofs</span><span class="params">(filename)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(!ofs.<span class="built_in">is_open</span>()) {</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Failed to open file: &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        ofs &lt;&lt; <span class="string">&quot;Cycle,DynamicPower,StaticPower,TotalPower\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;dynamic_power_per_cycle.<span class="built_in">size</span>();i++){</span><br><span class="line">            <span class="type">int</span> dyn = dynamic_power_per_cycle[i];</span><br><span class="line">            <span class="type">int</span> total = dyn + static_power;</span><br><span class="line">            ofs &lt;&lt; (i+<span class="number">1</span>) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; dyn &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; static_power &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; total &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        }</span><br><span class="line">        ofs.<span class="built_in">close</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Power data exported to &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">random_bit_flip</span><span class="params">()</span></span>{</span><br><span class="line">        std::uniform_real_distribution&lt;&gt; <span class="built_in">dis</span>(<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dis</span>(gen)&lt;<span class="number">0.01</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count_bit_changes</span><span class="params">(<span class="type">uint8_t</span> a,<span class="type">uint8_t</span> b)</span></span>{</span><br><span class="line">        <span class="type">uint8_t</span> diff = a^b;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(diff){ count+=diff&amp;<span class="number">1</span>; diff&gt;&gt;=<span class="number">1</span>; }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check_cache</span><span class="params">(<span class="type">int</span> port, <span class="type">int</span> addr,<span class="type">size_t</span> length)</span></span>{</span><br><span class="line">        <span class="type">int</span> line = addr % cache_size;</span><br><span class="line">        <span class="type">int</span> tag = addr / cache_size;</span><br><span class="line">        <span class="keyword">return</span> cache[line].valid &amp;&amp; cache[line].tag==tag;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update_cache</span><span class="params">(<span class="type">int</span> port, <span class="type">int</span> addr,<span class="type">const</span> std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; data,<span class="type">bool</span> write=<span class="literal">false</span>)</span></span>{</span><br><span class="line">        <span class="type">int</span> line = addr % cache_size;</span><br><span class="line">        <span class="type">int</span> tag = addr / cache_size;</span><br><span class="line">        cache[line].valid=<span class="literal">true</span>;</span><br><span class="line">        cache[line].tag=tag;</span><br><span class="line">        <span class="keyword">if</span>(write) write_hits[port]++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply_write</span><span class="params">(<span class="type">int</span> addr,<span class="type">const</span> std::vector&lt;<span class="type">uint8_t</span>&gt;&amp; data)</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;data.<span class="built_in">size</span>();i++) mem[(addr+i)%mem.<span class="built_in">size</span>()]=data[i];</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例主程序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="function">EdaMemoryFull <span class="title">mem</span><span class="params">(<span class="number">1024</span>,<span class="number">2</span>,<span class="number">16</span>,EdaMemoryFull::WRITE_FIRST)</span></span>;</span><br><span class="line"></span><br><span class="line">    mem.<span class="built_in">write</span>(<span class="number">0</span>,<span class="number">10</span>,{<span class="number">42</span>,<span class="number">43</span>,<span class="number">44</span>});</span><br><span class="line">    mem.<span class="built_in">write</span>(<span class="number">1</span>,<span class="number">11</span>,{<span class="number">99</span>});</span><br><span class="line">    mem.<span class="built_in">read</span>(<span class="number">0</span>,<span class="number">10</span>,<span class="number">3</span>,[](std::vector&lt;<span class="type">uint8_t</span>&gt; data){</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Port0 read burst: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:data) std::cout&lt;&lt;(<span class="type">int</span>)v&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        std::cout&lt;&lt;std::endl;</span><br><span class="line">    });</span><br><span class="line">    mem.<span class="built_in">read</span>(<span class="number">1</span>,<span class="number">11</span>,<span class="number">1</span>,[](std::vector&lt;<span class="type">uint8_t</span>&gt; data){</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Port1 read: &quot;</span>&lt;&lt;(<span class="type">int</span>)data[<span class="number">0</span>]&lt;&lt;std::endl;</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) mem.<span class="built_in">tick</span>();</span><br><span class="line">    <span class="comment">// 导出功耗数据</span></span><br><span class="line">    mem.<span class="built_in">export_power_csv</span>(<span class="string">&quot;memory_power.csv&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mem.<span class="built_in">print_stats</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>输出的 memory_power.csv 文件内容示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Cycle,DynamicPower,StaticPower,TotalPower</span><br><span class="line">1,3,128,131</span><br><span class="line">2,0,128,128</span><br><span class="line">3,5,128,133</span><br><span class="line">4,2,128,130</span><br><span class="line">5,7,128,135</span><br><span class="line">6,1,128,129</span><br><span class="line">7,4,128,132</span><br><span class="line">8,0,128,128</span><br><span class="line">9,2,128,130</span><br><span class="line">10,3,128,131</span><br></pre></td></tr></table></figure>

<p>每列含义：</p>
<ul>
<li>Cycle：周期号</li>
<li>DynamicPower：每周期动态功耗单位</li>
<li>StaticPower：静态功耗单位（固定）</li>
<li>TotalPower：总功耗单位</li>
</ul>
<p>功耗分析</p>
<figure class="highlight python"><figcaption><span>report_power.py</span><a href="/blog/downloads/code/eda/memory/report_power.py">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 CSV</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;memory_power.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到动态功耗峰值周期</span></span><br><span class="line">peak_cycle = df[<span class="string">&#x27;DynamicPower&#x27;</span>].idxmax() + <span class="number">1</span></span><br><span class="line">peak_value = df[<span class="string">&#x27;DynamicPower&#x27;</span>].<span class="built_in">max</span>()</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制条形背景（ASCII风格效果）</span></span><br><span class="line"><span class="keyword">for</span> i, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(df[<span class="string">&#x27;DynamicPower&#x27;</span>]):</span><br><span class="line">    bar_len = <span class="built_in">int</span>(val / peak_value * <span class="number">50</span>)  <span class="comment"># 50字符最大长度</span></span><br><span class="line">    plt.text(i+<span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;#&#x27;</span> * bar_len, fontsize=<span class="number">8</span>, color=<span class="string">&#x27;grey&#x27;</span>, va=<span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制曲线</span></span><br><span class="line">plt.plot(df[<span class="string">&#x27;Cycle&#x27;</span>], df[<span class="string">&#x27;DynamicPower&#x27;</span>], label=<span class="string">&#x27;Dynamic Power&#x27;</span>, marker=<span class="string">&#x27;o&#x27;</span>, color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">plt.plot(df[<span class="string">&#x27;Cycle&#x27;</span>], df[<span class="string">&#x27;StaticPower&#x27;</span>], label=<span class="string">&#x27;Static Power&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>, color=<span class="string">&#x27;orange&#x27;</span>)</span><br><span class="line">plt.plot(df[<span class="string">&#x27;Cycle&#x27;</span>], df[<span class="string">&#x27;TotalPower&#x27;</span>], label=<span class="string">&#x27;Total Power&#x27;</span>, linestyle=<span class="string">&#x27;-.&#x27;</span>, color=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高亮峰值</span></span><br><span class="line">plt.scatter(peak_cycle, peak_value, color=<span class="string">&#x27;red&#x27;</span>, s=<span class="number">100</span>, label=<span class="string">&#x27;Peak Dynamic Power&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&#x27;Memory Power Simulation with Peak Highlight &amp; ASCII-style Bars&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Cycle&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Power Units&#x27;</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>, linestyle=<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h3 id="burst-multi-port-总线冲突"><a href="#burst-multi-port-总线冲突" class="headerlink" title="burst&#x2F;multi-port 总线冲突"></a>burst&#x2F;multi-port 总线冲突</h3><p>在多端口系统中，尤其是在使用总线结构的系统中，总线冲突（Bus contention）是一个常见的问题。总线冲突通常发生在多个设备尝试同时访问总线上的同一资源时。这种情况可能会导致数据损坏、系统性能下降或甚至系统崩溃。下面是一些解决和缓解总线冲突的策略：</p>
<ol>
<li>仲裁机制<br>仲裁是解决总线冲突的一种常用方法。它通过一个仲裁器（Arbiter）来决定哪个设备可以访问总线。常见的仲裁策略有：</li>
</ol>
<p>优先级仲裁：根据预先设定的优先级顺序决定哪个设备可以访问总线。</p>
<p>轮询仲裁：轮流让每个设备访问总线。</p>
<p>基于请求的仲裁（如请求共享（Request-for-Shared, RFS）和请求独占（Request-for-Exclusive, RFE））：设备首先请求对资源的访问，然后根据请求的类型（共享或独占）来决定访问权限。</p>
<ol start="2">
<li><p>分时复用<br>通过时间分割（Time Division Multiplexing, TDM）或频率分割（Frequency Division Multiplexing, FDM），可以允许多个设备在不同的时间或频率上使用总线，从而减少冲突。例如，可以使用时分多路复用将总线的不同时间段分配给不同的设备。</p>
</li>
<li><p>编码和解码技术<br>使用特殊的编码和解码技术，如霍纳编码（Hornar code）或格雷码（Gray code），可以减少在总线上传输数据时的错误，并帮助检测和纠正数据冲突。</p>
</li>
<li><p>总线锁定<br>在访问总线期间，通过总线锁定机制确保没有其他设备可以访问总线。这可以通过在总线上设置一个锁定信号来实现，该信号在访问期间保持激活状态。</p>
</li>
<li><p>缓存和缓冲<br>为每个设备提供局部缓存或缓冲机制，可以减少对总线的直接访问次数，从而降低冲突的可能性。当一个设备需要与总线上的另一个设备通信时，它可以先将数据写入自己的缓存，然后再由缓存同步到总线上。</p>
</li>
<li><p>使用更宽的总线<br>增加总线的宽度可以允许在同一时间内传输更多的数据，从而减少对总线的需求，降低冲突的可能性。</p>
</li>
</ol>
<p>实施步骤<br>评估系统需求：确定哪些类型的设备将使用总线，以及它们对带宽的需求。</p>
<p>选择仲裁策略：根据设备的优先级和带宽需求选择合适的仲裁策略。</p>
<p>设计硬件：根据选定的策略设计硬件，包括添加仲裁器、缓存和适当的控制逻辑。</p>
<p>测试和优化：实施后进行系统测试，根据测试结果调整策略或硬件设计。</p>
<p>通过上述方法，可以有效管理和减少多端口系统中的总线冲突问题，提高系统的稳定性和性能。</p>
<h3 id="Cache-Tag（缓存标记）"><a href="#Cache-Tag（缓存标记）" class="headerlink" title="Cache Tag（缓存标记）"></a>Cache Tag（缓存标记）</h3><p>Cache Tag（缓存标记）是高速缓存（Cache）中的关键组成部分，用于存储数据在主存中的地址信息，以便快速定位数据位置。 ‌</p>
<p>核心功能<br>Tag字段存储了主存中数据的地址信息，当CPU访问主存时，首先通过Tag字段判断数据是否存在于Cache中。若存在，则直接从Cache读取；若不存在，则访问主存。 ‌</p>
<p>结构组成</p>
<ul>
<li>‌Tag‌：记录数据在主存的地址信息。</li>
<li>‌Data‌：存储实际数据。</li>
<li>‌Valid Bit‌：标记数据是否有效。</li>
<li>‌Dir‌：目录信息，用于区分不同数据块。 ‌</li>
</ul>
<p>应用场景</p>
<p>现代处理器通常采用多级Cache结构（如L1、L2、L3），其中Tag与Data共同构成Cache Line，用于快速访问和存储数据。例如，ARMv8-A架构的处理器包含独立的I-Cache和D-Cache，分别存储指令和数据。</p>
<p>Cache Tag 仿真代码</p>
<blockquote>
<p>FIXME: 该代码会 coredump 。</p>
</blockquote>
<figure class="highlight cpp"><figcaption><span>cache_simulator.h</span><a href="/blog/downloads/code/eda/memory/cache/cache_simulator.h">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CACHE_SIMULATOR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHE_SIMULATOR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存行结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CacheLine</span> {</span><br><span class="line">    <span class="type">bool</span> valid = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> dirty = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">uint32_t</span> tag = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint64_t</span> last_used = <span class="number">0</span>; <span class="comment">// 用于LRU替换策略</span></span><br><span class="line">    std::vector&lt;<span class="type">uint8_t</span>&gt; data;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 端口访问请求结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PortRequest</span> {</span><br><span class="line">    <span class="type">uint32_t</span> port_id;</span><br><span class="line">    <span class="type">bool</span> is_write;</span><br><span class="line">    <span class="type">uint32_t</span> addr;</span><br><span class="line">    <span class="type">uint8_t</span>* data_ptr;</span><br><span class="line">    <span class="type">size_t</span> data_size;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CacheSimulator</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CacheSimulator</span>(<span class="type">uint32_t</span> line_size, <span class="type">uint32_t</span> num_lines, <span class="type">uint32_t</span> num_ports);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 多端口访问接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process_request</span><span class="params">(<span class="type">const</span> PortRequest&amp; req)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 缓存配置</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_write_policy</span><span class="params">(<span class="type">bool</span> write_back)</span></span>; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_replacement_policy</span><span class="params">(<span class="type">int</span> policy)</span></span>; <span class="comment">// 0:LRU, 1:FIFO, 2:Random</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 内部缓存操作</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">access_cache</span><span class="params">(<span class="type">uint32_t</span> port_id, <span class="type">uint32_t</span> addr, <span class="type">bool</span> is_write, <span class="type">uint8_t</span>* data, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle_miss</span><span class="params">(<span class="type">uint32_t</span> port_id, <span class="type">uint32_t</span> addr)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">evict_line</span><span class="params">(<span class="type">uint32_t</span> set_idx, <span class="type">uint32_t</span> way_idx)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多端口同步</span></span><br><span class="line">    std::atomic&lt;<span class="type">uint64_t</span>&gt; global_counter_{<span class="number">0</span>}; <span class="comment">// 原子计数器</span></span><br><span class="line">    std::vector&lt;std::mutex&gt; port_locks_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 缓存结构</span></span><br><span class="line">    <span class="type">uint32_t</span> line_size_;</span><br><span class="line">    <span class="type">uint32_t</span> num_sets_;</span><br><span class="line">    std::vector&lt;std::vector&lt;CacheLine&gt;&gt; cache_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 策略配置</span></span><br><span class="line">    <span class="type">bool</span> write_back_;</span><br><span class="line">    <span class="type">int</span> replacement_policy_;</span><br><span class="line">};</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>cache_simulator.cpp</span><a href="/blog/downloads/code/eda/memory/cache/cache_simulator.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cache_simulator.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line">CacheSimulator::<span class="built_in">CacheSimulator</span>(<span class="type">uint32_t</span> line_size, <span class="type">uint32_t</span> num_lines, <span class="type">uint32_t</span> num_ports) </span><br><span class="line">    : <span class="built_in">port_locks_</span>(num_ports), <span class="built_in">line_size_</span>(line_size) {</span><br><span class="line">    num_sets_ = num_lines; <span class="comment">// 简单实现，可扩展为组相联</span></span><br><span class="line">    cache_.<span class="built_in">resize</span>(num_sets_, std::<span class="built_in">vector</span>&lt;CacheLine&gt;(<span class="number">1</span>)); <span class="comment">// 直接映射</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CacheSimulator::process_request</span><span class="params">(<span class="type">const</span> PortRequest&amp; req)</span> </span>{</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(port_locks_[req.port_id])</span></span>;</span><br><span class="line">    <span class="built_in">access_cache</span>(req.port_id, req.addr, req.is_write, req.data_ptr, req.data_size);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CacheSimulator::access_cache</span><span class="params">(<span class="type">uint32_t</span> port_id, <span class="type">uint32_t</span> addr, <span class="type">bool</span> is_write, </span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">uint8_t</span>* data, <span class="type">size_t</span> size)</span> </span>{</span><br><span class="line">    <span class="type">uint32_t</span> tag = addr / line_size_;</span><br><span class="line">    <span class="type">uint32_t</span> set_idx = tag % num_sets_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找命中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; line : cache_[set_idx]) {</span><br><span class="line">        <span class="keyword">if</span> (line.valid &amp;&amp; line.tag == tag) {</span><br><span class="line">            line.last_used = ++global_counter_;</span><br><span class="line">            <span class="keyword">if</span> (is_write) {</span><br><span class="line">                <span class="built_in">memcpy</span>(line.data.<span class="built_in">data</span>(), data, size);</span><br><span class="line">                line.dirty = <span class="literal">true</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="built_in">memcpy</span>(data, line.data.<span class="built_in">data</span>(), size);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 未命中处理</span></span><br><span class="line">    <span class="built_in">handle_miss</span>(port_id, addr);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CacheSimulator::handle_miss</span><span class="params">(<span class="type">uint32_t</span> port_id, <span class="type">uint32_t</span> addr)</span> </span>{</span><br><span class="line">    <span class="type">uint32_t</span> tag = addr / line_size_;</span><br><span class="line">    <span class="type">uint32_t</span> set_idx = tag % num_sets_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找可替换行</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; lines = cache_[set_idx];</span><br><span class="line">    <span class="keyword">auto</span> victim = std::<span class="built_in">min_element</span>(lines.<span class="built_in">begin</span>(), lines.<span class="built_in">end</span>(),</span><br><span class="line">        [](<span class="type">const</span> CacheLine&amp; a, <span class="type">const</span> CacheLine&amp; b) {</span><br><span class="line">            <span class="keyword">return</span> a.last_used &lt; b.last_used; <span class="comment">// LRU策略</span></span><br><span class="line">        });</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写回脏数据</span></span><br><span class="line">    <span class="keyword">if</span> (write_back_ &amp;&amp; victim-&gt;dirty) {</span><br><span class="line">        <span class="comment">// 模拟写回主存操作</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载新数据</span></span><br><span class="line">    victim-&gt;valid = <span class="literal">true</span>;</span><br><span class="line">    victim-&gt;tag = tag;</span><br><span class="line">    victim-&gt;dirty = <span class="literal">false</span>;</span><br><span class="line">    victim-&gt;last_used = ++global_counter_;</span><br><span class="line">    <span class="comment">// 模拟从主存加载数据</span></span><br><span class="line">    victim-&gt;data.<span class="built_in">resize</span>(line_size_);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>main.cpp</span><a href="/blog/downloads/code/eda/memory/cache/main.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cache_simulator.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">port_thread</span><span class="params">(CacheSimulator&amp; cache, <span class="type">uint32_t</span> port_id)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) {</span><br><span class="line">        PortRequest req;</span><br><span class="line">        req.port_id = port_id;</span><br><span class="line">        req.is_write = (i % <span class="number">3</span> == <span class="number">0</span>);</span><br><span class="line">        req.addr = <span class="built_in">rand</span>() % <span class="number">0xFFFF</span>;</span><br><span class="line">        <span class="type">uint8_t</span> data[<span class="number">64</span>] = {<span class="number">0</span>};</span><br><span class="line">        req.data_ptr = data;</span><br><span class="line">        req.data_size = <span class="built_in">sizeof</span>(data);</span><br><span class="line">        </span><br><span class="line">        cache.<span class="built_in">process_request</span>(req);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">CacheSimulator <span class="title">cache</span><span class="params">(<span class="number">64</span>, <span class="number">1024</span>, <span class="number">4</span>)</span></span>; <span class="comment">// 64B行, 1024行, 4端口</span></span><br><span class="line">    </span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) {</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(port_thread, std::<span class="built_in">ref</span>(cache), i);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) {</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Cache simulation completed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>Makefile</span><a href="/blog/downloads/code/eda/memory/cache/Makefile">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 编译器配置</span><br><span class="line">CXX := g++</span><br><span class="line">CXXFLAGS := -std=c++<span class="number">17</span> -Wall -Wextra -O3 -pthread</span><br><span class="line">LDFLAGS := -pthread</span><br><span class="line"></span><br><span class="line"># 项目结构</span><br><span class="line">SRC_DIR := .</span><br><span class="line">BUILD_DIR := build</span><br><span class="line">TARGET := $(BUILD_DIR)/cache_simulator</span><br><span class="line"></span><br><span class="line"># 源文件列表</span><br><span class="line">SRCS := $(wildcard $(SRC_DIR)<span class="comment">/*.cpp)</span></span><br><span class="line"><span class="comment">OBJS := $(patsubst $(SRC_DIR)/%.cpp,$(BUILD_DIR)/%.o,$(SRCS))</span></span><br><span class="line"><span class="comment">DEPS := $(OBJS:.o=.d)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 默认目标</span></span><br><span class="line"><span class="comment">all: $(BUILD_DIR) $(TARGET)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 创建构建目录</span></span><br><span class="line"><span class="comment">$(BUILD_DIR):</span></span><br><span class="line"><span class="comment">	mkdir -p $(BUILD_DIR)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 主目标链接</span></span><br><span class="line"><span class="comment">$(TARGET): $(OBJS)</span></span><br><span class="line"><span class="comment">	$(CXX) $(LDFLAGS) $^ -o $@</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 编译规则</span></span><br><span class="line"><span class="comment">$(BUILD_DIR)/%.o: $(SRC_DIR)/%.cpp</span></span><br><span class="line"><span class="comment">	$(CXX) $(CXXFLAGS) -MMD -c $&lt; -o $@</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 包含依赖关系</span></span><br><span class="line"><span class="comment">-include $(DEPS)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 清理</span></span><br><span class="line"><span class="comment">clean:</span></span><br><span class="line"><span class="comment">	rm -rf $(BUILD_DIR)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">.PHONY: all clean</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en, zh_CN">
    <link itemprop="mainEntityOfPage" href="https://bi-an.github.io/blog/2025/08/19/concurrency/TBB%E5%85%B8%E5%9E%8B%E5%9C%BA%E6%99%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="bi-an">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="江南人物的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2025/08/19/concurrency/TBB%E5%85%B8%E5%9E%8B%E5%9C%BA%E6%99%AF/" class="post-title-link" itemprop="url">TBB典型场景</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-19 22:48:38" itemprop="dateCreated datePublished" datetime="2025-08-19T22:48:38+00:00">2025-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-09-15 11:59:20" itemprop="dateModified" datetime="2025-09-15T11:59:20+00:00">2025-09-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="IO-CPU-密集-IO"><a href="#IO-CPU-密集-IO" class="headerlink" title="IO + CPU 密集 + IO"></a>IO + CPU 密集 + IO</h2><p>tasks</p>
<figure class="highlight cpp"><figcaption><span>tasks.hpp</span><a href="/blog/downloads/code/tbb/pipeline/tasks.hpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟 IO 和 CPU 任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataChunk</span> {</span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; data;</span><br><span class="line">    <span class="built_in">DataChunk</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">DataChunk</span><span class="params">(<span class="type">size_t</span> size)</span> : data(size) {</span>}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CompressedChunk</span> {</span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; data;</span><br><span class="line">    <span class="built_in">CompressedChunk</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CompressedChunk</span><span class="params">(<span class="type">size_t</span> size)</span> : data(size) {</span>}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟数据读取函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">read_from_network</span><span class="params">(DataChunk&amp; chunk)</span> </span>{</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);  <span class="comment">// 模拟 IO 延迟</span></span><br><span class="line"></span><br><span class="line">    chunk.data.<span class="built_in">resize</span>(<span class="number">100</span>);  <span class="comment">// 模拟每个数据块有 100 个字节</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (count++ &gt;= <span class="number">10</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 模拟读取 10 个数据块后结束</span></span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">generate</span>(chunk.data.<span class="built_in">begin</span>(), chunk.data.<span class="built_in">end</span>(),</span><br><span class="line">                  []() { <span class="keyword">return</span> <span class="built_in">rand</span>() % <span class="number">256</span>; });</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟压缩函数</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">compress_byte</span><span class="params">(<span class="type">char</span> byte)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10&#x27;000ll</span>; ++i)</span><br><span class="line">        ;               <span class="comment">// 模拟 CPU busy</span></span><br><span class="line">    <span class="keyword">return</span> byte % <span class="number">128</span>;  <span class="comment">// 简单压缩算法示例</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟写入函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_to_file</span><span class="params">(<span class="type">const</span> CompressedChunk&amp; chunk)</span> </span>{</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);  <span class="comment">// 模拟 IO 延迟</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Writing chunk of size &quot;</span> &lt;&lt; chunk.data.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>方案一</p>
<figure class="highlight cpp"><figcaption><span>1_message_queue.cpp</span><a href="/blog/downloads/code/tbb/pipeline/1_message_queue.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方案 1：异步队列 + TBB 流水线</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/tbb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tasks.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局队列</span></span><br><span class="line">std::queue&lt;std::vector&lt;<span class="type">char</span>&gt;&gt; readQueue;</span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::atomic_bool stop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">networkReader</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (!stop) {</span><br><span class="line">        DataChunk chunk;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">read_from_network</span>(chunk))  <span class="comment">// 阻塞 I/O</span></span><br><span class="line">        {</span><br><span class="line">            stop.<span class="built_in">store</span>(<span class="literal">true</span>, memory_order::releaxed);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        {</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            readQueue.<span class="built_in">push</span>(std::<span class="built_in">move</span>(chunk.data));</span><br><span class="line">        }</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩任务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compressor</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (!stop) {</span><br><span class="line">        DataChunk chunk;</span><br><span class="line">        {</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock, [] { <span class="keyword">return</span> !readQueue.<span class="built_in">empty</span>(); });</span><br><span class="line">            chunk.data = std::<span class="built_in">move</span>(readQueue.<span class="built_in">front</span>());</span><br><span class="line">            readQueue.<span class="built_in">pop</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CPU 密集计算，使用 TBB 并行</span></span><br><span class="line">        <span class="function">CompressedChunk <span class="title">compressed</span><span class="params">(chunk.data.size())</span></span>;</span><br><span class="line">        tbb::<span class="built_in">parallel_for</span>(<span class="built_in">size_t</span>(<span class="number">0</span>), chunk.data.<span class="built_in">size</span>(), [&amp;](<span class="type">size_t</span> i) {</span><br><span class="line">            compressed.data[i] = <span class="built_in">compress_byte</span>(chunk.data[i]);  <span class="comment">// 假设单字节压缩</span></span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="built_in">write_to_file</span>(compressed);  <span class="comment">// 可以异步</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">std::thread <span class="title">reader</span><span class="params">(networkReader)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(compressor)</span></span>;</span><br><span class="line"></span><br><span class="line">    reader.<span class="built_in">join</span>();</span><br><span class="line">    worker.<span class="built_in">join</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>方案二</p>
<figure class="highlight cpp"><figcaption><span>2_flow_graph.cpp</span><a href="/blog/downloads/code/tbb/pipeline/2_flow_graph.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方案 2：TBB Flow Graph</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/flow_graph.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/tbb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tasks.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tbb;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tbb::flow;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    graph g;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 读取节点（串行）</span></span><br><span class="line">    <span class="function">input_node&lt;DataChunk&gt; <span class="title">reader</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        g,</span></span></span><br><span class="line"><span class="params"><span class="function">        [](flow_control&amp; fc) -&gt; DataChunk {</span></span></span><br><span class="line"><span class="params"><span class="function">            DataChunk chunk(<span class="number">1024</span>);  <span class="comment">// 1KB数据块</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (!read_from_network(chunk)) {</span></span></span><br><span class="line"><span class="params"><span class="function">                fc.stop();</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">return</span> DataChunk();</span></span></span><br><span class="line"><span class="params"><span class="function">            }</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">return</span> chunk;</span></span></span><br><span class="line"><span class="params"><span class="function">        })</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 并行处理节点（无限制并发）</span></span><br><span class="line">    <span class="function">function_node&lt;DataChunk, CompressedChunk&gt; <span class="title">processor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        g, unlimited,</span></span></span><br><span class="line"><span class="params"><span class="function">        [](<span class="type">const</span> DataChunk&amp; input) -&gt; CompressedChunk {</span></span></span><br><span class="line"><span class="params"><span class="function">            CompressedChunk output(input.data.size());</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            tbb::parallel_for(</span></span></span><br><span class="line"><span class="params"><span class="function">                tbb::blocked_range&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>, input.data.size()),</span></span></span><br><span class="line"><span class="params"><span class="function">                [&amp;](<span class="type">const</span> tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r) {</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">for</span> (<span class="type">size_t</span> i = r.begin(); i != r.end(); ++i) {</span></span></span><br><span class="line"><span class="params"><span class="function">                        output.data[i] = compress_byte(input.data[i]);</span></span></span><br><span class="line"><span class="params"><span class="function">                    }</span></span></span><br><span class="line"><span class="params"><span class="function">                });</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">return</span> output;</span></span></span><br><span class="line"><span class="params"><span class="function">        })</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 写入节点（串行保证写入顺序）</span></span><br><span class="line">    <span class="function">function_node&lt;CompressedChunk&gt; <span class="title">writer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        g, serial,</span></span></span><br><span class="line"><span class="params"><span class="function">        [](<span class="type">const</span> CompressedChunk&amp; output) {</span></span></span><br><span class="line"><span class="params"><span class="function">            write_to_file(output);</span></span></span><br><span class="line"><span class="params"><span class="function">        })</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建数据流管道</span></span><br><span class="line">    <span class="built_in">make_edge</span>(reader, processor);</span><br><span class="line">    <span class="built_in">make_edge</span>(processor, writer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动管道</span></span><br><span class="line">    reader.<span class="built_in">activate</span>();</span><br><span class="line">    g.<span class="built_in">wait_for_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>方案三</p>
<figure class="highlight cpp"><figcaption><span>3_pipeline.cpp</span><a href="/blog/downloads/code/tbb/pipeline/3_pipeline.cpp">view raw</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方案 3: TBB 流水线</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/tbb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tasks.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    tbb::<span class="built_in">parallel_pipeline</span>(</span><br><span class="line">        <span class="comment">/* max_number_of_live_token */</span> <span class="number">4</span>,</span><br><span class="line">        <span class="comment">// Stage 1: 读网络数据</span></span><br><span class="line">        tbb::<span class="built_in">make_filter</span>&lt;<span class="type">void</span>, DataChunk&gt;(</span><br><span class="line">            tbb::filter_mode::serial_in_order,</span><br><span class="line">            [](tbb::flow_control&amp; fc) -&gt; DataChunk {</span><br><span class="line">                DataChunk chunk;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">read_from_network</span>(chunk)) {  <span class="comment">// 返回 false 时结束</span></span><br><span class="line">                    fc.<span class="built_in">stop</span>();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> chunk;</span><br><span class="line">            }) &amp;</span><br><span class="line">            <span class="comment">// Stage 2: CPU 压缩</span></span><br><span class="line">            tbb::<span class="built_in">make_filter</span>&lt;DataChunk, CompressedChunk&gt;(</span><br><span class="line">                tbb::filter_mode::parallel,</span><br><span class="line">                [](DataChunk chunk) -&gt; CompressedChunk {</span><br><span class="line">                    CompressedChunk <span class="built_in">out</span>(chunk.data.<span class="built_in">size</span>());</span><br><span class="line">                    tbb::<span class="built_in">parallel_for</span>(<span class="built_in">size_t</span>(<span class="number">0</span>), chunk.data.<span class="built_in">size</span>(), [&amp;](<span class="type">size_t</span> i) {</span><br><span class="line">                        out.data[i] = <span class="built_in">compress_byte</span>(chunk.data[i]);</span><br><span class="line">                    });</span><br><span class="line">                    <span class="keyword">return</span> out;</span><br><span class="line">                }) &amp;</span><br><span class="line">            <span class="comment">// Stage 3: 写文件</span></span><br><span class="line">            tbb::<span class="built_in">make_filter</span>&lt;CompressedChunk, <span class="type">void</span>&gt;(</span><br><span class="line">                tbb::filter_mode::serial_in_order,</span><br><span class="line">                [](CompressedChunk out) {</span><br><span class="line">                    <span class="built_in">write_to_file</span>(out);  <span class="comment">// 可以异步</span></span><br><span class="line">                }));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/10/">10</a><a class="extend next" rel="next" href="/blog/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="bi-an"
      src="/blog/images/avatar.gif">
  <p class="site-author-name" itemprop="name">bi-an</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">100</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/bi-an" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;bi-an" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ah_zzg@126.com" title="E-Mail → mailto:ah_zzg@126.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://cuda-doc.readthedocs.io/" title="https:&#x2F;&#x2F;cuda-doc.readthedocs.io" rel="noopener" target="_blank">CUDA中文手册</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://infiniband-doc.readthedocs.io/" title="https:&#x2F;&#x2F;infiniband-doc.readthedocs.io&#x2F;" rel="noopener" target="_blank">InfiniBand中文手册</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bi-an</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>




  




  
<script src="/blog/js/local-search.js"></script>













  

  

</body>
</html>
